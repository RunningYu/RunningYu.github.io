<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>1. 零碎笔记 | Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Java虚拟机不只是适用于java语言，也适用于其它语言，只要其它语言通过编译器生成的字节码文件遵循java虚拟机的规则，java虚拟机就可以运行  虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。  大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们完全">
<meta property="og:type" content="article">
<meta property="og:title" content="1. 零碎笔记">
<meta property="og:url" content="http://example.com/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:description" content="Java虚拟机不只是适用于java语言，也适用于其它语言，只要其它语言通过编译器生成的字节码文件遵循java虚拟机的规则，java虚拟机就可以运行  虚拟机 所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。  大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们完全">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210028078.png">
<meta property="og:image" content="http://example.com/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210242978.png">
<meta property="og:image" content="http://example.com/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210338812.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221112212347371.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221112212742280.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221112225810473.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221112225721970.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221113093105220.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221113101445106.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221113101718312.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221114203139057.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221114213537778.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221114210548293.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221115204949307.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221115205956137.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221115210219781.png">
<meta property="og:image" content="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png">
<meta property="og:image" content="http://example.com/2022/11/12/images/image-20221115212723174.png">
<meta property="article:published_time" content="2022-11-12T13:04:00.571Z">
<meta property="article:modified_time" content="2022-11-20T14:35:39.593Z">
<meta property="article:author" content="其然乐衣">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="内存与垃圾回收篇">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210028078.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>126</strong><br>文章</div></a>
      <a href="/categories"><div><strong>60</strong><br>分类</div></a>
      <a href="/tags"><div><strong>45</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main"><article id="post-JVM/JVM上篇：内存与垃圾回收篇/jvm零碎笔记" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="post-time" datetime="2022-11-12T13:04:00.571Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      1. 零碎笔记
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210028078.png" alt="image-20221112210028078"></p>
<p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210242978.png" alt="image-20221112210242978"></p>
<p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210338812.png" alt="image-20221112210338812"></p>
<p><img src="../../../images/image-20221112212347371.png" alt="image-20221112212347371"></p>
<p>Java虚拟机不只是适用于java语言，也适用于其它语言，只要其它语言通过编译器生成的字节码文件遵循java虚拟机的规则，java虚拟机就可以运行</p>
<p><img src="../../../images/image-20221112212742280.png" alt="image-20221112212742280"></p>
<p><strong>虚拟机</strong></p>
<p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<p><strong>Java 虚拟机</strong></p>
<ul>
<li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</li>
<li>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li>
<li><mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li>
</ul>
<p>作用</p>
<ul>
<li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li>
</ul>
<p>特点</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<hr>
<p><strong>编译器前端</strong>（将源文件编译生成字节码文件），<strong>编译器后端</strong>（将字节码指令编译成机器指令）</p>
<p>因为机器指令是反复执行的<strong>热点代码</strong>，所以缓存起来，下次可以直接调用</p>
<hr>
<p><img src="../../../images/image-20221112225810473.png" alt="image-20221112225810473"></p>
<p>栈式架构采用的是8位作为一个基本单位的，所以栈的指令集更小，但是指令数多</p>
<p>寄存器架构采用的是16位的双字节的进行设计的，所以指令集大，但指令数更少</p>
<p>比如：</p>
<p><img src="../../../images/image-20221112225721970.png" alt="image-20221112225721970"></p>
<p><strong>总结</strong></p>
<p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p>
<p>优点：是跨平台，指令集小，编译器容易实现。</p>
<p>缺点：是性能下降，实现同样的功能需要更多的指令。</p>
<p>栈：</p>
<p>跨平台、指令集小、指令多，执行性能比寄存器差</p>
<hr>
<h1 id="虚拟机的生命周期"><a class="markdownIt-Anchor" href="#虚拟机的生命周期"></a> 虚拟机的生命周期</h1>
<h2 id="虚拟机的启动"><a class="markdownIt-Anchor" href="#虚拟机的启动"></a> <strong>虚拟机的启动</strong></h2>
<p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<p><img src="../../../images/image-20221113093105220.png" alt="image-20221113093105220"></p>
<p>像上面我们自定义的类，是由系统类加载器来加载的</p>
<p>但（如果）没有明确指定的父类，它的父类就是Object，Object作为核心api，由引导类加载器（bootstrap class loader）加载的</p>
<p>我们要启动一个类，而父类是要早于子类先加载的，但是父类还没加载而它的子类要用，所以我们就需要先启动Java虚拟机</p>
<h2 id="虚拟机的执行"><a class="markdownIt-Anchor" href="#虚拟机的执行"></a> <strong>虚拟机的执行</strong></h2>
<ul>
<li>
<p>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</p>
</li>
<li>
<p>程序开始执行时他才运行，程序结束时他就停止。</p>
</li>
<li>
<p><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></p>
</li>
</ul>
<h2 id="虚拟机的退出"><a class="markdownIt-Anchor" href="#虚拟机的退出"></a> <strong>虚拟机的退出</strong></h2>
<p>有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ul>
<hr>
<p><img src="../../../images/image-20221113101445106.png" alt="image-20221113101445106"></p>
<p><img src="../../../images/image-20221113101718312.png" alt="image-20221113101718312"></p>
<hr>
<h3 id="hotspot-vm"><a class="markdownIt-Anchor" href="#hotspot-vm"></a> HotSpot VM</h3>
<ul>
<li>HotSpot 历史
<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li>
<li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li>
</ul>
</li>
<li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark>
<ul>
<li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li>
<li>Sun / Oracle JDK 和 OpenJDK 的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
</li>
<li>从服务器、桌面到移动端、嵌入式都有应用。</li>
<li>名称中的 HotSpot 指的就是它的<strong>热点代码探测技术</strong>。
<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h3 id="jrockit"><a class="markdownIt-Anchor" href="#jrockit"></a> JRockit</h3>
<ul>
<li>
<p><mark>专注于服务器端应用</mark></p>
<ul>
<li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
</li>
<li>
<p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p>
<ul>
<li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li>
</ul>
</li>
<li>
<p>优势：全面的 Java 运行时解决方案组合</p>
<ul>
<li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
<li>
<p>2008 年，JRockit 被 oracle 收购。</p>
</li>
<li>
<p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p>
</li>
<li>
<p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
</li>
</ul>
<h3 id><a class="markdownIt-Anchor" href="#"></a> </h3>
<h3 id="ibm-的-j9"><a class="markdownIt-Anchor" href="#ibm-的-j9"></a> IBM 的 J9</h3>
<ul>
<li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</li>
<li>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</li>
<li>广泛用于 IBM 的各种 Java 产品（一般用于自己的产品）。</li>
<li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机（但J9只是在自己的产品上使用时比较快，而通用性的话，还是JRockit好点）。</li>
<li>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</li>
</ul>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> …</h3>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<p>​		具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p>
<hr>
<h1 id="2-类加载子系统"><a class="markdownIt-Anchor" href="#2-类加载子系统"></a> 2. 类加载子系统</h1>
<p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<p>**类加载器子系统：**获取字节码文件的信息（常量信息，变量信息，方法，指令等），然后有组织第分配到内存当中（<strong>运行时数据区</strong>）</p>
<p><strong>执行引擎:</strong>  需要去解释这些指令</p>
<hr>
<p>如果不是一个合法的字节码文件，就会在加载的过程中抛出异常。如果有些恶意攻击的话，就会对这个字节码文件进行修改，就不合法了</p>
<h3 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h3>
<ul>
<li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li>
<li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li>
</ul>
<p><img src="../../../images/image-20221114203139057.png" alt="image-20221114203139057"></p>
<p>当要只能main方法时，先把这个ClinitTest1类加载到内存当中（当然在加载这个类之前先把它的父类加载），加载完后，调用main静态方法，里面要加载Son这个类，要把Son这个类加载进来，但在加载Son类之前要先加载Son的父类Father，加载完父类后，在加载Son的时候，在初始化这个环节，把A的值赋过来，这时A已经等于2，所以main中打印出来的结果就是2</p>
<p><strong>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</strong></p>
<p>线程2进来了，但是线程2出不来，它还在初始化这个DeadThread类，线程1也进不去，因为线程正在处于一个加锁的状态</p>
<p><img src="../../../images/image-20221114213537778.png" alt="image-20221114213537778"></p>
<p><img src="../../../images/image-20221114210548293.png" alt="image-20221114210548293"></p>
<p>static代码块只执行一次原因：</p>
<p>​		static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的，它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p>
<hr>
<h1 id="231-虚拟机自带的加载器"><a class="markdownIt-Anchor" href="#231-虚拟机自带的加载器"></a> 2.3.1. 虚拟机自带的加载器</h1>
<p><strong>启动类加载器（引导类加载器，Boostrap ClassLoader）</strong>,我们获取不到，它是由C/C++语言编写的</p>
<p>**扩展类加载器（Extension ClassLoader）**和 **应用程序类加载器（系统类加载器，AppClassLoader）**都是由java语言编写的</p>
<p>还要记住什么样的类加载器加载什么样的类文件</p>
<hr>
<p><strong>为什么要自定义类加载器？</strong></p>
<ul>
<li>隔离加载类 (避免类的冲突)
<ul>
<li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</li>
</ul>
</li>
<li>修改类加载的方式 （可以实现动态的加载）
<ul>
<li>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行<strong>动态加载</strong>。</li>
</ul>
</li>
<li>扩展加载源
<ul>
<li>比如从数据库、网络、甚至是电视机机顶盒进行加载。</li>
</ul>
</li>
<li>防止源码泄漏
<ul>
<li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>获取 ClassLoader 的途径</strong></p>
<ul>
<li>
<p>方式一：获取当前 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式二：获取当前线程上下文的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式三：获取系统的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>方式四：获取调用者的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> </h2>
<h1 id="25-双亲委派机制"><a class="markdownIt-Anchor" href="#25-双亲委派机制"></a> 2.5. 双亲委派机制</h1>
<p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> <strong>工作原理</strong></h2>
<ul>
<li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>3）<strong>如果父类加载器可以完成类加载任务，就成功返回</strong>（就不会由子类加载器去加载了），倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p>
<p>举例：</p>
<ol>
<li></li>
</ol>
<p><img src="../../../images/image-20221115204949307.png" alt="image-20221115204949307"></p>
<p>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。一看你是java开头的，引导类加载就说了。这是归我管我来加载String（核心API里的String）。因此有父类来加载后，就不会再向下委托了，所以我们new 的这个String对象就是核心API里面的String类对象，而不是我们自定义的String，因此就没有打印出自定义String里的static静态资源里的语句</p>
<ol start="2">
<li></li>
</ol>
<p><img src="../../../images/image-20221115205956137.png" alt="image-20221115205956137"></p>
<p>委托到引导类加载器，它发现你这个包是jvm开头的，不归引导类加载管，就向下委托，也不归扩展类加载器管，所以最后回到系统类加载器来加载，因此最后输出结果就是系统类加载来进行的加载</p>
<ol start="3">
<li></li>
</ol>
<p><img src="../../../images/image-20221115210219781.png" alt="image-20221115210219781"></p>
<p>一直往上委托，就交给到了引导类加载器，它加载了String类以后，然后就想去执行main方法，但是核心API的String里面是没有main方法的，所以就报了 <mark>错误: 在类 java.lang.String 中找不到 main 方法</mark>. 可知，根本就没有试着想去加载我们自定义的String类，完全忽略掉你了</p>
<ol start="4">
<li></li>
</ol>
<p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p>
<h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> <strong>优势</strong></h2>
<ul>
<li><strong>避免类的重复加载</strong></li>
<li><strong>保护程序安全，防止核心 API 被随意篡改</strong>
<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li>
</ul>
</li>
</ul>
<p><img src="../../../images/image-20221115212723174.png" alt="image-20221115212723174"></p>
<p>引导类加载器看到是 java.lang开头的，就表示这是归它管，于是就要去加载这个ShkStart类了，但直接直接给它报错了，相当于，要加载java.lang这个包，要想访问是要有权限的，现在报错就是阻止我们去直接用这个java.lang包来自定义这个ShkStart类。其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个类，加载成功的话，就会导致对引导类加载器本身造成影响，所以这里是直接把引导类加载器给整挂了。所以我们也禁止去用java.lang这样的包名去命名</p>
<p>其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个种自定义的类，加载成功的话，但里面可能会有一些<strong>恶意代码</strong>，就可能会会对现有的项目和程序进行破坏</p>
<h2 id="沙箱安全机制"><a class="markdownIt-Anchor" href="#沙箱安全机制"></a> <strong>沙箱安全机制</strong></h2>
<p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<hr>
<h2 id="26-其他"><a class="markdownIt-Anchor" href="#26-其他"></a> 2.6. 其他</h2>
<p><strong>如何判断两个 class 对象是否相同</strong></p>
<p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li>
</ul>
<p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/" data-id="clcz0h31f006pvwv6f595au74" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/14/interview/waitingSee/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2022/11/12/SpringSecurity/UserDetailsServiceImpl/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">自定义UserDetailsServiceImpl</div>
    </a>
  
</nav>

  
</article>



</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>126</strong><br>文章</div></a>
      <a href="/categories"><div><strong>60</strong><br>分类</div></a>
      <a href="/tags"><div><strong>45</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>