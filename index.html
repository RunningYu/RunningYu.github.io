<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>154</strong><br>文章</div></a>
      <a href="/categories"><div><strong>83</strong><br>分类</div></a>
      <a href="/tags"><div><strong>55</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-SpringCloud微服务/Sentinel/Sentinel-限流规则(流控模式：直接、关联、链路)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/" class="article-date">
  <time class="post-time" datetime="2023-02-26T04:28:58.799Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/">Sentinel-限流规则(流控模式：直接、关联、链路)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>,<a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/">Sentinel</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p> <img src="https://img-blog.csdnimg.cn/061b8c23ef694d6e9d18abe3647c9dbe.png" alt="img"></p>
<h1 id="一、流控模式-直接"><a href="#一、流控模式-直接" class="headerlink" title="一、流控模式-直接"></a>一、流控模式-直接</h1><p>添加规则：</p>
<p><img src="https://img-blog.csdnimg.cn/6d5781b7da1345f59e3321b3c8806571.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/8df1b81beca34a90a71af4aa2f1b8026.png" alt="img"></p>
<p>测试例子分析：</p>
<p><img src="https://img-blog.csdnimg.cn/39b96b130c9046078bc6d632580aff3e.png" alt="img"></p>
<p> 启动测试</p>
<p><img src="https://img-blog.csdnimg.cn/5ec171ee24494c7488e3b09e3d7d8b47.png" alt="img"></p>
<p>点击 <strong>察看结果树</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cc093a02f2be44fd938dfcc603a06ca3.png" alt="img"></p>
<p> 上面测试例子，到Sentinel控制台的实时监控可以看到<img src="https://img-blog.csdnimg.cn/3dd6594966864a3a8f8d230c66387980.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/57592224a235458b826fc55819f5ea3d.png" alt="img"></p>
<h1 id="二、流控模式-关联"><a href="#二、流控模式-关联" class="headerlink" title="二、流控模式-关联"></a>二、流控模式-关联</h1><p>•<strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p>
<p>•<strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争            抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订            单业务触发阈值时，需要对查询订单业务限流。</p>
<p><img src="https://img-blog.csdnimg.cn/b8cf0fa094f0443db55cd6567f70b192.png" alt="img"></p>
<p>当**/write<strong>资源访问量触发阈值时，就会对</strong>/read**资源限流，避免影响/write资源。</p>
<h2 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h2><p>​    需求：  </p>
<p>​     •在OrderController新建两个端点：/order/query和/order/update，无需实现业务  </p>
<p>​     •配置流控规则，当/order/ update资源被访问的QPS超过5时，对/order/query请求限流</p>
<h2 id="1-编写测试controller方法"><a href="#1-编写测试controller方法" class="headerlink" title="1. 编写测试controller方法:"></a>1. 编写测试controller方法:</h2><p><img src="https://img-blog.csdnimg.cn/dfda223212c6437a96852a8aa4d744e0.png" alt="img"></p>
<h2 id="2-添加规则（想给谁限流，就给谁添加规则）"><a href="#2-添加规则（想给谁限流，就给谁添加规则）" class="headerlink" title="2. 添加规则（想给谁限流，就给谁添加规则）"></a>2. 添加规则（想给谁限流，就给谁添加规则）</h2><h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/9fc5937b14504fce8dde85b0c1a5cfb6.png" alt="img"></h2><h2 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/d93155d750694872a0818677f4cb81a8.png" alt="img"></h2><h2 id="-2"><a href="#-2" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/ddfa4ee5ed00436c9c0f3e147d8c7b6d.png" alt="img"></h2><h2 id="3-借助JMeter进行测试："><a href="#3-借助JMeter进行测试：" class="headerlink" title="3. 借助JMeter进行测试："></a>3. 借助JMeter进行测试：</h2><p><img src="https://img-blog.csdnimg.cn/5ff99d435d124355914f816b525b9a7a.png" alt="img"></p>
<h2 id="编辑-4-去网页访问验证-编辑"><a href="#编辑-4-去网页访问验证-编辑" class="headerlink" title="编辑 4. 去网页访问验证:编辑"></a><img src="https://img-blog.csdnimg.cn/38c110824b1f478883e86b43a4df0017.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑 4. 去网页访问验证:<img src="https://img-blog.csdnimg.cn/6d7e4884e3314d76a707bf0e0e6548d0.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</h2><p>query被限流 <img src="https://img-blog.csdnimg.cn/21342817472a4d2587669ada29df161c.png" alt="img"></p>
<h2 id="5-总结：-满足下面条件可以使用关联模式"><a href="#5-总结：-满足下面条件可以使用关联模式" class="headerlink" title="5. 总结： 满足下面条件可以使用关联模式"></a>5. 总结： 满足下面条件可以使用关联模式</h2><ol>
<li><p>两个有竞争关系的资源  </p>
</li>
<li><p>一个优先级较高，一个优先级较低（优先级高的触发阈值时（本案例的order），对优先级低的限流（本案例的query））</p>
</li>
</ol>
<h1 id="三、流控模式-链路"><a href="#三、流控模式-链路" class="headerlink" title="三、流控模式-链路"></a>三、流控模式-链路</h1><p><img src="https://img-blog.csdnimg.cn/56e2dc9f451441a2bbb8483750137bf4.png" alt="img"></p>
<h2 id="案例：-1"><a href="#案例：-1" class="headerlink" title="案例："></a>案例：</h2><p><img src="https://img-blog.csdnimg.cn/00c8c659e1c44e098c46b7ce5fd7b219.png" alt="img"></p>
<h2 id="1-编写测试代码："><a href="#1-编写测试代码：" class="headerlink" title="1. 编写测试代码："></a>1. 编写测试代码：</h2><p><img src="https://img-blog.csdnimg.cn/540402db64874fab953436a286717e02.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/32565b6a61534e3d87a9de1d1d9b7446.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/b0c343dd8ae54320bed317a725bda5d6.png" alt="img"></p>
<h2 id="2-注意："><a href="#2-注意：" class="headerlink" title="2. 注意："></a><strong>2. 注意：</strong></h2><p> Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用**@SentinelResource**注解</p>
<p>去配置文件里配置，关闭context，就可以让controller里的方法单独成为一个链路；不关闭context的话，controller里的方法都会默认进去sentinel默认的根链路里，这样就只有一条链路，无法流控链路模式</p>
<p><img src="https://img-blog.csdnimg.cn/dba8e68e6bc049b18fceab90848e5a24.png" alt="img"></p>
<h2 id="3-启动之后，并到网页里分别访问了-x2F-order-x2F-query和-x2F-order-x2F-save接口后"><a href="#3-启动之后，并到网页里分别访问了-x2F-order-x2F-query和-x2F-order-x2F-save接口后" class="headerlink" title="3. 启动之后，并到网页里分别访问了/order/query和/order/save接口后"></a>3. 启动之后，并到网页里分别访问了/order/query和/order/save接口后</h2><p><img src="https://img-blog.csdnimg.cn/bb6e754ffb7e4e4f8b715fe3910cbecd.png" alt="img"></p>
<h2 id="4-添加规则：-对query做限制，save没有做限制"><a href="#4-添加规则：-对query做限制，save没有做限制" class="headerlink" title="4. 添加规则：(对query做限制，save没有做限制)"></a>4. 添加规则：(对query做限制，save没有做限制)</h2><p><img src="https://img-blog.csdnimg.cn/cc38bc601afc440f9405972e04257f5b.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/feb37cb8556e49c4a151ff9c8397497f.png" alt="img"></p>
<h2 id="5-借助JMeter来测试："><a href="#5-借助JMeter来测试：" class="headerlink" title="5. 借助JMeter来测试："></a>5. 借助JMeter来测试：</h2><p><img src="https://img-blog.csdnimg.cn/ed662f7afdb54e60a0455ce48d55c18e.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/7f1e916b436d43379585d1e9a52828a4.png" alt="img"></p>
<p>启动测试 <img src="https://img-blog.csdnimg.cn/4917bbf6a6b34670aed4ad9d3c751b02.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/45dd3918b3124af6983bfb648adfbb3a.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/df349c02421040b9bc8e00a398be0c9d.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/" data-id="cleqdl4rp007wycv6fi568n1k" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/Untitled" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/23/interview/Untitled/" class="article-date">
  <time class="post-time" datetime="2023-02-23T04:35:18.199Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">23</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/23/interview/Untitled/" data-id="cleqdl4qb0040ycv662jw760j" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/应用层常见协议总结（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-20T05:55:49.239Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">应用层常见协议总结（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">应用层常见协议总结（应用层）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP-超文本传输协议"><a href="#HTTP-超文本传输协议" class="headerlink" title="HTTP:超文本传输协议"></a>HTTP:超文本传输协议</h2><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p>
<p><img src="/../../../images/image-20230220135638150.png" alt="image-20230220135638150"></p>
<p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>
<h2 id="SMTP-简单邮件传输-发送-协议"><a href="#SMTP-简单邮件传输-发送-协议" class="headerlink" title="# SMTP:简单邮件传输(发送)协议"></a><a href="#smtp-%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93-%E5%8F%91%E9%80%81-%E5%8D%8F%E8%AE%AE">#</a> SMTP:简单邮件<font color="red">传输(发送)</font>协议</h2><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p>
<p><img src="/../../../images/image-20230220135632455.png" alt="image-20230220135632455"></p>
<p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“<a href="mailto:dabai@cszhinan.com">dabai@cszhinan.com</a>”，我要向“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>
<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li>
<li>qq邮箱服务器接收邮件之后就通知邮箱为“<a href="mailto:xiaoma@qq.com">xiaoma@qq.com</a>”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://verify-email.org/">https://verify-email.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li>
<li><a target="_blank" rel="noopener" href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li>
</ol>
<h2 id="POP3-x2F-IMAP-邮件接收的协议"><a href="#POP3-x2F-IMAP-邮件接收的协议" class="headerlink" title="# POP3/IMAP:邮件接收的协议"></a><a href="#pop3-imap-%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> POP3/IMAP:邮件<font color="red">接收</font>的协议</h2><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p>
<p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p>
<h2 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="# FTP:文件传输协议"></a><a href="#ftp-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> FTP:文件传输协议</h2><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img src="/../../../images/image-20230220135623263.png" alt="image-20230220135623263"></p>
<h2 id="Telnet-远程登陆协议"><a href="#Telnet-远程登陆协议" class="headerlink" title="# Telnet:远程登陆协议"></a><a href="#telnet-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AE">#</a> Telnet:远程登陆协议</h2><p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>
<h2 id="SSH-安全的网络传输协议"><a href="#SSH-安全的网络传输协议" class="headerlink" title="# SSH:安全的网络传输协议"></a><a href="#ssh-%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> SSH:安全的网络传输协议</h2><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>
<p><img src="/../../../images/image-20230220135616527.png" alt="image-20230220135616527"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="cleqdl4sn00aqycv65p3dez1a" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/TCP 传输可靠性保障（传输层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-20T05:53:11.455Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 传输可靠性保障（传输层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 传输可靠性保障（传输层）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="TCP-如何保证传输的可靠性？"><a href="#TCP-如何保证传输的可靠性？" class="headerlink" title="TCP 如何保证传输的可靠性？"></a>TCP 如何保证传输的可靠性？</h2><ol>
<li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失open in new window</a>并进行重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的<strong>滑动窗口协议（</strong>TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h2 id="TCP-如何实现流量控制？"><a href="#TCP-如何实现流量控制？" class="headerlink" title="# TCP 如何实现流量控制？"></a><a href="#tcp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">#</a> TCP 如何实现流量控制？</h2><p><strong>TCP 利用<font color="red">滑动窗口</font>实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="为什么需要流量控制"><a href="#为什么需要流量控制" class="headerlink" title="为什么需要流量控制?"></a><strong>为什么需要流量控制?</strong></h3><p>这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<p>这里需要注意的是（常见误区）：</p>
<ul>
<li>发送端不等同于客户端</li>
<li>接收端不等同于服务端</li>
</ul>
<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是接收端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>
<h3 id="TCP-发送窗口可以划分成四个部分-："><a href="#TCP-发送窗口可以划分成四个部分-：" class="headerlink" title="TCP 发送窗口可以划分成四个部分 ："></a><strong>TCP 发送窗口可以划分成四个部分</strong> ：</h3><ol>
<li>已经发送并且确认的TCP段（<strong>已经发送并确认</strong>）；</li>
<li>已经发送但是没有确认的TCP段（<strong>已经发送未确认</strong>）；</li>
<li>未发送但是接收方准备接收的TCP段（<strong>可以发送</strong>）；</li>
<li>未发送并且接收方也并未准备接受的TCP段（<strong>不可发送</strong>）。</li>
</ol>
<h3 id="TCP发送窗口结构图示-："><a href="#TCP发送窗口结构图示-：" class="headerlink" title="TCP发送窗口结构图示 ："></a><strong>TCP<font color="red">发送</font>窗口结构图示</strong> ：</h3><p><img src="/../../../images/image-20230220135411913.png" alt="image-20230220135411913"></p>
<ul>
<li><strong>SND.WND</strong> ：发送窗口。</li>
<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>
<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>
</ul>
<p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>
<h3 id="TCP-接收窗口可以划分成三个部分-："><a href="#TCP-接收窗口可以划分成三个部分-：" class="headerlink" title="TCP 接收窗口可以划分成三个部分 ："></a><strong>TCP <font color="red">接收</font>窗口可以划分成三个部分</strong> ：</h3><ol>
<li>已经接收并且已经确认的 TCP 段（<strong>已经接收并确认</strong>）；</li>
<li>等待接收且允许发送方发送 TCP 段（<strong>可以接收未确认</strong>）；</li>
<li>不可接收且不允许发送方发送TCP段（<strong>不可接收</strong>）。</li>
</ol>
<h3 id="TCP-接收窗口结构图示-："><a href="#TCP-接收窗口结构图示-：" class="headerlink" title="TCP 接收窗口结构图示 ："></a><strong>TCP 接收窗口结构图示</strong> ：</h3><p><img src="/../../../images/image-20230220135419120.png" alt="image-20230220135419120"></p>
<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>
<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>
<h2 id="TCP-的拥塞控制是怎么实现的？"><a href="#TCP-的拥塞控制是怎么实现的？" class="headerlink" title="# TCP 的拥塞控制是怎么实现的？"></a><a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> TCP 的拥塞控制是怎么实现的？</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><img src="/../../../images/image-20230220135425341.png" alt="image-20230220135425341"></p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="ARQ-协议了解吗-（Automatic-Repeat-reQuest）"><a href="#ARQ-协议了解吗-（Automatic-Repeat-reQuest）" class="headerlink" title="# ARQ 协议了解吗?（Automatic Repeat-reQuest）"></a><a href="#arq-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97">#</a> ARQ 协议了解吗?（Automatic Repeat-reQuest）</h2><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的<strong>错误纠正协</strong>议之一。<strong>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输</strong>。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h3 id="停止等待-ARQ-协议"><a href="#停止等待-ARQ-协议" class="headerlink" title="# 停止等待 ARQ 协议"></a><a href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a> 停止等待 ARQ 协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h4 id="1-无差错情况"><a href="#1-无差错情况" class="headerlink" title="1) 无差错情况:"></a><strong>1) 无差错情况:</strong></h4><p>发送方发送分组, 接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<h4 id="2-出现差错情况（超时重传）"><a href="#2-出现差错情况（超时重传）" class="headerlink" title="2) 出现差错情况（超时重传）:"></a><strong>2) 出现差错情况（超时重传）:</strong></h4><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h4 id="3-确认丢失和确认迟到"><a href="#3-确认丢失和确认迟到" class="headerlink" title="3) 确认丢失和确认迟到"></a><strong>3) 确认丢失和确认迟到</strong></h4><ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h3 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="# 连续 ARQ 协议"></a><a href="#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE">#</a> 连续 ARQ 协议</h3><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><p> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><p>不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" data-id="cleqdl4sm00amycv6aqi058ge" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/OSI 和 TCPIP 网络分层模型详解（基础）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:06:44.282Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">OSI 和 TCP/IP 网络分层模型详解（基础）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/OSI-%E5%92%8C-TCP-IP-%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">OSI 和 TCP/IP 网络分层模型详解（基础）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>OSI模型</strong>: 即<strong>开放式通信系统互联参考模型</strong>（<strong>Open System Interconnection Reference Model</strong>），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。</p>
<h2 id="OSI-七层模型"><a href="#OSI-七层模型" class="headerlink" title="OSI 七层模型"></a>OSI 七层模型</h2><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="/../../../images/image-20230220134708482.png" alt="image-20230220134708482"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>
<p><img src="/../../../images/image-20230220134715273.png" alt="image-20230220134715273"></p>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>
<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>
<p><img src="/../../../images/image-20230220134722147.png" alt="image-20230220134722147"></p>
<h2 id="TCP-x2F-IP-四层模型"><a href="#TCP-x2F-IP-四层模型" class="headerlink" title="# TCP/IP 四层模型"></a><a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> TCP/IP 四层模型</h2><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="/../../../images/image-20230220134732543.png" alt="image-20230220134732543"></p>
<h3 id="应用层（Application-layer）"><a href="#应用层（Application-layer）" class="headerlink" title="# 应用层（Application layer）"></a><a href="#%E5%BA%94%E7%94%A8%E5%B1%82-application-layer">#</a> 应用层（Application layer）</h3><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img src="/../../../images/image-20230220134737489.png" alt="image-20230220134737489"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><img src="/../../../images/image-20230220134743725.png" alt="image-20230220134743725"></p>
<p>应用层常见协议总结，请看这篇文章：<a href="">应用层常见协议总结（应用层）</a>。</p>
<h3 id="传输层（Transport-layer）"><a href="#传输层（Transport-layer）" class="headerlink" title="# 传输层（Transport layer）"></a><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82-transport-layer">#</a> 传输层（Transport layer）</h3><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>运输层主要使用以下两种协议：</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<p><img src="/../../../images/image-20230220134748906.png" alt="image-20230220134748906"></p>
<h3 id="网络层（Network-layer）"><a href="#网络层（Network-layer）" class="headerlink" title="# 网络层（Network layer）"></a><a href="#%E7%BD%91%E7%BB%9C%E5%B1%82-network-layer">#</a> 网络层（Network layer）</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><img src="/../../../images/image-20230220134754055.png" alt="image-20230220134754055"></p>
<p><strong>网络层常见协议</strong> ：</p>
<ul>
<li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li>
<li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li>
<li>……</li>
</ul>
<h3 id="网络接口层（Network-interface-layer）"><a href="#网络接口层（Network-interface-layer）" class="headerlink" title="# 网络接口层（Network interface layer）"></a><a href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-network-interface-layer">#</a> 网络接口层（Network interface layer）</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<p><img src="/../../../images/image-20230220134759211.png" alt="image-20230220134759211"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a><a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h3><p>简单总结一下每一层包含的协议和核心技术:</p>
<p><img src="/../../../images/image-20230220134804106.png" alt="image-20230220134804106"></p>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li>
<li>DHCP 协议（动态主机配置）</li>
<li>DNS 系统原理（域名系统）</li>
<li>FTP 协议（文件传输协议）</li>
<li>Telnet协议（远程登陆协议）</li>
<li>电子邮件协议等（SMTP、POP3、IMAP）</li>
<li>……</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议 <ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议 <ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li>
<li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT 协议（网络地址转换协议）</li>
<li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li>
<li>……</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA/CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
<li>……</li>
</ul>
<h2 id="网络分层的原因"><a href="#网络分层的原因" class="headerlink" title="# 网络分层的原因"></a><a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0">#</a> 网络分层的原因</h2><p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" data-id="cleqdl4sk00agycv62bstcwzm" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/HTTP vs HTTPS（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:05:17.336Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP vs HTTPS（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-vs-HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP vs HTTPS（应用层）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h2><h3 id="HTTP-协议介绍"><a href="#HTTP-协议介绍" class="headerlink" title="# HTTP 协议介绍"></a><a href="#http-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTP 协议介绍</h3><p>HTTP 协议，全称<strong>超文本传输协议</strong>（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3 id="HTTP-协议通信过程"><a href="#HTTP-协议通信过程" class="headerlink" title="# HTTP 协议通信过程"></a><a href="#http-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B">#</a> HTTP 协议通信过程</h3><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 80 端口等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<h3 id="HTTP-协议优点"><a href="#HTTP-协议优点" class="headerlink" title="# HTTP 协议优点"></a><a href="#http-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTP 协议优点</h3><p>扩展性强、速度快、跨平台支持性好。</p>
<h2 id="HTTPS-协议"><a href="#HTTPS-协议" class="headerlink" title="# HTTPS 协议"></a><a href="#https-%E5%8D%8F%E8%AE%AE">#</a> HTTPS 协议</h2><h3 id="HTTPS-协议介绍"><a href="#HTTPS-协议介绍" class="headerlink" title="# HTTPS 协议介绍"></a><a href="#https-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTPS 协议介绍</h3><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<h3 id="HTTPS-协议优点"><a href="#HTTPS-协议优点" class="headerlink" title="# HTTPS 协议优点"></a><a href="#https-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTPS 协议优点</h3><p>保密性好、信任度高。</p>
<h2 id="HTTPS-的核心—SSL-x2F-TLS协议"><a href="#HTTPS-的核心—SSL-x2F-TLS协议" class="headerlink" title="# HTTPS 的核心—SSL/TLS协议"></a><a href="#https-%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94ssl-tls%E5%8D%8F%E8%AE%AE">#</a> HTTPS 的核心—SSL/TLS协议</h2><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>
<h3 id="SSL-和-TLS-的区别？"><a href="#SSL-和-TLS-的区别？" class="headerlink" title="# SSL 和 TLS 的区别？"></a><a href="#ssl-%E5%92%8C-tls-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> SSL 和 TLS 的区别？</h3><p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p>
<h3 id="SSL-x2F-TLS-的工作原理"><a href="#SSL-x2F-TLS-的工作原理" class="headerlink" title="# SSL/TLS 的工作原理"></a><a href="#ssl-tls-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> SSL/TLS 的工作原理</h3><h4 id="非对称加密"><a href="#非对称加密" class="headerlink" title="# 非对称加密"></a><a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 非对称加密</h4><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<p><img src="/../../../images/image-20230220134425749.png" alt="image-20230220134425749"></p>
<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<p><img src="/../../../images/image-20230220134444105.png" alt="image-20230220134444105"></p>
<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>
<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<h4 id="对称加密"><a href="#对称加密" class="headerlink" title="# 对称加密"></a><a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 对称加密</h4><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<p><img src="/../../../images/image-20230220134457419.png" alt="image-20230220134457419"></p>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h4 id="公钥传输的信赖性"><a href="#公钥传输的信赖性" class="headerlink" title="# 公钥传输的信赖性"></a><a href="#%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%A1%E8%B5%96%E6%80%A7">#</a> 公钥传输的信赖性</h4><p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<p><img src="/../../../images/image-20230220134509815.png" alt="image-20230220134509815"></p>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="# 数字签名"></a><a href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">#</a> 数字签名</h4><p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<p><img src="/../../../images/image-20230220134547914.png" alt="image-20230220134547914"></p>
<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<p><img src="/../../../images/image-20230220134604571.png" alt="image-20230220134604571"></p>
<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18N411X7ty/">数字签名及数字证书原理open in new window</a>这个视频，这是我看过最清晰的讲解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220321121814946.png" alt="img"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="# 总结"></a><a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h2><ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="cleqdl4sk00aeycv64q83ek2x" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/HTTP常见状态码总结（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:03:30.381Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP 常见状态码总结（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP 常见状态码总结（应用层）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="/../../../images/image-20230220134615645.png" alt="image-20230220134615645"></p>
<h3 id="1xx-Informational（信息性状态码）"><a href="#1xx-Informational（信息性状态码）" class="headerlink" title="# 1xx Informational（信息性状态码）"></a><a href="#_1xx-informational-%E4%BF%A1%E6%81%AF%E6%80%A7%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 1xx Informational（信息性状态码）</h3><p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h3 id="2xx-Success（成功状态码）"><a href="#2xx-Success（成功状态码）" class="headerlink" title="# 2xx Success（成功状态码）"></a><a href="#_2xx-success-%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 2xx Success（成功状态码）</h3><ul>
<li><strong>200 OK</strong> ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>
<li><strong>201 Created</strong> ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>
<li><strong>202 Accepted</strong> ：服务端已经接收到了请求，但是还未处理。</li>
<li><strong>204 No Content</strong> ： 服务端已经成功处理了请求，但是没有返回任何内容。</li>
</ul>
<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-10.2.5">HTTP RFC 2616对204状态码的描述open in new window</a>如下：</p>
<blockquote>
<p>The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.</p>
<p>If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent’s active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent’s active view.</p>
<p>The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.</p>
</blockquote>
<p>简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p>
<p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p>
<h3 id="3xx-Redirection（重定向状态码）"><a href="#3xx-Redirection（重定向状态码）" class="headerlink" title="# 3xx Redirection（重定向状态码）"></a><a href="#_3xx-redirection-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 3xx Redirection（重定向状态码）</h3><ul>
<li><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</li>
<li><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>
</ul>
<h3 id="4xx-Client-Error（客户端错误状态码）"><a href="#4xx-Client-Error（客户端错误状态码）" class="headerlink" title="# 4xx Client Error（客户端错误状态码）"></a><a href="#_4xx-client-error-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 4xx Client Error（客户端错误状态码）</h3><ul>
<li><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</li>
<li><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</li>
<li><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>
<li><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h3 id="5xx-Server-Error（服务端错误状态码）"><a href="#5xx-Server-Error（服务端错误状态码）" class="headerlink" title="# 5xx Server Error（服务端错误状态码）"></a><a href="#_5xx-server-error-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 5xx Server Error（服务端错误状态码）</h3><ul>
<li><strong>500 Internal Server Error</strong> ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>
<li><strong>502 Bad Gateway</strong> ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="cleqdl4si00aaycv6fy02912d" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/TCP 三次握手和四次挥手（传输层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:01:27.122Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 三次握手和四次挥手（传输层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 三次握手和四次挥手（传输层）</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>(了解一下 半关闭状态)</p>
<p><strong>SYN</strong>：同步序列编号（<strong>Synchronize Sequence Numbers</strong>）。是TCP/IP建立连接时使用的<strong>握手信号</strong>。</p>
<p><strong>ACK</strong> : (<strong>Acknowledge character</strong>）即是确认字符，在数据通信中，接收站发给发送站的一种传输类<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>。表示发来的数据已确认接收无误。</p>
<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h2 id="建立连接-TCP-三次握手"><a href="#建立连接-TCP-三次握手" class="headerlink" title="# 建立连接-TCP 三次握手"></a><a href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 建立连接-TCP 三次握手</h2><p><img src="/../../../images/image-20230220134640946.png" alt="image-20230220134640946"></p>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>
</ul>
<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>
<h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="# 为什么要三次握手?"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 为什么要三次握手?</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p>更详细的解答可以看这个：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎open in new window</a> 。</p>
<h3 id="第2次握手传回了ACK，为什么还要传回SYN？"><a href="#第2次握手传回了ACK，为什么还要传回SYN？" class="headerlink" title="# 第2次握手传回了ACK，为什么还要传回SYN？"></a><a href="#%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ack-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9Esyn">#</a> 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 <strong>SYN 则是为了建立并确认从服务端到客户端的通信</strong>。</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h2 id="断开连接-TCP-四次挥手"><a href="#断开连接-TCP-四次挥手" class="headerlink" title="# 断开连接-TCP 四次挥手"></a><a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 断开连接-TCP 四次挥手</h2><p><img src="/../../../images/image-20230220134646808.png" alt="image-20230220134646808"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h4 id="ps-TCP状态说明"><a href="#ps-TCP状态说明" class="headerlink" title="ps: TCP状态说明"></a><strong>ps: TCP状态说明</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：表示初始状态。对服务端和C客户端双方都一样。</span><br><span class="line">LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。</span><br><span class="line">SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。</span><br><span class="line">SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。</span><br><span class="line">ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。</span><br><span class="line">FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。</span><br><span class="line">FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。</span><br><span class="line">TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</span><br><span class="line">CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。</span><br><span class="line">CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。</span><br><span class="line">LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">特别提示的是：为什么TIME_WAIT状态还需要等待2MSL才能回到CLOSED状态？或者为什么TCP要引入TIME_WAIT状态？</span><br><span class="line">《TCP/IP详解》中如此解释：当TCP执行一个主动关闭，并发回最后一个ACK后，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL，这样可以让TCP再次发送最后的ACK以防止这个ACK丢失（另一端超时重发最后的FIN）。</span><br><span class="line">附注：MSL（Maximum Segment Lifetime）即最大生存时间，RFC 793中指出MSL为2分钟，但是实现中的常用值为30秒、1分钟或者2分钟。</span><br></pre></td></tr></tbody></table></figure>

<h3 id="为什么要四次挥手？"><a href="#为什么要四次挥手？" class="headerlink" title="# 为什么要四次挥手？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。<mark>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接</mark>。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h3 id="为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？"><a href="#为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？" class="headerlink" title="# 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ack-%E5%92%8C-fin-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5-%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h3 id="如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？" class="headerlink" title="# 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？"></a><a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3 id="为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="# 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" data-id="cleqdl4sl00akycv6gdp6asyn" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/计算机网络面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-02-19T08:59:06.959Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">计算机网络基础</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/">计算机网络基础</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h2><h3 id="OSI-和-TCP-x2F-IP-网络分层模型"><a href="#OSI-和-TCP-x2F-IP-网络分层模型" class="headerlink" title="OSI 和 TCP/IP 网络分层模型"></a>OSI 和 TCP/IP 网络分层模型</h3><p><strong>相关面试题</strong> ：</p>
<ul>
<li>OSI 七层模型是什么？每一层的作用是什么？</li>
<li>TCP/IP 四层模型是什么？每一层的作用是什么？</li>
<li>为什么网络要分层？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="">OSI 和 TCP/IP 网络分层模型详解（基础）</a>。</p>
<h3 id="应用层有哪些常见的协议？"><a href="#应用层有哪些常见的协议？" class="headerlink" title="应用层有哪些常见的协议？"></a>应用层有哪些常见的协议？</h3><p><a href="">应用层常见协议总结（应用层）</a></p>
<h2 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h2><p><strong>TCP</strong>: <strong>传输控制协议（TCP，Transmission Control Protocol）</strong>是一种面向连接的、可靠的、基于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E6%B5%81/3196772?fromModule=lemma_inlink">字节流</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536?fromModule=lemma_inlink">传输层</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3351624?fromModule=lemma_inlink">通信协议</a>，由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IETF/2800318?fromModule=lemma_inlink">IETF</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/RFC/2798645?fromModule=lemma_inlink">RFC</a> 定义。</p>
<p><strong>UDP</strong>: [Internet ](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Internet">https://baike.baidu.com/item/Internet</a> /272794?fromModule=lemma_inlink)协议集支持一个无连接的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821?fromModule=lemma_inlink">传输协议</a>，该协议称为<strong>用户数据报协议（UDP，User Datagram Protocol）</strong>。UDP 为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>提供了一种<strong>无需建立连接</strong>就可以发送封装的 IP 数据包的方法。RFC 描述了 UDP。</p>
<h3 id="TCP-与-UDP-的区别（重要）"><a href="#TCP-与-UDP-的区别（重要）" class="headerlink" title="TCP 与 UDP 的区别（重要）"></a>TCP 与 UDP 的区别（重要）</h3><ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。<strong>TCP 传输是有状态的</strong>，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态服务</strong>，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
<li>……</li>
</ol>
<p>我把上面总结的内容通过表格形式展示出来了！</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<h3 id="什么时候选择-TCP-什么时候选-UDP"><a href="#什么时候选择-TCP-什么时候选-UDP" class="headerlink" title="什么时候选择 TCP,什么时候选 UDP?"></a>什么时候选择 TCP,什么时候选 UDP?</h3><ul>
<li><strong>UDP 一般用于即时通信</strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3 id="HTTP-基于-TCP-还是-UDP？"><a href="#HTTP-基于-TCP-还是-UDP？" class="headerlink" title="HTTP 基于 TCP 还是 UDP？"></a>HTTP 基于 TCP 还是 UDP？</h3><p><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</p>
<h3 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3><p><strong>运行于 TCP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li>
<li><strong>POP3/IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>……</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h3 id="TCP-三次握手和四次挥手（非常重要）"><a href="#TCP-三次握手和四次挥手（非常重要）" class="headerlink" title="TCP 三次握手和四次挥手（非常重要）"></a>TCP 三次握手和四次挥手（非常重要）</h3><p><strong>相关面试题</strong> ：</p>
<ul>
<li>为什么要三次握手?</li>
<li>第 2 次握手传回了ACK，为什么还要传回SYN？</li>
<li>为什么要四次挥手？</li>
<li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li>
<li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li>
<li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="">TCP 三次握手和四次挥手（传输层）</a> 。</p>
<h3 id="TCP-如何保证传输的可靠性？（重要）"><a href="#TCP-如何保证传输的可靠性？（重要）" class="headerlink" title="TCP 如何保证传输的可靠性？（重要）"></a>TCP 如何保证传输的可靠性？（重要）</h3><p><a href="">TCP 传输可靠性保障（传输层）</a></p>
<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="从输入URL-到页面展示到底发生了什么？（非常重要）"><a href="#从输入URL-到页面展示到底发生了什么？（非常重要）" class="headerlink" title="从输入URL 到页面展示到底发生了什么？（非常重要）"></a>从输入URL 到页面展示到底发生了什么？（非常重要）</h3><blockquote>
<p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p>
</blockquote>
<p>图解（图片来源：《图解 HTTP》）：</p>
<p><img src="/../../../images/image-20230220134232347.png" alt="image-20230220134232347"></p>
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么？open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li>
</ul>
<h3 id="HTTP-状态码有哪些？"><a href="#HTTP-状态码有哪些？" class="headerlink" title="HTTP 状态码有哪些？"></a>HTTP 状态码有哪些？</h3><p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="/../../../images/image-20230220134252269.png" alt="image-20230220134252269"></p>
<p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="">HTTP 常见状态码总结（应用层）</a>。</p>
<h3 id="HTTP-和-HTTPS-有什么区别？（重要）"><a href="#HTTP-和-HTTPS-有什么区别？（重要）" class="headerlink" title="# HTTP 和 HTTPS 有什么区别？（重要）"></a><a href="#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">#</a> HTTP 和 HTTPS 有什么区别？（重要）</h3><ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
<p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP vs HTTPS（应用层）</a> 。</p>
<h3 id="HTTP-1-0-和-HTTP-1-1-有什么区别？"><a href="#HTTP-1-0-和-HTTP-1-1-有什么区别？" class="headerlink" title="# HTTP 1.0 和 HTTP 1.1 有什么区别？"></a><a href="#http-1-0-%E5%92%8C-http-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP 1.0 和 HTTP 1.1 有什么区别？</h3><ul>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段。</li>
</ul>
<p>关于 HTTP 1.0 和 HTTP 1.1 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP 1.0 vs HTTP 1.1（应用层）</a> 。</p>
<h3 id="HTTP-是不保存状态的协议-如何保存用户状态"><a href="#HTTP-是不保存状态的协议-如何保存用户状态" class="headerlink" title="# HTTP 是不保存状态的协议, 如何保存用户状态?"></a><a href="#http-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81">#</a> HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<p><img src="/../../../images/image-20230220134259293.png" alt="image-20230220134259293"></p>
<h3 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="# URI 和 URL 的区别是什么?"></a><a href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> URI 和 URL 的区别是什么?</h3><ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="# ARP"></a><a href="#arp">#</a> ARP</h2><h3 id="什么是-Mac-地址？"><a href="#什么是-Mac-地址？" class="headerlink" title="# 什么是 Mac 地址？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-mac-%E5%9C%B0%E5%9D%80">#</a> 什么是 Mac 地址？</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p><img src="/.com//../../../../../assets/2008410143049281.3c367990.png" alt="路由器的背面就会注明 MAC 位址"></p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3 id="ARP-协议解决了什么问题地位如何？"><a href="#ARP-协议解决了什么问题地位如何？" class="headerlink" title="# ARP 协议解决了什么问题地位如何？"></a><a href="#arp-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%9C%B0%E4%BD%8D%E5%A6%82%E4%BD%95">#</a> ARP 协议解决了什么问题地位如何？</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<h3 id="ARP-协议的工作原理？"><a href="#ARP-协议的工作原理？" class="headerlink" title="# ARP 协议的工作原理？"></a><a href="#arp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> ARP 协议的工作原理？</h3><p><a href="">ARP 协议详解(网络层)</a></p>
<h2 id="复习建议"><a href="#复习建议" class="headerlink" title="# 复习建议"></a><a href="#%E5%A4%8D%E4%B9%A0%E5%BB%BA%E8%AE%AE">#</a> 复习建议</h2><p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cleqdl4sq00b1ycv65my85b1f" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/牛客网java核心基础面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-02-19T08:22:52.808Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">牛客网java核心基础面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">牛客网java核心基础面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么Java代码可以实现一次编写、到处运行？"><a href="#为什么Java代码可以实现一次编写、到处运行？" class="headerlink" title="为什么Java代码可以实现一次编写、到处运行？"></a>为什么Java代码可以实现一次编写、到处运行？</h2><p><img src="/../../images/image-20230222165320333.png" alt="image-20230222165320333"></p>
<h2 id="遇到过异常吗，如何处理？"><a href="#遇到过异常吗，如何处理？" class="headerlink" title="遇到过异常吗，如何处理？"></a>遇到过异常吗，如何处理？</h2><p><strong>参考答案</strong></p>
<p>在Java中，可以按照如下三个步骤处理异常：</p>
<ol>
<li><strong>捕获异常</strong></li>
</ol>
<p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p>
<ol start="2">
<li><strong>处理异常</strong></li>
</ol>
<p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p>
<ol start="3">
<li><strong>回收资源</strong></li>
</ol>
<p>如果业务代码打开了某个资源，比如数据库连接、网络连接、磁盘文件等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p>
<h2 id="说一说Java的异常机制？"><a href="#说一说Java的异常机制？" class="headerlink" title="说一说Java的异常机制？"></a>说一说Java的异常机制？</h2><p><strong>参考答案</strong></p>
<p><strong>关于异常的处理：</strong></p>
<p>在Java中，处理异常的语句由try、catch、finally三部分组成。其中，try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p>
<p><strong>关于抛出异常：</strong></p>
<p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上通过throws关键字声明抛出异常，则该异常将交给JVM处理。</p>
<p><strong>关于异常跟踪栈：</strong></p>
<p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p>
<h2 id="finally是无条件执行的吗？"><a href="#finally是无条件执行的吗？" class="headerlink" title="finally是无条件执行的吗？"></a>finally是无条件执行的吗？</h2><p><strong>参考答案</strong></p>
<p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p>
<p><strong>注意事项</strong></p>
<p>如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p>
<h2 id="在finally中return会发生什么？"><a href="#在finally中return会发生什么？" class="headerlink" title="在finally中return会发生什么？"></a>在finally中return会发生什么？</h2><p><strong>参考答案</strong></p>
<p>在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中return、throw语句失效。</p>
<p><strong>详细解析</strong></p>
<p>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p>
<h2 id="static和final有什么区别？"><a href="#static和final有什么区别？" class="headerlink" title="static和final有什么区别？"></a>static和final有什么区别？</h2><p><img src="/../../images/image-20230219163021865.png" alt="image-20230219163021865"></p>
<p><img src="/../../images/image-20230219163033920.png" alt="image-20230219163033920"></p>
<h2 id="说说你对泛型的理解"><a href="#说说你对泛型的理解" class="headerlink" title="说说你对泛型的理解"></a>说说你对泛型的理解</h2><p><img src="/../../images/image-20230219162902190.png" alt="image-20230219162902190"></p>
<h2 id="List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？"><a href="#List-lt-super-T-gt-和List-lt-extends-T-gt-有什么区别？" class="headerlink" title="List<? super T>和List<? extends T>有什么区别？"></a>List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</h2><p><strong>参考答案</strong></p>
<ul>
<li><p>? 是类型通配符， List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List； </p>
</li>
<li><p>List&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；</p>
</li>
<li><p>List&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。</p>
</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<integer> 对象赋值给List<number> 变量。</number></integer></p>
<p>数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但 G<foo> 不是 G<bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</bar></foo></p>
<h2 id="说说你对Java反射机制的理解"><a href="#说说你对Java反射机制的理解" class="headerlink" title="说说你对Java反射机制的理解"></a>说说你对Java反射机制的理解</h2><p><img src="/../../images/image-20230219162554595.png" alt="image-20230219162554595"></p>
<h2 id="Java反射在实际项目种有哪些应用场景？"><a href="#Java反射在实际项目种有哪些应用场景？" class="headerlink" title="Java反射在实际项目种有哪些应用场景？"></a>Java反射在实际项目种有哪些应用场景？</h2><p><strong>参考答案</strong></p>
<p>Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p>
<ul>
<li><p>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</p>
</li>
<li><p>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</p>
</li>
<li><p>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</p>
</li>
</ul>
<p><img src="/../../images/image-20230219162329199.png" alt="image-20230219162329199"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cleqdl4qf004eycv67o063jbj" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>154</strong><br>文章</div></a>
      <a href="/categories"><div><strong>83</strong><br>分类</div></a>
      <a href="/tags"><div><strong>55</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>