<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>179</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-MQ/RabbitMQ架构模型" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/29/MQ/RabbitMQ%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/" class="article-date">
  <time class="post-time" datetime="2023-07-29T03:02:23.816Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/29/MQ/RabbitMQ%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/">RabbitMQ架构模型</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/MQ/">MQ</a>,<a class="article-category-link" href="/categories/MQ/rabbitmq/">rabbitmq</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RabbitMQ是采用Erlang语言实现AMQP（Advanced Message Queuing Protocol,高级消息队列协议）的消息中间件。</p>
<h1 id="RabbitMQ架构模型"><a href="#RabbitMQ架构模型" class="headerlink" title="RabbitMQ架构模型"></a>RabbitMQ架构模型</h1><p><img src="/../../images/image-20230729110344452.png" alt="image-20230729110344452"></p>
<p><img src="/../../images/image-20230729110358056.png" alt="image-20230729110358056"></p>
<h2 id="Producer：生产者"><a href="#Producer：生产者" class="headerlink" title="# Producer：生产者"></a># Producer：生产者</h2><p>就是投递消息的一方，生产者创建消息发布到RabbitMQ中。</p>
<p>消息包含2部分：</p>
<p><strong>消息体（payload）：</strong></p>
<p>一般是一个带有业务逻辑结构的数据，比如一个JSON字符串。</p>
<p><strong>标签(Label)</strong></p>
<p>用来描述这条消息，比如一个交换器的名称和一个路由键。</p>
<p>生产者把消息交由RabbitMQ，RabbitMQ之后会根据标签吧消息发送给感兴趣的消费者</p>
<h2 id="Consumer：消费方"><a href="#Consumer：消费方" class="headerlink" title="# Consumer：消费方"></a># Consumer：消费方</h2><p>就是接受消息一方</p>
<p>消费者连接到RabbitMQ服务器，并订阅到队列上。当消费者消费一条消息时，只是消费消息的消息体（payload）。在消息路由的过程中，消息的标签会丢弃，存入到队列中的消息只有消息体，消费者也只会消费到消息体。</p>
<p>消息如果只是存储在队列里是没有任何用处的。被应用消费掉，消息的价值才能够体现。在 AMQP 0-9-1 模型中，有两种途径可以达到此目的：</p>
<ol>
<li>将消息投递给应用 (“push API”)</li>
<li>应用根据需要主动获取消息 (“pull API”)</li>
</ol>
<h2 id="Broker：服务节点"><a href="#Broker：服务节点" class="headerlink" title="# Broker：服务节点"></a># Broker：服务节点</h2><p>可以将一个RabbitMQ Broker看作一台RabbitMQ服务器。</p>
<p><img src="/../../images/image-20230729110532514.png" alt="image-20230729110532514"></p>
<h2 id="Queue队列："><a href="#Queue队列：" class="headerlink" title="# Queue队列："></a># Queue队列：</h2><p>用于存储消息</p>
<p><img src="/../../images/image-20230729110551724.png" alt="image-20230729110551724"></p>
<h3 id="队列属性"><a href="#队列属性" class="headerlink" title="队列属性"></a><strong>队列属性</strong></h3><p>队列跟交换机共享某些属性，但是队列也有一些另外的属性。</p>
<ul>
<li>Name</li>
<li>Durable（消息代理重启后，队列依旧存在）</li>
<li>Exclusive（只被一个连接（connection）使用，而且当连接关闭后队列即被删除）</li>
<li>Auto-delete（当最后一个消费者退订后即被删除）</li>
<li>Arguments（一些消息代理用他来完成类似与 TTL 的某些额外功能）</li>
</ul>
<h3 id="队列创建"><a href="#队列创建" class="headerlink" title="队列创建"></a>队列创建</h3><p>队列在声明（declare）后才能被使用。</p>
<p>如果一个队列尚不存在，声明一个队列会创建它。</p>
<p>如果声明的队列已经存在，并且属性完全相同，那么此次声明不会对原有队列产生任何影响。</p>
<p>如果声明中的属性与已存在队列的属性有差异，那么一个错误代码为 406 的通道级异常就会被抛出。</p>
<h3 id="队列持久化"><a href="#队列持久化" class="headerlink" title="队列持久化"></a>队列持久化</h3><p>持久化队列（Durable queues）会被存储在磁盘上，当消息代理（broker）重启的时候，它依旧存在。没有被持久化的队列称作暂存队列（Transient queues）。并不是所有的场景和案例都需要将队列持久化。</p>
<p>持久化的队列并不会使得路由到它的消息也具有持久性。倘若消息代理挂掉了，重新启动，那么在重启的过程中持久化队列会被重新声明，无论怎样，只有经过持久化的消息才能被重新恢复。</p>
<h2 id="Exchange：交换器"><a href="#Exchange：交换器" class="headerlink" title="# Exchange：交换器"></a># Exchange：交换器</h2><p>生产者将消息发送到Exchange，由交换器将消息路由到一个或者多个队列中，如果路由不到，或许返回给生产者，或许直接丢弃。</p>
<p><img src="/../../images/image-20230729110643513.png" alt="image-20230729110643513"></p>
<h3 id="交换机有两种状态："><a href="#交换机有两种状态：" class="headerlink" title="交换机有两种状态："></a>交换机有两种状态：</h3><h4 id="持久（durable）："><a href="#持久（durable）：" class="headerlink" title="持久（durable）："></a>持久（durable）：</h4><p>持久化的交换机会在消息代理（broker）重启后依旧存在，而暂存的交换机则不会（它们需要在代理再次上线后重新被声明）。</p>
<p>并不是所有的应用场景都需要持久化的交换机。</p>
<h4 id="暂存（transient）"><a href="#暂存（transient）" class="headerlink" title="暂存（transient）"></a>暂存（transient）</h4><h3 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h3><h4 id="–fanout广播"><a href="#–fanout广播" class="headerlink" title="–fanout广播"></a>–fanout广播</h4><p>将所有发送到交换器的消息路由到所有与该交换器绑定对的队列中。</p>
<h4 id="–topic主题"><a href="#–topic主题" class="headerlink" title="–topic主题"></a>–topic主题</h4><p>主题交换机（topic exchanges）通过对消息的路由键和队列到交换机的绑定模式之间的匹配，将消息路由给一个或多个队列。主题交换机经常用来实现各种分发/订阅模式及其变种。主题交换机通常用来实现消息的多播路由（multicast routing）。</p>
<p>RoutingKey为一个点号“.”分割的字符串（被点号“.”分隔开的每一段独立的字符串称为一个单词）</p>
<p>BindingKey中可以存在两种特殊的字符串“*”和“#”，用于做模糊匹配，</p>
<p>匹配0个或者多个单词</p>
<ul>
<li>匹配一个单词</li>
</ul>
<p><img src="/../../images/image-20230729110759035.png" alt="image-20230729110759035"></p>
<h4 id="–direct直连"><a href="#–direct直连" class="headerlink" title="–direct直连"></a>–direct直连</h4><p>把消息路由到哪些BindKey和RoutingKey完全匹配的队列中。</p>
<h4 id="–headers头交换机"><a href="#–headers头交换机" class="headerlink" title="–headers头交换机"></a>–headers头交换机</h4><p>不依赖与路由键的匹配规则，基本不用了</p>
<h2 id="RoutingKey：路由键"><a href="#RoutingKey：路由键" class="headerlink" title="# RoutingKey：路由键"></a># RoutingKey：路由键</h2><p>生产者将消息发送给交换器的时候，一般会指定一个RoutingKey，用来指定消息的路由规则，而这个RoutingKey需要与交换器类型和绑定键（BindingKey）联合使用才能最终生效。</p>
<p>在交换器类型和绑定键(BindingKey）固定的情况下，生产者可以发送消息给交换器时，通过指定RoutingKey来决定消息流向哪里。</p>
<h2 id="BindingKey：绑定"><a href="#BindingKey：绑定" class="headerlink" title="# BindingKey：绑定"></a># BindingKey：绑定</h2><p>RabbitMQ通过绑定将交换器与队列关联起来，在绑定的时候一般会指定一个绑定键（BindingKey），这样RabbitMQ就知道如何正确的将消息路由到队列了。</p>
<p><img src="/../../images/image-20230729110830440.png" alt="image-20230729110830440"></p>
<h2 id="Connection-连接"><a href="#Connection-连接" class="headerlink" title="# Connection:连接"></a># Connection:连接</h2><p>:Connection 和Channel 。我们知道无论是生产者还是消费者，都需要和RabbitMQ Broker 建立连接，这个连接就是一条<font color="red"><strong>TCP</strong></font> 连接，也就是Connection 。</p>
<p><img src="/../../images/image-20230729110854942.png" alt="image-20230729110854942"></p>
<h2 id="Channel：信道"><a href="#Channel：信道" class="headerlink" title="# Channel：信道"></a># Channel：信道</h2><p>一旦TCP 连接建立起来，客户端紧接着可以创建一个AMQP 信道(Channel) ，每个信道都会被指派一个唯一的ID 。信道是建立在Connection 之上的<strong>虚拟连接</strong>， RabbitMQ 处理的每条AMQP 指令都是通过信道完成的。</p>
<p><strong>我们完全可以直接使用Connection 就能完成信道的工作，为什么还要引入信道呢?</strong></p>
<p>一个应用程序中有很多个线程需要从RabbitMQ 中消费消息，或者生产消息，那么必然需要建立很多个Connection ，也就是许多个TCP 连接。然而对于操作系统而言，建立和销毁TCP 连接是非常昂贵的开销，如果遇到使用高峰，性能瓶颈也随之显现。RabbitMQ 采用类似NIO’ (Non-blocking 1/0) 的做法，选择TCP 连接复用，不仅可以减少性能开销，同时也便于管理。</p>
<p>每个线程把持一个信道，所以信道复用了Connection 的TCP 连接。同时RabbitMQ 可以确保每个线程的私密性，就像拥有独立的连接一样。当每个信道的流量不是很大时，复用单一的Connection 可以在产生性能瓶颈的情况下有效地节省TCP 连接资源。但是当信道本身的流量很大时，这时候多个信道复用一个Connection 就会产生性能瓶颈，进而使整体的流量被限制了。此时就需要开辟多个Connection ，将这些信道均摊到这些Connection 中， 至于这些相关的调优策略需要根据业务自身的实际情况进行调节。</p>
<p>信道在AMQP 中是一个很重要的概念，大多数操作都是在信道这个层面展开的。在代码清单中也可以看出一些端倪，</p>
<p>比如channel.exchangeDeclare 、channel .queueDeclare 、channel.basicPublish 和channel.basicConsume 等方法。</p>
<p>RabbitMQ 相关的API 与AMQP紧密相连，比如channel.basicPublish 对应AMQP 的Basic.Publish 命令.</p>
<h2 id="vhosts：虚拟主机"><a href="#vhosts：虚拟主机" class="headerlink" title="# vhosts：虚拟主机"></a># vhosts：虚拟主机</h2><p>为了在一个单独的代理上实现多个隔离的环境（用户、用户组、交换机、队列 等），AMQP 提供了一个虚拟主机（virtual hosts - vhosts）的概念。这跟 Web servers 虚拟主机概念非常相似，这为 AMQP 实体提供了完全隔离的环境。当连接被建立的时候，AMQP 客户端来指定使用哪个虚拟主机。</p>
<h2 id="RabbitMQ运转流程"><a href="#RabbitMQ运转流程" class="headerlink" title="# RabbitMQ运转流程"></a># RabbitMQ运转流程</h2><h3 id="生产者发送消息的时候"><a href="#生产者发送消息的时候" class="headerlink" title="生产者发送消息的时候"></a>生产者发送消息的时候</h3><p>(1)  生产者连接到RabbitMQ Broker ， 建立一个连接( Connection) ，开启一个信道(Channel)</p>
<p>(2)  生产者声明一个交换器，并设置相关属性，比如交换机类型、是否持久化等</p>
<p>(3)  生产者声明一个队列井设置相关属性，比如是否排他、是否持久化、是否自动删除等</p>
<p>(4)  生产者通过路由键将交换器和队列绑定起来</p>
<p>(5)  生产者发送消息至RabbitMQ Broker，其中包含路由键、交换器等信息</p>
<p>(6)  相应的交换器根据接收到的路由键查找相匹配的队列。</p>
<p>(7)  如果找到，则将从生产者发送过来的消息存入相应的队列中。</p>
<p>(8)  如果没有找到，则根据生产者配置的属性选择丢弃还是回退给生产者</p>
<p>(9)  关闭信道。</p>
<p>(10)  关闭连接。</p>
<h3 id="消费者接收消息的过程"><a href="#消费者接收消息的过程" class="headerlink" title="消费者接收消息的过程:"></a>消费者接收消息的过程:</h3><p>(1) 消费者连接到RabbitMQ Broker ，建立一个连接(Connection ) ，开启一个信道(Channel) 。</p>
<p>(2) 消费者向RabbitMQ Broker 请求消费相应队列中的消息，可能会设置相应的回调函数，<br>以及做一些准备工作</p>
<p>(3) 等待RabbitMQ Broker 回应并投递相应队列中的消息， 消费者接收消息。</p>
<p>(4) 消费者确认( ack) 接收到的消息。</p>
<p>(5) RabbitMQ 从队列中删除相应己经被确认的消息。</p>
<p>(6) 关闭信道。</p>
<p>(7) 关闭连接</p>
<h2 id="AMQP协议"><a href="#AMQP协议" class="headerlink" title="# AMQP协议"></a># AMQP协议</h2><p>RabbitMQ是采用Erlang语言实现AMQP（Advanced Message Queuing Protocol,高级消息队列协议）的消息中间件。</p>
<p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。</p>
<p>AMQP 说到底还是一个通信协议，通信协议都会涉及报文交互，从low-level 举例来说，AMQP 本身是应用层的协议，其填充于TCP 协议层的数据部分。而从high-level 来说， AMQP是通过协议命令进行交互的。AMQP 协议可以看作一系列结构化命令的集合，这里的命令代表一种操作，类似于HTTP 中的方法(GET 、POST 、PUT 、DELETE 等) </p>
<h2 id="消息机制"><a href="#消息机制" class="headerlink" title="# 消息机制"></a># 消息机制</h2><h3 id="消息确认"><a href="#消息确认" class="headerlink" title="消息确认"></a>消息确认</h3><p>消费者应用（Consumer applications） - 用来接受和处理消息的应用 - 在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。这就给我们出了个难题，AMQP 代理在什么时候删除消息才是正确的？AMQP 0-9-1 规范给我们两种建议：</p>
<p>自动确认模式：当消息代理（broker）将消息发送给应用后立即删除。（使用 AMQP 方法：basic.deliver 或 basic.get-ok）)<br>显式确认模式：待应用（application）发送一个确认回执（acknowledgement）后再删除消息。（使用 AMQP 方法：basic.ack）<br>如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。</p>
<h3 id="拒绝消息"><a href="#拒绝消息" class="headerlink" title="拒绝消息"></a>拒绝消息</h3><p>当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。应用可以向消息代理表明，本条消息由于 “拒绝消息（Rejecting Messages）” 的原因处理失败了（或者未能在此时完成）。</p>
<p>当拒绝某条消息时，应用可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。</p>
<p>当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。</p>
<p>在 AMQP 中，basic.reject 方法用来执行拒绝消息的操作。但 basic.reject 有个限制：你不能使用它决绝多个带有确认回执（acknowledgements）的消息。但是如果你使用的是 RabbitMQ，那么你可以使用被称作 negative acknowledgements（也叫 nacks）的 AMQP 0-9-1 扩展来解决这个问题。</p>
<h3 id="预取消息"><a href="#预取消息" class="headerlink" title="预取消息"></a>预取消息</h3><p>在多个消费者共享一个队列的案例中，明确指定在收到下一个确认回执前每个消费者一次可以接受多少条消息是非常有用的。这可以在试图批量发布消息的时候起到简单的负载均衡和提高消息吞吐量的作用。For example, if a producing application sends messages every minute because of the nature of the work it is doing.（例如，如果生产应用每分钟才发送一条消息，这说明处理工作尚在运行。）</p>
<p>注意，RabbitMQ 只支持通道级的预取计数，而不是连接级的或者基于大小的预取。</p>
<h3 id="消息属性"><a href="#消息属性" class="headerlink" title="消息属性"></a>消息属性</h3><p>AMQP 模型中的消息（Message）对象是带有属性（Attributes）的。有些属性及其常见，以至于 AMQP 0-9-1 明确的定义了它们，并且应用开发者们无需费心思思考这些属性名字所代表的具体含义。例如：</p>
<ul>
<li>Content type（内容类型）</li>
<li>Content encoding（内容编码）</li>
<li>Routing key（路由键）</li>
<li>Delivery mode (persistent or not)</li>
<li>投递模式（持久化 或 非持久化）</li>
<li>Message priority（消息优先权）</li>
<li>Message publishing timestamp（消息发布的时间戳）</li>
<li>Expiration period（消息有效期）</li>
<li>Publisher application id（发布应用的 ID）</li>
</ul>
<p>有些属性是被 AMQP 代理所使用的，但是大多数是开放给接收它们的应用解释器用的。有些属性是可选的也被称作消息头（headers）。他们跟 HTTP 协议的 X-Headers 很相似。消息属性需要在消息被发布的时候定义。</p>
<h3 id="消息主体"><a href="#消息主体" class="headerlink" title="消息主体"></a>消息主体</h3><p>AMQP 的消息除属性外，也含有一个有效载荷 - Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。</p>
<p>消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和 MessagePack 将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP 及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。</p>
<h3 id="消息持久化"><a href="#消息持久化" class="headerlink" title="消息持久化"></a>消息持久化</h3><p>消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。</p>
<p>简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：它完全取决与消息本身的持久模式（persistence mode）。将消息以持久化方式发布时，会对性能造成一定的影响（就像数据库操作一样，健壮性的存在必定造成一些性能牺牲）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/29/MQ/RabbitMQ%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%9E%8B/" data-id="clkngg0ev000h2wv6g19v4m5u" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rabbitmq/" rel="tag">rabbitmq</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-MQ/MQ如何确保消息的重复消费" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/29/MQ/MQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/" class="article-date">
  <time class="post-time" datetime="2023-07-29T01:43:28.903Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>幂等：一个数据或者一个请求，重复了多次，确保对应的数据是不会改变的，不能出错</p>
<p>思路：</p>
<ul>
<li>如果是redis，就没问题，因为每次都是set（会覆盖），天然幂等性</li>
<li>生产者发送消息的时候会带上一个确据唯一的id，消费者拿到消息之后，先根据这个id去redis里查一下，之前有没有消费过，没后消费过就处理，并且写入这个唯一id到redis中，如果消费过，则不处理</li>
<li>基于数据库做 <strong>去重表</strong><ul>
<li>利用数据库表单的特性来实现幂等，常用的一个思路是在表上构建唯一性索引，保证某一类数据一旦执行完毕，后续同样的请求不再重复处理了（利用一张日志表来记录已经处理成功的消息ID，如果新到的消息ID，如果新到的消息ID已经在日志表中，那么就不再处理这条消息）</li>
<li>以电商平台为例子，电商平台上的订单 id 就是最适合的 token。当用户下单时，会经历多个环节，比如生成订单，)减库存，减优惠券等等。每一个环节执行时都先检测一下该订单 id 是否已经执行过这一步骤，对未执行的请求，执行操作并缓存结果，而对已经执行过的 id，则直接返回之前的执行结果，不做任何操作。这样可以在最大程度上避免操作的重复执行问题，缓存起来的执行结果也能用于事务的控制等。</li>
<li><img src="/../../images/image-20230729101655318.png" alt="image-20230729101655318"></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/29/MQ/MQ%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9/" data-id="clkngg0er000e2wv62uvzaen8" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/操作系统/协程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/27/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%8F%E7%A8%8B/" class="article-date">
  <time class="post-time" datetime="2023-07-26T16:44:26.972Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="什么是协程？"><a href="#什么是协程？" class="headerlink" title="什么是协程？"></a>什么是协程？</h2><h1 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h1><p>协程（Coroutines）是一种比线程更加轻量级的存在。协程完全由程序所控制（在<mark><strong>用户态</strong></mark>执行），带来的好处是性能大幅度的提升。 一个操作系统中可以有多个进程；一个进程可以有多个线程；同理，一个线程可以有多个协程。</p>
<p>协程是一个特殊的<mark><strong>函数</strong></mark>，这个函数可以在某个地方挂起，并且可以重新在挂起处继续运行。 <strong>一个线程内的多个协程的运行是串行的，这点和多进程（多线程）在多核CPU上执行时是不同的。</strong> 多进程（多线程）在多核CPU上是可以并行的。<strong>当线程内的某一个协程运行时，其它协程必须挂起。</strong></p>
<h2 id="协程切换"><a href="#协程切换" class="headerlink" title="协程切换"></a>协程切换</h2><p>由于<strong>协程切换是在线程内完成的，涉及到的资源比较少</strong>。不像内核级线程（进程）切换那样，上下文的内容比较多，切换代价较大。协程本身是非常轻巧的，可以简单理解为只是切换了寄存器和协程栈的内容。这样代价就非常小。</p>
<p>如果有不了解进程（线程）切换的，可以参考下面的资料:</p>
<p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://blog.csdn.net/21cnbao/article/details/108860584">深入理解Linux内核进程上下文切换</a></p>
<p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://blog.csdn.net/williamgavin/article/details/83062645">操作系统（四） – 用户级线程与核心级线程（线程的切换）</a></p>
<p><a href="https://cloud.tencent.com/developer/tools/blog-entry?target=https://blog.csdn.net/zy010101/article/details/83547157">线程</a></p>
<h3 id="协程切换的问题"><a href="#协程切换的问题" class="headerlink" title="协程切换的问题"></a>协程切换的问题</h3><p>实际上协程只有在等待IO的过程中才能重复利用线程，也就是说协程本质是通过多路复用来完成的。但是有个问题是，协程本身不是线程，只是一个特殊的函数，它不能被操作系统感知到（操作系统只能感知到进程和内核级线程），如果某个线程中的协程调用了阻塞IO，那么将会导致线程切换发生。因此只有协程是不够的，是无法解决问题的。还需要异步来配合协程。 <strong>因此，实际上我们可以把协程可以看做是一种用户级线程的实现。</strong> <strong>协程+异步才能发挥出协程的最大作用</strong></p>
<h2 id="协程的使用"><a href="#协程的使用" class="headerlink" title="协程的使用"></a>协程的使用</h2><ul>
<li>计算型的操作，利用协程来回切换执行，没有任何意义，来回切换并保存状态 反倒会降低性能。</li>
<li><strong>IO型的操作，利用协程在IO等待时间就去切换执行其他任务，当IO操作结束后再自动回调</strong>，那么就会大大节省资源并提供性能，从而实现<strong>异步编程</strong>（不等待任务结束就可以去执行其他代码）。</li>
</ul>
<p><strong>协程不是什么银弹，要注意使用场景。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/27/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%8D%8F%E7%A8%8B/" data-id="clkngg0os00c62wv64f7x0cu7" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/Spring面试/Spring常见面试题总结" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/22/interview/Spring%E9%9D%A2%E8%AF%95/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="post-time" datetime="2023-07-22T07:08:03.374Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">22</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring常见面试题总结"><a href="#Spring常见面试题总结" class="headerlink" title="Spring常见面试题总结"></a>Spring常见面试题总结</h1><hr>
<p>此页内容</p>
<ul>
<li><a href="">Spring 基础</a></li>
<li><ul>
<li><a href="">什么是 Spring 框架?</a></li>
<li><a href="">Spring 包含的模块有哪些？</a></li>
<li><a href="">Spring,Spring MVC,Spring Boot 之间什么关系?</a></li>
</ul>
</li>
<li><a href="">Spring IoC</a></li>
<li><ul>
<li><a href="">谈谈自己对于 Spring IoC 的了解</a></li>
<li><a href="">什么是 Spring Bean？</a></li>
<li><a href="">将一个类声明为 Bean 的注解有哪些?</a></li>
<li><a href="">@Component 和 @Bean 的区别是什么？</a></li>
<li><a href="">注入 Bean 的注解有哪些？</a></li>
<li><a href="">@Autowired 和 @Resource 的区别是什么？</a></li>
<li><a href="">Bean 的作用域有哪些?</a></li>
<li><a href="">Bean 是线程安全的吗？</a></li>
<li><a href="">Bean 的生命周期了解么?</a></li>
</ul>
</li>
<li><a href="">Spring AoP</a></li>
<li><ul>
<li><a href="">谈谈自己对于 AOP 的了解</a></li>
<li><a href="">Spring AOP 和 AspectJ AOP 有什么区别？</a></li>
<li><a href="">AspectJ 定义的通知类型有哪些？</a></li>
<li><a href="">多个切面的执行顺序如何控制？</a></li>
</ul>
</li>
<li><a href="">Spring MVC</a></li>
<li><ul>
<li><a href="">说说自己对于 Spring MVC 了解?</a></li>
<li><a href="">Spring MVC 的核心组件有哪些？</a></li>
<li><a href="">SpringMVC 工作原理了解吗?</a></li>
<li><a href="">统一异常处理怎么做？</a></li>
</ul>
</li>
<li><a href="">Spring 框架中用到了哪些设计模式？</a></li>
<li><a href="">Spring 事务</a></li>
<li><ul>
<li><a href="">Spring 管理事务的方式有几种？</a></li>
<li><a href="">Spring 事务中哪几种事务传播行为?</a></li>
<li><a href="">Spring 事务中的隔离级别有哪几种?</a></li>
<li><a href="">@Transactional(rollbackFor = Exception.class)注解了解吗？</a></li>
</ul>
</li>
<li><a href="">Spring Data JPA</a></li>
<li><ul>
<li><a href="">如何使用 JPA 在数据库中非持久化一个字段？</a></li>
<li><a href="">JPA 的审计功能是做什么的？有什么用？</a></li>
<li><a href="">实体之间的关联关系注解有哪些？</a></li>
</ul>
</li>
<li><a href="">Spring Security</a></li>
<li><ul>
<li><a href="">有哪些控制请求访问权限的方法？</a></li>
<li><a href="">hasRole 和 hasAuthority 有区别吗？</a></li>
<li><a href="">如何对密码进行加密？</a></li>
<li><a href="">如何优雅更换系统使用的加密算法？</a></li>
</ul>
</li>
<li><a href="">参考</a></li>
</ul>
<p>这是一则或许对你有用的小广告</p>
<ul>
<li><strong>面试专版</strong>：准备 Java 面试的小伙伴可以考虑面试专版：**<a target="_blank" rel="noopener" href="https://javaguide.cn/zhuanlan/java-mian-shi-zhi-bei.html">《Java 面试指北 》open in new window</a>** (质量很高，专为面试打造，配合 JavaGuide 食用)。</li>
<li><strong>知识星球</strong>：专属面试小册/一对一交流/简历修改/专属求职指南，欢迎加入 **<a target="_blank" rel="noopener" href="https://javaguide.cn/about-the-author/zhishixingqiu-two-years.html">JavaGuide 知识星球open in new window</a>**（点击链接即可查看星球的详细介绍，一定一定一定确定自己真的需要再加入，一定一定要看完详细介绍之后再加我）。</li>
</ul>
<p>这篇文章主要是想通过一些问题，加深大家对于 Spring 的理解，所以不会涉及太多的代码！</p>
<p>下面的很多问题我自己在使用 Spring 的过程中也并没有注意，自己也是临时查阅了很多资料和书籍补上的。网上也有一些很多关于 Spring 常见问题/面试题整理的文章，我感觉大部分都是互相 copy，而且很多问题也不是很好，有些回答也存在问题。所以，自己花了一周的业余时间整理了一下，希望对大家有帮助。</p>
<h2 id="Spring-基础"><a href="#Spring-基础" class="headerlink" title="# Spring 基础"></a><a href="#spring-%E5%9F%BA%E7%A1%80">#</a> Spring 基础</h2><h3 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="# 什么是 Spring 框架?"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-%E6%A1%86%E6%9E%B6">#</a> 什么是 Spring 框架?</h3><p>Spring 是一款开源的轻量级 Java 开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发，比如说 Spring 支持 IoC（Inversion of Control:控制反转） 和 AOP(Aspect-Oriented Programming:面向切面编程)、可以很方便地对数据库进行访问、可以很方便地集成第三方组件（电子邮件，任务，调度，缓存等等）、对单元测试支持比较好、支持 RESTful Java 应用程序的开发。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/38ef122122de4375abcd27c3de8f60b4.png" alt="img"></p>
<p>Spring 最核心的思想就是不重新造轮子，开箱即用，提高开发效率。</p>
<p>Spring 翻译过来就是春天的意思，可见其目标和使命就是为 Java 程序员带来春天啊！感动！</p>
<p>🤐 多提一嘴：<strong>语言的流行通常需要一个杀手级的应用，Spring 就是 Java 生态的一个杀手级的应用框架。</strong></p>
<p>Spring 提供的核心功能主要是 IoC 和 AOP。学习 Spring ，一定要把 IoC 和 AOP 的核心思想搞懂！</p>
<ul>
<li>Spring 官网：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/open in new window</a></li>
<li>GitHub 地址： <a target="_blank" rel="noopener" href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></li>
</ul>
<h3 id="Spring-包含的模块有哪些？"><a href="#Spring-包含的模块有哪些？" class="headerlink" title="# Spring 包含的模块有哪些？"></a><a href="#spring-%E5%8C%85%E5%90%AB%E7%9A%84%E6%A8%A1%E5%9D%97%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> Spring 包含的模块有哪些？</h3><p><strong>Spring4.x 版本</strong>：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/jvme0c60b4606711fc4a0b6faf03230247a.png" alt="Spring4.x主要模块">Spring4.x主要模块</p>
<p><strong>Spring5.x 版本</strong>：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200831175708.png" alt="Spring5.x主要模块">Spring5.x主要模块</p>
<p>Spring5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p>Spring 各个模块的依赖关系如下：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/20200902100038.png" alt="Spring 各个模块的依赖关系">Spring 各个模块的依赖关系</p>
<h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="# Core Container"></a><a href="#core-container">#</a> Core Container</h4><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p>
<ul>
<li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li>
<li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li>
<li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li>
<li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li>
</ul>
<h4 id="AOP"><a href="#AOP" class="headerlink" title="# AOP"></a><a href="#aop">#</a> AOP</h4><ul>
<li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li>
<li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li>
<li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li>
</ul>
<h4 id="Data-Access-x2F-Integration"><a href="#Data-Access-x2F-Integration" class="headerlink" title="# Data Access/Integration"></a><a href="#data-access-integration">#</a> Data Access/Integration</h4><ul>
<li><strong>spring-jdbc</strong>：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li>
<li><strong>spring-tx</strong>：提供对事务的支持。</li>
<li><strong>spring-orm</strong>：提供对 Hibernate、JPA、iBatis 等 ORM 框架的支持。</li>
<li><strong>spring-oxm</strong>：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li>
<li><strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li>
</ul>
<h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="# Spring Web"></a><a href="#spring-web">#</a> Spring Web</h4><ul>
<li><strong>spring-web</strong>：对 Web 功能的实现提供一些最基础的支持。</li>
<li><strong>spring-webmvc</strong>：提供对 Spring MVC 的实现。</li>
<li><strong>spring-websocket</strong>：提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li>
<li><strong>spring-webflux</strong>：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li>
</ul>
<h4 id="Messaging"><a href="#Messaging" class="headerlink" title="# Messaging"></a><a href="#messaging">#</a> Messaging</h4><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p>
<h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="# Spring Test"></a><a href="#spring-test">#</a> Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p>
<p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p>
<h3 id="Spring-Spring-MVC-Spring-Boot-之间什么关系"><a href="#Spring-Spring-MVC-Spring-Boot-之间什么关系" class="headerlink" title="# Spring,Spring MVC,Spring Boot 之间什么关系?"></a><a href="#spring-spring-mvc-spring-boot-%E4%B9%8B%E9%97%B4%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB">#</a> Spring,Spring MVC,Spring Boot 之间什么关系?</h3><p>很多人对 Spring,Spring MVC,Spring Boot 这三者傻傻分不清楚！这里简单介绍一下这三者，其实很简单，没有什么高深的东西。</p>
<p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p>
<p>下图对应的是 Spring4.x 版本。目前最新的 5.x 版本中 Web 模块的 Portlet 组件已经被废弃掉，同时增加了用于异步响应式处理的 WebFlux 组件。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/jvme0c60b4606711fc4a0b6faf03230247a.png" alt="Spring主要模块">Spring主要模块</p>
<p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png" alt="img"></p>
<p>使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！</p>
<p>Spring 旨在简化 J2EE 企业应用程序开发。Spring Boot 旨在简化 Spring 开发（减少配置文件，开箱即用！）。</p>
<p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p>
<h3 id="Spring-Spring-MVC-Spring-Boot-有什么区别"><a href="#Spring-Spring-MVC-Spring-Boot-有什么区别" class="headerlink" title="Spring,Spring MVC,Spring Boot 有什么区别?"></a>Spring,Spring MVC,Spring Boot 有什么区别?</h3><p><img src="/../../../images/image-20230722172641950.png" alt="image-20230722172641950"></p>
<h2 id="Spring-IoC"><a href="#Spring-IoC" class="headerlink" title="# Spring IoC"></a><a href="#spring-ioc">#</a> Spring IoC</h2><h3 id="谈谈自己对于-Spring-IoC-的了解"><a href="#谈谈自己对于-Spring-IoC-的了解" class="headerlink" title="# 谈谈自己对于 Spring IoC 的了解"></a><a href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-ioc-%E7%9A%84%E4%BA%86%E8%A7%A3">#</a> 谈谈自己对于 Spring IoC 的了解</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。 </p>
<p><strong>为什么叫控制反转？</strong></p>
<ul>
<li><strong>控制</strong>：指的是对象创建（实例化、管理）的权力</li>
<li><strong>反转</strong>：控制权交给外部环境（Spring 框架、IoC 容器）</li>
</ul>
<p><img src="https://oss.javaguide.cn/java-guide-blog/frc-365faceb5697f04f31399937c059c162.png" alt="IoC 图解">IoC 图解</p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能依赖了很多其他的类，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IoC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p>
<p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 <font color="red"><strong>Map（key，value）</strong></font>，Map 中存放的是各种对象。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。  </p>
<p>相关阅读：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/spring-ioc">IoC 源码阅读open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486938&amp;idx=1&amp;sn=c99ef0233f39a5ffc1b98c81e02dfcd4&amp;chksm=cea24211f9d5cb07fa901183ba4d96187820713a72387788408040822ffb2ed575d28e953ce7&amp;token=1736772241&amp;lang=zh_CN#rd">面试被问了几百遍的 IoC 和 AOP ，还在傻傻搞不清楚？open in new window</a></li>
</ul>
<h3 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="# 什么是 Spring Bean？"></a><a href="#%E4%BB%80%E4%B9%88%E6%98%AF-spring-bean">#</a> 什么是 Spring Bean？</h3><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p>
<p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Constructor-arg with 'value' attribute --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>下图简单地展示了 IoC 容器如何使用配置元数据来管理对象。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/062b422bd7ac4d53afd28fb74b2bc94d.png" alt="img"></p>
<p><code>org.springframework.beans</code>和 <code>org.springframework.context</code> 这两个包是 IoC 实现的基础，如果想要研究 IoC 相关的源码的话，可以去看看</p>
<h3 id="将一个类声明为-Bean-的注解有哪些"><a href="#将一个类声明为-Bean-的注解有哪些" class="headerlink" title="# 将一个类声明为 Bean 的注解有哪些?"></a><a href="#%E5%B0%86%E4%B8%80%E4%B8%AA%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%BA-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> 将一个类声明为 Bean 的注解有哪些?</h3><ul>
<li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li>
<li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li>
<li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li>
</ul>
<h3 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="# @Component 和 @Bean 的区别是什么？"></a><a href="#component-%E5%92%8C-bean-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> @Component 和 @Bean 的区别是什么？</h3><ul>
<li><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li>
<li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li>
<li><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li>
</ul>
<p><code>@Bean</code>注解使用示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TransferService <span class="title function_">transferService</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransferServiceImpl</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码相当于下面的 xml 配置</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> OneService <span class="title function_">getService</span><span class="params">(status)</span> {</span><br><span class="line">    <span class="keyword">case</span> (status)  {</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl1</span>();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl2</span>();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">serviceImpl3</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="注入-Bean-的注解有哪些？"><a href="#注入-Bean-的注解有哪些？" class="headerlink" title="# 注入 Bean 的注解有哪些？"></a><a href="#%E6%B3%A8%E5%85%A5-bean-%E7%9A%84%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> 注入 Bean 的注解有哪些？</h3><p>Spring 内置的 <code>@Autowired</code> 以及 JDK 内置的 <code>@Resource</code> 和 <code>@Inject</code> 都可以用于注入 Bean。</p>
<table>
<thead>
<tr>
<th>Annotaion</th>
<th>Package</th>
<th>Source</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Autowired</code></td>
<td><code>org.springframework.bean.factory</code></td>
<td>Spring 2.5+</td>
</tr>
<tr>
<td><code>@Resource</code></td>
<td><code>javax.annotation</code></td>
<td>Java JSR-250</td>
</tr>
<tr>
<td><code>@Inject</code></td>
<td><code>javax.inject</code></td>
<td>Java JSR-330</td>
</tr>
</tbody></table>
<p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p>
<h3 id="Autowired-和-Resource-的区别是什么？"><a href="#Autowired-和-Resource-的区别是什么？" class="headerlink" title="# @Autowired 和 @Resource 的区别是什么？"></a><a href="#autowired-%E5%92%8C-resource-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> @Autowired 和 @Resource 的区别是什么？</h3><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p>
<p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p>
<p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smsService 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></tbody></table></figure>

<p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="comment">// smsServiceImpl1 就是我们上面所说的名称</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier(value = "smsServiceImpl1")</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></tbody></table></figure>

<p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p>
<p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p>
<p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Resource {</span><br><span class="line">    String <span class="title function_">name</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">    Class&lt;?&gt; type() <span class="keyword">default</span> Object.class;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错，byName 和 byType 都无法匹配到 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span></span><br><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsServiceImpl1;</span><br><span class="line"><span class="comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span></span><br><span class="line"><span class="meta">@Resource(name = "smsServiceImpl1")</span></span><br><span class="line"><span class="keyword">private</span> SmsService smsService;</span><br></pre></td></tr></tbody></table></figure>

<p>简单总结一下：</p>
<ul>
<li><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li>
<li><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li>
<li>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li>
</ul>
<h3 id="Bean-的作用域有哪些"><a href="#Bean-的作用域有哪些" class="headerlink" title="# Bean 的作用域有哪些?"></a><a href="#bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> Bean 的作用域有哪些?</h3><p>Spring 中 Bean 的作用域通常有下面几种：</p>
<ul>
<li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li>
<li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li>
<li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li>
<li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li>
<li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li>
<li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li>
</ul>
<p><strong>如何配置 bean 的作用域呢？</strong></p>
<p>xml 方式：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"..."</span> <span class="attr">class</span>=<span class="string">"..."</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span></span><br><span class="line"><span class="keyword">public</span> Person <span class="title function_">personPrototype</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Bean-是线程安全的吗？"><a href="#Bean-是线程安全的吗？" class="headerlink" title="# Bean 是线程安全的吗？"></a><a href="#bean-%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97">#</a> Bean 是线程安全的吗？</h3><p>Spring 框架中的 Bean 是否线程安全，取决于其作用域和状态。</p>
<p>我们这里以最常用的两种作用域 prototype 和 singleton 为例介绍。几乎所有场景的 Bean 作用域都是使用默认的 singleton ，重点关注 singleton 作用域即可。</p>
<p>prototype 作用域下，每次获取都会创建一个新的 bean 实例，不存在资源竞争问题，所以不存在线程安全问题。singleton 作用域下，IoC 容器中只有唯一的 bean 实例，可能会存在资源竞争问题（取决于 Bean 是否有状态）。如果这个 bean 是有状态的话，那就存在线程安全问题（有状态 Bean 是指包含可变的成员变量的对象）。</p>
<p>不过，大部分 Bean 实际都是无状态（没有定义可变的成员变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p>
<p>对于有状态单例 Bean 的线程安全问题，常见的有两种解决办法：</p>
<ol>
<li>在 Bean 中尽量避免定义可变的成员变量。</li>
<li>在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li>
</ol>
<h3 id="Bean-的生命周期了解么"><a href="#Bean-的生命周期了解么" class="headerlink" title="# Bean 的生命周期了解么?"></a><a href="#bean-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BA%86%E8%A7%A3%E4%B9%88">#</a> Bean 的生命周期了解么?</h3><ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li>
<li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li>
<li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li>
<li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li>
<li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<p>图示：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/24bc2bad3ce28144d60d9e0a2edf6c7f.jpg" alt="Spring Bean 生命周期">Spring Bean 生命周期</p>
<p>与之比较类似的中文版本:</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/b5d264565657a5395c2781081a7483e1.jpg" alt="Spring Bean 生命周期">Spring Bean 生命周期</p>
<h2 id="Spring-AoP"><a href="#Spring-AoP" class="headerlink" title="# Spring AoP"></a><a href="#spring-aop">#</a> Spring AoP</h2><h3 id="谈谈自己对于-AOP-的了解"><a href="#谈谈自己对于-AOP-的了解" class="headerlink" title="# 谈谈自己对于 AOP 的了解"></a><a href="#%E8%B0%88%E8%B0%88%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-aop-%E7%9A%84%E4%BA%86%E8%A7%A3">#</a> 谈谈自己对于 AOP 的了解</h3><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/230ae587a322d6e4d09510161987d346.jpeg" alt="SpringAOPProcess">SpringAOPProcess</p>
<p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>AOP 切面编程设计到的一些专业术语：</p>
<table>
<thead>
<tr>
<th align="left">术语</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">目标(Target)</td>
<td align="center">被通知的对象</td>
</tr>
<tr>
<td align="left">代理(Proxy)</td>
<td align="center">向目标对象应用通知之后创建的代理对象</td>
</tr>
<tr>
<td align="left">连接点(JoinPoint)</td>
<td align="center">目标对象的所属类中，定义的所有方法均为连接点</td>
</tr>
<tr>
<td align="left">切入点(Pointcut)</td>
<td align="center">被切面拦截 / 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td>
</tr>
<tr>
<td align="left">通知(Advice)</td>
<td align="center">增强的逻辑 / 代码，也即拦截到目标对象的连接点之后要做的事情</td>
</tr>
<tr>
<td align="left">切面(Aspect)</td>
<td align="center">切入点(Pointcut)+通知(Advice)</td>
</tr>
<tr>
<td align="left">Weaving(织入)</td>
<td align="center">将通知应用到目标对象，进而生成代理对象的过程动作</td>
</tr>
</tbody></table>
<h3 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="# Spring AOP 和 AspectJ AOP 有什么区别？"></a><a href="#spring-aop-%E5%92%8C-aspectj-aop-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> Spring AOP 和 AspectJ AOP 有什么区别？</h3><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p>
<h3 id="AspectJ-定义的通知类型有哪些？"><a href="#AspectJ-定义的通知类型有哪些？" class="headerlink" title="# AspectJ 定义的通知类型有哪些？"></a><a href="#aspectj-%E5%AE%9A%E4%B9%89%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> AspectJ 定义的通知类型有哪些？</h3><ul>
<li><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li>
<li><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li>
<li><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li>
<li><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li>
<li><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li>
</ul>
<h3 id="多个切面的执行顺序如何控制？"><a href="#多个切面的执行顺序如何控制？" class="headerlink" title="# 多个切面的执行顺序如何控制？"></a><a href="#%E5%A4%9A%E4%B8%AA%E5%88%87%E9%9D%A2%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6">#</a> 多个切面的执行顺序如何控制？</h3><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值越小优先级越高</span></span><br><span class="line"><span class="meta">@Order(3)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> {</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> <span class="keyword">implements</span> <span class="title class_">Ordered</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// 返回值越小优先级越高</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="# Spring MVC"></a><a href="#spring-mvc">#</a> Spring MVC</h2><h3 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="# 说说自己对于 Spring MVC 了解?"></a><a href="#%E8%AF%B4%E8%AF%B4%E8%87%AA%E5%B7%B1%E5%AF%B9%E4%BA%8E-spring-mvc-%E4%BA%86%E8%A7%A3">#</a> 说说自己对于 Spring MVC 了解?</h3><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/image-20210809181452421.png" alt="img"></p>
<p>网上有很多人说 MVC 不是设计模式，只是软件设计规范，我个人更倾向于 MVC 同样是众多设计模式中的一种。**<a target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns">java-design-patternsopen in new window</a>** 项目中就有关于 MVC 的相关介绍。</p>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/159b3d3e70dd45e6afa81bf06d09264e.png" alt="img"></p>
<p>想要真正理解 Spring MVC，我们先来看看 Model 1 和 Model 2 这两个没有 Spring MVC 的时代。</p>
<p><strong>Model 1 时代</strong></p>
<p>很多学 Java 后端比较晚的朋友可能并没有接触过 Model 1 时代下的 JavaWeb 应用开发。在 Model1 模式下，整个 Web 应用几乎全部用 JSP 页面组成，只用少量的 JavaBean 来处理数据库连接、访问等操作。</p>
<p>这个模式下 JSP 即是控制层（Controller）又是表现层（View）。显而易见，这种模式存在很多问题。比如控制逻辑和表现逻辑混杂在一起，导致代码重用率极低；再比如前端和后端相互依赖，难以进行测试维护并且开发效率极低。</p>
<p><img src="https://oss.javaguide.cn/java-guide-blog/mvc-mode1.png" alt="mvc-mode1">mvc-mode1</p>
<p><strong>Model 2 时代</strong></p>
<p>学过 Servlet 并做过相关 Demo 的朋友应该了解“Java Bean(Model)+ JSP（View）+Servlet（Controller） ”这种开发模式，这就是早期的 JavaWeb MVC 开发模式。</p>
<ul>
<li>Model:系统涉及的数据，也就是 dao 和 bean。</li>
<li>View：展示模型中的数据，只是用来展示。</li>
<li>Controller：处理用户请求都发送给 ，返回数据给 JSP 并展示给用户。</li>
</ul>
<p><img src="https://oss.javaguide.cn/java-guide-blog/mvc-model2.png" alt="img"></p>
<p>Model2 模式下还存在很多问题，Model2 的抽象和封装程度还远远不够，使用 Model2 进行开发时不可避免地会重复造轮子，这就大大降低了程序的可维护性和复用性。</p>
<p>于是，很多 JavaWeb 开发相关的 MVC 框架应运而生比如 Struts2，但是 Struts2 比较笨重。</p>
<p><strong>Spring MVC 时代</strong></p>
<p>随着 Spring 轻量级开发框架的流行，Spring 生态圈出现了 Spring MVC 框架， Spring MVC 是当前最优秀的 MVC 框架。相比于 Struts2 ， Spring MVC 使用更加简单和方便，开发效率更高，并且 Spring MVC 运行速度更快。</p>
<p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p>
<h3 id="Spring-MVC-的核心组件有哪些？"><a href="#Spring-MVC-的核心组件有哪些？" class="headerlink" title="# Spring MVC 的核心组件有哪些？"></a><a href="#spring-mvc-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> Spring MVC 的核心组件有哪些？</h3><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p>
<ul>
<li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li>
<li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li>
<li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li>
<li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li>
</ul>
<h3 id="SpringMVC-工作原理了解吗"><a href="#SpringMVC-工作原理了解吗" class="headerlink" title="# SpringMVC 工作原理了解吗?"></a><a href="#springmvc-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%BA%86%E8%A7%A3%E5%90%97">#</a> SpringMVC 工作原理了解吗?</h3><p><strong>Spring MVC 原理如下图所示：</strong></p>
<blockquote>
<p>SpringMVC 工作原理的图解我没有自己画，直接图省事在网上找了一个非常清晰直观的，原出处不明。</p>
</blockquote>
<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/de6d2b213f112297298f3e223bf08f28.png" alt="img"></p>
<p><strong>流程说明（重要）：</strong></p>
<ol>
<li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li>
<li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 uri 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li>
<li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li>
<li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（浏览器）</li>
</ol>
<h3 id="统一异常处理怎么做？"><a href="#统一异常处理怎么做？" class="headerlink" title="# 统一异常处理怎么做？"></a><a href="#%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%8E%E4%B9%88%E5%81%9A">#</a> 统一异常处理怎么做？</h3><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(BaseException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;?&gt; handleAppException(BaseException ex, HttpServletRequest request) {</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = ResourceNotFoundException.class)</span></span><br><span class="line">    <span class="keyword">public</span> ResponseEntity&lt;ErrorReponse&gt; <span class="title function_">handleResourceNotFoundException</span><span class="params">(ResourceNotFoundException ex, HttpServletRequest request)</span> {</span><br><span class="line">      <span class="comment">//......</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p>
<p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">	<span class="keyword">private</span> Method <span class="title function_">getMappedMethod</span><span class="params">(Class&lt;? extends Throwable&gt; exceptionType)</span> {</span><br><span class="line">		List&lt;Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt;&gt; matches = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span></span><br><span class="line">		<span class="keyword">for</span> (Class&lt;? <span class="keyword">extends</span> <span class="title class_">Throwable</span>&gt; mappedException : <span class="built_in">this</span>.mappedMethods.keySet()) {</span><br><span class="line">			<span class="keyword">if</span> (mappedException.isAssignableFrom(exceptionType)) {</span><br><span class="line">				matches.add(mappedException);</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">    <span class="comment">// 不为空说明有方法处理异常</span></span><br><span class="line">		<span class="keyword">if</span> (!matches.isEmpty()) {</span><br><span class="line">      <span class="comment">// 按照匹配程度从小到大排序</span></span><br><span class="line">			matches.sort(<span class="keyword">new</span> <span class="title class_">ExceptionDepthComparator</span>(exceptionType));</span><br><span class="line">      <span class="comment">// 返回处理异常的方法</span></span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.mappedMethods.get(matches.get(<span class="number">0</span>));</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span> {</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br></pre></td></tr></tbody></table></figure>

<p>从源代码看出：**<code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。**</p>
<h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="# Spring 框架中用到了哪些设计模式？"></a><a href="#spring-%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">#</a> Spring 框架中用到了哪些设计模式？</h2><blockquote>
<p>关于下面这些设计模式的详细介绍，可以看我写的 <a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html">Spring 中的设计模式详解open in new window</a> 这篇文章。</p>
</blockquote>
<ul>
<li><strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li>
<li><strong>代理设计模式</strong> : Spring AOP 功能的实现。</li>
<li><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li>
<li><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li>
<li><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li>
<li><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li>
<li><strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li>
<li>……</li>
</ul>
<h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="# Spring 事务"></a><a href="#spring-%E4%BA%8B%E5%8A%A1">#</a> Spring 事务</h2><p>关于 Spring 事务的详细介绍，可以看我写的 <a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-transaction.html">Spring 事务详解open in new window</a> 这篇文章。</p>
<h3 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="# Spring 管理事务的方式有几种？"></a><a href="#spring-%E7%AE%A1%E7%90%86%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%87%A0%E7%A7%8D">#</a> Spring 管理事务的方式有几种？</h3><ul>
<li><strong>编程式事务</strong>：在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li>
<li><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li>
</ul>
<h3 id="Spring-事务中哪几种事务传播行为"><a href="#Spring-事务中哪几种事务传播行为" class="headerlink" title="# Spring 事务中哪几种事务传播行为?"></a><a href="#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E5%93%AA%E5%87%A0%E7%A7%8D%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA">#</a> Spring 事务中哪几种事务传播行为?</h3><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p>
<p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p>
<p>正确的事务传播行为可能的值如下:</p>
<p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p>
<p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p>
<p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p>
<p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p>
<p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p>
<p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p>
<p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p>
<p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p>
<p>这个使用的很少。</p>
<p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p>
<ul>
<li><strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li><strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<h3 id="Spring-事务中的隔离级别有哪几种"><a href="#Spring-事务中的隔离级别有哪几种" class="headerlink" title="# Spring 事务中的隔离级别有哪几种?"></a><a href="#spring-%E4%BA%8B%E5%8A%A1%E4%B8%AD%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D">#</a> Spring 事务中的隔离级别有哪几种?</h3><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Isolation</span> {</span><br><span class="line"></span><br><span class="line">    DEFAULT(TransactionDefinition.ISOLATION_DEFAULT),</span><br><span class="line"></span><br><span class="line">    READ_UNCOMMITTED(TransactionDefinition.ISOLATION_READ_UNCOMMITTED),</span><br><span class="line"></span><br><span class="line">    READ_COMMITTED(TransactionDefinition.ISOLATION_READ_COMMITTED),</span><br><span class="line"></span><br><span class="line">    REPEATABLE_READ(TransactionDefinition.ISOLATION_REPEATABLE_READ),</span><br><span class="line"></span><br><span class="line">    SERIALIZABLE(TransactionDefinition.ISOLATION_SERIALIZABLE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    Isolation(<span class="type">int</span> value) {</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">value</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>下面我依次对每一种事务隔离级别进行介绍：</p>
<ul>
<li><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li>
<li><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h3 id="Transactional-rollbackFor-x3D-Exception-class-注解了解吗？"><a href="#Transactional-rollbackFor-x3D-Exception-class-注解了解吗？" class="headerlink" title="# @Transactional(rollbackFor = Exception.class)注解了解吗？"></a><a href="#transactional-rollbackfor-exception-class-%E6%B3%A8%E8%A7%A3%E4%BA%86%E8%A7%A3%E5%90%97">#</a> @Transactional(rollbackFor = Exception.class)注解了解吗？</h3><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</p>
<h2 id="Spring-Data-JPA"><a href="#Spring-Data-JPA" class="headerlink" title="# Spring Data JPA"></a><a href="#spring-data-jpa">#</a> Spring Data JPA</h2><p>JPA 重要的是实战，这里仅对小部分知识点进行总结。</p>
<h3 id="如何使用-JPA-在数据库中非持久化一个字段？"><a href="#如何使用-JPA-在数据库中非持久化一个字段？" class="headerlink" title="# 如何使用 JPA 在数据库中非持久化一个字段？"></a><a href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-jpa-%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E9%9D%9E%E6%8C%81%E4%B9%85%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5">#</a> 如何使用 JPA 在数据库中非持久化一个字段？</h3><p>假如我们有下面一个类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity(name="USER")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span></span><br><span class="line">    <span class="meta">@Column(name = "ID")</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name="USER_NAME")</span></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name="PASSWORD")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secrect;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String transient1; <span class="comment">// not persistent because of static</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">transient2</span> <span class="operator">=</span> <span class="string">"Satish"</span>; <span class="comment">// not persistent because of final</span></span><br><span class="line"><span class="keyword">transient</span> String transient3; <span class="comment">// not persistent because of transient</span></span><br><span class="line"><span class="meta">@Transient</span></span><br><span class="line">String transient4; <span class="comment">// not persistent because of @Transient</span></span><br></pre></td></tr></tbody></table></figure>

<p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p>
<h3 id="JPA-的审计功能是做什么的？有什么用？"><a href="#JPA-的审计功能是做什么的？有什么用？" class="headerlink" title="# JPA 的审计功能是做什么的？有什么用？"></a><a href="#jpa-%E7%9A%84%E5%AE%A1%E8%AE%A1%E5%8A%9F%E8%83%BD%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84-%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8">#</a> JPA 的审计功能是做什么的？有什么用？</h3><p>审计功能主要是帮助我们记录数据库操作的具体行为比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@MappedSuperclass</span></span><br><span class="line"><span class="meta">@EntityListeners(value = AuditingEntityListener.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractAuditBase</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedDate</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant createdAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedDate</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> Instant updatedAt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@CreatedBy</span></span><br><span class="line">    <span class="meta">@Column(updatable = false)</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String createdBy;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@LastModifiedBy</span></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">private</span> String updatedBy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</p>
</li>
<li><p><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值</p>
<p><code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</p>
</li>
</ul>
<h3 id="实体之间的关联关系注解有哪些？"><a href="#实体之间的关联关系注解有哪些？" class="headerlink" title="# 实体之间的关联关系注解有哪些？"></a><a href="#%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E6%B3%A8%E8%A7%A3%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> 实体之间的关联关系注解有哪些？</h3><ul>
<li><code>@OneToOne </code> : 一对一。</li>
<li><code>@ManyToMany</code>：多对多。</li>
<li><code>@OneToMany</code> : 一对多。</li>
<li><code>@ManyToOne</code>：多对一。</li>
</ul>
<p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p>
<h2 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="# Spring Security"></a><a href="#spring-security">#</a> Spring Security</h2><p>Spring Security 重要的是实战，这里仅对小部分知识点进行总结。</p>
<h3 id="有哪些控制请求访问权限的方法？"><a href="#有哪些控制请求访问权限的方法？" class="headerlink" title="# 有哪些控制请求访问权限的方法？"></a><a href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8E%A7%E5%88%B6%E8%AF%B7%E6%B1%82%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95">#</a> 有哪些控制请求访问权限的方法？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728201854641.png" alt="img"></p>
<ul>
<li><code>permitAll()</code>：无条件允许任何形式访问，不管你登录还是没有登录。</li>
<li><code>anonymous()</code>：允许匿名访问，也就是没有登录才可以访问。</li>
<li><code>denyAll()</code>：无条件决绝任何形式的访问。</li>
<li><code>authenticated()</code>：只允许已认证的用户访问。</li>
<li><code>fullyAuthenticated()</code>：只允许已经登录或者通过 remember-me 登录的用户访问。</li>
<li><code>hasRole(String)</code> : 只允许指定的角色访问。</li>
<li><code>hasAnyRole(String) </code> : 指定一个或者多个角色，满足其一的用户即可访问。</li>
<li><code>hasAuthority(String)</code>：只允许具有指定权限的用户访问</li>
<li><code>hasAnyAuthority(String)</code>：指定一个或者多个权限，满足其一的用户即可访问。</li>
<li><code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li>
</ul>
<h3 id="hasRole-和-hasAuthority-有区别吗？"><a href="#hasRole-和-hasAuthority-有区别吗？" class="headerlink" title="# hasRole 和 hasAuthority 有区别吗？"></a><a href="#hasrole-%E5%92%8C-hasauthority-%E6%9C%89%E5%8C%BA%E5%88%AB%E5%90%97">#</a> hasRole 和 hasAuthority 有区别吗？</h3><p>可以看看松哥的这篇文章：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/GTNOa2k9_n_H0w24upClRw">Spring Security 中的 hasRole 和 hasAuthority 有区别吗？open in new window</a>，介绍的比较详细。</p>
<h3 id="如何对密码进行加密？"><a href="#如何对密码进行加密？" class="headerlink" title="# 如何对密码进行加密？"></a><a href="#%E5%A6%82%E4%BD%95%E5%AF%B9%E5%AF%86%E7%A0%81%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86">#</a> 如何对密码进行加密？</h3><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p>
<p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p>
<p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">PasswordEncoder</span> {</span><br><span class="line">    <span class="comment">// 加密也就是对原始密码进行编码</span></span><br><span class="line">    String <span class="title function_">encode</span><span class="params">(CharSequence var1)</span>;</span><br><span class="line">    <span class="comment">// 比对原始密码和数据库中保存的密码</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(CharSequence var1, String var2)</span>;</span><br><span class="line">    <span class="comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span></span><br><span class="line">    <span class="keyword">default</span> <span class="type">boolean</span> <span class="title function_">upgradeEncoding</span><span class="params">(String encodedPassword)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://oss.javaguide.cn/github/javaguide/system-design/framework/spring/image-20220728183540954.png" alt="img"></p>
<p>官方推荐使用基于 bcrypt 强哈希函数的加密算法实现类。</p>
<h3 id="如何优雅更换系统使用的加密算法？"><a href="#如何优雅更换系统使用的加密算法？" class="headerlink" title="# 如何优雅更换系统使用的加密算法？"></a><a href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E6%9B%B4%E6%8D%A2%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%E7%9A%84%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">#</a> 如何优雅更换系统使用的加密算法？</h3><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p>
<p>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求。</p>
<p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0 之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="# 参考"></a><a href="#%E5%8F%82%E8%80%83">#</a> 参考</h2><hr>
<p>著作权归Guide所有 原文链接：<a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/22/interview/Spring%E9%9D%A2%E8%AF%95/Spring%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" data-id="clkngg0oe00bq2wv6eti9foil" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/操作系统/juc" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/19/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/juc/" class="article-date">
  <time class="post-time" datetime="2023-07-19T15:49:17.232Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="线程池状态"><a href="#线程池状态" class="headerlink" title="# 线程池状态"></a># 线程池状态</h1><p><img src="https://pic2.zhimg.com/80/v2-9ad6dad52f1bf581fed962a762ee312d_1440w.webp" alt="img"></p>
<ul>
<li>RUNNING：能接受新提交的任务，并且也能处理阻塞队列中的任务。</li>
<li>SHUTDOWN：指调用了 shutdown() 方法，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</li>
<li>STOP：指调用了 shutdownNow() 方法，不再接受新提交的任务，同时抛弃阻塞队列里的所有任务并中断所有正在执行任务。</li>
<li>TIDYING： 所有任务都执行完毕，workerCount 有效线程数为 0。</li>
<li>TERMINATED：终止状态，当执行 terminated() 后会更新为这个状态。</li>
</ul>
<h1 id="线程状态"><a href="#线程状态" class="headerlink" title="# 线程状态"></a># 线程状态</h1><p>线程实际上是分为六种状态的，既</p>
<ul>
<li><p><strong>1.初始状态（NEW）</strong></p>
<ul>
<li>线程被构建，但是还没有调用start方法</li>
</ul>
</li>
<li><p><strong>2.运行状态（RUNNABLE）</strong></p>
<ul>
<li>Java线程把操作系统中就绪和运行两种状态统一称为“运行中”</li>
</ul>
</li>
<li><p><strong>3.阻塞状态（BLOCKED）</strong><br>        表示线程进入等待状态，也就是线程因为某种原因放弃了CPU的使用权，阻塞也分为几种情况（当一个线程试图获取一个内部的对象锁（非java.util.concurrent库中的锁），而该锁被其他线程持有，则该线程进入阻塞状态。）</p>
</li>
</ul>
<p>​                    <strong>等待阻塞</strong>：运行的线程执行了Thread.sleep、wait、join等方法，JVM会把当前线程设置为等待状态，当sleep结束，join线程终止或者线程被唤醒后，该线程从等待状态进入阻塞状态，重新占用锁后进行线程恢复</p>
<p>​                    <strong>同步阻塞</strong>：运行的线程在获取对象的同步锁时，若该同步锁被其他线程锁占用了，那么JVM会把当前项城放入到锁池中</p>
<p>​                    <strong>其他阻塞</strong>：发出I/O请求，JVM会把当前线程设置为阻塞状态，当I/O处理完毕则线程恢复</p>
<ul>
<li><strong>4.等待（WAITING）</strong><ul>
<li>等待状态，没有超时时间（无限等待），要被其他线程或者有其他的中断操作</li>
</ul>
</li>
</ul>
<p>​            执行wait、join、LockSupport.park()</p>
<ul>
<li><strong>5.超时等待（TIME_WAITING）</strong><ul>
<li>与等待不同的是，不是无限等待，超时后自动返回</li>
</ul>
</li>
</ul>
<p>​            执行sleep，带参数的wait等可以实现</p>
<ul>
<li><strong>6.终止（Teminated）</strong><br>        代表线程执行完毕</li>
</ul>
<p><img src="/../../../images/image-20230719235443525.png" alt="image-20230719235443525"></p>
<h1 id="核心线程-和-救急线程的区别"><a href="#核心线程-和-救急线程的区别" class="headerlink" title="# 核心线程 和 救急线程的区别"></a># 核心线程 和 救急线程的区别</h1><p>救急线程是有个生存时间的，它执行完任务了，过了一段时间，没有新任务了，救急线程就会销毁掉，变成结束的状态</p>
<p>核心线程没有生存时间，它执行完任务后，它仍然会被保存在线程池中，不会让核心线程结束，会让核心线程一直去运行</p>
<p>KeepAliveTime 生存时间、unit时间单位，这两个参数就是针对于救急线程的</p>
<p><img src="/../../../images/image-20221014221100359.png" alt="image-20221014221100359"></p>
<p>使用救急线程的前提，是要配合有界队列的使用。</p>
<p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p>
<p>如果队列选择的是无界队列，那么就不会用到救急线程，任务会一直存入无界队列，然后由核心线程来轮流去处理无界队列里的任务。</p>
<p>如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略。拒绝策略 jdk 提供了 4 种实现，</p>
<p>但是很多第三方框架都不是使用的jdk提供的，而是选择使用 更功能上的增强，在这些 功能上进行扩展</p>
<p><img src="/../../../images/image-20221014222804634.png" alt="image-20221014222804634"></p>
<h1 id="Executors-固定大小线程池"><a href="#Executors-固定大小线程池" class="headerlink" title="# Executors-固定大小线程池"></a># Executors-固定大小线程池</h1><p><img src="/../../../images/image-20221015090229540.png" alt="image-20221015090229540"></p>
<h1 id="Executors-单线程线程池"><a href="#Executors-单线程线程池" class="headerlink" title="# Executors-单线程线程池"></a># Executors-单线程线程池</h1><p><img src="/../../../images/image-20221015091919686.png" alt="image-20221015091919686"></p>
<h1 id="线程池中shutdown-和shutdownNow-方法的区别"><a href="#线程池中shutdown-和shutdownNow-方法的区别" class="headerlink" title="# 线程池中shutdown()和shutdownNow()方法的区别"></a># 线程池中shutdown()和shutdownNow()方法的区别</h1><p>一般情况下，当我们频繁的使用线程的时候，为了节约资源快速响应需求，我们都会考虑使用线程池，线程池使用完毕都会想着关闭，关闭的时候一般情况下会用到shutdown和shutdownNow，这两个函数都能够用来关闭线程池，那么他们俩之间的区别是什么呢？下面我就用一句话来说明白shutdown和shutdownNow的区别。</p>
<p>一句话说明白shutdown和shutdownNow的区别：</p>
<p>​		shutdown只是将线程池的状态设置为SHUTWDOWN状态，正在执行的任务会继续执行下去，没有被执行的则中断。</p>
<p>​		而shutdownNow则是将线程池的状态设置为STOP，正在执行的任务则被停止，没被执行任务的则返回。</p>
<p>​    	例子：举个工人吃包子的例子，一个厂的工人（Workers）正在吃包子（可以理解为任务），假如接到shutdown的命令，那么这个厂的工人们则会把手头上的包子给吃完，没有拿到手里的笼子里面的包子则不能吃！而如果接到shutdownNow的命令以后呢，这些工人们立刻停止吃包子，会把手头上没吃完的包子放下，更别提笼子里的包子了。 </p>
<p>  1、<strong>shutDown()</strong> </p>
<p>  当线程池调用该方法时,线程池的状态则立刻变成SHUTDOWN状态。此时，则不能再往线程池中添加任何任务，否则将会抛出RejectedExecutionException异常。但是，此时线程池不会立刻退出，<strong>直到添加到线程池中的任务都已经处理完成，才会退出。</strong> </p>
<p>  2、<strong>shutdownNow()</strong> </p>
<p>   执行该方法，线程池的状态立刻变成STOP状态，并试图停止所有正在执行的线程，<strong>不再处理还在池队列中等待的任务</strong>，当然，它会返回那些未执行的任务。<br>   它试图终止线程的方法是通过调用Thread.interrupt()方法来实现的，但是大家知道，这种方法的作用有限，如果线程中没有sleep 、wait、Condition、定时锁等应用, interrupt()方法是无法中断当前的线程的。所以，ShutdownNow()并不代表线程池就一定立即就能退出，它可能必须要等待所有正在执行的任务都执行完成了才能退出。 </p>
<p><img src="/../../../images/image-20221015095349872.png" alt="image-20221015095349872"></p>
<p><img src="/../../../images/image-20221015095425618.png" alt="image-20221015095425618"></p>
<h1 id="ABA-问题及解决"><a href="#ABA-问题及解决" class="headerlink" title="# ABA 问题及解决"></a># ABA 问题及解决</h1><p><strong>CAS引发的ABA问题</strong></p>
<p>ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题。在JDK的java.util.concurrent.atomic包中提供了<strong>AtomicStampedReference</strong>来解决ABA问题，该类的compareAndSet是该类的核心方法，实现如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(V   expectedReference,</span></span><br><span class="line"><span class="params">                             V   newReference,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> expectedStamp,</span></span><br><span class="line"><span class="params">                             <span class="type">int</span> newStamp)</span> {</span><br><span class="line">    Pair&lt;V&gt; current = pair;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        expectedReference == current.reference &amp;&amp;</span><br><span class="line">        expectedStamp == current.stamp &amp;&amp;</span><br><span class="line">        ((newReference == current.reference &amp;&amp;</span><br><span class="line">          newStamp == current.stamp) ||</span><br><span class="line">         casPair(current, Pair.of(newReference, newStamp)));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>我们可以发现，该类检查了当前引用与当前标志是否与预期相同，如果全部相等，才会以原子方式将该引用和该标志的值设为新的更新值，这样CAS操作中的比较就不依赖于变量的值了。</p>
<p>但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了</p>
<p><strong>AtomicMarkableReference</strong>：<br>基本和AtomicStampedReference差不多，AtomicStampedReference主要关注版本号，即reference的值被修改了多少次；AtomicMarkableReference是使用boolean mark来标记reference是否被修改过</p>
<h1 id="Synchronized-和-Lock-的主要区别"><a href="#Synchronized-和-Lock-的主要区别" class="headerlink" title="# Synchronized 和 Lock 的主要区别"></a># Synchronized 和 Lock 的主要区别</h1><p>Synchronzied 和 Lock 的主要区别如下：</p>
<ul>
<li><strong>存在层面</strong>：Syncronized 是Java 中的一个关键字，存在于 JVM 层面，Lock 是 Java 中的一个接口</li>
<li><strong>锁的释放条件</strong>：1. 获取锁的线程执行完同步代码后，自动释放；2. 线程发生异常时，JVM会让线程释放锁；Lock 必须在 finally 关键字中释放锁，不然容易造成线程死锁</li>
<li><strong>锁的获取</strong>: 在 Syncronized 中，假设线程 A 获得锁，B 线程等待。如果 A 发生阻塞，那么 B 会一直等待。在 Lock 中，会分情况而定，Lock 中有尝试获取锁的方法，如果尝试获取到锁，则不用一直等待</li>
<li><strong>锁的状态</strong>：Synchronized 无法判断锁的状态，Lock 则可以判断</li>
<li><strong>锁的类型</strong>：Synchronized 是可重入，不可中断，非公平锁；Lock 锁则是 可重入，可判断，可公平锁</li>
<li><strong>锁的性能</strong>：Synchronized 适用于少量同步的情况下，性能开销比较大。Lock 锁适用于大量同步阶段：</li>
<li>Lock 锁可以提高多个线程进行读的效率(使用 readWriteLock)</li>
<li>在竞争不是很激烈的情况下，Synchronized的性能要优于ReetrantLock，但是在资源竞争很激烈的情况下，Synchronized的性能会下降几十倍，但是ReetrantLock的性能能维持常态；</li>
<li>ReetrantLock 提供了多样化的同步，比如有时间限制的同步，可以被Interrupt的同步（synchronized的同步是不能Interrupt的）等。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/19/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/juc/" data-id="clkngg0on00c12wv6bixkf2nz" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/redis/Redis缓存穿透、击穿、雪崩" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/15/interview/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" class="article-date">
  <time class="post-time" datetime="2023-07-15T05:43:47.665Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/07/15/interview/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/">Redis的缓存穿透、缓存击穿、缓存雪崩</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>,<a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/">Redis</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis/">Redis</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Redis的缓存穿透、缓存击穿、缓存雪崩"><a href="#Redis的缓存穿透、缓存击穿、缓存雪崩" class="headerlink" title="Redis的缓存穿透、缓存击穿、缓存雪崩"></a>Redis的缓存穿透、缓存击穿、缓存雪崩</h1><h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p><strong>① 缓存穿透</strong>：大量请求根本不存在的key</p>
<p><strong>② 缓存雪崩</strong>：Redis中大量key集体过期</p>
<p><strong>③ 缓存击穿</strong>：Redis中一个热点key过期</p>
<p>三者出现的根本原因：Redis命中率下降，请求直接打在DB上<br>        正常情况下，大量的资源请求都会被redis响应，在redis得不到响应的小部分请求才会去请求DB，这样DB的压力是非常小的，是可以正常工作的（如下图）</p>
<p><img src="/../../../images/image-20230715135117005.png" alt="image-20230715135117005"></p>
<p>​    如果大量的请求在redis上得不到响应，那么就会导致这些请求会直接去访问DB，导致DB的压力瞬间变大而卡死或者宕机。如下图：</p>
<p>① 大量的高并发的请求打在redis上</p>
<p>② 这些请求发现redis上并没有需要请求的资源，redis命中率降低</p>
<p>③ 因此这些大量的高并发请求转向DB（数据库服务器）请求对应的资源</p>
<p>④ DB压力瞬间增大，直接将DB打垮，进而引发一系列“灾害”</p>
<p> <img src="/../../../images/image-20230715135155569.png" alt="image-20230715135155569"></p>
<p>​		那么为什么redis会没有需要访问的数据呢？通过分析大致可以总结为三种情况，也就对应着redis的雪崩、穿透和击穿（下文开始进行详解） </p>
<p><img src="/../../../images/image-20230715135236580.png" alt="image-20230715135236580"></p>
<h1 id="二、情景分析-（详解）"><a href="#二、情景分析-（详解）" class="headerlink" title="二、情景分析 （详解）"></a>二、情景分析 （详解）</h1><h2 id="（一）缓存击穿"><a href="#（一）缓存击穿" class="headerlink" title="（一）缓存击穿"></a>（一）缓存击穿</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>产生缓存雪崩的原因：redis中的某个热点key过期，但是此时有大量的用户访问该过期key</p>
<p><img src="/../../../images/image-20230715135655943.png" alt="image-20230715135655943"></p>
<h3 id="情景："><a href="#情景：" class="headerlink" title="情景："></a>情景：</h3><p>缓存击穿的原因通常有以下几种：</p>
<ol>
<li><p>缓存中不存在所需的热点数据：当系统中某个热点数据需要被频繁访问时，如果这个热点数据最开始没有被缓存，那么就会导致系统每次请求都需要直接查询数据库，造成数据库负担。</p>
</li>
<li><p>缓存的热点数据过期：当一个热点数据过期并需要重新缓存时，如果此时有大量请求，那么就会导致所有请求都要直接查询数据库。</p>
<pre><code> 类似于“某男明星塌房事件”上了热搜，这时候大量的“粉丝”都在访问该热点事件，但是可能由于某种原因，redis的这个热点key过期了，那么这时候大量高并发对于该key的请求就得不到redis的响应，那么就会将请求直接打在DB服务器上，导致整个DB瘫痪。
</code></pre>
</li>
</ol>
<h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><h4 id="1-设置永不过期（提前对热点数据进行设置）"><a href="#1-设置永不过期（提前对热点数据进行设置）" class="headerlink" title="1.设置永不过期（提前对热点数据进行设置）"></a>1.设置永不过期（提前对热点数据进行设置）</h4><p>类似于新闻、某博等软件都需要对热点数据进行预先设置在redis中</p>
<h4 id="2-加锁排队"><a href="#2-加锁排队" class="headerlink" title="2.加锁排队"></a>2.加锁排队</h4><h5 id="（方式一）双重检查锁："><a href="#（方式一）双重检查锁：" class="headerlink" title="（方式一）双重检查锁："></a>（方式一）双重检查锁：</h5><p>只有一个请求A可以获取到互斥锁，其它请求在外排队，然后线程A到DB中将数据查询并返回到Redis，之后所有请求就可以从Redis中得到响应（这些请求有两种情况：一，已经进入排队的请求获得锁之后，可在第二重查询redis中获取数据；二，没有进入排队的请求【也就是没有通过 if(obj == null) 而进入争取锁的队列中的请求】，直接在外部的查询redis获取到数据）</p>
<p><img src="/../../../images/image-20230715140125819.png" alt="image-20230715140125819"></p>
<h5 id="（方式二）分布式锁："><a href="#（方式二）分布式锁：" class="headerlink" title="（方式二）分布式锁："></a>（方式二）分布式锁：</h5><h5 id="不好之处："><a href="#不好之处：" class="headerlink" title="不好之处："></a>不好之处：</h5><p>高并发的情况下，影响性能。但大多数情况下访问是可以从外层就可以获取到缓存数据的了，而只有在偶尔的情况下会因为key突然过期，才会导致那个时间的请求进入锁机制，而且进入排队的，也有二重检查来减轻对数据库的压力。</p>
<h4 id="3-监控数据，适时调整"><a href="#3-监控数据，适时调整" class="headerlink" title="3.监控数据，适时调整"></a>3.监控数据，适时调整</h4><p>监控哪些数据是热门数据，实时的调整key的过期时长</p>
<h2 id="（二）缓存雪崩"><a href="#（二）缓存雪崩" class="headerlink" title="（二）缓存雪崩"></a>（二）缓存雪崩</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><p>缓存雪崩产生的原因：redis中大量的key集体过期</p>
<p><img src="/../../../images/image-20230715141420609.png" alt="image-20230715141420609"></p>
<p>举例：</p>
<pre><code>    当redis中的大量key集体过期，可以理解为redis中的大部分数据都被清空了（失效了），那么这时候如果有大量并发的请求来到，那么redis就无法进行有效的响应（命中率急剧下降），请求就都打到DB上了，到时DB直接崩溃
</code></pre>
<h3 id="情景：-1"><a href="#情景：-1" class="headerlink" title="情景："></a>情景：</h3><ul>
<li><p><strong>大量key集体过期</strong></p>
<ul>
<li>解决方法<ul>
<li>1.加锁排队 + 将失效时间分散开</li>
<li>2.使用多级缓存架构</li>
<li>3.设置缓存标记</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Redis服务宕机</strong></p>
<ul>
<li>解决方法：redis高可用（集群、哨兵模式）</li>
</ul>
</li>
<li><p><strong>机房断电</strong></p>
<ul>
<li>解决方法：提前做好灾备，做好多机房，一个机房挂掉了，马上切换到另外一个地方的机房</li>
</ul>
</li>
</ul>
<h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><h4 id="1-加锁排队-将失效时间分散开"><a href="#1-加锁排队-将失效时间分散开" class="headerlink" title="1.加锁排队 + 将失效时间分散开"></a>1.加锁排队 + 将失效时间分散开</h4><p>通过使用自动生成随机数使得key的过期时间是随机的，防止集体过期</p>
<p><img src="/../../../images/image-20230715142038202.png" alt="image-20230715142038202"></p>
<h4 id="2-使用多级架构"><a href="#2-使用多级架构" class="headerlink" title="2.使用多级架构"></a>2.使用多级架构</h4><p>使用nginx缓存+redis缓存+其他缓存，不同层使用不同（过期时间）的缓存，可靠性更强</p>
<h4 id="3-设置缓存标记"><a href="#3-设置缓存标记" class="headerlink" title="3.设置缓存标记"></a>3.设置缓存标记</h4><p>记录缓存数据是否过期，如果过期会去跟新实际的key。</p>
<p>（1）<strong>不另外启一个线程</strong>，而是在value里面，储存了个逻辑过期时间（相当于实际过期时间我们设置1小时，但逻辑过期时间可能是50分钟），取值的时候，判断 实际时间 &gt; 逻辑时间，则进行加锁更新，其余的线程，拿不到锁的先全部返回旧数据。</p>
<p>（2）<strong>异步处理</strong>：但判断 实际时间 &gt; 逻辑时间，通知另外的线程进行更新</p>
<h4 id="4-redis高可用（集群、哨兵模式）"><a href="#4-redis高可用（集群、哨兵模式）" class="headerlink" title="4.redis高可用（集群、哨兵模式）"></a>4.redis高可用（集群、哨兵模式）</h4><p>如果是Redis服务宕机，那就需要提前给Redis做好集群，并做好哨兵模式，发现宕机，另外的补上。</p>
<h2 id="（三）缓存穿透"><a href="#（三）缓存穿透" class="headerlink" title="（三）缓存穿透"></a>（三）缓存穿透</h2><h3 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h3><p>缓存穿透产生的原因：请求根本不存在的资源（DB本身就不存在，Redis更是不存在）</p>
<p><img src="/../../../images/image-20230715143842809.png" alt="image-20230715143842809"></p>
<p>举例（情景在线）：客户端发送大量的不可响应的请求（如下图）</p>
<p><img src="/../../../images/image-20230715143928303.png" alt="image-20230715143928303"></p>
<pre><code>    当大量的客户端发出类似于：http://localhost:8080/user/19833?id=-3872 的请求，就可能导致出现缓存穿透的情况。因为数据库DB中本身就没有id=-3872的用户的数据，所以Redis也没有对应的数据，那么这些请求在redis就得不到响应，就会直接打在DB上，导致DB压力过大而卡死情景在线或宕机。
    缓存穿透很有可能是黑客攻击所为，黑客通过发送大量的高并发的无法响应的请求给服务器，由于请求的资源根本就不存在，DB就很容易被打垮了。
</code></pre>
<h3 id="解决方式：-1"><a href="#解决方式：-1" class="headerlink" title="解决方式："></a>解决方式：</h3><h4 id="1-缓存空对象（-加锁排队-将失效时间分散开）"><a href="#1-缓存空对象（-加锁排队-将失效时间分散开）" class="headerlink" title="1.缓存空对象（+加锁排队 + 将失效时间分散开）"></a>1.缓存空对象（+加锁排队 + 将失效时间分散开）</h4><p><img src="/../../../images/image-20230715144221629.png" alt="image-20230715144221629"></p>
<ul>
<li>类似于上面的例子，虽然数据库中没有id=-3872的用户的数据，但是在redis中对他进行缓存（key=-3872，value=null），这样当请求到达redis的时候就会直接返回一个null的值给客户端，避免了大量无法访问的数据直接打在DB上<ul>
<li>注意：<ul>
<li>使用空值作为缓存的时候，key设置的过期时间不能太长，防止占用太多redis资源（比如大量的恶意攻击）</li>
<li>当前访问的数据可能当时数据库中没有，但后面可能会有，所以设置过期时间不能太长，建议随机的短时间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-布隆过滤器"><a href="#2-布隆过滤器" class="headerlink" title="2.布隆过滤器"></a>2.布隆过滤器</h4><ul>
<li>黑名单：把请求不存在的数据存进黑名单，下次访问数据前先判断布隆过滤器中是都存在该key，存在则拒绝访问。</li>
<li>白名单：把数据库存在的数据存进布隆过滤器，请求访问判断到布隆过滤器中有才释放后续访问数据，不存在则拒绝后续访问。</li>
</ul>
<p><strong>注意：</strong></p>
<ol>
<li><p>要做好数据同步，因为不是所有的数据都是一直在黑名单或白名单的，增删改会导致变动。所以这种方式的缺点就是要做数据同步。</p>
</li>
<li><p>布隆过滤器是有一定的误差，所以一般需要配合一些接口流量的限制（规定用户在一段时间内访问的频率）、权限校验、黑名单等来解决缓存穿透的问题</p>
</li>
</ol>
<h4 id="3-实时监控："><a href="#3-实时监控：" class="headerlink" title="3.实时监控："></a>3.实时监控：</h4><p>​        对redis进行实时监控，当发现redis中的命中率下降的时候进行原因的排查，配合运维人员对访问对象和访问数据进行分析查询，从而进行黑名单的设置限制服务（拒绝黑客攻击）</p>
<h4 id="4-接口校验"><a href="#4-接口校验" class="headerlink" title="4.接口校验"></a>4.接口校验</h4><p>​        类似于用户权限的拦截，对于id=-3872这些无效访问就直接拦截，不允许这些请求到达Redis、DB上。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/15/interview/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/" data-id="clkngg0oz00cc2wv60qo93nw9" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/redis/Redis缓存穿透、击穿、雪崩/Redis缓存" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/07/14/interview/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/Redis%E7%BC%93%E5%AD%98/" class="article-date">
  <time class="post-time" datetime="2023-07-14T13:07:17.849Z" itemprop="datePublished">
    <span class="post-month">7月</span><br/>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Spring-Boot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？"><a href="#Spring-Boot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？" class="headerlink" title="Spring Boot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？"></a>Spring Boot中如何解决Redis的缓存穿透、缓存击穿、缓存雪崩？</h1><p>大家好，我是飘渺！今天给大家介绍一下如何在SpringBoot中解决Redis的缓存穿透、缓存击穿、缓存雪崩的问题。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透指的是一个缓存系统无法缓存某个查询的数据，从而导致这个查询每一次都要访问数据库。</p>
<p>常见的Redis缓存穿透场景包括：</p>
<ol>
<li>查询一个不存在的数据：攻击者可能会发送一些无效的查询来触发缓存穿透。</li>
<li>查询一些非常热门的数据：如果一个数据被访问的非常频繁，那么可能会导致缓存系统无法处理这些请求，从而造成缓存穿透。</li>
<li>查询一些异常数据：这种情况通常发生在数据服务出现故障或异常时，从而造成缓存系统无法访问相关数据，从而导致缓存穿透。</li>
</ol>
<h3 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h3><p>我们可以使用Guava在内存中维护一个布隆过滤器。具体步骤如下：</p>
<ol>
<li>添加Guava和Redis依赖：</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>29.0-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>创建一个BloomFilterUtil类，用于在缓存中维护Bloom Filter。</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BloomFilterUtil</span> {</span><br><span class="line">    <span class="comment">// 布隆过滤器的预计容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">expectedInsertions</span> <span class="operator">=</span> <span class="number">1000000</span>;</span><br><span class="line">    <span class="comment">// 布隆过滤器误判率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">double</span> <span class="variable">fpp</span> <span class="operator">=</span> <span class="number">0.001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charset.defaultCharset()), expectedInsertions, fpp);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向Bloom Filter中添加元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(String key)</span>{</span><br><span class="line">        bloomFilter.put(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断元素是否存在于Bloom Filter中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">mightContain</span><span class="params">(String key)</span>{</span><br><span class="line">        <span class="keyword">return</span> bloomFilter.mightContain(key);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在Controller中查询数据时，先根据请求参数进行Bloom Filter的过滤</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping("/user/{id}")</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>{</span><br><span class="line">    <span class="comment">// 先从布隆过滤器中判断此id是否存在</span></span><br><span class="line">    <span class="keyword">if</span>(!BloomFilterUtil.mightContain(id.toString())){</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 查询缓存数据</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">"user_"</span>+id.toString();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(userKey);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// 查询数据库</span></span><br><span class="line">        user = userRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span>){</span><br><span class="line">            <span class="comment">// 将查询到的数据加入缓存</span></span><br><span class="line">            redisTemplate.opsForValue().set(userKey, user, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="comment">// 查询结果为空，将请求记录下来，并在布隆过滤器中添加</span></span><br><span class="line">            BloomFilterUtil.add(id.toString());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>缓存击穿指的是在一些高并发访问下，一个热点数据从缓存中不存在，每次请求都要直接查询数据库，从而导致数据库压力过大，并且系统性能下降的现象。</p>
<p>缓存击穿的原因通常有以下几种：</p>
<ol>
<li>缓存中不存在所需的热点数据：当系统中某个热点数据需要被频繁访问时，如果这个热点数据最开始没有被缓存，那么就会导致系统每次请求都需要直接查询数据库，造成数据库负担。</li>
<li>缓存的热点数据过期：当一个热点数据过期并需要重新缓存时，如果此时有大量请求，那么就会导致所有请求都要直接查询数据库。</li>
</ol>
<h3 id="如何解决-1"><a href="#如何解决-1" class="headerlink" title="如何解决"></a>如何解决</h3><p>主要思路 : <strong>在遇到缓存击穿问题时，我们可以在查询数据库之前，先判断一下缓存中是否已有数据，如果没有数据则使用Redis的单线程特性，先查询数据库然后将数据写入缓存中。</strong></p>
<ol>
<li>添加Redis依赖</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在Controller中查询数据时，先从缓存中查询数据，如果缓存中无数据则进行锁操作</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping("/user/{id}")</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>{</span><br><span class="line">    <span class="comment">// 先从缓存中获取值</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">"user_"</span>+id.toString();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) redisTemplate.opsForValue().get(userKey);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// 查询数据库之前加锁</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">lockKey</span> <span class="operator">=</span> <span class="string">"lock_user_"</span>+id.toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">lockValue</span> <span class="operator">=</span> UUID.randomUUID().toString();</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="type">Boolean</span> <span class="variable">lockResult</span> <span class="operator">=</span> redisTemplate.opsForValue().setIfAbsent(lockKey, lockValue, <span class="number">60</span>, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span>(lockResult != <span class="literal">null</span> &amp;&amp; lockResult){</span><br><span class="line">                <span class="comment">// 查询数据库</span></span><br><span class="line">                user = userRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span>(user != <span class="literal">null</span>){</span><br><span class="line">                    <span class="comment">// 将查询到的数据加入缓存</span></span><br><span class="line">                    redisTemplate.opsForValue().set(userKey, user, <span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">finally</span>{</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            <span class="keyword">if</span>(lockValue.equals(redisTemplate.opsForValue().get(lockKey))){</span><br><span class="line">                redisTemplate.delete(lockKey);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>指缓存中大量数据的失效时间集中在某一个时间段，导致在这个时间段内缓存失效并额外请求数据库查询数据的请求大量增加，从而对数据库造成极大的压力和负荷。</p>
<p>常见的Redis缓存雪崩场景包括：</p>
<ol>
<li>缓存服务器宕机：当缓存服务器宕机或重启时，大量的访问请求将直接命中数据库，并在同一时间段内导致大量的数据库查询请求，从而将数据库压力大幅提高。</li>
<li>缓存数据同时失效：在某个特定时间点，缓存中大量数据的失效时间集中在一起，这些数据会在同一时间段失效，并且这些数据被高频访问，将导致大量的访问请求去查询数据库。</li>
<li>缓存中数据过期时间设计不合理：当缓存中的数据有效时间过短，且数据集中在同一时期失效时，就容易导致大量的请求直接查询数据库，加剧数据库压力。</li>
<li>波动式的访问过程：当数据的访问存在波动式特征时，例如输出某些活动物品或促销商品时，将会带来高频的查询请求访问，导致缓存大量失效并产生缓存雪崩。</li>
</ol>
<h3 id="如何解决-2"><a href="#如何解决-2" class="headerlink" title="如何解决"></a>如何解决</h3><p>在遇到缓存雪崩时，我们可以使用两种方法：一种是将缓存过期时间分散开，即为不同的数据设置不同的过期时间；另一种是使用Redis的多级缓存架构，通过增加一层代理层来解决。具体步骤如下：</p>
<ol>
<li>添加相关依赖</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.sf.ehcache<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在application.properties中配置Ehcache缓存</li>
</ol>
<figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">properties</span></span><br><span class="line"><span class="attr">复制代码spring.cache.type</span>=<span class="string">ehcache</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>创建一个CacheConfig类，用于配置Ehcache：</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> EhCacheCacheManager <span class="title function_">ehCacheCacheManager</span><span class="params">(CacheManager cm)</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">EhCacheCacheManager</span>(cm);</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CacheManager <span class="title function_">ehCacheManager</span><span class="params">()</span>{</span><br><span class="line">        <span class="type">EhCacheManagerFactoryBean</span> <span class="variable">cmfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EhCacheManagerFactoryBean</span>();</span><br><span class="line">        cmfb.setConfigLocation(<span class="keyword">new</span> <span class="title class_">ClassPathResource</span>(<span class="string">"ehcache.xml"</span>));</span><br><span class="line">        cmfb.setShared(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> cmfb.getObject();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在ehcache.xml中添加缓存配置</li>
</ol>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xml复制代码<span class="meta">&lt;?xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">updateCheck</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">monitoring</span>=<span class="string">"autodetect"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">dynamicConfig</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">"userCache"</span> <span class="attr">maxEntriesLocalHeap</span>=<span class="string">"10000"</span> <span class="attr">timeToLiveSeconds</span>=<span class="string">"60"</span> <span class="attr">timeToIdleSeconds</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li>在Controller中查询数据时，先从Ehcache缓存中获取，如果缓存中无数据则再从Redis缓存中获取数据</li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">java复制代码<span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> CacheManager ehCacheManager;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping("/user/{id}")</span></span><br><span class="line"><span class="meta">@Cacheable(value = "userCache", key = "#id")</span></span><br><span class="line"><span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span>{</span><br><span class="line">    <span class="comment">// 先从Ehcache缓存中获取</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">userKey</span> <span class="operator">=</span> <span class="string">"user_"</span>+id.toString();</span><br><span class="line">    <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) ehCacheManager.getCache(<span class="string">"userCache"</span>).get(userKey).get();</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="literal">null</span>){</span><br><span class="line">        <span class="comment">// 再从Redis缓存中获取</span></span><br><span class="line">        user = (User) redisTemplate.opsForValue().get(userKey);</span><br><span class="line">        <span class="keyword">if</span>(user != <span class="literal">null</span>){</span><br><span class="line">            ehCacheManager.getCache(<span class="string">"userCache"</span>).put(userKey, user);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>以上就是使用SpringBoot时如何解决Redis的缓存穿透、缓存击穿、缓存雪崩的常用方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/07/14/interview/redis/Redis%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/Redis%E7%BC%93%E5%AD%98/" data-id="clkngg0qs00e52wv698mj7mvs" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-redis/分布式锁" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/06/04/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" class="article-date">
  <time class="post-time" datetime="2023-06-04T02:28:56.289Z" itemprop="datePublished">
    <span class="post-month">6月</span><br/>
    <span class="post-day">04</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/06/04/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">为何要用分布式锁&amp;Redis实现分布式锁</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/redis/">redis</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="为何要用分布式锁"><a href="#为何要用分布式锁" class="headerlink" title="为何要用分布式锁"></a>为何要用分布式锁</h1><h2 id="一、为什么要使用分布式锁"><a href="#一、为什么要使用分布式锁" class="headerlink" title="一、为什么要使用分布式锁"></a><strong>一、为什么要使用分布式锁</strong></h2><p>为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种<strong>跨JVM的互斥机制</strong>来控制共享资源的访问，这就是分布式锁要解决的问题</p>
<h2 id="二、分布式锁应该具备哪些条件"><a href="#二、分布式锁应该具备哪些条件" class="headerlink" title="二、分布式锁应该具备哪些条件"></a><strong>二、分布式锁应该具备哪些条件</strong></h2><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：<br>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</p>
<p>2、高可用的获取锁与释放锁；</p>
<p>3、高性能的获取锁与释放锁；</p>
<p>4、具备可重入特性；</p>
<p>5、具备锁失效机制，防止死锁；</p>
<p>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</p>
<p><img src="/../../images/image-20230604103343211.png" alt="image-20230604103343211"></p>
<p><img src="/../../images/image-20230604103310644.png" alt="image-20230604103310644"></p>
<h1 id="数据库实现分布式锁原理："><a href="#数据库实现分布式锁原理：" class="headerlink" title="数据库实现分布式锁原理："></a>数据库实现分布式锁原理：</h1><p><img src="/../../images/image-20230604102928951.png" alt="image-20230604102928951"></p>
<h1 id="Redis实现分布式锁原理："><a href="#Redis实现分布式锁原理：" class="headerlink" title="Redis实现分布式锁原理："></a>Redis实现分布式锁原理：</h1><p><img src="/../../images/image-20230604103157783.png" alt="image-20230604103157783"></p>
<p><img src="/../../images/image-20230604103116683.png" alt="image-20230604103116683"></p>
<h1 id="问题注意："><a href="#问题注意：" class="headerlink" title="问题注意："></a>问题注意：</h1><ul>
<li>业务失败锁还在，就会产生死锁，可以加一个过期时间自动释放锁，但是自动释放可能出现释放掉<strong>其他jvm锁</strong>的情况，所以要给锁加一个唯一标识，删除前先看看是不是本机持有的锁，是的话再删除，还要保证查询和删除是一个原子操作，可以使用lua脚本<img src="https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png@48w_48h.webp" alt="[脱单doge]"></li>
<li>产生死锁现象，导致虚拟机实例无法再次获取资源，可以设置失效时间，缺陷：因为不确定业务执行时间的长短，所以失效时间的设置具有不确定性。优化：使用try catch finally 语句块，在finally语句中调用del方法删除key完成释放锁的目的，这样下次虚拟机实例请求资源时便能通过setNx（）方法获取到锁，执行响应业务逻辑！<img src="https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png@48w_48h.webp" alt="[脱单doge]"></li>
</ul>
<p>看门狗：</p>
<h3 id="对于Redis集群而言可能存在的问题："><a href="#对于Redis集群而言可能存在的问题：" class="headerlink" title="对于Redis集群而言可能存在的问题："></a>对于Redis集群而言可能存在的问题：</h3><ul>
<li><strong>问题</strong>：主从切换的时候，主从同步延迟，可能锁信息没有同步到新主</li>
<li><strong>解决：</strong><ul>
<li>利用多个redis实例来存储共享，加锁时给每个redis都加锁<ul>
<li>第一步：获取当前系统时间 （主要为了计算客户端对多个实例加锁所耗费的一个总时间）</li>
<li>第二步：依次对多个实例进行加锁，加锁完成后，计算客户端对多个实例加锁所耗费的一个总时耗时</li>
<li>如果加锁的总耗时比锁设置的有效时间短，说明加锁成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Redis分布式锁的正确实现方式"><a href="#Redis分布式锁的正确实现方式" class="headerlink" title="Redis分布式锁的正确实现方式"></a>Redis分布式锁的正确实现方式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式锁一般有三种实现方式：</p>
<ol>
<li>数据库乐观锁；</li>
<li>基于Redis的分布式锁；</li>
<li>基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。</li>
</ol>
<hr>
<h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ol>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ol>
<hr>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="组件依赖"><a href="#组件依赖" class="headerlink" title="组件依赖"></a>组件依赖</h3><p>首先我们要通过Maven引入<code>Jedis</code>开源组件，在<code>pom.xml</code>文件加入下面的代码：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="加锁代码"><a href="#加锁代码" class="headerlink" title="加锁代码"></a>加锁代码</h2><h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTool</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">LOCK_SUCCESS</span> <span class="operator">=</span> <span class="string">"OK"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_IF_NOT_EXIST</span> <span class="operator">=</span> <span class="string">"NX"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SET_WITH_EXPIRE_TIME</span> <span class="operator">=</span> <span class="string">"PX"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime 超期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否获取成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">tryGetDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="type">int</span> expireTime)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCK_SUCCESS.equals(result)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p>
<ul>
<li>第一个为key，我们使用key来当锁，因为key是唯一的。</li>
<li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li>
<li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p>
<p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
<h3 id="错误示例1"><a href="#错误示例1" class="headerlink" title="错误示例1"></a>错误示例1</h3><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongGetLock1</span><span class="params">(Jedis jedis, String lockKey, String requestId, <span class="type">int</span> expireTime)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">Long</span> <span class="variable">result</span> <span class="operator">=</span> jedis.setnx(lockKey, requestId);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">1</span>) {</span><br><span class="line">        <span class="comment">// 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span></span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
<h3 id="错误示例2"><a href="#错误示例2" class="headerlink" title="错误示例2"></a>错误示例2</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">wrongGetLock2</span><span class="params">(Jedis jedis, String lockKey, <span class="type">int</span> expireTime)</span> {</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">expires</span> <span class="operator">=</span> System.currentTimeMillis() + expireTime;</span><br><span class="line">    <span class="type">String</span> <span class="variable">expiresStr</span> <span class="operator">=</span> String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前锁不存在，返回加锁成功</span></span><br><span class="line">    <span class="keyword">if</span> (jedis.setnx(lockKey, expiresStr) == <span class="number">1</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果锁存在，获取锁的过期时间</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">currentValueStr</span> <span class="operator">=</span> jedis.get(lockKey);</span><br><span class="line">    <span class="keyword">if</span> (currentValueStr != <span class="literal">null</span> &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) {</span><br><span class="line">        <span class="comment">// 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">oldValueStr</span> <span class="operator">=</span> jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        <span class="keyword">if</span> (oldValueStr != <span class="literal">null</span> &amp;&amp; oldValueStr.equals(currentValueStr)) {</span><br><span class="line">            <span class="comment">// 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 其他情况，一律返回加锁失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程：1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p>
<p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p>
<h2 id="解锁代码"><a href="#解锁代码" class="headerlink" title="解锁代码"></a>解锁代码</h2><h3 id="正确姿势-1"><a href="#正确姿势-1" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>还是先展示代码，再带大家慢慢解释为什么这样实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisTool</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Long</span> <span class="variable">RELEASE_SUCCESS</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 释放分布式锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> jedis Redis客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockKey 锁</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestId 请求标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是否释放成功</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">releaseDistributedLock</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">"if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end"</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (RELEASE_SUCCESS.equals(result)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p>
<p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读<a target="_blank" rel="noopener" href="http://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#releaseLock-wrongDemo2">【解锁代码-错误示例2】</a> 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p>
<p><img src="http://o7x0ygc3f.bkt.clouddn.com/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F_01.png" alt="img"></p>
<p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p>
<h3 id="错误示例1-1"><a href="#错误示例1-1" class="headerlink" title="错误示例1"></a>错误示例1</h3><p>最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongReleaseLock1(Jedis jedis, String lockKey) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="错误示例2-1"><a href="#错误示例2-1" class="headerlink" title="错误示例2"></a>错误示例2</h3><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">wrongReleaseLock2</span><span class="params">(Jedis jedis, String lockKey, String requestId)</span> {</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 判断加锁与解锁是不是同一个客户端</span></span><br><span class="line">    <span class="keyword">if</span> (requestId.equals(jedis.get(lockKey))) {</span><br><span class="line">        <span class="comment">// 若在此时，这把锁突然不是这个客户端的，则会误解锁</span></span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p>
<p>如果你的项目中Redis是多机部署的，那么可以尝试使用<code>Redisson</code>实现分布式锁，这是Redis官方提供的Java组件，链接在<a target="_blank" rel="noopener" href="http://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB">参考阅读</a>章节已经给出。</p>
<p>其它博文参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/165118929">深入解析 Redis 分布式锁原理 - 知乎 (zhihu.com)</a></p>
<h1 id="看门狗，给锁续时"><a href="#看门狗，给锁续时" class="headerlink" title="看门狗，给锁续时"></a>看门狗，给锁续时</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gD4y1u7eC/?spm_id_from=333.788.recommend_more_video.11&amp;vd_source=746b9336d739b80b11820809545b6604">【Java进阶】五分钟梳理看门狗的实现原理，手写Redis锁续期功能，打造核心竞争力_哔哩哔哩_bilibili</a></p>
<ul>
<li>方案：可基于<strong>HashedWheelTimer</strong>，加上自旋的方式来实现</li>
<li><strong>HashedWheelTimer</strong>：时间轮，异步的延时执行任务的工具类</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/268290754">Redis分布式锁解决高并发场景 - 知乎 (zhihu.com)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/06/04/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/" data-id="clkngg0kb005z2wv6a9xr1abp" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/redis/" rel="tag">redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/springboot/" rel="tag">springboot</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Netty/IM仿微信聊天/IM" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/" class="article-date">
  <time class="post-time" datetime="2023-05-20T08:12:31.462Z" itemprop="datePublished">
    <span class="post-month">5月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/../../../images/image-20230520161301132.png" alt="image-20230520161301132"></p>
<h1 id="网络通信层"><a href="#网络通信层" class="headerlink" title="网络通信层"></a>网络通信层</h1><p><strong>Bootstrap</strong></p>
<p>负责客户端启动并用来连接远程Netty Server</p>
<p>但这里不用Bootstrap，因为 IM实战的通讯方式是通过WebSocket前端网页来链接连接我们的netty的server端的</p>
<p><img src="/../../../images/image-20230520162251684.png" alt="image-20230520162251684"></p>
<p><img src="/../../../images/image-20230520162457445.png" alt="image-20230520162457445"></p>
<p><img src="/../../../images/image-20230520162426147.png" alt="image-20230520162426147"></p>
<p>上图的远离机制：</p>
<p>Client这三个客户端，会发送消息到BossGroup；BossGroup是一个线程池，中有一个Selector主要作用是会生成 SocketChannel；SocketChannel会封装成NIOSocketChannel；NIOSocketChannel会注册到工作线程中的Selector；若要读数据或写数据，那么工作线程中selector就会分发到不同对应的Handler中进行处理</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/" data-id="clkngg0mr00952wv69oq97jal" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/浏览器从输入URL到页面展示的过程" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/" class="article-date">
  <time class="post-time" datetime="2023-04-29T02:18:01.535Z" itemprop="datePublished">
    <span class="post-month">4月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/">浏览器从输入网址到页面展示的过程</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="浏览器从输入网址到页面展示的过程"><a href="#浏览器从输入网址到页面展示的过程" class="headerlink" title="浏览器从输入网址到页面展示的过程"></a>浏览器从输入网址到页面展示的过程</h1><p>完整高频题库仓库地址：<a target="_blank" rel="noopener" href="https://github.com/hzfe/awesome-interview"><strong>https://github.com/hzfe/awesome-interview</strong></a></p>
<p>完整高频题库阅读地址：<a target="_blank" rel="noopener" href="https://febook.hzfe.org/"><strong>https://febook.hzfe.org/</strong></a></p>
<h2 id="回答关键点"><a href="#回答关键点" class="headerlink" title="回答关键点"></a><strong>回答关键点</strong></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL` `DNS` `TCP` `渲染</span><br></pre></td></tr></tbody></table></figure>

<p>浏览器从输入网址到渲染页面主要分为以下几个过程</p>
<ul>
<li>URL 输入</li>
<li>DNS 解析</li>
<li>建立 TCP 连接</li>
<li>发送 HTTP / HTTPS 请求（建立 TLS 连接）</li>
<li>服务器响应请求</li>
<li>浏览器解析渲染页面</li>
<li>HTTP 请求结束，断开 TCP 连接</li>
</ul>
<h2 id="知识点深入"><a href="#知识点深入" class="headerlink" title="知识点深入"></a><strong>知识点深入</strong></h2><h3 id="1-URL-输入"><a href="#1-URL-输入" class="headerlink" title="1. URL 输入"></a><strong>1. URL 输入</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/2911d132881a03e20edc7c8942e65fed.png" alt="img"></p>
<p>URL地址 </p>
<p>URL（统一资源定位符，Uniform Resource Locator）用于定位互联网上资源，俗称网址。</p>
<p>我们在地址栏输入 HZFE 官方网址 hzfe.org 后敲下回车，浏览器会对输入的信息进行以下判断：</p>
<ol>
<li>检查输入的内容是否是一个合法的 URL 链接。</li>
<li>是，则判断输入的 URL 是否完整。如果不完整，浏览器可能会对域进行猜测，补全前缀或者后缀。</li>
<li>否，将输入内容作为搜索条件，使用用户设置的默认搜索引擎来进行搜索。</li>
</ol>
<p>大部分浏览器会从历史记录、书签等地方开始查找我们输入的网址，并给出智能提示。</p>
<h3 id="2-DNS（Domain-Name-System）解析"><a href="#2-DNS（Domain-Name-System）解析" class="headerlink" title="2. DNS（Domain Name System）解析"></a><strong>2. DNS（Domain Name System）解析</strong></h3><p>因为浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需要进行 DNS 解析，查找到对应的 IP 地址进行访问。</p>
<p>DNS 解析流程如下：</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/eb1b6b726e6cbe7c04beb6b7885202e4.png" alt="img"></p>
<p>DNS 解析 </p>
<ol>
<li>在浏览器中输入 hzfe.org 域名，操作系统检查浏览器缓存和本地的 hosts 文件中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li>
<li>查找本地 DNS 解析器缓存中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li>
<li>使用 TCP/IP 参数中设置的 DNS 服务器进行查询。如果要查询的域名包含在本地配置区域资源中，则返回解析结果，完成域名解析。</li>
<li>检查本地 DNS 服务器是否缓存该网址记录，有则返回解析结果，完成域名解析。</li>
<li>本地 DNS 服务器发送查询报文至根 DNS 服务器，根 DNS 服务器收到请求后，用顶级域 DNS 服务器地址进行响应。</li>
<li>本地 DNS 服务器发送查询报文至顶级域 DNS 服务器。顶级域 DNS 服务器收到请求后，用权威 DNS 服务器地址进行响应。</li>
<li>本地 DNS 服务器发送查询报文至权威 DNS 服务器，权威 DNS 服务器收到请求后，用 hzfe.org 的 IP 地址进行响应，完成域名解析。</li>
</ol>
<p>查询通常遵循以上流程，从请求主机到本地 DNS 服务器的查询是递归查询，DNS 服务器获取到所需映射的查询过程是迭代查询。</p>
<h3 id="3-建立-TCP-连接"><a href="#3-建立-TCP-连接" class="headerlink" title="3. 建立 TCP 连接"></a><strong>3. 建立 TCP 连接</strong></h3><blockquote>
<p> 世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层。 HTTP 的连接实际上就是 TCP 连接以及其使用规则。 –《HTTP 权威指南》 </p>
</blockquote>
<p>当浏览器获取到服务器的 IP 地址后，浏览器会用一个随机的端口（1024 &lt; 端口 &lt; 65535）向服务器 80 端口发起 TCP 连接请求（注：HTTP 默认约定 80 端口，HTTPS 为 443 端口）。这个连接请求到达服务端后，通过 TCP 三次握手，建立 TCP 的连接。</p>
<h4 id="3-1-分层模型"><a href="#3-1-分层模型" class="headerlink" title="3.1 分层模型"></a><strong>3.1 分层模型</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ----------------------------------</span><br><span class="line"><span class="number">7</span>|   应用层   |           |   <span class="variable constant_">HTTP</span>  |</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>|   表示层   |   应用层   |</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>|   会话层   |           |         |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">4</span>|   传输层   |   传输层   | <span class="variable constant_">TCP</span> <span class="variable constant_">TLS</span> |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">3</span>|   网络层   |   网络层   |   <span class="variable constant_">IP</span>    |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">2</span>|  数据链路层</span><br><span class="line">             |   链路层</span><br><span class="line"><span class="number">1</span>|   物理层</span><br><span class="line">  --------------------------------</span><br><span class="line">     [<span class="variable constant_">OSI</span>]   |   [<span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span>]</span><br></pre></td></tr></tbody></table></figure>

<p>复制</p>
<h4 id="3-2-TCP-三次握手"><a href="#3-2-TCP-三次握手" class="headerlink" title="3.2 TCP 三次握手"></a><strong>3.2 TCP 三次握手</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable constant_">SYN</span> 是建立连接时的握手信号，<span class="variable constant_">TCP</span> 中发送第一个 <span class="variable constant_">SYN</span> 包的为客户端，接收的为服务端</span><br><span class="line"># <span class="variable constant_">TCP</span> 中，当发送端数据到达接收端时，接收端返回一个已收到消息的通知。这个消息叫做确认应答 <span class="variable constant_">ACK</span></span><br><span class="line"></span><br><span class="line">  假设有客户端A，服务端B。我们要建立可靠的数据传输。</span><br><span class="line">      <span class="title function_">SYN</span>(=j)       <span class="comment">// SYN: A 请求建立连接</span></span><br><span class="line">  A ----------&gt; B</span><br><span class="line">                |</span><br><span class="line">     <span class="title function_">ACK</span>(=j+<span class="number">1</span>)  |   <span class="comment">// ACK: B 确认应答 A 的 SYN</span></span><br><span class="line">     <span class="title function_">SYN</span>(=k)    |   <span class="comment">// SYN: B 发送一个 SYN</span></span><br><span class="line">  A &lt;-----------</span><br><span class="line">  |</span><br><span class="line">  |  <span class="title function_">ACK</span>(=k+<span class="number">1</span>)</span><br><span class="line">   -----------&gt; B   <span class="comment">// ACK: A 确认应答 B 的包</span></span><br></pre></td></tr></tbody></table></figure>

<p>复制</p>
<ol>
<li>客户端发送 SYN 包（seq = j）到服务器，并进入 SYN_SEND 状态，等待服务器确认。</li>
<li>服务器收到 SYN 包，必须确认客户的 SYN（ACK = k + 1），同时自己也发送一个 SYN 包（seq = k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li>
<li>客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ACK = k + 1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</li>
</ol>
<h3 id="4-TLS-协商"><a href="#4-TLS-协商" class="headerlink" title="4. TLS 协商"></a><strong>4. TLS 协商</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/cdb05918db5147cc4f92f12cad6f5d15.png?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>TLS协商 </p>
<p>建立连接后就可以通过 HTTP 进行数据传输。如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。</p>
<ul>
<li>SSL <ul>
<li>认证用户和服务器，确保数据发送到正确的客户端和服务器。</li>
<li>加密数据防止数据中途被窃取。</li>
<li>维护数据的完整性，确保数据在传输过程中不被改变。</li>
</ul>
</li>
<li>TLS <ul>
<li>用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li>
</ul>
</li>
</ul>
<h4 id="4-1-TLS-握手协议"><a href="#4-1-TLS-握手协议" class="headerlink" title="4.1 TLS 握手协议"></a><strong>4.1 TLS 握手协议</strong></h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/3ac0cf1dcd3100b2b96c55bf4e827adf.png?imageView2/2/w/2560/h/7000" alt="img"></p>
<p>TLS握手协议 </p>
<ol>
<li>客户端发出一个 client hello 消息，携带的信息包括：所支持的 SSL/TLS 版本列表；支持的与加密算法；所支持的数据压缩方法；随机数 A。</li>
<li>服务端响应一个 server hello 消息，携带的信息包括：协商采用的 SSL/TLS 版本号；会话 ID；随机数 B；服务端数字证书 serverCA；由于双向认证需求，服务端需要对客户端进行认证，会同时发送一个 client certificate request，表示请求客户端的证书。</li>
<li>客户端校验服务端的数字证书；校验通过之后发送随机数 C，该随机数称为 pre-master-key，使用数字证书中的公钥加密后发出；由于服务端发起了 client certificate request，客户端使用私钥加密一个随机数 clientRandom 随客户端的证书 clientCA 一并发出。</li>
<li>服务端校验客户端的证书，并成功将客户端加密的随机数 clientRandom 解密；根据随机数 A/随机数 B/随机数 C（pre-master-key） 产生动态密钥 master-key，加密一个 finish 消息发至客户端。</li>
<li>客户端根据同样的随机数和算法生成 master-key，加密一个 finish 消息发送至服务端。</li>
<li>服务端和客户端分别解密成功，至此握手完成，之后的数据包均采用 master-key 进行加密传输。</li>
</ol>
<h3 id="5-服务器响应"><a href="#5-服务器响应" class="headerlink" title="5. 服务器响应"></a><strong>5. 服务器响应</strong></h3><p>当浏览器到 web 服务器的连接建立后，浏览器会发送一个初始的 HTTP GET 请求，请求目标通常是一个 HTML 文件。服务器收到请求后，将<strong>发回一个 HTTP 响应报文</strong>，内容包括相关响应头和 HTML 正文。</p>
<figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的博客<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"heading"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://hzfe.org/"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure>

<p>复制</p>
<h4 id="5-1-状态码"><a href="#5-1-状态码" class="headerlink" title="5.1 状态码"></a><strong>5.1 状态码</strong></h4><p>状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五类可能取值</p>
<ul>
<li>1xx：指示信息——表示请求已接收，继续处理</li>
<li>2xx：成功——表示请求已被成功接收、理解、接受</li>
<li>3xx：重定向——要完成请求必须进行更进一步的操作</li>
<li>4xx：客户端错误——请求有语法错误或请求无法实现</li>
<li>5xx：服务器端错误——服务器未能实现合法的请求</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应状态码 - HTTP | MDN (mozilla.org)</a></p>
<h4 id="5-2-常见的请求头和字段"><a href="#5-2-常见的请求头和字段" class="headerlink" title="5.2 常见的请求头和字段"></a><strong>5.2 常见的请求头和字段</strong></h4><ul>
<li>Cache-Control：must-revalidate、no-cache、private（是否需要缓存资源）</li>
<li>Connection：keep-alive（保持连接）</li>
<li>Content-Encoding：gzip（web 服务器支持的返回内容压缩编码类型）</li>
<li>Content-Type：text/html；charset=UTF-8（文件类型和字符编码格式）</li>
<li>Date：Sun， 21 Sep 2021 06:18:21 GMT（服务器消息发出的时间）</li>
<li>Transfer-Encoding：chunked（服务器发送的资源的方式是分块发送）</li>
</ul>
<h4 id="5-3-HTTP-响应报文"><a href="#5-3-HTTP-响应报文" class="headerlink" title="5.3 HTTP 响应报文"></a><strong>5.3 HTTP 响应报文</strong></h4><p>响应报文由四部分组成（响应行 + 响应头 + 空行 + 响应体）</p>
<ul>
<li>状态行：HTTP 版本 + 空格 + 状态码 + 空格 + 状态码描述 + 回车符（CR） + 换行符（LF）</li>
<li>响应头：字段名 + 冒号 + 值 + 回车符 + 换行符</li>
<li>空行：回车符 + 换行符</li>
<li>响应体：由用户自定义添加，如 post 的 body 等</li>
</ul>
<h3 id="6-浏览器解析并绘制"><a href="#6-浏览器解析并绘制" class="headerlink" title="6. 浏览器解析并绘制"></a><strong>6. 浏览器解析并绘制</strong></h3><p>不同的浏览器引擎渲染过程都不太一样，这里以 Chrome 浏览器渲染方式为例。</p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/601ac9a205ada2bd56a06ed97996b301.png?imageView2/2/w/2560/h/7000" alt="img"></p>
<ol>
<li>处理 HTML 标记并构建 DOM 树。</li>
<li>处理 CSS 标记并构建 CSSOM 树。</li>
<li>将 DOM 与 CSSOM 合并成一个渲染树。</li>
<li>根据渲染树来布局，以计算每个节点的几何信息。</li>
<li>将各个节点绘制到屏幕上。</li>
</ol>
<h3 id="7-TCP-断开连接"><a href="#7-TCP-断开连接" class="headerlink" title="7. TCP 断开连接"></a><strong>7. TCP 断开连接</strong></h3><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是<strong>四次挥手</strong>。关闭是一个全双工的过程，发包的顺序是不一定的。一般来说是客户端主动发起的关闭，过程如下图所示： </p>
<p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/cd2cb58d98ca10faed28f809eab5b461.png?imageView2/2/w/2560/h/7000" alt="img"></p>
<ol>
<li>主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 确认报文，主动关闭方依然会重发这些数据），但此时主动关闭方还可以接受数据。</li>
<li>被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。</li>
<li>被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li>
<li>主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/" data-id="clkngg0pu00d62wv6ds6i85p1" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/2/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>179</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>