<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>为何要用分布式锁&amp;Redis实现分布式锁</title>
      <link href="/2023/06/04/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
      <url>/2023/06/04/redis/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h1 id="为何要用分布式锁"><a class="markdownIt-Anchor" href="#为何要用分布式锁"></a> 为何要用分布式锁</h1><h2 id="一-为什么要使用分布式锁"><a class="markdownIt-Anchor" href="#一-为什么要使用分布式锁"></a> <strong>一、为什么要使用分布式锁</strong></h2><p>为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，在传统单体应用单机部署的情况下，可以使用Java并发处理相关的API(如ReentrantLcok或synchronized)进行互斥控制。但是，随着业务发展的需要，原单体单机部署的系统被演化成分布式系统后，由于分布式系统多线程、多进程并且分布在不同机器上，这将使原单机部署情况下的并发控制锁策略失效，为了解决这个问题就需要一种跨JVM的互斥机制来控制共享资源的访问，这就是分布式锁要解决的问题</p><h2 id="二-分布式锁应该具备哪些条件"><a class="markdownIt-Anchor" href="#二-分布式锁应该具备哪些条件"></a> <strong>二、分布式锁应该具备哪些条件</strong></h2><p>在分析分布式锁的三种实现方式之前，先了解一下分布式锁应该具备哪些条件：<br>1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行；</p><p>2、高可用的获取锁与释放锁；</p><p>3、高性能的获取锁与释放锁；</p><p>4、具备可重入特性；</p><p>5、具备锁失效机制，防止死锁；</p><p>6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。</p><p><img src="../../images/image-20230604103343211.png" alt="image-20230604103343211"></p><p><img src="../../images/image-20230604103310644.png" alt="image-20230604103310644"></p><h1 id="数据库实现分布式锁原理"><a class="markdownIt-Anchor" href="#数据库实现分布式锁原理"></a> 数据库实现分布式锁原理：</h1><p><img src="../../images/image-20230604102928951.png" alt="image-20230604102928951"></p><h1 id="redis实现分布式锁原理"><a class="markdownIt-Anchor" href="#redis实现分布式锁原理"></a> Redis实现分布式锁原理：</h1><p><img src="../../images/image-20230604103157783.png" alt="image-20230604103157783"></p><p><img src="../../images/image-20230604103116683.png" alt="image-20230604103116683"></p><h1 id="问题注意"><a class="markdownIt-Anchor" href="#问题注意"></a> 问题注意：</h1><ul><li>业务失败锁还在，就会产生死锁，可以加一个过期时间自动释放锁，但是自动释放可能出现释放掉其他jvm锁的情况，所以要给锁加一个唯一标识，删除前先看看是不是本机持有的锁，是的话再删除，还要保证查询和删除是一个原子操作，可以使用lua脚本<img src="https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png@48w_48h.webp" alt="[脱单doge]"></li><li>产生死锁现象，导致虚拟机实例无法再次获取资源，可以设置失效时间，缺陷：因为不确定业务执行时间的长短，所以失效时间的设置具有不确定性。优化：使用try catch finally 语句块，在finally语句中调用del方法删除key完成释放锁的目的，这样下次虚拟机实例请求资源时便能通过setNx（）方法获取到锁，执行响应业务逻辑！<img src="https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png@48w_48h.webp" alt="[脱单doge]"></li></ul><p>看门狗：</p><h3 id="对于redis集群而言可能存在的问题"><a class="markdownIt-Anchor" href="#对于redis集群而言可能存在的问题"></a> 对于Redis集群而言可能存在的问题：</h3><ul><li><strong>问题</strong>：主从切换的时候，主从同步延迟，可能锁信息没有同步到新主</li><li><strong>解决：</strong><ul><li>利用多个redis实例来存储共享，加锁时给每个redis都加锁<ul><li>第一步：获取当前系统时间 （主要为了计算客户端对多个实例加锁所耗费的一个总时间）</li><li>第二步：依次对多个实例进行加锁，加锁完成后，计算客户端对多个实例加锁所耗费的一个总时耗时</li><li>如果加锁的总耗时比锁设置的有效时间短，说明加锁成功</li></ul></li></ul></li></ul><h1 id="redis分布式锁的正确实现方式"><a class="markdownIt-Anchor" href="#redis分布式锁的正确实现方式"></a> Redis分布式锁的正确实现方式</h1><h2 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h2><p>分布式锁一般有三种实现方式：</p><ol><li>数据库乐观锁；</li><li>基于Redis的分布式锁；</li><li>基于ZooKeeper的分布式锁。本篇博客将介绍第二种方式，基于Redis实现分布式锁。虽然网上已经有各种介绍Redis分布式锁实现的博客，然而他们的实现却有着各种各样的问题，为了避免误人子弟，本篇博客将详细介绍如何正确地实现Redis分布式锁。</li></ol><hr><h2 id="可靠性"><a class="markdownIt-Anchor" href="#可靠性"></a> 可靠性</h2><p>首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p><ol><li>互斥性。在任意时刻，只有一个客户端能持有锁。</li><li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li><li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li><li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li></ol><hr><h2 id="代码实现"><a class="markdownIt-Anchor" href="#代码实现"></a> 代码实现</h2><h3 id="组件依赖"><a class="markdownIt-Anchor" href="#组件依赖"></a> 组件依赖</h3><p>首先我们要通过Maven引入<code>Jedis</code>开源组件，在<code>pom.xml</code>文件加入下面的代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;redis.clients&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jedis&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="加锁代码"><a class="markdownIt-Anchor" href="#加锁代码"></a> 加锁代码</h2><h3 id="正确姿势"><a class="markdownIt-Anchor" href="#正确姿势"></a> 正确姿势</h3><p>Talk is cheap, show me the code。先展示代码，再带大家慢慢解释为什么这样实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class RedisTool {</span><br><span class="line"></span><br><span class="line">    private static final String LOCK_SUCCESS = "OK";</span><br><span class="line">    private static final String SET_IF_NOT_EXIST = "NX";</span><br><span class="line">    private static final String SET_WITH_EXPIRE_TIME = "PX";</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 尝试获取分布式锁</span><br><span class="line">     * @param jedis Redis客户端</span><br><span class="line">     * @param lockKey 锁</span><br><span class="line">     * @param requestId 请求标识</span><br><span class="line">     * @param expireTime 超期时间</span><br><span class="line">     * @return 是否获取成功</span><br><span class="line">     */</span><br><span class="line">    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {</span><br><span class="line"></span><br><span class="line">        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);</span><br><span class="line"></span><br><span class="line">        if (LOCK_SUCCESS.equals(result)) {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们加锁就一行代码：<code>jedis.set(String key, String value, String nxxx, String expx, int time)</code>，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用<code>UUID.randomUUID().toString()</code>方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li></ul><p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p><p>心细的童鞋就会发现了，我们的加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p><h3 id="错误示例1"><a class="markdownIt-Anchor" href="#错误示例1"></a> 错误示例1</h3><p>比较常见的错误示例就是使用<code>jedis.setnx()</code>和<code>jedis.expire()</code>组合实现加锁，代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongGetLock1(Jedis jedis, String lockKey, String requestId, int expireTime) {</span><br><span class="line"></span><br><span class="line">    Long result = jedis.setnx(lockKey, requestId);</span><br><span class="line">    if (result == 1) {</span><br><span class="line">        // 若在这里程序突然崩溃，则无法设置过期时间，将发生死锁</span><br><span class="line">        jedis.expire(lockKey, expireTime);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p><h3 id="错误示例2"><a class="markdownIt-Anchor" href="#错误示例2"></a> 错误示例2</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static boolean wrongGetLock2(Jedis jedis, String lockKey, int expireTime) {</span><br><span class="line"></span><br><span class="line">    long expires = System.currentTimeMillis() + expireTime;</span><br><span class="line">    String expiresStr = String.valueOf(expires);</span><br><span class="line"></span><br><span class="line">    // 如果当前锁不存在，返回加锁成功</span><br><span class="line">    if (jedis.setnx(lockKey, expiresStr) == 1) {</span><br><span class="line">        return true;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 如果锁存在，获取锁的过期时间</span><br><span class="line">    String currentValueStr = jedis.get(lockKey);</span><br><span class="line">    if (currentValueStr != null &amp;&amp; Long.parseLong(currentValueStr) &lt; System.currentTimeMillis()) {</span><br><span class="line">        // 锁已过期，获取上一个锁的过期时间，并设置现在锁的过期时间</span><br><span class="line">        String oldValueStr = jedis.getSet(lockKey, expiresStr);</span><br><span class="line">        if (oldValueStr != null &amp;&amp; oldValueStr.equals(currentValueStr)) {</span><br><span class="line">            // 考虑多线程并发的情况，只有一个线程的设置值和当前值相同，它才有权利加锁</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">        </span><br><span class="line">    // 其他情况，一律返回加锁失败</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这一种错误示例就比较难以发现问题，而且实现也比较复杂。实现思路：使用<code>jedis.setnx()</code>命令实现加锁，其中key是锁，value是锁的过期时间。执行过程：1. 通过setnx()方法尝试加锁，如果当前锁不存在，返回加锁成功。2. 如果锁已经存在则获取锁的过期时间，和当前时间比较，如果锁已经过期，则设置新的过期时间，返回加锁成功。代码如下：</p><p>那么这段代码问题在哪里？1. 由于是客户端自己生成过期时间，所以需要强制要求分布式下每个客户端的时间必须同步。 2. 当锁过期的时候，如果多个客户端同时执行<code>jedis.getSet()</code>方法，那么虽然最终只有一个客户端可以加锁，但是这个客户端的锁的过期时间可能被其他客户端覆盖。3. 锁不具备拥有者标识，即任何客户端都可以解锁。</p><h2 id="解锁代码"><a class="markdownIt-Anchor" href="#解锁代码"></a> 解锁代码</h2><h3 id="正确姿势-2"><a class="markdownIt-Anchor" href="#正确姿势-2"></a> 正确姿势</h3><p>还是先展示代码，再带大家慢慢解释为什么这样实现：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class RedisTool {</span><br><span class="line"></span><br><span class="line">    private static final Long RELEASE_SUCCESS = 1L;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 释放分布式锁</span><br><span class="line">     * @param jedis Redis客户端</span><br><span class="line">     * @param lockKey 锁</span><br><span class="line">     * @param requestId 请求标识</span><br><span class="line">     * @return 是否释放成功</span><br><span class="line">     */</span><br><span class="line">    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {</span><br><span class="line"></span><br><span class="line">        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";</span><br><span class="line">        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));</span><br><span class="line"></span><br><span class="line">        if (RELEASE_SUCCESS.equals(result)) {</span><br><span class="line">            return true;</span><br><span class="line">        }</span><br><span class="line">        return false;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，上一次见到这个编程语言还是在《黑客与画家》里，没想到这次居然用上了。第二行代码，我们将Lua代码传到<code>jedis.eval()</code>方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。eval()方法是将Lua代码交给Redis服务端执行。</p><p>那么这段Lua代码的功能是什么呢？其实很简单，首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）。那么为什么要使用Lua语言来实现呢？因为要确保上述操作是原子性的。关于非原子性会带来什么问题，可以阅读<a href="http://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#releaseLock-wrongDemo2">【解锁代码-错误示例2】</a> 。那么为什么执行eval()方法可以确保原子性，源于Redis的特性，下面是官网对eval命令的部分解释：</p><p><img src="http://o7x0ygc3f.bkt.clouddn.com/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F_01.png" alt="img"></p><p>简单来说，就是在eval命令执行Lua代码的时候，Lua代码将被当成一个命令去执行，并且直到eval命令执行完成，Redis才会执行其他命令。</p><h3 id="错误示例1-2"><a class="markdownIt-Anchor" href="#错误示例1-2"></a> 错误示例1</h3><p>最常见的解锁代码就是直接使用<code>jedis.del()</code>方法删除锁，这种不先判断锁的拥有者而直接解锁的方式，会导致任何客户端都可以随时进行解锁，即使这把锁不是它的。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongReleaseLock1(Jedis jedis, String lockKey) {</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="错误示例2-2"><a class="markdownIt-Anchor" href="#错误示例2-2"></a> 错误示例2</h3><p>这种解锁代码乍一看也是没问题，甚至我之前也差点这样实现，与正确姿势差不多，唯一区别的是分成两条命令去执行，代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void wrongReleaseLock2(Jedis jedis, String lockKey, String requestId) {</span><br><span class="line">        </span><br><span class="line">    // 判断加锁与解锁是不是同一个客户端</span><br><span class="line">    if (requestId.equals(jedis.get(lockKey))) {</span><br><span class="line">        // 若在此时，这把锁突然不是这个客户端的，则会误解锁</span><br><span class="line">        jedis.del(lockKey);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如代码注释，问题在于如果调用<code>jedis.del()</code>方法的时候，这把锁已经不属于当前客户端的时候会解除他人加的锁。那么是否真的有这种场景？答案是肯定的，比如客户端A加锁，一段时间之后客户端A解锁，在执行<code>jedis.del()</code>之前，锁突然过期了，此时客户端B尝试加锁成功，然后客户端A再执行del()方法，则将客户端B的锁给解除了。</p><hr><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>本文主要介绍了如何使用Java代码正确实现Redis分布式锁，对于加锁和解锁也分别给出了两个比较经典的错误示例。其实想要通过Redis实现分布式锁并不难，只要保证能满足可靠性里的四个条件。互联网虽然给我们带来了方便，只要有问题就可以google，然而网上的答案一定是对的吗？其实不然，所以我们更应该时刻保持着质疑精神，多想多验证。</p><p>如果你的项目中Redis是多机部署的，那么可以尝试使用<code>Redisson</code>实现分布式锁，这是Redis官方提供的Java组件，链接在<a href="http://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/#%E5%8F%82%E8%80%83%E9%98%85%E8%AF%BB">参考阅读</a>章节已经给出。</p><p>其它博文参考：<a href="https://zhuanlan.zhihu.com/p/165118929">深入解析 Redis 分布式锁原理 - 知乎 (zhihu.com)</a></p><h1 id="看门狗给锁续时"><a class="markdownIt-Anchor" href="#看门狗给锁续时"></a> 看门狗，给锁续时</h1><p><a href="https://www.bilibili.com/video/BV1gD4y1u7eC/?spm_id_from=333.788.recommend_more_video.11&amp;vd_source=746b9336d739b80b11820809545b6604">【Java进阶】五分钟梳理看门狗的实现原理，手写Redis锁续期功能，打造核心竞争力_哔哩哔哩_bilibili</a></p><ul><li>方案：可基于<strong>HashedWheelTimer</strong>，加上自旋的方式来实现</li><li><strong>HashedWheelTimer</strong>：时间轮，异步的延时执行任务的工具类</li></ul>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/"/>
      <url>/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/</url>
      
        <content type="html"><![CDATA[<p><img src="../../../images/image-20230520161301132.png" alt="image-20230520161301132"></p><h1 id="网络通信层"><a class="markdownIt-Anchor" href="#网络通信层"></a> 网络通信层</h1><p><strong>Bootstrap</strong></p><p>负责客户端启动并用来连接远程Netty Server</p><p>但这里不用Bootstrap，因为 IM实战的通讯方式是通过WebSocket前端网页来链接连接我们的netty的server端的</p><p><img src="../../../images/image-20230520162251684.png" alt="image-20230520162251684"></p><p><img src="../../../images/image-20230520162457445.png" alt="image-20230520162457445"></p><p><img src="../../../images/image-20230520162426147.png" alt="image-20230520162426147"></p><p>上图的远离机制：</p><p>Client这三个客户端，会发送消息到BossGroup；BossGroup是一个线程池，中有一个Selector主要作用是会生成 SocketChannel；SocketChannel会封装成NIOSocketChannel；NIOSocketChannel会注册到工作线程中的Selector；若要读数据或写数据，那么工作线程中selector就会分发到不同对应的Handler中进行处理</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器从输入网址到页面展示的过程</title>
      <link href="/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
      <url>/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器从输入网址到页面展示的过程"><a class="markdownIt-Anchor" href="#浏览器从输入网址到页面展示的过程"></a> 浏览器从输入网址到页面展示的过程</h1><p>完整高频题库仓库地址：<a href="https://github.com/hzfe/awesome-interview"><strong>https://github.com/hzfe/awesome-interview</strong></a></p><p>完整高频题库阅读地址：<a href="https://febook.hzfe.org/"><strong>https://febook.hzfe.org/</strong></a></p><h2 id="回答关键点"><a class="markdownIt-Anchor" href="#回答关键点"></a> <strong>回答关键点</strong></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL` `DNS` `TCP` `渲染</span><br></pre></td></tr></tbody></table></figure><p>浏览器从输入网址到渲染页面主要分为以下几个过程</p><ul><li>URL 输入</li><li>DNS 解析</li><li>建立 TCP 连接</li><li>发送 HTTP / HTTPS 请求（建立 TLS 连接）</li><li>服务器响应请求</li><li>浏览器解析渲染页面</li><li>HTTP 请求结束，断开 TCP 连接</li></ul><h2 id="知识点深入"><a class="markdownIt-Anchor" href="#知识点深入"></a> <strong>知识点深入</strong></h2><h3 id="1-url-输入"><a class="markdownIt-Anchor" href="#1-url-输入"></a> <strong>1. URL 输入</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/2911d132881a03e20edc7c8942e65fed.png?" alt="img"></p><p>URL地址</p><p>URL（统一资源定位符，Uniform Resource Locator）用于定位互联网上资源，俗称网址。</p><p>我们在地址栏输入 HZFE 官方网址 <a href="http://hzfe.org">hzfe.org</a> 后敲下回车，浏览器会对输入的信息进行以下判断：</p><ol><li>检查输入的内容是否是一个合法的 URL 链接。</li><li>是，则判断输入的 URL 是否完整。如果不完整，浏览器可能会对域进行猜测，补全前缀或者后缀。</li><li>否，将输入内容作为搜索条件，使用用户设置的默认搜索引擎来进行搜索。</li></ol><p>大部分浏览器会从历史记录、书签等地方开始查找我们输入的网址，并给出智能提示。</p><h3 id="2-dnsdomain-name-system解析"><a class="markdownIt-Anchor" href="#2-dnsdomain-name-system解析"></a> <strong>2. DNS（Domain Name System）解析</strong></h3><p>因为浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需要进行 DNS 解析，查找到对应的 IP 地址进行访问。</p><p>DNS 解析流程如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/eb1b6b726e6cbe7c04beb6b7885202e4.png?" alt="img"></p><p>DNS 解析</p><ol><li>在浏览器中输入 <a href="http://hzfe.org">hzfe.org</a> 域名，操作系统检查浏览器缓存和本地的 hosts 文件中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li><li>查找本地 DNS 解析器缓存中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li><li>使用 TCP/IP 参数中设置的 DNS 服务器进行查询。如果要查询的域名包含在本地配置区域资源中，则返回解析结果，完成域名解析。</li><li>检查本地 DNS 服务器是否缓存该网址记录，有则返回解析结果，完成域名解析。</li><li>本地 DNS 服务器发送查询报文至根 DNS 服务器，根 DNS 服务器收到请求后，用顶级域 DNS 服务器地址进行响应。</li><li>本地 DNS 服务器发送查询报文至顶级域 DNS 服务器。顶级域 DNS 服务器收到请求后，用权威 DNS 服务器地址进行响应。</li><li>本地 DNS 服务器发送查询报文至权威 DNS 服务器，权威 DNS 服务器收到请求后，用 <a href="http://hzfe.org">hzfe.org</a> 的 IP 地址进行响应，完成域名解析。</li></ol><p>查询通常遵循以上流程，从请求主机到本地 DNS 服务器的查询是递归查询，DNS 服务器获取到所需映射的查询过程是迭代查询。</p><h3 id="3-建立-tcp-连接"><a class="markdownIt-Anchor" href="#3-建立-tcp-连接"></a> <strong>3. 建立 TCP 连接</strong></h3><blockquote><p>世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层。 HTTP 的连接实际上就是 TCP 连接以及其使用规则。 –《HTTP 权威指南》</p></blockquote><p>当浏览器获取到服务器的 IP 地址后，浏览器会用一个随机的端口（1024 &lt; 端口 &lt; 65535）向服务器 80 端口发起 TCP 连接请求（注：HTTP 默认约定 80 端口，HTTPS 为 443 端口）。这个连接请求到达服务端后，通过 TCP 三次握手，建立 TCP 的连接。</p><h4 id="31-分层模型"><a class="markdownIt-Anchor" href="#31-分层模型"></a> <strong>3.1 分层模型</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ----------------------------------</span><br><span class="line"><span class="number">7</span>|   应用层   |           |   <span class="variable constant_">HTTP</span>  |</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>|   表示层   |   应用层   |</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>|   会话层   |           |         |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">4</span>|   传输层   |   传输层   | <span class="variable constant_">TCP</span> <span class="variable constant_">TLS</span> |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">3</span>|   网络层   |   网络层   |   <span class="variable constant_">IP</span>    |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">2</span>|  数据链路层</span><br><span class="line">             |   链路层</span><br><span class="line"><span class="number">1</span>|   物理层</span><br><span class="line">  --------------------------------</span><br><span class="line">     [<span class="variable constant_">OSI</span>]   |   [<span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span>]</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h4 id="32-tcp-三次握手"><a class="markdownIt-Anchor" href="#32-tcp-三次握手"></a> <strong>3.2 TCP 三次握手</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable constant_">SYN</span> 是建立连接时的握手信号，<span class="variable constant_">TCP</span> 中发送第一个 <span class="variable constant_">SYN</span> 包的为客户端，接收的为服务端</span><br><span class="line"># <span class="variable constant_">TCP</span> 中，当发送端数据到达接收端时，接收端返回一个已收到消息的通知。这个消息叫做确认应答 <span class="variable constant_">ACK</span></span><br><span class="line"></span><br><span class="line">  假设有客户端A，服务端B。我们要建立可靠的数据传输。</span><br><span class="line">      <span class="title function_">SYN</span>(=j)       <span class="comment">// SYN: A 请求建立连接</span></span><br><span class="line">  A ----------&gt; B</span><br><span class="line">                |</span><br><span class="line">     <span class="title function_">ACK</span>(=j+<span class="number">1</span>)  |   <span class="comment">// ACK: B 确认应答 A 的 SYN</span></span><br><span class="line">     <span class="title function_">SYN</span>(=k)    |   <span class="comment">// SYN: B 发送一个 SYN</span></span><br><span class="line">  A &lt;-----------</span><br><span class="line">  |</span><br><span class="line">  |  <span class="title function_">ACK</span>(=k+<span class="number">1</span>)</span><br><span class="line">   -----------&gt; B   <span class="comment">// ACK: A 确认应答 B 的包</span></span><br></pre></td></tr></tbody></table></figure><p>复制</p><ol><li>客户端发送 SYN 包（seq = j）到服务器，并进入 SYN_SEND 状态，等待服务器确认。</li><li>服务器收到 SYN 包，必须确认客户的 SYN（ACK = k + 1），同时自己也发送一个 SYN 包（seq = k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ACK = k + 1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</li></ol><h3 id="4-tls-协商"><a class="markdownIt-Anchor" href="#4-tls-协商"></a> <strong>4. TLS 协商</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/cdb05918db5147cc4f92f12cad6f5d15.png?imageView2/2/w/2560/h/7000" alt="img"></p><p>TLS协商</p><p>建立连接后就可以通过 HTTP 进行数据传输。如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。</p><ul><li>SSL<ul><li>认证用户和服务器，确保数据发送到正确的客户端和服务器。</li><li>加密数据防止数据中途被窃取。</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul></li><li>TLS<ul><li>用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li></ul></li></ul><h4 id="41-tls-握手协议"><a class="markdownIt-Anchor" href="#41-tls-握手协议"></a> <strong>4.1 TLS 握手协议</strong></h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/3ac0cf1dcd3100b2b96c55bf4e827adf.png?imageView2/2/w/2560/h/7000" alt="img"></p><p>TLS握手协议</p><ol><li>客户端发出一个 client hello 消息，携带的信息包括：所支持的 SSL/TLS 版本列表；支持的与加密算法；所支持的数据压缩方法；随机数 A。</li><li>服务端响应一个 server hello 消息，携带的信息包括：协商采用的 SSL/TLS 版本号；会话 ID；随机数 B；服务端数字证书 serverCA；由于双向认证需求，服务端需要对客户端进行认证，会同时发送一个 client certificate request，表示请求客户端的证书。</li><li>客户端校验服务端的数字证书；校验通过之后发送随机数 C，该随机数称为 pre-master-key，使用数字证书中的公钥加密后发出；由于服务端发起了 client certificate request，客户端使用私钥加密一个随机数 clientRandom 随客户端的证书 clientCA 一并发出。</li><li>服务端校验客户端的证书，并成功将客户端加密的随机数 clientRandom 解密；根据随机数 A/随机数 B/随机数 C（pre-master-key） 产生动态密钥 master-key，加密一个 finish 消息发至客户端。</li><li>客户端根据同样的随机数和算法生成 master-key，加密一个 finish 消息发送至服务端。</li><li>服务端和客户端分别解密成功，至此握手完成，之后的数据包均采用 master-key 进行加密传输。</li></ol><h3 id="5-服务器响应"><a class="markdownIt-Anchor" href="#5-服务器响应"></a> <strong>5. 服务器响应</strong></h3><p>当浏览器到 web 服务器的连接建立后，浏览器会发送一个初始的 HTTP GET 请求，请求目标通常是一个 HTML 文件。服务器收到请求后，将<strong>发回一个 HTTP 响应报文</strong>，内容包括相关响应头和 HTML 正文。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的博客<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"heading"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://hzfe.org/"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h4 id="51-状态码"><a class="markdownIt-Anchor" href="#51-状态码"></a> <strong>5.1 状态码</strong></h4><p>状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五类可能取值</p><ul><li>1xx：指示信息——表示请求已接收，继续处理</li><li>2xx：成功——表示请求已被成功接收、理解、接受</li><li>3xx：重定向——要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误——请求有语法错误或请求无法实现</li><li>5xx：服务器端错误——服务器未能实现合法的请求</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应状态码 - HTTP | MDN (mozilla.org)</a></p><h4 id="52-常见的请求头和字段"><a class="markdownIt-Anchor" href="#52-常见的请求头和字段"></a> <strong>5.2 常见的请求头和字段</strong></h4><ul><li>Cache-Control：must-revalidate、no-cache、private（是否需要缓存资源）</li><li>Connection：keep-alive（保持连接）</li><li>Content-Encoding：gzip（web 服务器支持的返回内容压缩编码类型）</li><li>Content-Type：text/html；charset=UTF-8（文件类型和字符编码格式）</li><li>Date：Sun， 21 Sep 2021 06:18:21 GMT（服务器消息发出的时间）</li><li>Transfer-Encoding：chunked（服务器发送的资源的方式是分块发送）</li></ul><h4 id="53-http-响应报文"><a class="markdownIt-Anchor" href="#53-http-响应报文"></a> <strong>5.3 HTTP 响应报文</strong></h4><p>响应报文由四部分组成（响应行 + 响应头 + 空行 + 响应体）</p><ul><li>状态行：HTTP 版本 + 空格 + 状态码 + 空格 + 状态码描述 + 回车符（CR） + 换行符（LF）</li><li>响应头：字段名 + 冒号 + 值 + 回车符 + 换行符</li><li>空行：回车符 + 换行符</li><li>响应体：由用户自定义添加，如 post 的 body 等</li></ul><h3 id="6-浏览器解析并绘制"><a class="markdownIt-Anchor" href="#6-浏览器解析并绘制"></a> <strong>6. 浏览器解析并绘制</strong></h3><p>不同的浏览器引擎渲染过程都不太一样，这里以 Chrome 浏览器渲染方式为例。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/601ac9a205ada2bd56a06ed97996b301.png?imageView2/2/w/2560/h/7000" alt="img"></p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h3 id="7-tcp-断开连接"><a class="markdownIt-Anchor" href="#7-tcp-断开连接"></a> <strong>7. TCP 断开连接</strong></h3><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是<strong>四次挥手</strong>。关闭是一个全双工的过程，发包的顺序是不一定的。一般来说是客户端主动发起的关闭，过程如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/cd2cb58d98ca10faed28f809eab5b461.png?imageView2/2/w/2560/h/7000" alt="img"></p><ol><li>主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 确认报文，主动关闭方依然会重发这些数据），但此时主动关闭方还可以接受数据。</li><li>被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。</li><li>被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础（上）</title>
      <link href="/2023/04/27/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A/"/>
      <url>/2023/04/27/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络基础"><a class="markdownIt-Anchor" href="#计算机网络基础"></a> 计算机网络基础</h2><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> 网络分层模型</h3><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> OSI 七层模型是什么？每一层的作用是什么？</h4><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p><p><img src="../../../images/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="osi七层模型2"></p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> TCP/IP 四层模型是什么？每一层的作用是什么？</h4><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p><p>关于每一层作用的详细介绍，请看 <a href="https://javaguide.cn/cs-basics/network/osi&amp;tcp-ip-model.html">OSI 和 TCP/IP 网络分层模型详解（基础）open in new window</a> 这篇文章。</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82">#</a> 为什么网络要分层？</h4><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">#</a> 常见网络协议</h3><h4 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 应用层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层常见协议"></p><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong> ：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong> ：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP（邮件接收协议）</strong> ：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>Telnet（远程登陆协议）</strong> ：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong> ：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ul><p>关于这些协议的详细介绍请看 <a href="">应用层常见协议总结（应用层）</a> 这篇文章。</p><h4 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 传输层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层常见协议"></p><ul><li><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li><li><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li></ul><h4 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 网络层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" alt="网络层常见协议"></p><ul><li><strong>IP（Internet Protocol，网际协议）</strong> ： TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong> ：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong> ：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong> ：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP(Routing Information Protocol，路由信息协议）</strong> ：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong> ：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h2 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#http">#</a> HTTP</h2><h3 id="-10"><a class="markdownIt-Anchor" href="#-10"></a> <a href="#%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88-%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81">#</a> 从输入 URL 到页面展示到底发生了什么？（非常重要）</h3><blockquote><p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>图解（图片来源：《图解 HTTP》）：</p><p><img src="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 <strong>OSPF（Open Shortest Path First，ospf）开放最短路径优先协议</strong>, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">从输入 URL 到页面加载发生了什么？open in new window</a></li><li><a href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li></ul><h3 id="-11"><a class="markdownIt-Anchor" href="#-11"></a> <a href="#http-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> HTTP 状态码有哪些？</h3><p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码"></p><p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="">HTTP 常见状态码总结（应用层）</a>。</p><h3 id="-12"><a class="markdownIt-Anchor" href="#-12"></a> <a href="#http-header-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> HTTP Header 中常见的字段有哪些？</h3><table><thead><tr><th style="text-align:left">请求头字段名</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">能够接受的回应内容类型（Content-Types）。</td><td style="text-align:left">Accept: text/plain</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">能够接受的字符集</td><td style="text-align:left">Accept-Charset: utf-8</td></tr><tr><td style="text-align:left">Accept-Datetime</td><td style="text-align:left">能够接受的按照时间来表示的版本</td><td style="text-align:left">Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">能够接受的编码方式列表。参考 HTTP 压缩。</td><td style="text-align:left">Accept-Encoding: gzip, deflate</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">能够接受的回应内容的自然语言列表。</td><td style="text-align:left">Accept-Language: en-US</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">用于超文本传输协议的认证的认证信息</td><td style="text-align:left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td><td style="text-align:left">Cache-Control: no-cache</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">该浏览器想要优先使用的连接类型</td><td style="text-align:left">Connection: keep-alive Connection: Upgrade</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">以 八位字节数组 （8 位的字节）表示的请求体的长度</td><td style="text-align:left">Content-Length: 348</td></tr><tr><td style="text-align:left">Content-MD5</td><td style="text-align:left">请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td><td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</td><td style="text-align:left">Content-Type: application/x-www-form-urlencoded</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td><td style="text-align:left">Cookie: $Version=1; Skin=new;</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">发送该消息的日期和时间(按照 RFC 7231 中定义的"超文本传输协议日期"格式来发送)</td><td style="text-align:left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td style="text-align:left">Expect</td><td style="text-align:left">表明客户端要求服务器做出特定的行为</td><td style="text-align:left">Expect: 100-continue</td></tr><tr><td style="text-align:left">From</td><td style="text-align:left">发起此请求的用户的邮件地址</td><td style="text-align:left">From: <a href="mailto:user@example.com">user@example.com</a></td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。</td><td style="text-align:left">Host: <a href="http://en.wikipedia.org:80">en.wikipedia.org:80</a></td></tr><tr><td style="text-align:left">If-Match</td><td style="text-align:left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td><td style="text-align:left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Modified-Since</td><td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td style="text-align:left">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td style="text-align:left">If-None-Match</td><td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td style="text-align:left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Range</td><td style="text-align:left">如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td style="text-align:left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Unmodified-Since</td><td style="text-align:left">仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td><td style="text-align:left">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td style="text-align:left">Max-Forwards</td><td style="text-align:left">限制该消息可被代理及网关转发的次数。</td><td style="text-align:left">Max-Forwards: 10</td></tr><tr><td style="text-align:left">Origin</td><td style="text-align:left">发起一个针对 跨来源资源共享 的请求。</td><td style="text-align:left">Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.comopen in new window</a></td></tr><tr><td style="text-align:left">Pragma</td><td style="text-align:left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。</td><td style="text-align:left">Pragma: no-cache</td></tr><tr><td style="text-align:left">Proxy-Authorization</td><td style="text-align:left">用来向代理进行认证的认证信息。</td><td style="text-align:left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:left">Range</td><td style="text-align:left">仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。</td><td style="text-align:left">Range: bytes=500-999</td></tr><tr><td style="text-align:left">Referer</td><td style="text-align:left">表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td><td style="text-align:left">Referer: <a href="https://en.wikipedia.org/wiki/Main_Page">http://en.wikipedia.org/wiki/Main_Pageopen in new window</a></td></tr><tr><td style="text-align:left">TE</td><td style="text-align:left">浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；</td><td style="text-align:left">TE: trailers, deflate</td></tr><tr><td style="text-align:left">Upgrade</td><td style="text-align:left">要求服务器升级到另一个协议。</td><td style="text-align:left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">浏览器的浏览器身份标识字符串</td><td style="text-align:left">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td></tr><tr><td style="text-align:left">Via</td><td style="text-align:left">向服务器告知，这个请求是由哪些代理发出的。</td><td style="text-align:left">Via: 1.0 fred, 1.1 <a href="http://example.com">example.com</a> (Apache/1.1)</td></tr><tr><td style="text-align:left">Warning</td><td style="text-align:left">一个一般性的警告，告知，在实体内容体中可能存在错误。</td><td style="text-align:left">Warning: 199 Miscellaneous warning</td></tr></tbody></table><h3 id="-13"><a class="markdownIt-Anchor" href="#-13"></a> <a href="#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">#</a> HTTP 和 HTTPS 有什么区别？（重要）</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-vs-https.png" alt="HTTP 和 HTTPS 对比"></p><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，<strong>加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><strong>SEO（搜索引擎优化）</strong> ：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ul><p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP vs HTTPS（应用层）</a> 。</p><h3 id="-14"><a class="markdownIt-Anchor" href="#-14"></a> <a href="#http-1-0-%E5%92%8C-http-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/1.0 和 HTTP/1.1 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p><ul><li><strong>连接方式</strong> : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽</strong> ：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</li></ul><p>关于 HTTP/1.0 和 HTTP/1.1 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP/1.0 vs HTTP/1.1（应用层）</a> 。</p><h3 id="-15"><a class="markdownIt-Anchor" href="#-15"></a> <a href="#http-1-1-%E5%92%8C-http-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/1.1 和 HTTP/2.0 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p><ul><li><strong>IO 多路复用（Multiplexing）</strong> ：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</li><li><strong>二进制帧（Binary Frames）</strong> ：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</li><li><strong>头部压缩（Header Compression）</strong> ：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，减少了网络开销。</li><li><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</li></ul><h3 id="-16"><a class="markdownIt-Anchor" href="#-16"></a> <a href="#http-2-0-%E5%92%8C-http-3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/2.0 和 HTTP/3.0 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png" alt="HTTP/2.0 和 HTTP/3.0 对比"></p><ul><li><strong>传输协议</strong> ：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了<mark> <strong>QUIC</strong>（Quick UDP Internet Connections）</mark> 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</li><li><strong>连接建立</strong> ：HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</li><li><strong>队头阻塞</strong> ：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其它数据流不受影响（本质上是多路复用+轮询）。</li><li><strong>错误恢复</strong> ：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</li><li><strong>安全性</strong> ：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li></ul><h3 id="-17"><a class="markdownIt-Anchor" href="#-17"></a> <a href="#http-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81">#</a> HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h3 id="-18"><a class="markdownIt-Anchor" href="#-18"></a> <a href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> URI 和 URL 的区别是什么?</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h3 id="-19"><a class="markdownIt-Anchor" href="#-19"></a> <a href="#cookie-%E5%92%8C-session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> Cookie 和 Session 有什么区别？</h3><p>准确点来说，这个问题属于认证授权的范畴，你可以在 <a href="https://javaguide.cn/system-design/security/basis-of-authority-certification.html">认证授权基础概念详解open in new window</a> 这篇文章中找到详细的答案。</p><h2 id="-20"><a class="markdownIt-Anchor" href="#-20"></a> <a href="#ping">#</a> PING</h2><h3 id="-21"><a class="markdownIt-Anchor" href="#-21"></a> <a href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> PING 命令的作用是什么？</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p><p>这里简单举一个例子，我们来 PING 一下百度。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送4个PING请求数据包到 www.baidu.com</span></span><br><span class="line">❯ ping -c 4 www.baidu.com</span><br><span class="line"></span><br><span class="line">PING www.a.shifen.com (14.119.104.189): 56 data bytes</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms</span><br></pre></td></tr></tbody></table></figure><p>PING 命令的输出结果通常包括以下几部分信息：</p><ol><li><strong>ICMP Echo Request（请求报文）信息</strong> ：序列号、TTL（Time to Live）值。</li><li><strong>目标主机的域名或 IP 地址</strong> ：输出结果的第一行。</li><li><strong>往返时间（RTT，Round-Trip Time）</strong> ：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li><li><strong>统计结果（Statistics）</strong> ：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li></ol><p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。</p><h3 id="-22"><a class="markdownIt-Anchor" href="#-22"></a> <a href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a> PING 命令的工作原理是什么？</h3><p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p><p>ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p><ul><li><strong>查询报文类型</strong> ：向目标主机发送请求并期望得到响应。</li><li><strong>差错报文类型</strong> ：向源主机发送错误信息，用于报告网络中的错误情况。</li></ul><p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p><ul><li>PING 命令会向目标主机发送 ICMP Echo Request。</li><li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li></ul><h2 id="-23"><a class="markdownIt-Anchor" href="#-23"></a> <a href="#dns">#</a> DNS</h2><h3 id="-24"><a class="markdownIt-Anchor" href="#-24"></a> <a href="#dns-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> DNS 的作用是什么？</h3><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png" alt="DNS:域名系统"></p><p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地<code>hosts</code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。</p><p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p><h3 id="-25"><a class="markdownIt-Anchor" href="#-25"></a> <a href="#dns-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> DNS 服务器有哪些？</h3><p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p><ul><li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构</li></ul><h3 id="-26"><a class="markdownIt-Anchor" href="#-26"></a> <a href="#dns-%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> DNS 解析的过程是什么样的？</h3><p>整个过程的步骤比较多，我单独写了一篇文章详细介绍：<a href="">DNS 域名系统详解（应用层）</a> 。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统问题</title>
      <link href="/2023/04/05/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/04/05/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://cloud.tencent.com/developer/article/1815965">这 50 道操作系统面试题，真牛批！ - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p><h2 id="1-进程和线程的区别"><a class="markdownIt-Anchor" href="#1-进程和线程的区别"></a> 1. 进程和线程的区别？</h2><ul><li>调度：进程是资源管理的基本单位，线程是程序执行的基本单位。</li><li>切换：线程上下文切换比进程上下文切换要快得多。</li><li>拥有资源： 进程是拥有资源的一个独立单位，线程不拥有系统资源，但是可以访问隶属于进程的资源。</li><li>系统开销： 创建或撤销进程时，系统都要为之分配或回收系统资源，如内存空间，I/O设备等，OS所付出的开销显著大于在创建或撤销线程时的开销，进程切换的开销也远大于线程切换的开销。</li></ul><hr><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><p>**根本区别：**进程是<mark>操作系统资源分配</mark>的基本单位，而线<mark>程是处理器任务调度和执行</mark>的基本单位</p></li><li><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p></li><li><p>**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p></li><li><p>**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p></li><li><p>**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p></li><li><p>**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ul><h2 id="2-协程与线程的区别"><a class="markdownIt-Anchor" href="#2-协程与线程的区别"></a> 2. 协程与线程的区别？</h2><ul><li>线程和进程都是同步机制，而协程是异步机制。</li><li>线程是抢占式，而协程是非抢占式的。需要用户释放使用权切换到其他协程，因此同一时间其实只有一个协程拥有运行权，相当于单线程的能力。</li><li>一个线程可以有多个协程，一个进程也可以有多个协程。</li><li>协程不被操作系统内核管理，而完全是由程序控制。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</li><li>协程能保留上一次调用时的状态。</li></ul><h2 id="协程地好处"><a class="markdownIt-Anchor" href="#协程地好处"></a> 协程地好处：</h2><ul><li>协程能保留上一次调用时的状态。</li><li>线程和进程都是同步机制，而协程是异步机制。</li></ul><h2 id="3-并发和并行有什么区别"><a class="markdownIt-Anchor" href="#3-并发和并行有什么区别"></a> 3. 并发和并行有什么区别？</h2><p>并发就是在一段时间内，多个任务都会被处理；但在某一时刻，只有一个任务在执行。单核处理器可以做到并发。比如有两个进程<code>A</code>和<code>B</code>，<code>A</code>运行一个时间片之后，切换到<code>B</code>，<code>B</code>运行一个时间片之后又切换到<code>A</code>。因为切换速度足够快，所以宏观上表现为在一段时间内能同时运行多个程序。</p><p>并行就是在同一时刻，有多个任务在执行。这个需要多核处理器才能完成，在微观上就能同时执行多条指令，不同的程序被放到不同的处理器上运行，这个是物理上的多个进程同时进行。</p><h2 id="4-进程与线程的切换流程"><a class="markdownIt-Anchor" href="#4-进程与线程的切换流程"></a> 4. 进程与线程的切换流程？</h2><p>进程切换分两步：</p><p>​1、切换<strong>页表</strong>以使用新的地址空间，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。</p><p>​2、切换内核栈和硬件上下文。</p><p>对于linux来说，线程和进程的最大区别就在于地址空间，对于线程切换，第1步是不需要做的，第2步是进程和线程切换都要做的。</p><p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换。</p><h2 id="5-为什么虚拟地址空间切换会比较耗时"><a class="markdownIt-Anchor" href="#5-为什么虚拟地址空间切换会比较耗时"></a> 5. 为什么虚拟地址空间切换会比较耗时？</h2><p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用Cache来缓存常用的地址映射，这样可以加速页表查找，这个Cache就是TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。</p><p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p><h2 id="6-进程间通信方式有哪些"><a class="markdownIt-Anchor" href="#6-进程间通信方式有哪些"></a> 6. 进程间通信方式有哪些？</h2><ul><li><p>管道：管道这种通讯方式有两种限制，一是半双工的通信，数据只能单向流动，二是只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p><p>管道可以分为两类：匿名管道和命名管道。匿名管道是单向的，只能在有亲缘关系的进程间通信；命名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</p></li><li><p>信号 ： 信号是一种比较复杂的通信方式，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p><p><strong>Linux系统中常用信号</strong>：<br>（1）<strong>SIGHUP</strong>：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</p><p>（2）<strong>SIGINT</strong>：程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。</p><p>（3）<strong>SIGQUIT</strong>：程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。</p><p>（4）<strong>SIGBUS和SIGSEGV</strong>：进程访问非法地址。</p><p>（5）<strong>SIGFPE</strong>：运算中出现致命错误，如除零操作、数据溢出等。</p><p>（6）<strong>SIGKILL</strong>：用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。</p><p>（7）<strong>SIGTERM</strong>：结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。</p><p>（8）<strong>SIGALRM</strong>：定时器信号。</p><p>（9）<strong>SIGCLD</strong>：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p></li><li><p>信号量：信号量是一个<strong>计数器</strong>，可以用来控制多个进程对共享资源的访问。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。</p></li><li><p>消息队列：消息队列是消息的链接表，包括Posix消息队列和System V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。</p></li><li><p>共享内存：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p></li><li><p>Socket：与其他通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ul><p><strong>优缺点</strong>：</p><ul><li><p>管道：速度慢，容量有限；</p></li><li><p>Socket：任何进程间都能通讯，但速度慢；</p></li><li><p>消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题；</p></li><li><p>信号量：不能传递复杂消息，只能用来同步；</p></li><li><p>共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了同一进程内的一块内存。</p></li></ul><h2 id="7-进程间同步的方式有哪些"><a class="markdownIt-Anchor" href="#7-进程间同步的方式有哪些"></a> 7. 进程间同步的方式有哪些？</h2><p>1、临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。</p><p>优点：保证在某一时刻只有一个线程能访问数据的简便办法。</p><p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程。</p><p>2、互斥量：为协调共同对一个共享资源的单独访问而设计的。互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限。</p><p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。</p><p>缺点：</p><ul><li><p>互斥量是可以命名的，也就是说它可以跨越进程使用，所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。</p></li><li><p>通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。</p></li></ul><p>3、信号量：为控制一个具有有限数量用户资源而设计。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了。</p><p>优点：适用于对Socket（套接字）程序中线程的同步。</p><p>缺点:</p><ul><li><p>信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的弱点；</p></li><li><p>信号量机制功能强大，但使用时对信号量的操作分散， 而且难以控制，读写和维护都很困难，加重了程序员的编码负担；</p></li><li><p>核心操作P-V分散在各用户程序的代码中，不易控制和管理，一旦错误，后果严重，且不易发现和纠正。</p></li></ul><p>4、事件： 用来通知线程有一些事件已发生，从而启动后继任务的开始。</p><p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作。</p><h2 id="8-线程同步的方式有哪些"><a class="markdownIt-Anchor" href="#8-线程同步的方式有哪些"></a> 8. 线程同步的方式有哪些？</h2><p>1、临界区：当多个线程访问一个独占性共享资源时，可以使用临界区对象。拥有临界区的线程可以访问被保护起来的资源或代码段，其他线程若想访问，则被挂起，直到拥有临界区的线程放弃临界区为止，以此达到用原子方式操 作共享资源的目的。</p><p>2、事件：事件机制，则允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。</p><p>3、互斥量：互斥对象和临界区对象非常相似，只是其允许在进程间使用，而临界区只限制与同一进程的各个线程之间使用，但是更节省资源，更有效率。</p><p>4、信号量：当需要一个计数器来限制可以使用某共享资源的线程数目时，可以使用“信号量”对象。</p><p>区别：</p><ul><li><p>互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说互斥量可以跨越进程使用，但创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量 。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。</p></li><li><p>互斥量，信号量，事件都可以被跨越进程使用来进行同步数据操作。</p></li></ul><h2 id="9-线程的分类"><a class="markdownIt-Anchor" href="#9-线程的分类"></a> 9. 线程的分类？</h2><p>从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）</p><p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现。比如英特尔i5-8250U是4核8线程，这里的线程就是内核级线程</p><p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p><h2 id="10-什么是临界区如何解决冲突"><a class="markdownIt-Anchor" href="#10-什么是临界区如何解决冲突"></a> 10. 什么是临界区，如何解决冲突？</h2><p>每个进程中访问临界资源的那段程序称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p><p>解决冲突的办法：</p><ul><li><p>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</p></li><li><p>进入临界区的进程要在<strong>有限时间内退出</strong>。</p></li><li><p>如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现“忙等”现象。</p></li></ul><h2 id="11-什么是死锁死锁产生的条件"><a class="markdownIt-Anchor" href="#11-什么是死锁死锁产生的条件"></a> 11. 什么是死锁？死锁产生的条件？</h2><p><strong>什么是死锁</strong>：</p><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><p><strong>死锁产生的四个必要条件</strong>：（有一个条件不成立，则不会产生死锁）</p><ul><li><p>互斥条件：一个资源一次只能被一个进程使用</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得资源保持不放</p></li><li><p>不剥夺条件：进程获得的资源，在未完全使用完之前，不能强行剥夺</p></li><li><p>循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系</p></li></ul><p><strong>如何处理死锁问题</strong>：</p><ul><li><p><strong>忽略该问题</strong>。例如鸵鸟算法，该算法可以应用在极少发生死锁的的情况下。为什么叫鸵鸟算法呢，因为传说中鸵鸟看到危险就把头埋在地底下，可能鸵鸟觉得看不到危险也就没危险了吧。跟掩耳盗铃有点像。</p></li><li><p><strong>检测死锁并且恢复。</strong></p></li><li><p>仔细地对资源进行动态分配，以<strong>避免死锁</strong>。</p></li><li><p><strong>通过破除死锁四个必要条件之一，来防止死锁产生。</strong></p></li></ul><h2 id="12-进程调度策略有哪几种"><a class="markdownIt-Anchor" href="#12-进程调度策略有哪几种"></a> 12. 进程调度策略有哪几种？</h2><ul><li><p><strong>先来先服务</strong>：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。另外，对<code>I/O</code>密集型进程也不利，因为这种进程每次进行<code>I/O</code>操作之后又得重新排队。</p></li><li><p><strong>短作业优先</strong>：非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。</p></li><li><p><strong>最短剩余时间优先</strong>：最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p></li><li><p><strong>时间片轮转</strong>：将所有就绪进程按 <code>FCFS</code> 的原则排成一个队列，每次调度时，把 <code>CPU</code> 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 <code>CPU</code> 时间分配给队首的进程。</p><p>时间片轮转算法的效率和时间片的大小有很大关系：因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。</p></li><li><p><strong>优先级调度</strong>：为每个进程分配一个优先级，按优先级进行调度。为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。</p></li></ul><h2 id="13-进程有哪些状态"><a class="markdownIt-Anchor" href="#13-进程有哪些状态"></a> 13. 进程有哪些状态？</h2><p>进程一共有<code>5</code>种状态，分别是创建、就绪、运行（执行）、终止、阻塞。</p><p><img src="https://pic4.zhimg.com/80/v2-b3bbb0af6ff6e3e01bda67b3d09537cb_1440w.webp" alt="img"></p><ul><li><p>运行状态就是进程正在<code>CPU</code>上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。</p></li><li><p>就绪状态就是说进程已处于准备运行的状态，即进程获得了除<code>CPU</code>之外的一切所需资源，一旦得到<code>CPU</code>即可运行。</p></li><li><p>阻塞状态就是进程正在等待某一事件而暂停运行，比如等待某资源为可用或等待<code>I/O</code>完成。即使<code>CPU</code>空闲，该进程也不能运行。</p></li></ul><p><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。<br><strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。<br><strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。<br><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</p><h2 id="14-什么是分页"><a class="markdownIt-Anchor" href="#14-什么是分页"></a> 14. 什么是分页？</h2><p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p><p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p><p><img src="https://pic3.zhimg.com/80/v2-77e2da59cc403feb97881b397e4b611e_1440w.webp" alt="img"></p><h2 id="15-什么是分段"><a class="markdownIt-Anchor" href="#15-什么是分段"></a> 15. 什么是分段？</h2><p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p><p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p><p><img src="https://pic1.zhimg.com/80/v2-ca9c4e730792fdb3d1489c68f03ecd80_1440w.webp" alt="img"></p><h2 id="16-分页和分段有什区别"><a class="markdownIt-Anchor" href="#16-分页和分段有什区别"></a> 16. 分页和分段有什区别？</h2><ul><li><p>分页对程序员是透明的，但是分段需要程序员显式划分每个段。</p></li><li><p>分页的地址空间是一维地址空间，分段是二维的。</p></li><li><p>页的大小不可变，段的大小可以动态改变。</p></li><li><p>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</p></li></ul><h2 id="17-什么是交换空间"><a class="markdownIt-Anchor" href="#17-什么是交换空间"></a> 17. 什么是交换空间？</h2><p>操作系统把物理内存(physical RAM)分成一块一块的小内存，每一块内存被称为<strong>页(page)</strong>。当内存资源不足时，<strong>Linux把某些页的内容转移至硬盘上的一块空间上，以释放内存空间</strong>。硬盘上的那块空间叫做<strong>交换空间</strong>(swap space),而这一过程被称为交换(swapping)。<strong>物理内存和交换空间的总容量就是虚拟内存的可用容量。</strong></p><p>用途：</p><ul><li><p>物理内存不足时一些不常用的页可以被交换出去，腾给系统。</p></li><li><p>程序启动时很多内存页被用来初始化，之后便不再需要，可以交换出去。</p></li></ul><h2 id="16-页面替换算法有哪些"><a class="markdownIt-Anchor" href="#16-页面替换算法有哪些"></a> 16. 页面替换算法有哪些？</h2><p>在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。</p><p>包括以下算法：</p><ul><li><p><strong>最佳算法</strong>：所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。这是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。</p></li><li><p><strong>先进先出</strong>：选择换出的页面是最先进入的页面。该算法将那些经常被访问的页面也被换出，从而使缺页率升高。</p></li><li><p><strong>LRU</strong>：虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。<code>LRU</code> 将最近最久未使用的页面换出。为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。因为每次访问都需要更新链表，因此这种方式实现的 <code>LRU</code> 代价很高。</p></li><li><p><strong>时钟算法</strong>：时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。它将整个环形链表的每一个页面做一个标记，如果标记是<code>0</code>，那么暂时就不会被替换，然后时钟算法遍历整个环，遇到标记为<code>1</code>的就替换，否则将标记为<code>0</code>的标记为<code>1</code>。</p></li></ul><h2 id="18-什么是缓冲区溢出有什么危害"><a class="markdownIt-Anchor" href="#18-什么是缓冲区溢出有什么危害"></a> 18. 什么是缓冲区溢出？有什么危害？</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><ul><li><p>程序崩溃，导致拒绝额服务</p></li><li><p>跳转并且执行一段恶意代码</p></li></ul><p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><h2 id="19-什么是虚拟内存"><a class="markdownIt-Anchor" href="#19-什么是虚拟内存"></a> 19. 什么是虚拟内存？</h2><p>虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p><h2 id="20-讲一讲io多路复用"><a class="markdownIt-Anchor" href="#20-讲一讲io多路复用"></a> 20. 讲一讲IO多路复用？</h2><p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p><ul><li><p>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</p></li><li><p>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</p></li><li><p>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</p></li><li><p>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</p></li><li><p>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</p></li><li><p>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p></li></ul><h2 id="21-硬链接和软链接有什么区别"><a class="markdownIt-Anchor" href="#21-硬链接和软链接有什么区别"></a> 21. 硬链接和软链接有什么区别？</h2><ul><li><p>硬链接就是在目录下创建一个条目，记录着文件名与 <code>inode</code> 编号，这个 <code>inode</code> 就是源文件的 <code>inode</code>。删除任意一个条目，文件还是存在，只要引用数量不为 <code>0</code>。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</p></li><li><p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 <code>Windows</code> 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。</p></li></ul><h2 id="22-中断的处理过程"><a class="markdownIt-Anchor" href="#22-中断的处理过程"></a> 22. 中断的处理过程?</h2><ol><li><p>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</p></li><li><p>开中断：以便执行中断时能响应较高级别的中断请求。</p></li><li><p>中断处理</p></li><li><p>关中断：保证恢复现场时不被新中断打扰</p></li><li><p>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</p></li></ol><h2 id="23-中断和轮询有什么区别"><a class="markdownIt-Anchor" href="#23-中断和轮询有什么区别"></a> 23. 中断和轮询有什么区别？</h2><ul><li><p>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</p></li><li><p>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/27/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/QPS/"/>
      <url>/2023/03/27/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/QPS/</url>
      
        <content type="html"><![CDATA[<h1 id="性能测试-峰值qps和计算公式"><a class="markdownIt-Anchor" href="#性能测试-峰值qps和计算公式"></a> 性能测试-峰值QPS和计算公式</h1><p><strong>峰值QPS和计算公式</strong><br><strong>概述</strong><br>因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。 对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p>计算关系： QPS = 并发量 / 平均响应时间 并发量 = QPS * 平均响应时间</p><p>通常QPS用来表达和衡量当前系统的负载，也可以用RPS来表示， 我们形容当前系统的运行状态时可以说当前QPS已经达到多少多少了， 在系统环境不变的情况下存在支持的最大QPS，但并不应该用来形容机器的性能。 可以通过提高TPS来提升当前系统的处理能力，来增加最大QPS的支持。 TPS用来形容机器的性能。</p><p><strong>QPS计算原理</strong><br>QPS = req/sec = 请求数/秒</p><p>原理:每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式:( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数&gt;(QPS)<br>机器:峰值时间每秒QPS / 单台机器的QPS = 需要的机器<br><strong>实例</strong><br>问:每天300w PV 的在单台机器上，这台机器需要多少QPS？</p><p>答:( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</p><p>问:如果一台机器的QPS是58，需要几台机器来支持？</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/27/interview/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2023/03/27/interview/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNCVCQiVCQiVFNSU4QSVBMSVFNyVBRSVBMSVFNyU5MCU4NiVFNSU5OSVBOC5wbmc?x-oss-process=image/format,png" alt="任务管理器"></p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line"><span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line"><span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) {</span><br><span class="line">System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[6] Monitor Ctrl-Break //监听线程转储或“线程堆栈跟踪”的线程</span><br><span class="line">[5] Attach Listener //负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者</span><br><span class="line">[4] Signal Dispatcher // 分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer //在垃圾收集前，调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler //用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收的线程</span><br><span class="line">[1] main //main 线程,程序入口</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><h2 id="进程与线程的区别总结"><a class="markdownIt-Anchor" href="#进程与线程的区别总结"></a> 进程与线程的区别总结</h2><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><p>**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p></li><li><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p></li><li><p>**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p></li><li><p>**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p></li><li><p>**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p></li><li><p>**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ul><h2 id="从-jvm-角度说进程和线程之间的关系重要"><a class="markdownIt-Anchor" href="#从-jvm-角度说进程和线程之间的关系重要"></a> 从 JVM 角度说进程和线程之间的关系（重要）</h2><h3 id="图解进程和线程的关系"><a class="markdownIt-Anchor" href="#图解进程和线程的关系"></a> 图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="https://img-blog.csdnimg.cn/20191105205545651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><h2 id="程序计数器为什么是私有的"><a class="markdownIt-Anchor" href="#程序计数器为什么是私有的"></a> 程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a class="markdownIt-Anchor" href="#虚拟机栈和本地方法栈为什么是私有的"></a> 虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li>**虚拟机栈：**每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li>**本地方法栈：**和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</li></ul><h2 id="一句话简单了解堆和方法区"><a class="markdownIt-Anchor" href="#一句话简单了解堆和方法区"></a> 一句话简单了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="多进程和多线程区别"><a class="markdownIt-Anchor" href="#多进程和多线程区别"></a> 多进程和多线程区别</h2><p>多进程：操作系统中同时运行的多个程序</p><p>多线程：在同一个进程中同时运行的多个任务</p><p>举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。</p><p>多线程提高CPU使用率</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNSVBNCU5QSVFNyVCQSVCRiVFNyVBOCU4Qi5wbmc?x-oss-process=image/format,png" alt="多线程"></p><p>多线程并不能提高运行速度，但可以提高运行效率，让CPU的使用率更高。但是如果多线程有安全问题或出现频繁的上下文切换时，运算速度可能反而更低。</p><h2 id="java中的多线程"><a class="markdownIt-Anchor" href="#java中的多线程"></a> Java中的多线程</h2><p>Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>多态</title>
      <link href="/2023/03/19/interview/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%80%81/"/>
      <url>/2023/03/19/interview/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="多态的概述"><a class="markdownIt-Anchor" href="#多态的概述"></a> 多态的概述</h2><p><img src="../../../images/image-20230319114544383.png" alt="image-20230319114544383"></p><h2 id="多态的格式与使用"><a class="markdownIt-Anchor" href="#多态的格式与使用"></a> 多态的格式与使用</h2><p><img src="../../../images/image-20230319115224624.png" alt="image-20230319115224624"></p><p><img src="../../../images/image-20230319114924748.png" alt="image-20230319114924748"></p><p><img src="../../../images/image-20230319115144427.png" alt="image-20230319115144427"></p><h2 id="多态中的成员变量的使用特点其实没有任何变化"><a class="markdownIt-Anchor" href="#多态中的成员变量的使用特点其实没有任何变化"></a> 多态中的成员变量的使用特点（其实没有任何变化）</h2><p>访问成员变量的两种方式：</p><ul><li>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找</li></ul><p>多态中，成员变量不可以发生覆盖重写（比如，可以在子类的成员变量上添加@Override，会发现报错），只有方法可以发生覆盖重写</p><p><img src="../../../images/image-20230319115914276.png" alt="image-20230319115914276"></p><p><img src="../../../images/image-20230319115854891.png" alt="image-20230319115854891"></p><p><img src="../../../images/image-20230319115831384.png" alt="image-20230319115831384"></p><h2 id="多态中的成员方法的使用特点"><a class="markdownIt-Anchor" href="#多态中的成员方法的使用特点"></a> 多态中的成员方法的使用特点</h2><p>在多态的代码中，成员方法的访问规则：</p><ul><li>看 new 的是谁，就优先用谁，没有则向上找</li></ul><p>口诀：编译看左边，运行看右边</p><p>对比：</p><ul><li>成员变量：编译看左边，运行还看左边</li><li>成员方法：编译看左边，运行看右边</li></ul><p><img src="../../../images/image-20230319120823517.png" alt="image-20230319120823517"></p><h2 id="多态的好处"><a class="markdownIt-Anchor" href="#多态的好处"></a> 多态的好处</h2><p><img src="../../../images/image-20230319181831562.png" alt="image-20230319181831562"></p><h2 id="对象的向上转型"><a class="markdownIt-Anchor" href="#对象的向上转型"></a> 对象的向上转型</h2><p><img src="../../../images/image-20230319182510068.png" alt="image-20230319182510068"></p><h2 id="对象的向下转型"><a class="markdownIt-Anchor" href="#对象的向下转型"></a> 对象的向下转型</h2><p><img src="../../../images/image-20230319183246604.png" alt="image-20230319183246604"></p><p><img src="../../../images/image-20230319184116304.png" alt="image-20230319184116304"></p><h3 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h3><p>如何知道一个父类引用的对象本来是哪个子类，怎么知道向哪个子类进行向下转型呢？</p><p>方案：用 instanceof</p><p>格式：  <strong>对象 instanceof 类名称</strong>      这会得到一个boolean值的结果，也就是判断前面的对象能不能当作后面类型的实例</p><p><img src="../../../images/image-20230319185037444.png" alt="image-20230319185037444"></p><p>向下转型时，在未知原本类型时，一定要用 instanceof，否则容易出异常</p>]]></content>
      
      
      <categories>
          
          <category> java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/16/interview/Spring%E9%9D%A2%E8%AF%95/Spring/"/>
      <url>/2023/03/16/interview/Spring%E9%9D%A2%E8%AF%95/Spring/</url>
      
        <content type="html"><![CDATA[<h1 id="spring中controlle单例"><a class="markdownIt-Anchor" href="#spring中controlle单例"></a> Spring中Controlle单例</h1><ul><li>controller默认是单例的，不要使用非静态的成员变量，否则会发生数据逻辑混乱。 正因为单例所以不是线程安全的。</li></ul><p>我们下面来简单的验证下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.riemann.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeTestController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>我们首先访问 <a href="http://localhost:8080/testScope%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF1%EF%BC%9B">http://localhost:8080/testScope，得到的答案是1；</a></li><li>然后我们再访问<a href="http://localhost:8080/testScope2%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF">http://localhost:8080/testScope2，得到的答案是</a> 2。</li></ul><p><strong>得到的不同的值，这是线程不安全的。</strong></p><p>接下来我们再来给controller增加作用多例 <mark>@Scope(“prototype”)</mark></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.riemann.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope("prototype")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeTestController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>我们依旧首先访问 <a href="http://localhost:8080/testScope%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF1%EF%BC%9B">http://localhost:8080/testScope，得到的答案是1；</a></li><li>然后我们再访问 <a href="http://localhost:8080/testScope2%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E8%BF%98%E6%98%AF">http://localhost:8080/testScope2，得到的答案还是</a> 1。</li></ul><p>相信大家不难发现 ：</p><p><a href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BE%8B&amp;spm=1001.2101.3001.7020">单例</a>是不安全的，会导致属性重复使用。</p><p>解决方案</p><ol><li>不要在controller中定义成员变量。</li><li>万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式。</li><li>在Controller中使用ThreadLocal变量</li></ol><p><font color="red">Spring MVC默认是单例模式，Controller、Service、Dao都是单例</font>所以在使用不当存在一定的安全隐患。Controller单例模式的好处在与：</p><ul><li>提高性能，不用每次创建Controller实例，减少了对象创建和垃圾收集的时间</li><li>没多例的必要，由于只有一个Controller的实例，当多个线程同时调用它的时候，它的成员变量就不是线程安全的。<br>当然在大多数情况下，<strong>我们根本不需要Controller考虑线程安全的问题，除非在类中声明了<mark>成员变量</mark></strong>。因此Spring MVC的Contrller在编码时，尽量避免使用实例变量。如果一定要使用实例变量，则可以改用以下方式：<br>Controller中声明 scope=”prototype”，即设置为多例模式<br>在Controller中使用ThreadLocal变量,如：private ThreadLocal count = new ThreadLocal();</li></ul><h1 id="springmvc-singleton有几种解决方法"><a class="markdownIt-Anchor" href="#springmvc-singleton有几种解决方法"></a> springmvc singleton有几种解决方法：</h1><p>1、在控制器中不使用实例变量（可以使用方法参数的形式解决，参考博文 Spring Bean Scope 有状态的Bean 无状态的Bean）<br>2、将控制器的作用域从单例改为原型，即在spring配置文件Controller中声明 <font color="blue"><strong>scope=“prototype”</strong></font>，每次都创建新的controller<br>3、在Controller中使用<font color="blue"><strong>ThreadLocal</strong></font>变量</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal使用与原理</title>
      <link href="/2023/03/16/juc/ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
      <url>/2023/03/16/juc/ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在处理多线程并发安全的方法中，最常用的方法，就是使用锁，通过锁来控制多个不同线程对临界区的访问。</p><p>但是，无论是什么样的锁，乐观锁或者悲观锁，都会在并发冲突的时候对性能产生一定的影响。</p><p>那有没有一种方法，可以彻底避免竞争呢？</p><p>答案是肯定的，这就是ThreadLocal。</p><p>从字面意思上看，ThreadLocal可以解释成线程的局部变量，也就是说一个ThreadLocal的变量只有当前自身线程可以访问，别的线程都访问不了，那么自然就避免了线程竞争。</p><p>因此，ThreadLocal提供了一种与众不同的线程安全方式，它不是在发生线程冲突时想办法解决冲突，而是彻底的<mark>避免了冲突的发生</mark>。</p><h2 id="threadlocal的基本使用"><a class="markdownIt-Anchor" href="#threadlocal的基本使用"></a> ThreadLocal的基本使用</h2><p>创建一个ThreadLocal对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><p>上述代码创建一个localInt变量，由于ThreadLocal是一个泛型类，这里指定了localInt的类型为整数。</p><p>下面展示了如果设置和获取这个变量的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setAndGet</span><span class="params">()</span>{</span><br><span class="line">    localInt.set(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> localInt.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码设置变量的值为8，接着取得这个值。</p><p>由于ThreadLocal里设置的值，只有当前线程自己看得见，这意味着你不可能通过其他线程为它初始化值。为了弥补这一点，ThreadLocal提供了一个withInitial()方法统一初始化所有线程的ThreadLocal的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; localInt = ThreadLocal.withInitial(() -&gt; <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p>上述代码将ThreadLocal的初始值设置为6，这对全体线程都是可见的。</p><h2 id="threadlocal的实现原理"><a class="markdownIt-Anchor" href="#threadlocal的实现原理"></a> ThreadLocal的实现原理</h2><p>ThreadLocal变量只在单个线程内可见，那它是如何做到的呢？我们先从最基本的get()方法说起：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//获得当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//每个线程 都有一个自己的ThreadLocalMap，</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap里就保存着所有的ThreadLocal变量</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">//ThreadLocalMap的key就是当前ThreadLocal对象实例，</span></span><br><span class="line">        <span class="comment">//多个ThreadLocal变量都是放在这个map中的</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="comment">//从map里取出来的值就是我们需要的这个ThreadLocal变量</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果map没有初始化，那么在这里初始化一下</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，所谓的ThreadLocal变量就是保存在每个线程的map中的。这个map就是Thread对象中的threadLocals字段。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><p>ThreadLocal.ThreadLocalMap是一个比较特殊的Map，它的每个Entry的key都是一个弱引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//key就是一个弱引用</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样设计的好处是，如果这个变量不再被其他对象使用时，可以自动回收这个ThreadLocal对象，避免可能的内存泄露（注意，Entry中的value，依然是强引用，如何回收，见下文分解）。</p><h2 id="理解threadlocal中的内存泄漏问题"><a class="markdownIt-Anchor" href="#理解threadlocal中的内存泄漏问题"></a> 理解ThreadLocal中的内存泄漏问题</h2><p>虽然ThreadLocalMap中的key是弱引用，当不存在外部强引用的时候，就会自动被回收，但是Entry中的value依然是强引用。这个value的引用链条如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68348e17e2588eec1a2c2f03939c5e4b.png" alt="img"></p><p>可以看到，只有当Thread被回收时，这个value才有被回收的机会，否则，只要线程不退出，value总是会存在一个强引用。但是，要求每个Thread都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成value对象出现泄漏的可能。处理的方法是，在ThreadLocalMap进行set(),get(),remove()的时候，都会进行清理：</p><p>以getEntry()为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="comment">//如果找到key，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果找不到，就会尝试清理，如果你总是访问存在的key，那么这个清理永远不会进来</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是getEntryAfterMiss()的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 整个e是entry ，也就是一个弱引用</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//如果找到了，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果key为null，说明弱引用已经被回收了</span></span><br><span class="line">            <span class="comment">//那么就要在这里回收里面的value了</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果key不是要找的那个，那说明有hash冲突，这里是处理冲突，找下一个entry</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>真正用来回收value的是expungeStaleEntry()方法，在remove()和set()方法中，都会直接或者间接调用到这个方法进行value的清理：</p><p>从这里可以看到，ThreadLocal为了避免内存泄露，也算是花了一番大心思。不仅使用了弱引用维护key，还会在每个操作上检查key是否被回收，进而再回收value。</p><p>但是从中也可以看到，ThreadLocal并不能100%保证不发生内存泄漏。</p><p>比如，很不幸的，你的get()方法总是访问固定几个一直存在的ThreadLocal，那么清理动作就不会执行，如果你没有机会调用set()和remove()，那么这个内存泄漏依然会发生。</p><p>因此，一个良好的习惯依然是：当你不需要这个ThreadLocal变量时，主动调用remove()，这样对整个系统是有好处的。</p><h2 id="threadlocalmap中的hash冲突处理"><a class="markdownIt-Anchor" href="#threadlocalmap中的hash冲突处理"></a> ThreadLocalMap中的Hash冲突处理</h2><p>ThreadLocalMap作为一个HashMap和java.util.HashMap的实现是不同的。对于java.util.HashMap使用的是链表法来处理冲突：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed997859830e2a95ad92f272c84e8714.png" alt="img"></p><p>但是，对于ThreadLocalMap，它使用的是简单的线性探测法，如果发生了元素冲突，那么就使用下一个槽位存放：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aa2d77a8245005b80f2da0c3ad65b492.png" alt="img"></p><p>具体来说，整个set()的过程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4ea4acee93016a8918a2af70a55943bc.png" alt="img"></p><h2 id="可以被继承的threadlocalinheritablethreadlocal"><a class="markdownIt-Anchor" href="#可以被继承的threadlocalinheritablethreadlocal"></a> 可以被继承的ThreadLocal——InheritableThreadLocal</h2><p>在实际开发过程中，我们可能会遇到这么一种场景。主线程开了一个子线程，但是我们希望在子线程中可以访问主线程中的ThreadLocal对象，也就是说有些数据需要进行父子线程间的传递。比如像这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    IntStream.range(<span class="number">0</span>,<span class="number">10</span>).forEach(i -&gt; {</span><br><span class="line">        <span class="comment">//每个线程的序列号，希望在子线程中能够拿到</span></span><br><span class="line">        threadLocal.set(i);</span><br><span class="line">        <span class="comment">//这里来了一个子线程，我们希望可以访问上面的threadLocal</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + threadLocal.get());</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行上述代码，你会看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">2</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">3</span>:<span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure><p>因为在子线程中，是没有threadLocal的。如果我们希望子线可以看到父线程的ThreadLocal，那么就可以使用InheritableThreadLocal。顾名思义，这就是一个支持线程间父子继承的ThreadLocal，将上述代码中的threadLocal使用InheritableThreadLocal：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InheritableThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br></pre></td></tr></tbody></table></figure><p>再执行，就能看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">4</span>:<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，每个线程都可以访问到从父进程传递过来的一个数据。虽然InheritableThreadLocal看起来挺方便的，但是依然要注意以下几点：</p><p>变量的传递是发生在线程创建的时候，如果不是新建线程，而是用了线程池里的线程，就不灵了<br>变量的赋值就是从主线程的map复制到子线程，它们的value是同一个对象，如果这个对象本身不是线程安全的，那么就会有线程安全问题</p><h2 id="写在最后的话"><a class="markdownIt-Anchor" href="#写在最后的话"></a> 写在最后的话</h2><p>今天，我们介绍了ThreadLocal，ThreadLocal在Java的多线程开发中有着十分重要的作用。</p><p>在这里，我们介绍了ThreadLocal的基本使用和实现原理，尤其重点介绍了基于当前实现原理下可能存在的内存泄漏问题。</p><p>最后，还介绍了一个用于在父子线程间传递数据的特殊的ThreadLocal实现，希望对大家有所帮助。</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS</title>
      <link href="/2023/03/16/juc/CAS/"/>
      <url>/2023/03/16/juc/CAS/</url>
      
        <content type="html"><![CDATA[<h1 id="并发编程的灵魂cas机制详解"><a class="markdownIt-Anchor" href="#并发编程的灵魂cas机制详解"></a> 并发编程的灵魂：CAS机制详解</h1><p>Java中提供了很多原子操作类来保证共享变量操作的原子性。这些原子操作的底层原理都是使用了CAS机制。在使用一门技术之前，了解这个技术的底层原理是非常重要的，所以本篇文章就先来讲讲什么是CAS机制，CAS机制存在的一些问题以及在Java中怎么使用CAS机制。</p><p>其实Java并发框架的基石一共有两块，一块是本文介绍的CAS，另一块就是AQS，后续也会写文章介绍。</p><h2 id="什么是cas机制"><a class="markdownIt-Anchor" href="#什么是cas机制"></a> 什么是CAS机制</h2><p>CAS机制是一种数据更新的方式。在具体讲什么是CAS机制之前，我们先来聊下在多线程环境下，对共享变量进行数据更新的两种模式：悲观锁模式和乐观锁模式。</p><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源，所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如你的更新操作其实是非常快的，这种情况下你还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比你的更新操作的时间还要长。</p><p>乐观锁更新方式认为:在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现。</p><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p><ul><li>主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li><li>工作内存中共享变量的副本值，也叫预期值：A</li><li>需要将共享变量更新到的最新值：B</li></ul><p><img src="https://pic1.zhimg.com/80/v2-f32df3fde2dc0132c05533572e2b659c_720w.webp" alt="img"></p><p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。</p><p>值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。</p><h2 id="cas机制优缺点"><a class="markdownIt-Anchor" href="#cas机制优缺点"></a> CAS机制优缺点</h2><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><p><strong>1. ABA问题</strong><br>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p><p><strong>2. 可能会消耗较高的CPU</strong><br>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p><p><strong>3. 不能保证代码块的原子性</strong><br>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>可以保证变量操作的原子性；</li><li>并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li><li>在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li></ul><h2 id="java提供的cas操作类unsafe类"><a class="markdownIt-Anchor" href="#java提供的cas操作类unsafe类"></a> Java提供的CAS操作类–Unsafe类</h2><p>从Java5开始引入了对CAS机制的底层的支持，在这之前需要开发人员编写相关的代码才可以实现CAS。在原子变量类Atomic<strong>中（例如AtomicInteger、AtomicLong）可以看到CAS操作的代码，在这里的代码都是调用了底层（核心代码调用native修饰的方法）的实现方法。在AtomicInteger源码中可以看getAndSet方法和compareAndSet方法之间的关系，compareAndSet方法调用了底层的实现，该方法可以实现与一个volatile变量的读取和写入相同的效果。在前面说到了volatile不支持例如i++这样的复合操作，在Atomic</strong>中提供了实现该操作的方法。JVM对CAS的支持通过这些原子类（Atomic）暴露出来，供我们使用。</p><p>而Atomic系类的类底层调用的是Unsafe类的API，Unsafe类提供了一系列的compareAndSwap*方法，下面就简单介绍下Unsafe类的API：</p><ul><li>long objectFieldOffset（Field field）方法：返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe函数中访问指定字段时使用。如下代码使用Unsafe类获取变量value在AtomicLong对象中的内存偏移。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static {</span><br><span class="line">   try {</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">           (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">   } catch (Exception ex) { throw new Error(ex); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>int arrayBaseOffset（Class arrayClass）方法：获取数组中第一个元素的地址。</li><li>int arrayIndexScale（Class arrayClass）方法：获取数组中一个元素占用的字节。</li><li>boolean compareAndSwapLong（Object obj, long offset, long expect, long update）方法：比较对象obj中偏移量为offset的变量的值是否与expect相等，相等则使用update值更新，然后返回true，否则返回false。</li><li>public native long getLongvolatile（Object obj, long offset）方法：获取对象obj中偏移量为offset的变量对应volatile语义的值。</li><li>void putLongvolatile（Object obj, long offset, long value）方法：设置obj对象中offset偏移的类型为long的field的值为value，支持volatile语义。</li><li>void putOrderedLong（Object obj, long offset, long value）方法：设置obj对象中offset偏移地址对应的long型field的值为value。这是一个有延迟的putLongvolatile方法，并且不保证值修改对其他线程立刻可见。只有在变量使用volatile修饰并且预计会被意外修改时才使用该方法。</li><li>void park（boolean isAbsolute, long time）方法：阻塞当前线程，其中参数isAbsolute等于false且time等于0表示一直阻塞。time大于0表示等待指定的time后阻塞线程会被唤醒，这个time是个相对值，是个增量值，也就是相对当前时间累加time后当前线程就会被唤醒。如果isAbsolute等于true，并且time大于0，则表示阻塞的线程到指定的时间点后会被唤醒，这里time是个绝对时间，是将某个时间点换算为ms后的值。另外，当其他线程调用了当前阻塞线程的interrupt方法而中断了当前线程时，当前线程也会返回，而当其他线程调用了unPark方法并且把当前线程作为参数时当前线程也会返回。</li><li>void unpark（Object thread）方法：唤醒调用park后阻塞的线程。</li></ul><p>下面是JDK8新增的函数，这里只列出Long类型操作。</p><ul><li>long getAndSetLong（Object obj, long offset, long update）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量volatile语义的值为update。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个方法只是封装了compareAndSwapLong的使用，不需要自己写重试机制</span><br><span class="line">public final long getAndSetLong(Object var1, long var2, long var4) {</span><br><span class="line">    long var6;</span><br><span class="line">    do {</span><br><span class="line">        var6 = this.getLongVolatile(var1, var2);</span><br><span class="line">    } while(!this.compareAndSwapLong(var1, var2, var6, var4));</span><br><span class="line"></span><br><span class="line">    return var6;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>long getAndAddLong（Object obj, long offset, long addValue）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量值为原始值+addValue，原理和上面的方法类似。</li></ul><h2 id="cas使用场景"><a class="markdownIt-Anchor" href="#cas使用场景"></a> CAS使用场景</h2><ul><li>使用一个变量统计网站的访问量；</li><li>Atomic类操作；</li><li>数据库乐观锁更新。</li></ul>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚合的分类</title>
      <link href="/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/"/>
      <url>/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="../../images/image-20230313221322812.png" alt="image-20230313221322812"></p><p><img src="../../images/image-20230313221351783.png" alt="image-20230313221351783"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT</span> <span class="operator">=</span> <span class="string">"parent"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHILD</span> <span class="operator">=</span> <span class="string">"child"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> {</span><br><span class="line">    System.out.print(PARENT + <span class="string">"A "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">   System.out.print(PARENT + <span class="string">"B "</span>);</span><br><span class="line">    }</span><br><span class="line">    {</span><br><span class="line">    System.out.print(PARENT + <span class="string">"C "</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> {</span><br><span class="line">    System.out.print(CHILD + <span class="string">"A "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">    System.out.print(CHILD + <span class="string">"B "</span>);</span><br><span class="line">    }</span><br><span class="line">        {</span><br><span class="line">        System.out.print(CHILD + <span class="string">"C "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：parentB childB parentC parentA childC childA</p><p>官方解析：考察父类、子类的加载顺序：</p><p><strong>父类的静态代码块 &gt; 子类的静态代码块 &gt; 父类的动态代码块 &gt; 父类的构造方法 &gt; 子类的动态代码块 &gt; 子类的构造方法。</strong></p><h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2、</h2><p><img src="../../images/image-20230312151036608.png" alt="image-20230312151036608"></p><h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3、</h2><p><img src="../../images/image-20230312151525256.png" alt="image-20230312151525256"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>3-Elasticsearch</title>
      <link href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/"/>
      <url>/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎03"><a class="markdownIt-Anchor" href="#分布式搜索引擎03"></a> 分布式搜索引擎03</h1><h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1><h1 id="1数据聚合"><a class="markdownIt-Anchor" href="#1数据聚合"></a> 1.数据聚合</h1><p>**<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="11聚合的种类"><a class="markdownIt-Anchor" href="#11聚合的种类"></a> 1.1.聚合的种类</h2><p>聚合常见的有三类：</p><ul><li><p>**桶（Bucket）**聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p>**度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><p>**管道（pipeline）**聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p>**注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><h2 id="12dsl实现聚合"><a class="markdownIt-Anchor" href="#12dsl实现聚合"></a> 1.2.DSL实现聚合</h2><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h3 id="121bucket聚合语法"><a class="markdownIt-Anchor" href="#121bucket聚合语法"></a> 1.2.1.Bucket聚合语法</h3><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;定义聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//给聚合起个名字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;参与聚合的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span>&nbsp;<span class="comment">//&nbsp;希望获取的聚合结果数量</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><p><img src="../../../images/image-20210723171948228.png" alt="image-20210723171948228"></p><h3 id="122聚合结果排序"><a class="markdownIt-Anchor" href="#122聚合结果排序"></a> 1.2.2.聚合结果排序</h3><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_count"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span> <span class="comment">//&nbsp;按照_count升序排列</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="123限定聚合范围"><a class="markdownIt-Anchor" href="#123限定聚合范围"></a> 1.2.3.限定聚合范围</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这次，聚合得到的品牌明显变少了：</p><p><img src="../../../images/image-20210723172404836.png" alt="image-20210723172404836"></p><h3 id="124metric聚合语法"><a class="markdownIt-Anchor" href="#124metric聚合语法"></a> 1.2.4.Metric聚合语法</h3><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"score_stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"score"</span>&nbsp;<span class="comment">//&nbsp;聚合字段，这里是score</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="../../../images/image-20210723172917636.png" alt="image-20210723172917636"></p><h3 id="125小结"><a class="markdownIt-Anchor" href="#125小结"></a> 1.2.5.小结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="13restapi实现聚合"><a class="markdownIt-Anchor" href="#13restapi实现聚合"></a> 1.3.RestAPI实现聚合</h2><h3 id="131api语法"><a class="markdownIt-Anchor" href="#131api语法"></a> 1.3.1.API语法</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p><p>聚合条件的语法：</p><p><img src="../../../images/image-20210723173057733.png" alt="image-20210723173057733"></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="../../../images/image-20210723173215728.png" alt="image-20210723173215728"></p><h3 id="132业务需求"><a class="markdownIt-Anchor" href="#132业务需求"></a> 1.3.2.业务需求</h3><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="../../../images/image-20210723192605566.png" alt="image-20210723192605566"></p><p>分析：</p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="../../../images/image-20210723193730799.png" alt="image-20210723193730799"></p><p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="../../../images/image-20210723203915982.png" alt="image-20210723203915982"></p><p>结果是一个Map结构：</p><ul><li>key是字符串，城市、星级、品牌、价格</li><li>value是集合，例如多个城市的名称</li></ul><h3 id="133业务实现"><a class="markdownIt-Anchor" href="#133业务实现"></a> 1.3.3.业务实现</h3><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("filters")</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">getFilters</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">    <span class="keyword">return</span> hotelService.getFilters(params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure><p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.设置size</span></span><br><span class="line">        request.source().size(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2.3.聚合</span></span><br><span class="line">        buildAggregation(request);</span><br><span class="line">        <span class="comment">// 3.发出请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">        <span class="comment">// 4.1.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; brandList = getAggByName(aggregations, <span class="string">"brandAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"品牌"</span>, brandList);</span><br><span class="line">        <span class="comment">// 4.2.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; cityList = getAggByName(aggregations, <span class="string">"cityAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"城市"</span>, cityList);</span><br><span class="line">        <span class="comment">// 4.3.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; starList = getAggByName(aggregations, <span class="string">"starAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"星级"</span>, starList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildAggregation</span><span class="params">(SearchRequest request)</span> {</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"brandAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"brand"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"cityAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"city"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"starAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"starName"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getAggByName</span><span class="params">(Aggregations aggregations, String aggName)</span> {</span><br><span class="line">    <span class="comment">// 4.1.根据聚合名称获取聚合结果</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(aggName);</span><br><span class="line">    <span class="comment">// 4.2.获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;String&gt; brandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) {</span><br><span class="line">        <span class="comment">// 4.4.获取key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        brandList.add(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> brandList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2自动补全"><a class="markdownIt-Anchor" href="#2自动补全"></a> 2.自动补全</h1><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="../../../images/image-20210723204936367.png" alt="image-20210723204936367"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h2 id="21拼音分词器"><a class="markdownIt-Anchor" href="#21拼音分词器"></a> 2.1.拼音分词器</h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p><img src="../../../images/image-20210723205932746.png" alt="image-20210723205932746"></p><p>课前资料中也提供了拼音分词器的安装包：</p><p><img src="../../../images/image-20210723205722303.png" alt="image-20210723205722303"></p><p>安装方式与IK分词器一样，分三步：</p><p>​①解压</p><p>​②上传到虚拟机中，elasticsearch的plugin目录</p><p>​③重启elasticsearch</p><p>​④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/_analyze</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家酒店还不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="../../../images/image-20210723210126506.png" alt="image-20210723210126506"></p><h2 id="22自定义分词器"><a class="markdownIt-Anchor" href="#22自定义分词器"></a> 2.2.自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p>文档分词时会依次由这三部分来处理文档：</p><p><img src="../../../images/image-20210723210427878.png" alt="image-20210723210427878"></p><p>声明自定义分词器的语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"settings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analysis"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义分词器</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"my_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;&nbsp;<span class="comment">//&nbsp;分词器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"tokenizer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="string">"py"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义tokenizer&nbsp;filter</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"py"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;过滤器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;过滤器类型，这里是pinyin</span></span><br><span class="line">  <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_original"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span>&nbsp;<span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"my_analyzer"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"search_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_smart"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>测试：</p><p><img src="../../../images/image-20210723211829150.png" alt="image-20210723211829150"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>如何使用拼音分词器？</p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h2 id="23自动补全查询"><a class="markdownIt-Anchor" href="#23自动补全查询"></a> 2.3.自动补全查询</h2><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;创建索引库</span></span><br><span class="line">PUT&nbsp;test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"completion"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>然后插入下面的数据：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Sony"</span><span class="punctuation">,</span>&nbsp;<span class="string">"WH-1000XM3"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"SK-II"</span><span class="punctuation">,</span>&nbsp;<span class="string">"PITERA"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Nintendo"</span><span class="punctuation">,</span>&nbsp;<span class="string">"switch"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;自动补全查询</span></span><br><span class="line">GET&nbsp;/test/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title_suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"s"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;关键字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"completion"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"title"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;补全查询的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"skip_duplicates"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;跳过重复的</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span>&nbsp;<span class="comment">//&nbsp;获取前10条结果</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="24实现酒店搜索框自动补全"><a class="markdownIt-Anchor" href="#24实现酒店搜索框自动补全"></a> 2.4.实现酒店搜索框自动补全</h2><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h3 id="241修改酒店映射结构"><a class="markdownIt-Anchor" href="#241修改酒店映射结构"></a> 2.4.1.修改酒店映射结构</h3><p>代码如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"settings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"analysis"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"text_anlyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"completion_analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"py"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"pinyin"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_original"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"mappings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"properties"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"id"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"address"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"price"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"score"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"brand"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"city"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"starName"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"business"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"location"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"geo_point"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"pic"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"all"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"suggestion"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"completion"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"completion_analyzer"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="242修改hoteldoc实体"><a class="markdownIt-Anchor" href="#242修改hoteldoc实体"></a> 2.4.2.修改HotelDoc实体</h3><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.business.contains(<span class="string">"/"</span>)){</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="built_in">this</span>.business.split(<span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="built_in">this</span>.suggestion = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.suggestion.add(<span class="built_in">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="built_in">this</span>.suggestion, arr);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.suggestion = Arrays.asList(<span class="built_in">this</span>.brand, <span class="built_in">this</span>.business);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="243重新导入"><a class="markdownIt-Anchor" href="#243重新导入"></a> 2.4.3.重新导入</h3><p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p><p><img src="../../../images/image-20210723213546183.png" alt="image-20210723213546183"></p><h3 id="244自动补全查询的javaapi"><a class="markdownIt-Anchor" href="#244自动补全查询的javaapi"></a> 2.4.4.自动补全查询的JavaAPI</h3><p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p><img src="../../../images/image-20210723213759922.png" alt="image-20210723213759922"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="../../../images/image-20210723213917524.png" alt="image-20210723213917524"></p><h3 id="245实现搜索框自动补全"><a class="markdownIt-Anchor" href="#245实现搜索框自动补全"></a> 2.4.5.实现搜索框自动补全</h3><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="../../../images/image-20210723214021062.png" alt="image-20210723214021062"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("suggestion")</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(<span class="meta">@RequestParam("key")</span> String prefix)</span> {</span><br><span class="line">    <span class="keyword">return</span> hotelService.getSuggestions(prefix);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span>;</span><br></pre></td></tr></tbody></table></figure><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        request.source().suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">            <span class="string">"suggestions"</span>,</span><br><span class="line">            SuggestBuilders.completionSuggestion(<span class="string">"suggestion"</span>)</span><br><span class="line">            .prefix(prefix)</span><br><span class="line">            .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">            .size(<span class="number">10</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3.发起请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">        <span class="comment">// 4.1.根据补全查询名称，获取补全结果</span></span><br><span class="line">        <span class="type">CompletionSuggestion</span> <span class="variable">suggestions</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">"suggestions"</span>);</span><br><span class="line">        <span class="comment">// 4.2.获取options</span></span><br><span class="line">        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">        <span class="comment">// 4.3.遍历</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(options.size());</span><br><span class="line">        <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().toString();</span><br><span class="line">            list.add(text);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3数据同步"><a class="markdownIt-Anchor" href="#3数据同步"></a> 3.数据同步</h1><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p><p><img src="../../../images/image-20210723214758392.png" alt="image-20210723214758392"></p><h2 id="31思路分析"><a class="markdownIt-Anchor" href="#31思路分析"></a> 3.1.思路分析</h2><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听binlog</li></ul><h3 id="311同步调用"><a class="markdownIt-Anchor" href="#311同步调用"></a> 3.1.1.同步调用</h3><p>方案一：同步调用</p><p><img src="../../../images/image-20210723214931869.png" alt="image-20210723214931869"></p><p>基本步骤如下：</p><ul><li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li></ul><h3 id="312异步通知"><a class="markdownIt-Anchor" href="#312异步通知"></a> 3.1.2.异步通知</h3><p>方案二：异步通知</p><p><img src="../../../images/image-20210723215140735.png" alt="image-20210723215140735"></p><p>流程如下：</p><ul><li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li><li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li></ul><h3 id="313监听binlog"><a class="markdownIt-Anchor" href="#313监听binlog"></a> 3.1.3.监听binlog</h3><p>方案三：监听binlog</p><p><img src="../../../images/image-20210723215518541.png" alt="image-20210723215518541"></p><p>流程如下：</p><ul><li>给mysql开启binlog功能</li><li>mysql完成增、删、改操作都会记录在binlog中</li><li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li></ul><h3 id="314选择"><a class="markdownIt-Anchor" href="#314选择"></a> 3.1.4.选择</h3><p>方式一：同步调用</p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务耦合度高</li></ul><p>方式二：异步通知</p><ul><li>优点：低耦合，实现难度一般</li><li>缺点：依赖mq的可靠性</li></ul><p>方式三：监听binlog</p><ul><li>优点：完全解除服务间耦合</li><li>缺点：开启binlog增加数据库负担、实现复杂度高</li></ul><h2 id="32实现数据同步"><a class="markdownIt-Anchor" href="#32实现数据同步"></a> 3.2.实现数据同步</h2><h3 id="321思路"><a class="markdownIt-Anchor" href="#321思路"></a> 3.2.1.思路</h3><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h3 id="322导入demo"><a class="markdownIt-Anchor" href="#322导入demo"></a> 3.2.2.导入demo</h3><p>导入课前资料提供的hotel-admin项目：</p><p><img src="../../../images/image-20210723220237930.png" alt="image-20210723220237930"></p><p>运行后，访问 <a href="http://localhost:8099">http://localhost:8099</a></p><p><img src="../../../images/image-20210723220354464.png" alt="image-20210723220354464"></p><p>其中包含了酒店的CRUD功能：</p><p><img src="../../../images/image-20210723220511090.png" alt="image-20210723220511090"></p><h3 id="323声明交换机-队列"><a class="markdownIt-Anchor" href="#323声明交换机-队列"></a> 3.2.3.声明交换机、队列</h3><p>MQ结构如图：</p><p><img src="../../../images/image-20210723215850307.png" alt="image-20210723215850307"></p><h4 id="1引入依赖"><a class="markdownIt-Anchor" href="#1引入依赖"></a> 1）引入依赖</h4><p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2声明队列交换机名称"><a class="markdownIt-Anchor" href="#2声明队列交换机名称"></a> 2）声明队列交换机名称</h4><p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constatnts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstants</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"hotel.topic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.insert.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.delete.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">"hotel.insert"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_KEY</span> <span class="operator">=</span> <span class="string">"hotel.delete"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3声明队列交换机"><a class="markdownIt-Anchor" href="#3声明队列交换机"></a> 3）声明队列交换机</h4><p>在hotel-demo中，定义配置类，声明队列、交换机：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="324发送mq消息"><a class="markdownIt-Anchor" href="#324发送mq消息"></a> 3.2.4.发送MQ消息</h3><p>在hotel-admin中的增、删、改业务中分别发送MQ消息：</p><p><img src="../../../images/image-20210723221843816.png" alt="image-20210723221843816"></p><h3 id="325接收mq消息"><a class="markdownIt-Anchor" href="#325接收mq消息"></a> 3.2.5.接收MQ消息</h3><p>hotel-demo接收到MQ消息要做的事情包括：</p><ul><li>新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库</li><li>删除消息：根据传递的hotel的id删除索引库中的一条数据</li></ul><p>1）首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中新增新增、删除业务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></tbody></table></figure><p>2）给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中实现业务：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">"hotel"</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">"hotel"</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3）编写监听器</p><p>在hotel-demo中的<code>cn.itcast.hotel.mq</code>包新增一个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4集群"><a class="markdownIt-Anchor" href="#4集群"></a> 4.集群</h1><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica ）</li></ul><p><strong>ES集群相关概念</strong>:</p><ul><li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p></li><li><p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p></li><li><p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p><p>解决问题：数据量太大，单点存储量有限的问题。</p><p><img src="../../../images/image-20200104124440086-5602723.png" alt="image-20200104124440086"></p><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote></li><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p><p>​</p></li></ul><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="../../../images/image-20200104124551912.png" alt="image-20200104124551912"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li>node0：保存了分片0和1</li><li>node1：保存了分片0和2</li><li>node2：保存了分片1和2</li></ul><h2 id="41搭建es集群"><a class="markdownIt-Anchor" href="#41搭建es集群"></a> 4.1.搭建ES集群</h2><p>参考课前资料的文档：</p><p><img src="../../../images/image-20210723222732427.png" alt="image-20210723222732427"></p><p>其中的第四章节：</p><p><img src="../../../images/image-20210723222812619.png" alt="image-20210723222812619"></p><h2 id="42集群脑裂问题"><a class="markdownIt-Anchor" href="#42集群脑裂问题"></a> 4.2.集群脑裂问题</h2><h3 id="421集群职责划分"><a class="markdownIt-Anchor" href="#421集群职责划分"></a> 4.2.1.集群职责划分</h3><p>elasticsearch中集群节点有不同的职责划分：</p><p><img src="../../../images/image-20210723223008967.png" alt="image-20210723223008967"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master节点：对CPU要求高，但是内存要求第</li><li>data节点：对CPU和内存要求都高</li><li>coordinating节点：对网络带宽、CPU要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的es集群职责划分如图：</p><p><img src="../../../images/image-20210723223629142.png" alt="image-20210723223629142"></p><h3 id="422脑裂问题"><a class="markdownIt-Anchor" href="#422脑裂问题"></a> 4.2.2.脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="../../../images/image-20210723223804995.png" alt="image-20210723223804995"></p><p>此时，node2和node3认为node1宕机，就会重新选主：</p><p><img src="../../../images/image-20210723223845754.png" alt="image-20210723223845754"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="../../../images/image-20210723224000555.png" alt="image-20210723224000555"></p><p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="423小结"><a class="markdownIt-Anchor" href="#423小结"></a> 4.2.3.小结</h3><p>master eligible节点的作用是什么？</p><ul><li>参与集群选主</li><li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li></ul><p>data节点的作用是什么？</p><ul><li>数据的CRUD</li></ul><p>coordinator节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="43集群分布式存储"><a class="markdownIt-Anchor" href="#43集群分布式存储"></a> 4.3.集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p><h3 id="431分片存储测试"><a class="markdownIt-Anchor" href="#431分片存储测试"></a> 4.3.1.分片存储测试</h3><p>插入三条数据：</p><p><img src="../../../images/image-20210723225006058.png" alt="image-20210723225006058"></p><p><img src="../../../images/image-20210723225034637.png" alt="image-20210723225034637"></p><p><img src="../../../images/image-20210723225112029.png" alt="image-20210723225112029"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="../../../images/image-20210723225227928.png" alt="image-20210723225227928"></p><p>结果：</p><p><img src="../../../images/image-20210723225342120.png" alt="image-20210723225342120"></p><h3 id="432分片存储原理"><a class="markdownIt-Anchor" href="#432分片存储原理"></a> 4.3.2.分片存储原理</h3><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><p><img src="../../../images/image-20210723224354904.png" alt="image-20210723224354904"></p><p>说明：</p><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="../../../images/image-20210723225436084.png" alt="image-20210723225436084"></p><p>解读：</p><ul><li>1）新增一个id=1的文档</li><li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li><li>3）shard-2的主分片在node3节点，将数据路由到node3</li><li>4）保存文档</li><li>5）同步给shard-2的副本replica-2，在node2节点</li><li>6）返回结果给coordinating-node节点</li></ul><h2 id="44集群分布式查询"><a class="markdownIt-Anchor" href="#44集群分布式查询"></a> 4.4.集群分布式查询</h2><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="../../../images/image-20210723225809848.png" alt="image-20210723225809848"></p><h2 id="45集群故障转移"><a class="markdownIt-Anchor" href="#45集群故障转移"></a> 4.5.集群故障转移</h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="../../../images/image-20210723225945963.png" alt="image-20210723225945963"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p>2）突然，node1发生了故障：</p><p><img src="../../../images/image-20210723230020574.png" alt="image-20210723230020574"></p><p>宕机后的第一件事，需要重新选主，例如选中了node2：</p><p><img src="../../../images/image-20210723230055974.png" alt="image-20210723230055974"></p><p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p><p><img src="../../../images/image-20210723230216642.png" alt="image-20210723230216642"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-Elasticsearch</title>
      <link href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/"/>
      <url>/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎02"><a class="markdownIt-Anchor" href="#分布式搜索引擎02"></a> 分布式搜索引擎02</h1><p>在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p><p>所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p><h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1><h1 id="1dsl查询文档"><a class="markdownIt-Anchor" href="#1dsl查询文档"></a> 1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p><h2 id="11dsl查询分类"><a class="markdownIt-Anchor" href="#11dsl查询分类"></a> 1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p></li><li><p><strong>全文检索（full text）查询</strong>：<mark>利用分词器对用户输入<strong>内容分词</strong>，然后去<strong>倒排索引库</strong>中匹配</mark>。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询类型"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询条件"</span><span class="punctuation">:</span>&nbsp;<span class="string">"条件值"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h2 id="12全文检索查询"><a class="markdownIt-Anchor" href="#12全文检索查询"></a> 1.2.全文检索查询</h2><h3 id="121使用场景"><a class="markdownIt-Anchor" href="#121使用场景"></a> 1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p><p><img src="../../../images/image-20210721165326938.png" alt="image-20210721165326938"></p><p>因为是拿着词条去匹配，因此<font color="red">参与搜索的字段也必须是可分词的text类型</font>的字段。</p><h3 id="122基本语法"><a class="markdownIt-Anchor" href="#122基本语法"></a> 1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"multi_match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"FIELD1"</span><span class="punctuation">,</span>&nbsp;<span class="string">" FIELD12"</span><span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="123示例"><a class="markdownIt-Anchor" href="#123示例"></a> 1.2.3.示例</h3><p>match查询示例：</p><p><img src="../../../images/image-20210721170455419.png" alt="image-20210721170455419"></p><p>multi_match查询示例：</p><p><img src="../../../images/image-20210721170720691.png" alt="image-20210721170720691"></p><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p><p>但是，<strong>搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</strong></p><h3 id="124总结"><a class="markdownIt-Anchor" href="#124总结"></a> 1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h2 id="13精准查询"><a class="markdownIt-Anchor" href="#13精准查询"></a> 1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h3 id="131term查询"><a class="markdownIt-Anchor" href="#131term查询"></a> 1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;term查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"value"</span><span class="punctuation">:</span>&nbsp;<span class="string">"VALUE"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="../../../images/image-20210721171655308.png" alt="image-20210721171655308"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="../../../images/image-20210721171838378.png" alt="image-20210721171838378"></p><h3 id="132range查询"><a class="markdownIt-Anchor" href="#132range查询"></a> 1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;range查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p><img src="../../../images/image-20210721172307172.png" alt="image-20210721172307172"></p><h3 id="133总结"><a class="markdownIt-Anchor" href="#133总结"></a> 1.3.3.总结</h3><p>精确查询常见的有哪些？</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h2 id="14地理坐标查询"><a class="markdownIt-Anchor" href="#14地理坐标查询"></a> 1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><p>附近的酒店：</p><p><img src="../../../images/image-20210721172645103.png" alt="image-20210721172645103"></p><p>附近的车：</p><p><img src="../../../images/image-20210721172654880.png" alt="image-20210721172654880"></p><h3 id="141矩形范围查询"><a class="markdownIt-Anchor" href="#141矩形范围查询"></a> 1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p><p><img src="../../../images/DKV9HZbVS6.gif" alt="DKV9HZbVS6"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_bounding_box查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_bounding_box"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"top_left"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 左上点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.5</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bottom_right"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 右下点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.7</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。</p><h3 id="142附近查询"><a class="markdownIt-Anchor" href="#142附近查询"></a> 1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/vZrdKAh19C.gif" alt="vZrdKAh19C"></p><p>语法说明：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_distance 查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_distance"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"distance"</span><span class="punctuation">:</span>&nbsp;<span class="string">"15km"</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"31.21,121.5"</span> <span class="comment">// 圆心</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="../../../images/image-20210721175443234.png" alt="image-20210721175443234"></p><p>发现共有47家酒店。</p><p>然后把半径缩短到3公里：</p><p><img src="../../../images/image-20210721182031475.png" alt="image-20210721182031475"></p><p>可以发现，搜索到的酒店数量减少到了5家。</p><h2 id="15复合查询"><a class="markdownIt-Anchor" href="#15复合查询"></a> 1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="151相关性算分"><a class="markdownIt-Anchor" href="#151相关性算分"></a> 1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"虹桥如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"外滩如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"迪士尼如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="../../../images/image-20210721190152134.png" alt="image-20210721190152134"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="../../../images/image-20210721190416214.png" alt="image-20210721190416214"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="../../../images/image-20210721190907320.png" alt="image-20210721190907320"></p><p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><h3 id="152算分函数查询"><a class="markdownIt-Anchor" href="#152算分函数查询"></a> 1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p><p><img src="../../../images/image-20210721191144560.png" alt="image-20210721191144560"></p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><h4 id="1语法说明"><a class="markdownIt-Anchor" href="#1语法说明"></a> 1）语法说明</h4><p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><h4 id="2示例"><a class="markdownIt-Anchor" href="#2示例"></a> 2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand = “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"function_score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>  .... <span class="punctuation">}</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"functions"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span>&nbsp;<span class="comment">//&nbsp;算分函数</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;满足的条件，品牌必须是如家</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"weight"</span><span class="punctuation">:</span>&nbsp;<span class="number">2</span>&nbsp;<span class="comment">//&nbsp;算分权重为2</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"boost_mode"</span><span class="punctuation">:</span> <span class="string">"sum"</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="../../../images/image-20210721193152520.png" alt="image-20210721193152520"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721193458182.png" alt="image-20210721193458182"></p><h4 id="3小结"><a class="markdownIt-Anchor" href="#3小结"></a> 3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><h3 id="153布尔查询"><a class="markdownIt-Anchor" href="#153布尔查询"></a> 1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p><p><img src="../../../images/image-20210721193822848.png" alt="image-20210721193822848"></p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p><p>需要注意的是，搜索时，参与**<mark>打分的字段越多，查询的性能也越差</mark>**。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><h4 id="1语法示例"><a class="markdownIt-Anchor" href="#1语法示例"></a> 1）语法示例：</h4><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bool"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"city"</span><span class="punctuation">:</span>&nbsp;<span class="string">"上海"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"should"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"皇冠假日"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"华美达"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must_not"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">500</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">45</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2示例-2"><a class="markdownIt-Anchor" href="#2示例-2"></a> 2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li><li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li><li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li></ul><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721194744183.png" alt="image-20210721194744183"></p><h4 id="3小结-2"><a class="markdownIt-Anchor" href="#3小结-2"></a> 3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h1 id="2搜索结果处理"><a class="markdownIt-Anchor" href="#2搜索结果处理"></a> 2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h2 id="21排序"><a class="markdownIt-Anchor" href="#21排序"></a> 2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><h3 id="211普通字段排序"><a class="markdownIt-Anchor" href="#211普通字段排序"></a> 2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span> </span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"desc"</span>&nbsp;&nbsp;<span class="comment">//&nbsp;排序字段、排序方式ASC、DESC</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p><p><img src="../../../images/image-20210721195728306.png" alt="image-20210721195728306"></p><h3 id="212地理坐标排序"><a class="markdownIt-Anchor" href="#212地理坐标排序"></a> 2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span> <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="../../../images/image-20210721200214690.png" alt="image-20210721200214690"></p><h2 id="22分页"><a class="markdownIt-Anchor" href="#22分页"></a> 2.2.分页</h2><p><strong>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了</strong>。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><h3 id="221基本的分页"><a class="markdownIt-Anchor" href="#221基本的分页"></a> 2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="222深度分页问题"><a class="markdownIt-Anchor" href="#222深度分页问题"></a> 2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">990</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p><p><img src="../../../images/image-20210721200643029.png" alt="image-20210721200643029"></p><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p><p><img src="../../../images/image-20210721201003229.png" alt="image-20210721201003229"></p><p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li><mark>search after</mark>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><h3 id="223小结"><a class="markdownIt-Anchor" href="#223小结"></a> 2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h2 id="23高亮"><a class="markdownIt-Anchor" href="#23高亮"></a> 2.3.高亮</h2><h3 id="231高亮原理"><a class="markdownIt-Anchor" href="#231高亮原理"></a> 2.3.1.高亮原理</h3><p>什么是高亮显示呢？</p><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p><p><img src="../../../images/image-20210721202705030.png" alt="image-20210721202705030"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><h3 id="232实现高亮"><a class="markdownIt-Anchor" href="#232实现高亮"></a> 2.3.2.实现高亮</h3><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"highlight"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;指定要高亮的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"pre_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;em&gt;"</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的前置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"post_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;/em&gt;"</span>&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的后置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul><p><strong>示例</strong>：</p><p><img src="../../../images/image-20210721203349633.png" alt="image-20210721203349633"></p><h2 id="24总结"><a class="markdownIt-Anchor" href="#24总结"></a> 2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：</p><p><img src="../../../images/image-20210721203657850.png" alt="image-20210721203657850"></p><h1 id="3restclient查询文档"><a class="markdownIt-Anchor" href="#3restclient查询文档"></a> 3.RestClient查询文档</h1><p>文档的查询同样适用前面学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul><h2 id="31快速入门"><a class="markdownIt-Anchor" href="#31快速入门"></a> 3.1.快速入门</h2><p>我们以match_all查询为例</p><h3 id="311发起查询请求"><a class="markdownIt-Anchor" href="#311发起查询请求"></a> 3.1.1.发起查询请求</h3><p><img src="../../../images/image-20210721203950559.png" alt="image-20210721203950559"></p><p>代码解读：</p><ul><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<font color="red"><code>request.source()</code></font>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p><p><img src="../../../images/image-20210721215640790.png" alt="image-20210721215640790"></p><p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p><p><img src="../../../images/image-20210721215729236.png" alt="image-20210721215729236"></p><h3 id="312解析响应"><a class="markdownIt-Anchor" href="#312解析响应"></a> 3.1.2.解析响应</h3><p>响应结果的解析：</p><p><img src="../../../images/image-20210721214221057.png" alt="image-20210721214221057"></p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h3 id="313完整代码"><a class="markdownIt-Anchor" href="#313完整代码"></a> 3.1.3.完整代码</h3><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="314小结"><a class="markdownIt-Anchor" href="#314小结"></a> 3.1.4.小结</h3><p>查询的基本步骤是：</p><ol><li><p>创建SearchRequest对象</p></li><li><p>准备Request.source()，也就是DSL。</p><p>① QueryBuilders来构建查询条件</p><p>② 传入Request.source() 的 query() 方法</p></li><li><p>发送请求，得到结果</p></li><li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p></li></ol><h2 id="32match查询"><a class="markdownIt-Anchor" href="#32match查询"></a> 3.2.match查询</h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p><img src="../../../images/image-20210721215923060.png" alt="image-20210721215923060"></p><p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p><p><img src="../../../images/image-20210721215843099.png" alt="image-20210721215843099"></p><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="33精确查询"><a class="markdownIt-Anchor" href="#33精确查询"></a> 3.3.精确查询</h2><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p>查询条件构造的API如下：</p><p><img src="../../../images/image-20210721220305140.png" alt="image-20210721220305140"></p><h2 id="34布尔查询"><a class="markdownIt-Anchor" href="#34布尔查询"></a> 3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="../../../images/image-20210721220927286.png" alt="image-20210721220927286"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">"city"</span>, <span class="string">"杭州"</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">"price"</span>).lte(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="35排序-分页"><a class="markdownIt-Anchor" href="#35排序-分页"></a> 3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p><p>对应的API如下：</p><p><img src="../../../images/image-20210721221121266.png" alt="image-20210721221121266"></p><p>完整代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">"price"</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="36高亮"><a class="markdownIt-Anchor" href="#36高亮"></a> 3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li><li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li></ul><h3 id="361高亮请求构建"><a class="markdownIt-Anchor" href="#361高亮请求构建"></a> 3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：</p><p><img src="../../../images/image-20210721221744883.png" alt="image-20210721221744883"></p><p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">"name"</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="362高亮结果解析"><a class="markdownIt-Anchor" href="#362高亮结果解析"></a> 3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="../../../images/image-20210721222057212.png" alt="image-20210721222057212"></p><p>代码解读：</p><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) {</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4黑马旅游案例"><a class="markdownIt-Anchor" href="#4黑马旅游案例"></a> 4.黑马旅游案例</h1><p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。</p><p>我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8090">http://localhost:8090</a>，就能看到项目页面了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721223159598.png" alt="image-20210721223159598"></p><h2 id="41酒店搜索和分页"><a class="markdownIt-Anchor" href="#41酒店搜索和分页"></a> 4.1.酒店搜索和分页</h2><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p><h3 id="411需求分析"><a class="markdownIt-Anchor" href="#411需求分析"></a> 4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：</p><p><img src="../../../images/image-20210721223859419.png" alt="image-20210721223859419"></p><p>点击搜索按钮，可以看到浏览器控制台发出了请求：</p><p><img src="../../../images/image-20210721224033789.png" alt="image-20210721224033789"></p><p>请求参数如下：</p><p><img src="../../../images/image-20210721224112708.png" alt="image-20210721224112708"></p><p>由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：/hotel/list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li>步骤一：定义实体类，接收请求参数的JSON对象</li><li>步骤二：编写controller，接收页面的请求</li><li>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页</li></ul><h3 id="412定义实体类"><a class="markdownIt-Anchor" href="#412定义实体类"></a> 4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p><p>1）请求参数</p><p>前端请求的json结构如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"key"</span><span class="punctuation">:</span> <span class="string">"搜索关键字"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"page"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"size"</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sortBy"</span><span class="punctuation">:</span> <span class="string">"default"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2）返回值</p><p>分页查询，需要返回分页结果PageResult，包含两个属性：</p><ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> {</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> {</span><br><span class="line">        <span class="built_in">this</span>.total = total;</span><br><span class="line">        <span class="built_in">this</span>.hotels = hotels;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="413定义controller"><a class="markdownIt-Anchor" href="#413定义controller"></a> 4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：/hotel/list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/hotel")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping("/list")</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="414实现搜索业务"><a class="markdownIt-Anchor" href="#414实现搜索业务"></a> 4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。</p><p>1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestHighLevelClient <span class="title function_">client</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">    ));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="keyword">private</span> PageResult <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line"><span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, hotels);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="42酒店结果过滤"><a class="markdownIt-Anchor" href="#42酒店结果过滤"></a> 4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能</p><h3 id="421需求分析"><a class="markdownIt-Anchor" href="#421需求分析"></a> 4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：</p><p><img src="../../../images/image-20210722091940726.png" alt="image-20210722091940726"></p><p>传递的参数如图：</p><p><img src="../../../images/image-20210722092051994.png" alt="image-20210722092051994"></p><p>包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li>修改请求参数的对象RequestParams，接收上述参数</li><li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li></ul><h3 id="422修改实体类"><a class="markdownIt-Anchor" href="#422修改实体类"></a> 4.2.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="423修改搜索业务"><a class="markdownIt-Anchor" href="#423修改搜索业务"></a> 4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。</p><p>在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p><ul><li>品牌过滤：是keyword类型，用term查询</li><li>星级过滤：是keyword类型，用term查询</li><li>价格过滤：是数值类型，用range查询</li><li>城市过滤：是keyword类型，用term查询</li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：</p><p><img src="../../../images/image-20210722092935453.png" alt="image-20210722092935453"></p><p>buildBasicQuery的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="43我周边的酒店"><a class="markdownIt-Anchor" href="#43我周边的酒店"></a> 4.3.我周边的酒店</h2><p>需求：我附近的酒店</p><h3 id="431需求分析"><a class="markdownIt-Anchor" href="#431需求分析"></a> 4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：</p><p><img src="../../../images/image-20210722093414542.png" alt="image-20210722093414542"></p><p>并且，在前端会发起查询请求，将你的坐标发送到服务端：</p><p><img src="../../../images/image-20210722093642382.png" alt="image-20210722093642382"></p><p>我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li>修改RequestParams参数，接收location字段</li><li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li></ul><h3 id="432修改实体类"><a class="markdownIt-Anchor" href="#432修改实体类"></a> 4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="433距离排序api"><a class="markdownIt-Anchor" href="#433距离排序api"></a> 4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p><ul><li>普通字段排序</li><li>地理坐标排序</li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"> &nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span>&nbsp;&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>对应的java代码示例：</p><p><img src="../../../images/image-20210722095227059.png" alt="image-20210722095227059"></p><h3 id="434添加距离排序"><a class="markdownIt-Anchor" href="#434添加距离排序"></a> 4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p><p><img src="../../../images/image-20210722095902314.png" alt="image-20210722095902314"></p><p>完整代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="literal">null</span> &amp;&amp; !location.equals(<span class="string">""</span>)) {</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">"location"</span>, <span class="keyword">new</span> <span class="title class_">GeoPoint</span>(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="435排序距离显示"><a class="markdownIt-Anchor" href="#435排序距离显示"></a> 4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100040674.png" alt="image-20210722100040674"></p><p>发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？</p><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p><p><img src="../../../images/image-20210722095648542.png" alt="image-20210722095648542"></p><p>因此，我们在结果解析阶段，除了解析source部分以外，还要得到<mark><strong>sort</strong></mark>部分，也就是排序的距离，然后放到响应结果中。</p><p>我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>2）修改HotelService中的handleResponse方法</p><p><img src="../../../images/image-20210722100613966.png" alt="image-20210722100613966"></p><p>重启后测试，发现页面能成功显示距离了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100838604.png" alt="image-20210722100838604"></p><h2 id="44酒店竞价排名"><a class="markdownIt-Anchor" href="#44酒店竞价排名"></a> 4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶</p><h3 id="441需求分析"><a class="markdownIt-Anchor" href="#441需求分析"></a> 4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：</p><p><img src="../../../images/image-20210722100947292.png" alt="image-20210722100947292"></p><p>页面会给指定的酒店添加<strong>广告</strong>标记。</p><p>那怎样才能让指定的酒店排名置顶呢？</p><p>我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。</p><p>比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li><p>给HotelDoc类添加isAD字段，Boolean类型</p></li><li><p>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</p></li><li><p>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</p></li></ol><h3 id="442修改hoteldoc实体"><a class="markdownIt-Anchor" href="#442修改hoteldoc实体"></a> 4.4.2.修改HotelDoc实体</h3><p>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：</p><p><img src="../../../images/image-20210722101908062.png" alt="image-20210722101908062"></p><h3 id="443添加广告标记"><a class="markdownIt-Anchor" href="#443添加广告标记"></a> 4.4.3.添加广告标记</h3><p>接下来，我们挑几个酒店，添加isAD字段，设置为true：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="444添加算分函数查询"><a class="markdownIt-Anchor" href="#444添加算分函数查询"></a> 4.4.4.添加算分函数查询</h3><p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p><p>function_score查询结构如下：</p><p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p><p>对应的JavaAPI如下：</p><p><img src="../../../images/image-20210722102850818.png" alt="image-20210722102850818"></p><p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p><p>修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    <span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQuery</span> <span class="operator">=</span></span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]{</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">"isAD"</span>, <span class="literal">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        });</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<hr><hr><h1 id="1-elasticsearch是什么"><a class="markdownIt-Anchor" href="#1-elasticsearch是什么"></a> 1、Elasticsearch是什么</h1><h2 id="11-概念"><a class="markdownIt-Anchor" href="#11-概念"></a> 1.1 概念:</h2><p>Elasticsearch是由 Java语言开发<strong>基于Lucene</strong>的一款开源的搜索、聚合分析和存储引擎。同时它也可以称作是一种非关系型文档数据库。</p><p><img src="../../images/image-20230305161034119.png" alt="image-20230305161034119"></p><h2 id="es可以替代mysql吗"><a class="markdownIt-Anchor" href="#es可以替代mysql吗"></a> ES可以替代MySQL吗？</h2><p>ElasticSearch和MySql分工不同，MySQL负责存储数据，ElasticSearch负责搜索数据</p><ul><li><p>MySQL有事务性，而ElasticSearch<mark>没有事务性</mark>，所以你<font color="red">删了的数据是无法恢复的</font>。</p></li><li><p>ElasticSearch<mark>没有物理外键</mark>这个特性，如果你的数据强一致性要求比较高还是建议慎用</p></li></ul><p><img src="../../images/image-20230305161337185.png" alt="image-20230305161337185"></p><h2 id="12特点"><a class="markdownIt-Anchor" href="#12特点"></a> 1.2特点</h2><ul><li>天生分布式、高性能（PB数据下可以秒读）、高可用、易扩展、易维护</li><li>跨语言、跨平台:几乎支持所有主流编程语言，并且支持在“Linux、Windows、MacOs”多平台部署</li><li>支持结构化、非结构化、地理位置搜索等</li></ul><h2 id="13适用场景"><a class="markdownIt-Anchor" href="#13适用场景"></a> 1.3适用场景</h2><ul><li>海量数据的全文检索，搜索引擎、垂直搜索、站内搜索:<ul><li>百度、知乎、微博、CSDN</li><li>导航、外卖、团购等软件</li><li>以京东、淘宝为代表的垂直搜索</li><li>B站、抖音、爱奇艺、QQ音乐等音视频软件Glthub</li></ul></li><li>数据分析和聚合查询.</li><li>日志系统 : ELK</li></ul><h1 id="elasticsearch核心概念"><a class="markdownIt-Anchor" href="#elasticsearch核心概念"></a> Elasticsearch核心概念</h1><p><img src="../../images/image-20230305161535075.png" alt="image-20230305161535075"></p><p><img src="../../images/image-20230305161817337.png" alt="image-20230305161817337"></p><p><img src="../../images/image-20230305162010287.png" alt="image-20230305162010287"></p><h1 id="mysql数据库查询存在的问题"><a class="markdownIt-Anchor" href="#mysql数据库查询存在的问题"></a> MySQL数据库查询存在的问题：</h1><p><img src="../../images/image-20230305153910496.png" alt="image-20230305153910496"></p><p><img src="../../images/image-20230305154253699.png" alt="image-20230305154253699"></p><h1 id="es的倒排索引"><a class="markdownIt-Anchor" href="#es的倒排索引"></a> ES的倒排索引</h1><p><img src="../../images/image-20230305154901840.png" alt="image-20230305154901840"></p><h1 id="elasticsearch数据的存储和搜索原理"><a class="markdownIt-Anchor" href="#elasticsearch数据的存储和搜索原理"></a> Elasticsearch数据的存储和搜索原理</h1><p><img src="../../images/image-20230305155606164.png" alt="image-20230305155606164"></p><p><img src="../../images/image-20230305155847211.png" alt="image-20230305155847211"></p><h3 id="1-解决性能低问题"><a class="markdownIt-Anchor" href="#1-解决性能低问题"></a> 1. 解决性能低问题：</h3><h4 id="如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"><a class="markdownIt-Anchor" href="#如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"></a> <strong>如果倒排索引中tearm词条太多不会导致一样要遍历很久吗？不会</strong></h4><p>因为ES生成的到排序索引中，词条会排序，形成一颗树形结构，提升词条的查询速度。</p><h3 id="2-解决功能弱问题"><a class="markdownIt-Anchor" href="#2-解决功能弱问题"></a> 2. 解决功能弱问题：</h3><p>ES会先对查询关键字进行分词，再进行查询。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty面试题</title>
      <link href="/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><h2 id="1-什么是-netty"><a class="markdownIt-Anchor" href="#1-什么是-netty"></a> 1、什么是 Netty？</h2><p>Netty 是由 JBOSS 提供的一个 Java 开源框架。Netty 提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序,是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</p><h2 id="2-netty-的优势"><a class="markdownIt-Anchor" href="#2-netty-的优势"></a> 2、Netty 的优势？</h2><ul><li><p>使用简单：封闭了 Java 原生 NIO 类库繁琐的 API，使用起来更加高效；</p></li><li><p>功能强大：预置多种编码能力，支持多种主流协议。同时通过 <mark>ChannelHandler</mark> 可以进行灵活的拓展，支持很强的定制能力；</p></li><li><p>高性能：与其它业界主流 NIO 框架相比，Netty 综合更优。主要体现在<mark>吞吐量更高、延迟更低、减少资源消耗以及最小化不必要的内存复制；</mark></p></li><li><p>社区活跃与稳定：版本更新周期短，BUG 修复速度快，让开发者可以专注业务本身。</p></li></ul><h2 id="3-netty-有什么特点"><a class="markdownIt-Anchor" href="#3-netty-有什么特点"></a> 3、Netty 有什么特点？</h2><ul><li><p><strong>高并发</strong>：Netty 是一款基于 NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架。</p></li><li><p><strong>传输快</strong>：Netty 使用零拷贝特性，尽量减少不必要的内存拷贝，实现更快的传输效率。</p></li><li><p><strong>封装好</strong>：Netty 封装了 NIO 操作的很多细节，提供易于使用的 API。</p></li></ul><h2 id="4-netty-有哪些应用场景"><a class="markdownIt-Anchor" href="#4-netty-有哪些应用场景"></a> 4、Netty 有哪些应用场景？</h2><p>理论上来说，NIO 可以做的事情，Netty 都可以做并且更好。Netty 主要用来做网络通信：</p><ul><li>RPC 框架的网络通信工具；</li><li>实现一个 HTTP 服务器；</li><li>实现一个即时通讯系统；</li><li>实现消息推送系统。</li></ul><h2 id="5-netty-的高性能体现在"><a class="markdownIt-Anchor" href="#5-netty-的高性能体现在"></a> 5、Netty 的高性能体现在？</h2><ul><li><strong>IO 线程模型</strong>：同步非阻塞；</li><li><strong>零拷贝</strong>：尽量做到不必要的内存拷贝：</li><li><strong>内存池设计</strong>：使用直接内存，并且可重复利用；</li><li><strong>串行化处理读写</strong>：避免使用锁带来的额外开销；</li><li><strong>高性能序列化协议</strong>：支持 protobuf 等高性能序列化协议。</li></ul><h2 id="6-相比原生-nio-的优势"><a class="markdownIt-Anchor" href="#6-相比原生-nio-的优势"></a> 6、相比原生 NIO 的优势？</h2><p>1）易用性：Netty 在 NIO 基础上封装了更加人性化的 API，大大降低开发人员的学习成本，同时还提供了很多开箱即用的工具。</p><p>2）稳定性：Netty 修复了 Java NIO 较多已知问题，如 select 空转导致 CPU 100%，TCP 断线重连，Keep-alive 检测等问题。</p><p>3）高性能：对象池复用（通过对象复用避免频繁创建和销毁带来的开销）和零拷贝技术。</p><h2 id="7-netty-和-tomcat-的区别"><a class="markdownIt-Anchor" href="#7-netty-和-tomcat-的区别"></a> 7、Netty 和 Tomcat 的区别？</h2><p>Netty 和 Tomcat 最大的区别在于对通信协议的支持：</p><ul><li><p>Tomcat 是基于 Http 协议的，本质是一个基于 http 协议的 web 容器，而 Netty 不仅支持 HTTP，还能通过编程自定义各种协议，通过 codec 自定义编码/解码字节流，完成数据传输。</p></li><li><p>Tomcat 需要遵循 Servlet 规范（HTTP 协议的请求-响应模型），而 Netty 不需要受到 Servlet 规范约束，可以发挥 NIO 最大特性。</p></li></ul><h2 id="8-bio-nio-aio-分别是什么"><a class="markdownIt-Anchor" href="#8-bio-nio-aio-分别是什么"></a> 8、BIO. NIO. AIO 分别是什么？</h2><ul><li><p><strong>BIO（同步阻塞 IO）</strong><br>服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK 1.4 以前的唯一选择，但程序直观简单易理解。</p></li><li><p><strong>NIO（同步非阻塞 IO）</strong><br>服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 IO 请求时才启动一个线程进行处理。NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK 1.4 开始支持。</p></li><li><p><strong>AIO（异步非阻塞 IO）</strong><br>服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK 1.7 开始支持。</p></li></ul><h2 id="9-select-poll-epoll-的区别"><a class="markdownIt-Anchor" href="#9-select-poll-epoll-的区别"></a> 9、Select、Poll、Epoll 的区别？</h2><p>ref</p><h2 id="10-什么是-reactor-模型"><a class="markdownIt-Anchor" href="#10-什么是-reactor-模型"></a> 10、什么是 Reactor 模型？</h2><h1 id="2-架构组件"><a class="markdownIt-Anchor" href="#2-架构组件"></a> 2 架构组件</h1><h2 id="1-netty-有哪些核心组件"><a class="markdownIt-Anchor" href="#1-netty-有哪些核心组件"></a> 1、Netty 有哪些核心组件？</h2><ul><li><p><strong>Channel</strong><br>基础的 IO 操作，如绑定、连接、读写等都依赖于底层网络传输所提供的原语，在 Java 的网络编程中，基础核心类是 Socket，而 Netty 的 Channel 提供了一组 API，极大地简化了直接与 Socket 进行操作的复杂性，并且 Channel 是很多类的父类，如 EmbeddedChannel、LocalServerChannel、NioDatagramChannel、NioSctpChannel、NioSocketChannel 等。</p></li><li><p><strong>EventLoop</strong><br>EventLoop 定义了处理在连接过程中发生的事件的核心抽象。</p></li></ul><p>​说白了，EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 IO 操作的处理。</p><p>​<strong>那 Channel 和 EventLoop 直接有啥联系呢？</strong></p><p>​Channel 为 Netty 网络操作（<strong>读写</strong>等操作）抽象类，EventLoop 负责处理注册到其上的 Channel 处理 IO 操作，两者配合参与 IO 操作。</p><ul><li><p><strong>ChannelFuture</strong></p><ul><li>由于 Netty 是异步非阻塞的，所有的 IO 操作也都为异步的，我们不能立刻得到操作是否执行成功，因此 Netty 提供 ChannelFuture 接口，使用其 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</li><li>并且，我们还可以通过 ChannelFuture 的 channel() 方法获取关联的Channel，甚至使用 sync() 方法让异步的操作变成同步的。</li></ul></li><li><p><strong>ChannelHandler 和 ChannelPipeline</strong></p><ul><li>从应用开发者看来，ChannelHandler 是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。ChannelHandler 的方法被网络事件触发，可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。如其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据。</li><li>ChannelPipeline为ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。当创建 Channel 时，会自动创建一个附属的 ChannelPipeline。</li></ul></li><li><p><strong>Bootstrap 和 ServerBootstrap</strong><br>Netty 的引导类应用程序网络层配置提供容器，其涉及将进程绑定到给定端口或连接一个进程到在指定主机上指定端口上运行的另一进程。引导类分为客户端引导 Bootstrap 和服务端引导 ServerBootstrap。</p></li></ul><h2 id="2-什么是-eventloop-和-eventloopgroup"><a class="markdownIt-Anchor" href="#2-什么是-eventloop-和-eventloopgroup"></a> 2、什么是 EventLoop 和 EventLoopGroup？</h2><p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程），上面我们已经说了 EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</p><p>并且 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p><p>上图是一个服务端对 EventLoopGroup 使用的大致模块图，其中 Boss EventloopGroup 用于接收连接，Worker EventloopGroup 用于具体的处理（消息的读写以及其他逻辑处理）。</p><p><img src="../../images/image-20230304103657806.png" alt="image-20230304103657806"></p><p>从上图可以看出：当客户端通过 connect 方法连接服务端时，bossGroup 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 workerGroup 来处理，然后 workerGroup 负责处理其 IO 相关操作。</p><h2 id="3-说说-netty-的线程模型"><a class="markdownIt-Anchor" href="#3-说说-netty-的线程模型"></a> 3、说说 Netty 的线程模型？</h2><p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。</p><ul><li><strong>单线程模型</strong><br>所有 IO 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求，向服务端发起连接，又要发送、读取请求或应答、响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、高并发的应用场景不合适。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">boobtstrap.group(eventGroup, eventGroup) </span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>多线程模型</strong><br>有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/1d2358f8e6484e0db5a574a4701960bf.png#pic_center" alt="在这里插入图片描述"></p><p>对于代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>主从多线程模型</strong><br>Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 IO 的读写等操作，从而保证主 Reactor 只负责接入认证、握手等操作。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</li></ul><p><img src="https://img-blog.csdnimg.cn/993566982c15443eb242cf628adc4d9b.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-netty-服务端的启动过程"><a class="markdownIt-Anchor" href="#4-netty-服务端的启动过程"></a> 4、Netty 服务端的启动过程？</h2><p>先来看一段代码实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap </span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  <span class="comment">// (非必备)打印日志  </span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 4.指定 IO 模型 </span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">         <span class="meta">@Override</span> </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> {</span><br><span class="line">             <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline(); </span><br><span class="line">             <span class="comment">//5.可以自定义客户端消息的业务处理逻辑 </span></span><br><span class="line">             p.addLast(<span class="keyword">new</span> <span class="title class_">HelloServerHandler</span>()); </span><br><span class="line">        } </span><br><span class="line">    }); </span><br><span class="line">    <span class="comment">// 6.绑定端口,调用 sync 方法阻塞知道绑定完成 </span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">    <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法) </span></span><br><span class="line">    f.channel().closeFuture().sync(); </span><br><span class="line">} <span class="keyword">finally</span> { </span><br><span class="line">    <span class="comment">//8.优雅关闭相关线程组资源 </span></span><br><span class="line">    bossGroup.shutdownGracefully(); </span><br><span class="line">    workerGroup.shutdownGracefully(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3 具体实现</h1><h2 id="1-netty-的无锁化体现在哪里"><a class="markdownIt-Anchor" href="#1-netty-的无锁化体现在哪里"></a> 1、Netty 的无锁化体现在哪里？</h2><p>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p><p><img src="https://img-blog.csdnimg.cn/1ed6fd9de8a64328806c5225edfc6bdb.png#pic_center" alt="在这里插入图片描述"></p><p>Netty 的 NioEventLoop 读取到消息后，直接调用 ChannelPipeline 的 fireChannelRead（Object msg），只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁竞争，从性能角度看是最优的。</p><h2 id="2-如何解决-jdk-epoll-空轮询问题"><a class="markdownIt-Anchor" href="#2-如何解决-jdk-epoll-空轮询问题"></a> 2、如何解决 JDK epoll 空轮询问题？</h2><p>这个 BUG 是指 Java 的 NIO 在 Linux 下进行 selector.select() 时，本来如果轮询的结果为空并且不调用 wakeup 方法的话，这个 selector.select() 应该是一直阻塞的，但是 Java 却会打破阻塞，继续执行，导致程序无限空转，造成 CPU 使用率 100%。（这个问题只存在 Linux 是因为 Linux 的 NIO 是基于 epoll 实现的，而 Java 实现的 epoll 存在 BUG，windows 下 NIO 基于 poll 就不存在此问题）</p><p><strong>Netty 的解决方案：</strong></p><p>为 Selector 的 select 操作设置超时时间，同时定义可以跳出阻塞的四种情况：</p><ul><li>有事件发生</li><li>wakeup</li><li>超时</li><li>空轮询 BUG</li></ul><p>而前两种返回值不为 0，可以跳出循环，超时有时间戳记录，所以每次空轮询，有专门的计数器进行 +1，如果空轮询的次数超过了 512 次（默认），就认为其触发了空轮询 BUG。</p><p>当触发 BUG 后，Netty 直接重建一个 Selector，将原来的 Channel 重新注册到新的 Selector 上，并将旧的 Selector 关掉。</p><h2 id="3-什么是拆包和粘包"><a class="markdownIt-Anchor" href="#3-什么是拆包和粘包"></a> 3、什么是拆包和粘包？</h2><p>TCP 是一个面向流的传输协议，所谓流，就是没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP <strong>粘包和拆包问题</strong>。</p><p>粘包和拆包是 TCP 网络编程中不可避免的，无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑 TCP 底层的粘包/拆包机制。</p><p><img src="https://img-blog.csdnimg.cn/6e67b9fbe3fa41e5b087e648a74c3af3.png#pic_center" alt="在这里插入图片描述"></p><p>数据从发送方到接收方需要经过操作系统的缓冲区，而造成粘包和拆包的主要原因就在这个缓冲区上。粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起，而拆包可以理解为发送的数据大于缓冲区，进行拆分处理。</p><p>详细来说，造成粘包和拆包的原因主要有以下三个：</p><p>1）应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p><p>2）进行 MSS 大小的 TCP 分段；</p><p>3）以太网帧的 payload 大于 MTU 进行 IP 分片。</p><h2 id="4-拆包粘包的解决方案"><a class="markdownIt-Anchor" href="#4-拆包粘包的解决方案"></a> 4、拆包粘包的解决方案？</h2><p>由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议可以归纳出以下解决方案：</p><p>1）消息长度固定，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息。</p><p>2）将特殊的分隔符作为消息的结束标志，如回车换行符。</p><p>3）通过在消息头中定义长度字段来标识消息的总长度。</p><h2 id="5-netty-如何解决拆包粘包"><a class="markdownIt-Anchor" href="#5-netty-如何解决拆包粘包"></a> 5、Netty 如何解决拆包粘包？</h2><p>相比粘包，拆包问题比较简单，用户可以自己定义自己的编码器进行处理，Netty 并没有提供相应的组件。对于粘包的问题，代码比较繁琐，Netty 提供了 4 种解码器来解决，分别如下：</p><ul><li><strong>固定长度的拆包器</strong>（FixedLengthFrameDecoder），每个应用层数据包的都拆分成都是固定长度的大小；</li><li><strong>行拆包器</strong>（LineBasedFrameDecoder），每个应用层数据包都以换行符作为分隔符，进行分割拆分；</li><li>**分隔符拆包器(**DelimiterBasedFrameDecoder），每个应用层数据包，都通过自定义的分隔符，进行分割拆分；</li><li><strong>基于数据包长度的拆包器</strong>（LengthFieldBasedFrameDecoder），将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度。</li></ul><h2 id="6-netty-零拷贝体现在哪里"><a class="markdownIt-Anchor" href="#6-netty-零拷贝体现在哪里"></a> 6、Netty 零拷贝体现在哪里？</h2><p>Zero-copy 就是在操作数据时, 不需要将数据 buffer从 一个内存区域拷贝到另一个内存区域。 少了一次内存的拷贝，CPU 效率就得到的提升。</p><ul><li><p>接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝；</p></li><li><p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作；</p></li><li><p>文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p></li></ul><p><strong>和操作系统上的零拷贝的区别？</strong></p><p>Netty 的 Zero-copy 完全是在用户态（Java 应用层）的, 更多的偏向于优化数据操作。而在 OS 层面上的 Zero-copy 通常指避免在用户态（User-space）与内核态（Kernel-space）之间来回拷贝数据。</p><h2 id="7-tcp-的长连接和短连接"><a class="markdownIt-Anchor" href="#7-tcp-的长连接和短连接"></a> 7、TCP 的长连接和短连接？</h2><p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p><p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p><p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p><h2 id="8-netty-长连接-心跳机制了解么"><a class="markdownIt-Anchor" href="#8-netty-长连接-心跳机制了解么"></a> 8、Netty 长连接、心跳机制了解么？</h2><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入<strong>心跳机制</strong>。</p><p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互（即处于 idle 状态）时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 <font color="red">PING-PONG</font> 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性。</p><p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<font color="red">SO_KEEPALIVE</font>。但 TCP 协议层面的长连接灵活性不够，所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。</p><h2 id="9-说说-netty-的对象池技术"><a class="markdownIt-Anchor" href="#9-说说-netty-的对象池技术"></a> 9、说说 Netty 的对象池技术？</h2><p>对象池其实就是缓存一些对象从而避免大量创建同一个类型的对象，类似线程池的概念。对象池缓存了一些已经创建好的对象，避免需要时才创建对象，同时限制了实例的个数。池化技术最终要的就是重复的使用池内已经创建的对象。从上面的内容就可以看出对象池适用于以下几个场景：</p><ul><li>创建对象的开销大；</li><li>会创建大量的实例；</li><li>限制一些资源的使用。</li></ul><p>Netty 自己实现了一套轻量级的对象池。在 Netty 中，通常会有多个 IO 线程独立工作（基于 NioEventLoop 实现）。每个 IO 线程轮询单独的 Selector 实例来检索 IO 事件，并在 IO 来临时开始处理。最常见的 IO 操作就是读写，具体到 NIO 就是从内核缓冲区拷贝数据到用户缓冲区或者从用户缓冲区拷贝数据到内核缓冲区。这里会涉及到大量的创建和回收 Buffer， Netty 对 Buffer 进行了池化从而降低系统开销。</p><p>ref</p><h2 id="10-有哪些序列化协议"><a class="markdownIt-Anchor" href="#10-有哪些序列化协议"></a> 10 有哪些序列化协议？</h2><p><strong>序列化</strong>（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p><p><strong>目前几种主流协议</strong></p><ul><li><p><strong>Java 默认提供的序列化</strong><br>无法跨语言、序列化后的码流太大、序列化的性能差。</p></li><li><p><strong>XML</strong><br>优点是人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p></li><li><p><strong>JSON</strong><br>是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p></li><li><p><strong>Fastjson</strong><br>采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端。</p></li><li><p><strong>Thrift</strong><br>不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案。</p></li><li><p><strong>Avro</strong><br>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p></li><li><p><strong>Protobuf</strong><br>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot面试题</title>
      <link href="/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="spring-boot面试题总结最全面的面试题"><a class="markdownIt-Anchor" href="#spring-boot面试题总结最全面的面试题"></a> Spring Boot面试题（总结最全面的面试题！！！）</h1><p>2020年04月13日</p><blockquote><p>Java面试总结汇总，整理了包括Java重点知识，以及常用开源框架，欢迎大家阅读。文章可能有错误的地方，因为个人知识有限，欢迎各位大佬指出！文章持续更新中…</p></blockquote><blockquote><table><thead><tr><th>ID</th><th>标题</th><th>地址</th></tr></thead><tbody><tr><td>1</td><td>设计模式面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125721772039">juejin.cn/post/684490…</a></td></tr><tr><td>2</td><td>Java基础知识面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738631">juejin.cn/post/684490…</a></td></tr><tr><td>3</td><td>Java集合面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125939843079">juejin.cn/post/684490…</a></td></tr><tr><td>4</td><td>JavaIO、BIO、NIO、AIO、Netty面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125700784136">juejin.cn/post/684490…</a></td></tr><tr><td>5</td><td>Java并发编程面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125755293710">juejin.cn/post/684490…</a></td></tr><tr><td>6</td><td>Java异常面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904128959741965">juejin.cn/post/684490…</a></td></tr><tr><td>7</td><td>Java虚拟机（JVM）面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125696573448">juejin.cn/post/684490…</a></td></tr><tr><td>8</td><td>Spring面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127051513864">juejin.cn/post/684490…</a></td></tr><tr><td>9</td><td>Spring MVC面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722253">juejin.cn/post/684490…</a></td></tr><tr><td>10</td><td>Spring Boot面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125709156359">juejin.cn/post/684490…</a></td></tr><tr><td>11</td><td>Spring Cloud面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125717544973">juejin.cn/post/684490…</a></td></tr><tr><td>12</td><td>Redis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127055527950">juejin.cn/post/684490…</a></td></tr><tr><td>13</td><td>MyBatis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935648776">juejin.cn/post/684490…</a></td></tr><tr><td>14</td><td>MySQL面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127047139335">juejin.cn/post/684490…</a></td></tr><tr><td>15</td><td>TCP、UDP、Socket、HTTP面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125692379143">juejin.cn/post/684490…</a></td></tr><tr><td>16</td><td>Nginx面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125784653837">juejin.cn/post/684490…</a></td></tr><tr><td>17</td><td>ElasticSearch面试题</td><td></td></tr><tr><td>18</td><td>kafka面试题</td><td></td></tr><tr><td>19</td><td>RabbitMQ面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935665160">juejin.cn/post/684490…</a></td></tr><tr><td>20</td><td>Dubbo面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499463">juejin.cn/post/684490…</a></td></tr><tr><td>21</td><td>ZooKeeper面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499464">juejin.cn/post/684490…</a></td></tr><tr><td>22</td><td>Netty面试题（总结最全面的面试题）</td><td></td></tr><tr><td>23</td><td>Tomcat面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722247">juejin.cn/post/684490…</a></td></tr><tr><td>24</td><td>Linux面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738637">juejin.cn/post/684490…</a></td></tr><tr><td>25</td><td>互联网相关面试题（总结最全面的面试题）</td><td></td></tr><tr><td>26</td><td>互联网安全面试题（总结最全面的面试题）</td><td></td></tr></tbody></table></blockquote><h3 id="什么是-spring-boot"><a class="markdownIt-Anchor" href="#什么是-spring-boot"></a> 什么是 Spring Boot？</h3><ul><li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li></ul><h3 id="为什么要用springboot"><a class="markdownIt-Anchor" href="#为什么要用springboot"></a> 为什么要用SpringBoot</h3><ul><li>快速开发，快速整合，配置简化、内嵌服务容器</li></ul><h3 id="springboot与springcloud-区别"><a class="markdownIt-Anchor" href="#springboot与springcloud-区别"></a> SpringBoot与SpringCloud 区别</h3><ul><li>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</li></ul><h3 id="spring-boot-有哪些优点"><a class="markdownIt-Anchor" href="#spring-boot-有哪些优点"></a> Spring Boot 有哪些优点？</h3><ul><li>Spring Boot 主要有如下优点：<ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li><li>快速轻松地开发基于 Spring 的应用程序；</li><li>无需部署war文件；</li><li>创建独立应用程序的能力；</li><li>帮助将 Tomcat、Jetty 或 Undertow 直接嵌入到应用程序中；</li><li>无需XML配置；</li><li>减少源代码数量；</li><li>额外的开箱即用功能；</li><li>轻松启动；</li><li>简单的设置和管理；</li></ol></li></ul><h3 id="spring-boot-的核心注解是哪个它主要由哪几个注解组成的"><a class="markdownIt-Anchor" href="#spring-boot-的核心注解是哪个它主要由哪几个注解组成的"></a> Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><ul><li>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<ul><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：<code>java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</code></li><li>@ComponentScan：Spring组件扫描。</li></ul></li></ul><h3 id="spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"><a class="markdownIt-Anchor" href="#spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"></a> Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h3><ul><li>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</li></ul><h3 id="spring-boot-中的-starter-到底是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的-starter-到底是什么"></a> Spring Boot 中的 starter 到底是什么 ?</h3><ul><li>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</li></ul><h3 id="springboot-starter的工作原理"><a class="markdownIt-Anchor" href="#springboot-starter的工作原理"></a> SpringBoot Starter的工作原理</h3><ul><li><code>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</code></li><li>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</li></ul><h3 id="spring-boot-2x-有什么新特性与-1x-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-2x-有什么新特性与-1x-有什么区别"></a> Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h3><ul><li>配置变更</li><li>JDK 版本升级</li><li>第三方类库升级</li><li>响应式 Spring 编程支持</li><li>HTTP/2 支持</li><li>配置属性绑定</li><li>更多改进与加强</li></ul><h3 id="springboot支持什么前端模板"><a class="markdownIt-Anchor" href="#springboot支持什么前端模板"></a> SpringBoot支持什么前端模板，</h3><ul><li>thymeleaf，freemarker，jsp，官方不推荐JSP会有限制</li></ul><h3 id="springboot的缺点"><a class="markdownIt-Anchor" href="#springboot的缺点"></a> SpringBoot的缺点</h3><p>尽管 Spring Boot 有很多优点，但它仍然有一些缺点需要牢记：</p><ul><li>由于不用自己做的配置，<mark>报错时很难定位</mark>。</li><li>缺乏控制。 Spring Boot 会<mark>创建大量未使用的依赖项，导致部署文件很大</mark>；</li><li>将遗留或现有 Spring 项目转换为 Spring Boot 应用程序的复杂且耗时的过程；</li><li>不适合大型项目。 尽管它非常适合使用微服务，但许多开发人员声称 Spring Boot 不适合构建单体应用程序。</li></ul><h3 id="运行-spring-boot-有哪几种方式"><a class="markdownIt-Anchor" href="#运行-spring-boot-有哪几种方式"></a> 运行 Spring Boot 有哪几种方式？</h3><ol><li>打包用命令或者放到容器中运行</li><li>用 Maven/ Gradle 插件运行</li><li>直接执行 main 方法运行</li></ol><h3 id="spring-boot-需要独立的容器运行吗"><a class="markdownIt-Anchor" href="#spring-boot-需要独立的容器运行吗"></a> Spring Boot 需要独立的容器运行吗？</h3><ul><li>可以不需要，内置了 Tomcat/ Jetty 等容器。</li></ul><h3 id="开启-spring-boot-特性有哪几种方式"><a class="markdownIt-Anchor" href="#开启-spring-boot-特性有哪几种方式"></a> 开启 Spring Boot 特性有哪几种方式？</h3><h4 id="1-继承spring-boot-starter-parent项目"><a class="markdownIt-Anchor" href="#1-继承spring-boot-starter-parent项目"></a> 1. 继承spring-boot-starter-parent项目</h4><parent><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter-parent</artifactid>    <version>2.2.6.RELEASE</version></parent><p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p><dependencies><dependency><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter</artifactid></dependency></dependencies><h4 id="2-导入spring-boot-dependencies项目依赖"><a class="markdownIt-Anchor" href="#2-导入spring-boot-dependencies项目依赖"></a> 2. 导入spring-boot-dependencies项目依赖</h4><dependencymanagement>    <dependencies>      <dependency>        <groupid>org.springframework.boot</groupid>        <artifactid>spring-boot-dependencies</artifactid>        <version>1.5.4.RELEASE</version>        <type>pom</type>        <scope>import</scope>      </dependency>    </dependencies></dependencymanagement><p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p><dependencies><dependency><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter</artifactid></dependency></dependencies><h3 id="springboot-实现热部署有哪几种方式"><a class="markdownIt-Anchor" href="#springboot-实现热部署有哪几种方式"></a> SpringBoot 实现热部署有哪几种方式？</h3><ul><li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li><li>主要有两种方式：<ul><li>Spring Loaded</li><li>Spring-boot-devtools</li></ul></li></ul><h3 id="springboot事务的使用"><a class="markdownIt-Anchor" href="#springboot事务的使用"></a> SpringBoot事务的使用</h3><ul><li>SpringBoot的事务很简单，首先使用注解@EnableTransactionManagement开启事务之后，然后在Service方法上添加注解@Transactional便可。</li></ul><h3 id="async异步调用方法"><a class="markdownIt-Anchor" href="#async异步调用方法"></a> Async异步调用方法</h3><ul><li>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入**@EnableAsync<strong>使异步调用</strong>@Async**注解生效。</li></ul><h3 id="如何在-spring-boot-启动的时候运行一些特定的代码"><a class="markdownIt-Anchor" href="#如何在-spring-boot-启动的时候运行一些特定的代码"></a> 如何在 Spring Boot 启动的时候运行一些特定的代码？</h3><p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</p><h4 id="1-applicationrunner"><a class="markdownIt-Anchor" href="#1-applicationrunner"></a> 1. ApplicationRunner</h4><ul><li>在项目中，可能会遇到这样一个问题：在项目启动完成之后，紧接着执行一段代码。<br>在SpringBoot中，提供了一个接口：ApplicationRunner。该接口中，只有一个run方法，他执行的时机是：spring容器启动完成之后，就会紧接着执行这个接口实现类的run方法。</li><li>实现了ApplicationRunner接口的类，并重写run方法，在springBoot项目启动后就是调用执行一次run方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImplApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">        System.out.println(<span class="string">"测试ApplicationRunner接口1"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>@Component注解<br>这个实现类，要注入到spring容器中，这里使用了@Component注解；<br>在同一个项目中，可以定义多个ApplicationRunner的实现类，他们的执行顺序通过注解@Order注解或者再实现Ordered接口来实现。</p></li><li><p>run方法的参数：ApplicationArguments可以获取到当前项目执行的命令参数。（比如把这个项目打成jar执行的时候，带的参数可以通过ApplicationArguments获取到）；由于该方法是在容器启动完成之后，才执行的，所以，这里可以从spring容器中拿到其他已经注入的bean。</p></li><li><p>@Order注解<br>如果有多个实现类，而你需要他们按一定顺序执行的话，可以在实现类上加上@Order注解。@Order(value=整数值)。SpringBoot会按照@Order中的value值从小到大依次执行。<br>@order，使用注解方式使bean的加载顺序得到控制,@Order标记定义了组件的加载顺序，值越小拥有越高的优先级，可为负数。值越小，越先被加载。</p></li><li><p>@Order(-1)优先于@Order(0)<br>@Order(1)优先于@Order(2)</p></li></ul><h4 id="2-commandlinerunner"><a class="markdownIt-Anchor" href="#2-commandlinerunner"></a> 2. CommandLineRunner</h4><p><strong>背景</strong></p><p>项目启动之前，预先加载数据。比如，权限容器、特殊用户数据等。通常我们可以使用监听器、事件来操作。但是，springboot提供了一个简单的方式来实现此类需求，即，CommandLineRunner。</p><p>先了解一下这个类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span></span><br><span class="line"><span class="comment"> * a {<span class="doctag">@link</span> SpringApplication}. Multiple {<span class="doctag">@link</span> CommandLineRunner} beans can be defined</span></span><br><span class="line"><span class="comment"> * within the same application context and can be ordered using the {<span class="doctag">@link</span> Ordered}</span></span><br><span class="line"><span class="comment"> * interface or {<span class="doctag">@link</span> Order <span class="doctag">@Order</span>} annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you need access to {<span class="doctag">@link</span> ApplicationArguments} instead of the raw String array</span></span><br><span class="line"><span class="comment"> * consider using {<span class="doctag">@link</span> ApplicationRunner}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationRunner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback used to run the bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>文档中，我们可以知道以下几点。</p><ul><li>这是一个接口，用户可以自定义实现该接口，具体实现run方法</li><li>任何在上下文容器之内的bean都可以实现run方法</li><li>如果在上下文中，存在多个该接口实现类，可以通过@order注解，指定加载顺序</li></ul><p>所以我们基本上大概已经了解了这个接口的作用以及用法。</p><p><strong>案例说明</strong><br>分别定义一个数据加载类MyStartupRunner1，排序为2；另一个数据加载类MyStartupRunner2,排序为1。看看它们记载数据的顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner1</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">       System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner1 order 2 &lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">   System.out.println(<span class="string">"&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner2 order 1 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot-有哪几种读取配置的方式"><a class="markdownIt-Anchor" href="#spring-boot-有哪几种读取配置的方式"></a> Spring Boot 有哪几种读取配置的方式？</h3><ul><li>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</li></ul><h3 id="什么是-javaconfig"><a class="markdownIt-Anchor" href="#什么是-javaconfig"></a> 什么是 JavaConfig？</h3><ul><li>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他，它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<ul><li>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</li><li>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</li><li>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</li></ul></li><li>常用的Java config：<ul><li>@Configuration：在类上打上写下此注解，表示这个类是配置类</li><li>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。</li><li>@Bean：bean的注入：相当于以前的&lt; bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /&gt;</li><li>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;</li><li>@ImportResource： 相当于xml的 &lt; import resource=“applicationContext-cache.xml”&gt;</li></ul></li></ul><h3 id="springboot的自动配置原理是什么"><a class="markdownIt-Anchor" href="#springboot的自动配置原理是什么"></a> SpringBoot的自动配置原理是什么</h3><ul><li>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</li><li>有了这个EnableAutoConfiguration的话就会：<ol><li>从配置文件META_INF/Spring.factories加载可能用到的自动配置类</li><li>去重，并将exclude和excludeName属性携带的类排除</li><li>过滤，将满足条件（@Conditional）的自动配置类返回</li></ol></li></ul><h3 id="你如何理解-spring-boot-配置加载顺序"><a class="markdownIt-Anchor" href="#你如何理解-spring-boot-配置加载顺序"></a> 你如何理解 Spring Boot 配置加载顺序？</h3><ul><li><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><ul><li>1.properties文件；</li><li>2.YAML文件；</li><li>3.系统环境变量；</li><li>4.命令行参数；</li><li>等等……</li></ul><p>常用配置文件中读取配置的结论：config配置中心 =&gt; jvm参数 =&gt; 系统环境变量 =&gt; 项目内的application-xxx.yaml =&gt; 项目内的application.yaml =&gt; bootstrap.yaml</p></li></ul><h3 id="什么是-yaml"><a class="markdownIt-Anchor" href="#什么是-yaml"></a> 什么是 YAML？</h3><ul><li>YAML 是一种<mark>人类可读的数据序列化语言</mark>。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</li><li>YAML 的语法比较简洁直观，特点是使用空格来表达层次结构，其最大优势在于<strong>数据结构</strong>方面的表达，所以 YAML 更多应用于<strong>编写配置文件</strong>，其文件一般以 <strong>.yml</strong> 为后缀。</li></ul><h3 id="yaml-配置的优势在哪里"><a class="markdownIt-Anchor" href="#yaml-配置的优势在哪里"></a> YAML 配置的优势在哪里 ?</h3><ul><li>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<ul><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</li></ul></li></ul><h3 id="spring-boot-是否可以使用-xml-配置"><a class="markdownIt-Anchor" href="#spring-boot-是否可以使用-xml-配置"></a> Spring Boot 是否可以使用 XML 配置 ?</h3><ul><li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</li></ul><h3 id="spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"><a class="markdownIt-Anchor" href="#spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"></a> spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><ul><li>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</li><li>spring boot 核心的两个配置文件：<ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 <mark>spring boot 项目的<strong>自动化配置</strong></mark>。</li></ul></li></ul><h3 id="什么是-spring-profiles"><a class="markdownIt-Anchor" href="#什么是-spring-profiles"></a> 什么是 Spring Profiles？</h3><ul><li>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能</li><li>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</li></ul><h3 id="springboot多数据源拆分的思路"><a class="markdownIt-Anchor" href="#springboot多数据源拆分的思路"></a> SpringBoot多数据源拆分的思路</h3><ul><li>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中</li></ul><h3 id="springboot多数据源事务如何管理"><a class="markdownIt-Anchor" href="#springboot多数据源事务如何管理"></a> SpringBoot多数据源事务如何管理</h3><ul><li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li><li>第二种是使用jta-atomikos实现分布式事务管理</li></ul><h3 id="保护-spring-boot-应用有哪些方法"><a class="markdownIt-Anchor" href="#保护-spring-boot-应用有哪些方法"></a> 保护 Spring Boot 应用有哪些方法？</h3><ul><li>在生产中使用HTTPS</li><li>使用Snyk检查你的依赖关系</li><li>升级到最新版本</li><li>启用CSRF保护</li><li>使用内容安全策略防止XSS攻击</li></ul><h3 id="如何实现-spring-boot-应用程序的安全性"><a class="markdownIt-Anchor" href="#如何实现-spring-boot-应用程序的安全性"></a> 如何实现 Spring Boot 应用程序的安全性？</h3><ul><li>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</li></ul><h3 id="比较一下-spring-security-和-shiro-各自的优缺点"><a class="markdownIt-Anchor" href="#比较一下-spring-security-和-shiro-各自的优缺点"></a> 比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><ul><li>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：<ul><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ul></li></ul><h3 id="spring-boot-中如何解决跨域问题"><a class="markdownIt-Anchor" href="#spring-boot-中如何解决跨域问题"></a> Spring Boot 中如何解决跨域问题 ?</h3><ul><li>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>) <span class="comment">//可以被跨域的路径</span></span><br><span class="line">            .allowedOrigins(<span class="string">"*"</span>) <span class="comment">//域名的白名单</span></span><br><span class="line">            .allowedMethods(<span class="string">"*"</span>)<span class="comment">/*"GET", "POST", "DELETE", "PUT"*/</span></span><br><span class="line">            .allowedHeaders(<span class="string">"*"</span>) <span class="comment">//允许所有的请求header访问，可以自定义设置任意请求头信息</span></span><br><span class="line">            .maxAge(<span class="number">3600</span>); <span class="comment">//这个复杂请求是预检用的，设置预检多久失效</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="如何使用-spring-boot-实现全局异常处理"><a class="markdownIt-Anchor" href="#如何使用-spring-boot-实现全局异常处理"></a> 如何使用 Spring Boot 实现全局异常处理？</h3><ul><li>Spring 提供了一种使用 <mark>ControllerAdvice</mark> 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</li></ul><h4 id="controlleradvice-作用"><a class="markdownIt-Anchor" href="#controlleradvice-作用"></a> @ControllerAdvice 作用</h4><p><font color="red"><strong>controller 的增强，用于对controller 做一些统一的操作，一般是用于全局的异常处理，也可以用于全局结果的返回处理</strong></font></p><p>可以在一定程度上简化代码，减少代码的书写量，统一对所有结果和异常做处理，包括异常信息的返回和错误日志的答应等</p><p>@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。主要作用有一下三种 :</p><ul><li>通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。</li><li>注解了@ControllerAdvice的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。<ul><li>@ExceptionHandler：用于全局处理控制器里的异常，进行全局异常处理</li><li>@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中，全局数据预处理。</li><li>@ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对 ，全局数据绑定。</li></ul></li><li>@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上。</li></ul><p>需要配合@ExceptionHandler使用。 当将异常抛到controller时,可以对异常进行统一处理,规定返回的json格式或是跳转到一个错误页面</p><p>全局异常处理举例以及说明<br>@ControllerAdvice ，@ExceptionHandler 的全局处理</p><p>Slf4j 为日志注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request, MyException e)</span> {</span><br><span class="line">        log.error(<span class="string">"错误信息:{}"</span>, e.getMessage(), e);</span><br><span class="line"><span class="keyword">return</span> Response.failMessage(e.getCode(), e.getMessage());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @Valid 校验框架抛出的特殊异常类</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleValidException</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException e)</span> {</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) {</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError allError : allErrors) {</span><br><span class="line">                message.append(allError.getDefaultMessage()).append(<span class="string">", "</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(message.toString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认其他的所有异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleOtherException</span><span class="params">(HttpServletRequest request, Exception e)</span> {</span><br><span class="line">        log.error(<span class="string">"request error Exception:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(e.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot-中的监视器是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的监视器是什么"></a> Spring Boot 中的监视器是什么？</h3><ul><li><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您<mark>访问生产环境中正在运行的应用程序的当前状态</mark>。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p></li><li><p>Spring Boot自带监控组件—Actuator，它可以帮助实现对程序内部运行情况的监控。本章首先介绍Actuator轻松实现应用程序的监控治理，比如健康状况、审计、统计和HTTP追踪、Bean加载情况、环境变量、日志信息、线程信息等，然后介绍如何使用Spring Boot Admin构建完整的运维监控平台。<br><strong>Actuator的核心是端点（Endpoint）</strong>，它用来监视、提供应用程序的信息，Spring Boot提供的spring-boot-actuator组件中已经内置了非常多的Endpoint（health、info、beans、metrics、httptrace、shutdown等），每个端点都可以启用和禁用。</p><p><strong>监控端点分类：</strong><br>1）应用配置类：可以查看应用在运行期的静态信息，比如自动配置信息、加载的Spring Bean信息、YML文件配置信息、环境信息、请求映射信息。<br>2）度量指标类：主要是运行期的动态信息，如堆栈、请求连接、健康状态、系统性能等<br>3）操作控制类：主要是指shutdown，用户可以发送一个请求将应用的监控功能关闭。</p></li></ul><h3 id="我们如何监视所有-spring-boot-微服务"><a class="markdownIt-Anchor" href="#我们如何监视所有-spring-boot-微服务"></a> 我们如何监视所有 Spring Boot 微服务？</h3><ul><li>Spring Boot 提供 <strong>监视器端点</strong> 以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 <strong>Spring Boot Actuator</strong> 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li></ul><h3 id="springboot性能如何优化"><a class="markdownIt-Anchor" href="#springboot性能如何优化"></a> SpringBoot性能如何优化</h3><ul><li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围</li><li>在项目启动时设置JVM初始内存和最大内存相同</li><li>将springboot内置服务器由tomcat设置为undertow</li></ul><h3 id="如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"><a class="markdownIt-Anchor" href="#如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"></a> 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><ul><li>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（<mark><strong>DevTools</strong></mark>）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot微服务中如何实现-session-共享"><a class="markdownIt-Anchor" href="#spring-boot微服务中如何实现-session-共享"></a> Spring Boot微服务中如何实现 session 共享 ?</h3><ul><li>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，<mark>常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session </mark>。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</li></ul><h3 id="您使用了哪些-starter-maven-依赖项"><a class="markdownIt-Anchor" href="#您使用了哪些-starter-maven-依赖项"></a> 您使用了哪些 starter maven 依赖项？</h3><ul><li>使用了下面的一些依赖项<ul><li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li><li>spring-boot-starter-data-jpa 数据库支持</li><li>spring-boot-starter-data-redis redis数据库支持</li><li>spring-boot-starter-data-solr solr支持</li><li>mybatis-spring-boot-starter 第三方的mybatis集成starter</li><li>自定义的starter(如果自己开发过就可以说出来)</li></ul></li></ul><h3 id="spring-boot-中如何实现定时任务"><a class="markdownIt-Anchor" href="#spring-boot-中如何实现定时任务"></a> Spring Boot 中如何实现定时任务 ?</h3><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 <mark>@Scheduled 注解</mark>，另一个则是使用第三方框架 <mark>Quartz</mark>。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li></ul><h3 id="spring-boot-starter-parent-有什么用"><a class="markdownIt-Anchor" href="#spring-boot-starter-parent-有什么用"></a> spring-boot-starter-parent 有什么用 ?</h3><ul><li><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li><p>定义了 Java 编译版本为 1.8 。</p></li><li><p>使用 UTF-8 格式编码。</p></li><li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。看源码发现：</p><p><img src="../../images/image-20230303224702882.png" alt="image-20230303224702882"></p></li><li><p>执行打包操作的配置。</p></li><li><p>自动化的资源过滤。</p></li><li><p>自动化的插件配置。</p></li><li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p></li></ol></li><li><p>总结就是打包用的</p></li></ul><h3 id="springboot如何实现打包"><a class="markdownIt-Anchor" href="#springboot如何实现打包"></a> SpringBoot如何实现打包</h3><ul><li>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包</li><li>或者点击右边选项栏中的Maven，先点击clean在点击package</li></ul><h3 id="spring-boot-打成的-jar-和普通的-jar-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-打成的-jar-和普通的-jar-有什么区别"></a> Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><ul><li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li><li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-限流规则(流控模式：直接、关联、链路)</title>
      <link href="/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/"/>
      <url>/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/</url>
      
        <content type="html"><![CDATA[<ul><li>​<strong>QPS</strong> <code>Queries Per Second</code> 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</li></ul><p><img src="https://img-blog.csdnimg.cn/061b8c23ef694d6e9d18abe3647c9dbe.png" alt="img"></p><h1 id="一-流控模式-直接"><a class="markdownIt-Anchor" href="#一-流控模式-直接"></a> 一、流控模式-直接</h1><p>添加规则：</p><p><img src="https://img-blog.csdnimg.cn/6d5781b7da1345f59e3321b3c8806571.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/8df1b81beca34a90a71af4aa2f1b8026.png" alt="img"></p><p>测试例子分析：</p><p><img src="https://img-blog.csdnimg.cn/39b96b130c9046078bc6d632580aff3e.png" alt="img"></p><p>启动测试</p><p><img src="https://img-blog.csdnimg.cn/5ec171ee24494c7488e3b09e3d7d8b47.png" alt="img"></p><p>点击 <strong>察看结果树</strong></p><p><img src="https://img-blog.csdnimg.cn/cc093a02f2be44fd938dfcc603a06ca3.png" alt="img"></p><p>上面测试例子，到Sentinel控制台的实时监控可以看到<img src="https://img-blog.csdnimg.cn/3dd6594966864a3a8f8d230c66387980.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/57592224a235458b826fc55819f5ea3d.png" alt="img"></p><h1 id="二-流控模式-关联"><a class="markdownIt-Anchor" href="#二-流控模式-关联"></a> 二、流控模式-关联</h1><p>•<strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>•<strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p><img src="https://img-blog.csdnimg.cn/b8cf0fa094f0443db55cd6567f70b192.png" alt="img"></p><p>当**/write<strong>资源访问量触发阈值时，就会对</strong>/read**资源限流，避免影响/write资源。</p><h2 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例：</h2><p>​    需求：</p><p>​     •在OrderController新建两个端点：/order/query和/order/update，无需实现业务</p><p>​     •配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流</p><h2 id="1-编写测试controller方法"><a class="markdownIt-Anchor" href="#1-编写测试controller方法"></a> 1. 编写测试controller方法:</h2><p><img src="https://img-blog.csdnimg.cn/dfda223212c6437a96852a8aa4d744e0.png" alt="img"></p><h2 id="2-添加规则想给谁限流就给谁添加规则"><a class="markdownIt-Anchor" href="#2-添加规则想给谁限流就给谁添加规则"></a> 2. 添加规则（想给谁限流，就给谁添加规则）</h2><h2 id="img"><a class="markdownIt-Anchor" href="#img"></a> <img src="https://img-blog.csdnimg.cn/9fc5937b14504fce8dde85b0c1a5cfb6.png" alt="img"></h2><h2 id="img-2"><a class="markdownIt-Anchor" href="#img-2"></a> <img src="https://img-blog.csdnimg.cn/d93155d750694872a0818677f4cb81a8.png" alt="img"></h2><h2 id="img-3"><a class="markdownIt-Anchor" href="#img-3"></a> <img src="https://img-blog.csdnimg.cn/ddfa4ee5ed00436c9c0f3e147d8c7b6d.png" alt="img"></h2><h2 id="3-借助jmeter进行测试"><a class="markdownIt-Anchor" href="#3-借助jmeter进行测试"></a> 3. 借助JMeter进行测试：</h2><p><img src="https://img-blog.csdnimg.cn/5ff99d435d124355914f816b525b9a7a.png" alt="img"></p><h2 id="img-4-去网页访问验证img"><a class="markdownIt-Anchor" href="#img-4-去网页访问验证img"></a> <img src="https://img-blog.csdnimg.cn/38c110824b1f478883e86b43a4df0017.png" alt="img"> 4. 去网页访问验证:<img src="https://img-blog.csdnimg.cn/6d7e4884e3314d76a707bf0e0e6548d0.png" alt="img"></h2><p>query被限流 <img src="https://img-blog.csdnimg.cn/21342817472a4d2587669ada29df161c.png" alt="img"></p><h2 id="5-总结-满足下面条件可以使用关联模式"><a class="markdownIt-Anchor" href="#5-总结-满足下面条件可以使用关联模式"></a> 5. 总结： 满足下面条件可以使用关联模式</h2><ol><li><p>两个有<mark>竞争关系</mark>的资源</p></li><li><p>一个优先级较高，一个优先级较低（优先级高的触发阈值时（本案例的order），对优先级低的限流（本案例的query））</p></li></ol><h1 id="三-流控模式-链路"><a class="markdownIt-Anchor" href="#三-流控模式-链路"></a> 三、流控模式-链路</h1><p><img src="https://img-blog.csdnimg.cn/56e2dc9f451441a2bbb8483750137bf4.png" alt="img"></p><h2 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> 案例：</h2><p><img src="https://img-blog.csdnimg.cn/00c8c659e1c44e098c46b7ce5fd7b219.png" alt="img"></p><h2 id="1-编写测试代码"><a class="markdownIt-Anchor" href="#1-编写测试代码"></a> 1. 编写测试代码：</h2><p><img src="https://img-blog.csdnimg.cn/540402db64874fab953436a286717e02.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/32565b6a61534e3d87a9de1d1d9b7446.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b0c343dd8ae54320bed317a725bda5d6.png" alt="img"></p><h2 id="2-注意"><a class="markdownIt-Anchor" href="#2-注意"></a> <strong>2. 注意：</strong></h2><p>Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用<mark><strong>@SentinelResource</strong>注解</mark></p><p>去配置文件里配置，<mark>关闭contextM</mark>，就可以让controller里的方法单独成为一个链路；不关闭context的话，controller里的方法都会默认进去sentinel默认的根链路里，这样就只有一条链路，无法流控链路模式</p><p><img src="https://img-blog.csdnimg.cn/dba8e68e6bc049b18fceab90848e5a24.png" alt="img"></p><h2 id="3-启动之后并到网页里分别访问了orderquery和ordersave接口后"><a class="markdownIt-Anchor" href="#3-启动之后并到网页里分别访问了orderquery和ordersave接口后"></a> 3. 启动之后，并到网页里分别访问了/order/query和/order/save接口后</h2><p><img src="https://img-blog.csdnimg.cn/bb6e754ffb7e4e4f8b715fe3910cbecd.png" alt="img"></p><h2 id="4-添加规则对query做限制save没有做限制"><a class="markdownIt-Anchor" href="#4-添加规则对query做限制save没有做限制"></a> 4. 添加规则：(对query做限制，save没有做限制)</h2><p><img src="https://img-blog.csdnimg.cn/cc38bc601afc440f9405972e04257f5b.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/feb37cb8556e49c4a151ff9c8397497f.png" alt="img"></p><h2 id="5-借助jmeter来测试"><a class="markdownIt-Anchor" href="#5-借助jmeter来测试"></a> 5. 借助JMeter来测试：</h2><p><img src="https://img-blog.csdnimg.cn/ed662f7afdb54e60a0455ce48d55c18e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/7f1e916b436d43379585d1e9a52828a4.png" alt="img"></p><p>启动测试 <img src="https://img-blog.csdnimg.cn/4917bbf6a6b34670aed4ad9d3c751b02.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/45dd3918b3124af6983bfb648adfbb3a.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/df349c02421040b9bc8e00a398be0c9d.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层常见协议总结（应用层）</title>
      <link href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
      <url>/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="http超文本传输协议"><a class="markdownIt-Anchor" href="#http超文本传输协议"></a> HTTP:超文本传输协议</h2><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p><p><img src="../../../images/image-20230220135638150.png" alt="image-20230220135638150"></p><p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#smtp-%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93-%E5%8F%91%E9%80%81-%E5%8D%8F%E8%AE%AE">#</a> SMTP:简单邮件<font color="red">传输(发送)</font>协议</h2><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p><p><img src="../../../images/image-20230220135632455.png" alt="image-20230220135632455"></p><p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><ol><li>电子邮件的发送过程</li><li>如何判断邮箱是真正存在的？</li></ol><p><strong>电子邮件的发送过程？</strong></p><p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li></ol><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><p>推荐几个在线邮箱是否有效检测工具：</p><ol><li><a href="https://verify-email.org/">https://verify-email.org/</a></li><li><a href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li><li><a href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li></ol><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#pop3-imap-%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> POP3/IMAP:邮件<font color="red">接收</font>的协议</h2><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p><p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p><h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#ftp-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> FTP:文件传输协议</h2><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote><p><img src="../../../images/image-20230220135623263.png" alt="image-20230220135623263"></p><h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#telnet-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AE">#</a> Telnet:远程登陆协议</h2><p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p><h2 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#ssh-%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> SSH:安全的网络传输协议</h2><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p><p><img src="../../../images/image-20230220135616527.png" alt="image-20230220135616527"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 传输可靠性保障（传输层）</title>
      <link href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/"/>
      <url>/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="tcp-如何保证传输的可靠性"><a class="markdownIt-Anchor" href="#tcp-如何保证传输的可靠性"></a> TCP 如何保证传输的可靠性？</h2><ol><li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失open in new window</a>并进行重传。</li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的**滑动窗口协议（**TCP 利用滑动窗口实现流量控制）。</li><li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li></ol><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">#</a> TCP 如何实现流量控制？</h2><p><strong>TCP 利用<font color="red">滑动窗口</font>实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="为什么需要流量控制"><a class="markdownIt-Anchor" href="#为什么需要流量控制"></a> <strong>为什么需要流量控制?</strong></h3><p>这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>这里需要注意的是（常见误区）：</p><ul><li>发送端不等同于客户端</li><li>接收端不等同于服务端</li></ul><p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是接收端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p><h3 id="tcp-发送窗口可以划分成四个部分"><a class="markdownIt-Anchor" href="#tcp-发送窗口可以划分成四个部分"></a> <strong>TCP 发送窗口可以划分成四个部分</strong> ：</h3><ol><li>已经发送并且确认的TCP段（<strong>已经发送并确认</strong>）；</li><li>已经发送但是没有确认的TCP段（<strong>已经发送未确认</strong>）；</li><li>未发送但是接收方准备接收的TCP段（<strong>可以发送</strong>）；</li><li>未发送并且接收方也并未准备接受的TCP段（<strong>不可发送</strong>）。</li></ol><h3 id="tcpfont-colorred发送font窗口结构图示"><a class="markdownIt-Anchor" href="#tcpfont-colorred发送font窗口结构图示"></a> <strong>TCP<font color="red">发送</font>窗口结构图示</strong> ：</h3><p><img src="../../../images/image-20230220135411913.png" alt="image-20230220135411913"></p><ul><li><strong>SND.WND</strong> ：发送窗口。</li><li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li><li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li></ul><p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p><h3 id="tcp-font-colorred接收font窗口可以划分成三个部分"><a class="markdownIt-Anchor" href="#tcp-font-colorred接收font窗口可以划分成三个部分"></a> <strong>TCP <font color="red">接收</font>窗口可以划分成三个部分</strong> ：</h3><ol><li>已经接收并且已经确认的 TCP 段（<strong>已经接收并确认</strong>）；</li><li>等待接收且允许发送方发送 TCP 段（<strong>可以接收未确认</strong>）；</li><li>不可接收且不允许发送方发送TCP段（<strong>不可接收</strong>）。</li></ol><h3 id="tcp-接收窗口结构图示"><a class="markdownIt-Anchor" href="#tcp-接收窗口结构图示"></a> <strong>TCP 接收窗口结构图示</strong> ：</h3><p><img src="../../../images/image-20230220135419120.png" alt="image-20230220135419120"></p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p><p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> TCP 的拥塞控制是怎么实现的？</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><img src="../../../images/image-20230220135425341.png" alt="image-20230220135425341"></p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#arq-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97">#</a> ARQ 协议了解吗?（Automatic Repeat-reQuest）</h2><p><font color="red"><strong>自动重传请求</strong></font>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的<strong>错误纠正协</strong>议之一。<strong>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输</strong>。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括<strong>停止等待 ARQ 协议</strong>和<strong>连续 ARQ 协议</strong>。</p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a> 停止等待 ARQ 协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><h4 id="1-无差错情况"><a class="markdownIt-Anchor" href="#1-无差错情况"></a> <strong>1) 无差错情况:</strong></h4><p>发送方发送分组, 接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><h4 id="2-出现差错情况超时重传"><a class="markdownIt-Anchor" href="#2-出现差错情况超时重传"></a> <strong>2) 出现差错情况（超时重传）:</strong></h4><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><h4 id="3-确认丢失和确认迟到"><a class="markdownIt-Anchor" href="#3-确认丢失和确认迟到"></a> <strong>3) 确认丢失和确认迟到</strong></h4><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE">#</a> 连续 ARQ 协议</h3><p>连续 ARQ 协议可<strong>提高信道利用率</strong>。发送方维持一个<strong>发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对<mark>按序到达</mark>的<mark>最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</mark></p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> <strong>优点：</strong></h4><p>信道利用率高，容易实现，即使确认丢失，也不必重传。</p><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> <strong>缺点：</strong></h4><p>不能向发送方反映出接收方已经正确收到的所有分组的信息。 <font color="blue">比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认</font>。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OSI 和 TCP/IP 网络分层模型详解（基础）</title>
      <link href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
      <url>/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>OSI模型</strong>: 即<strong>开放式通信系统互联参考模型</strong>（<strong>Open System Interconnection Reference Model</strong>），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。</p><h2 id="osi-七层模型"><a class="markdownIt-Anchor" href="#osi-七层模型"></a> OSI 七层模型</h2><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="../../../images/image-20230220134708482.png" alt="image-20230220134708482"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p><p><img src="../../../images/image-20230220134715273.png" alt="image-20230220134715273"></p><p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p><p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p><ol><li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li><li>OSI 的协议实现起来过分复杂，而且运行效率很低</li><li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li><li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li></ol><p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p><p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p><p><img src="../../../images/image-20230220134722147.png" alt="image-20230220134722147"></p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> TCP/IP 四层模型</h2><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><p><img src="../../../images/image-20230220134732543.png" alt="image-20230220134732543"></p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#%E5%BA%94%E7%94%A8%E5%B1%82-application-layer">#</a> 应用层（Application layer）</h3><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p><p><img src="../../../images/image-20230220134737489.png" alt="image-20230220134737489"></p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><p><img src="../../../images/image-20230220134743725.png" alt="image-20230220134743725"></p><p>应用层常见协议总结，请看这篇文章：<a href="">应用层常见协议总结（应用层）</a>。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#%E4%BC%A0%E8%BE%93%E5%B1%82-transport-layer">#</a> 传输层（Transport layer）</h3><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><p><img src="../../../images/image-20230220134748906.png" alt="image-20230220134748906"></p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%B1%82-network-layer">#</a> 网络层（Network layer）</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p><p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p><p><img src="../../../images/image-20230220134754055.png" alt="image-20230220134754055"></p><p><strong>网络层常见协议</strong> ：</p><ul><li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li><li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li><li>…</li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-network-interface-layer">#</a> 网络接口层（Network interface layer）</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><p><img src="../../../images/image-20230220134759211.png" alt="image-20230220134759211"></p><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h3><p>简单总结一下每一层包含的协议和核心技术:</p><p><img src="../../../images/image-20230220134804106.png" alt="image-20230220134804106"></p><p><strong>应用层协议</strong> :</p><ul><li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li><li>DHCP 协议（动态主机配置）</li><li>DNS 系统原理（域名系统）</li><li>FTP 协议（文件传输协议）</li><li>Telnet协议（远程登陆协议）</li><li>电子邮件协议等（SMTP、POP3、IMAP）</li><li>…</li></ul><p><strong>传输层协议</strong> :</p><ul><li>TCP 协议<ul><li>报文段结构</li><li>可靠数据传输</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>UDP 协议<ul><li>报文段结构</li><li>RDT（可靠数据传输协议）</li></ul></li></ul><p><strong>网络层协议</strong> :</p><ul><li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li><li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li><li>ICMP 协议（控制报文协议，用于发送控制消息）</li><li>NAT 协议（网络地址转换协议）</li><li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li><li>…</li></ul><p><strong>网络接口层</strong> :</p><ul><li>差错检测技术</li><li>多路访问协议（信道复用技术）</li><li>CSMA/CD 协议</li><li>MAC 协议</li><li>以太网技术</li><li>…</li></ul><h2 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0">#</a> 网络分层的原因</h2><p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP vs HTTPS（应用层）</title>
      <link href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
      <url>/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="http-协议"><a class="markdownIt-Anchor" href="#http-协议"></a> HTTP 协议</h2><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTP 协议介绍</h3><p>HTTP 协议，全称<strong>超文本传输协议</strong>（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p><p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B">#</a> HTTP 协议通信过程</h3><p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p><ol><li>服务器在 80 端口等待客户的请求。</li><li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li><li>服务器接收来自浏览器的 TCP 连接。</li><li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li><li>关闭 TCP 连接。</li></ol><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTP 协议优点</h3><p>扩展性强、速度快、跨平台支持性好。</p><h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#https-%E5%8D%8F%E8%AE%AE">#</a> HTTPS 协议</h2><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#https-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTPS 协议介绍</h3><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p><p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#https-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTPS 协议优点</h3><p>保密性好、信任度高。</p><h2 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#https-%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94ssl-tls%E5%8D%8F%E8%AE%AE">#</a> HTTPS 的核心—SSL/TLS协议</h2><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p><h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#ssl-%E5%92%8C-tls-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> SSL 和 TLS 的区别？</h3><p><strong>SSL 和 TLS 没有太大的区别。</strong></p><p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p><h3 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#ssl-tls-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> SSL/TLS 的工作原理</h3><h4 id="-10"><a class="markdownIt-Anchor" href="#-10"></a> <a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 非对称加密</h4><p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p><blockquote><p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p><p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p><p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p></blockquote><p><img src="../../../images/image-20230220134425749.png" alt="image-20230220134425749"></p><p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p><blockquote><p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p><p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p></blockquote><p><img src="../../../images/image-20230220134444105.png" alt="image-20230220134444105"></p><p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p><p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p><h4 id="-11"><a class="markdownIt-Anchor" href="#-11"></a> <a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 对称加密</h4><p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p><blockquote><p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p></blockquote><p><img src="../../../images/image-20230220134457419.png" alt="image-20230220134457419"></p><p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p><h4 id="-12"><a class="markdownIt-Anchor" href="#-12"></a> <a href="#%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%A1%E8%B5%96%E6%80%A7">#</a> 公钥传输的信赖性</h4><p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p><blockquote><p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p><ol><li>任何人都可以捕获通信包</li><li>通信包的保密性由发送者设计</li><li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li></ol><p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p><p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p></blockquote><p><img src="../../../images/image-20230220134509815.png" alt="image-20230220134509815"></p><p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p><p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p><h4 id="-13"><a class="markdownIt-Anchor" href="#-13"></a> <a href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">#</a> 数字签名</h4><p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p><p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p><blockquote><p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p><p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p><p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p></blockquote><p><img src="../../../images/image-20230220134547914.png" alt="image-20230220134547914"></p><p>总结来说，带有证书的公钥传输机制如下：</p><ol><li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li><li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li><li>S 获得 CA 颁发的证书，将该证书传递给 C。</li><li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li><li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li></ol><p><img src="../../../images/image-20230220134604571.png" alt="image-20230220134604571"></p><p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href="https://www.bilibili.com/video/BV18N411X7ty/">数字签名及数字证书原理open in new window</a>这个视频，这是我看过最清晰的讲解。</p><p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220321121814946.png" alt="img"></p><h2 id="-14"><a class="markdownIt-Anchor" href="#-14"></a> <a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h2><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP 常见状态码总结（应用层）</title>
      <link href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
      <url>/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p><p><img src="../../../images/image-20230220134615645.png" alt="image-20230220134615645"></p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#_1xx-informational-%E4%BF%A1%E6%81%AF%E6%80%A7%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 1xx Informational（信息性状态码）</h3><p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#_2xx-success-%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 2xx Success（成功状态码）</h3><ul><li><strong>200 OK</strong> ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li><li><strong>201 Created</strong> ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li><li><strong>202 Accepted</strong> ：服务端已经接收到了请求，但是还未处理。</li><li><strong>204 No Content</strong> ： 服务端已经成功处理了请求，但是没有返回任何内容。</li></ul><p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p><p><a href="https://tools.ietf.org/html/rfc2616#section-10.2.5">HTTP RFC 2616对204状态码的描述open in new window</a>如下：</p><blockquote><p>The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.</p><p>If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent’s active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent’s active view.</p><p>The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.</p></blockquote><p>简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p><p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#_3xx-redirection-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 3xx Redirection（重定向状态码）</h3><ul><li><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</li><li><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li></ul><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#_4xx-client-error-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 4xx Client Error（客户端错误状态码）</h3><ul><li><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</li><li><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</li><li><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</li><li><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li><li><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#_5xx-server-error-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 5xx Server Error（服务端错误状态码）</h3><ul><li><strong>500 Internal Server Error</strong> ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li><li><strong>502 Bad Gateway</strong> ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP 三次握手和四次挥手（传输层）</title>
      <link href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/"/>
      <url>/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>(了解一下 半关闭状态)</p><p><strong>SYN</strong>：同步序列编号（<strong>Synchronize Sequence Numbers</strong>）。是TCP/IP建立连接时使用的<strong>握手信号</strong>。</p><p><strong>ACK</strong> : (<strong>Acknowledge character</strong>）即是确认字符，在数据通信中，接收站发给发送站的一种传输类<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>。表示发来的数据已确认接收无误。</p><p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 建立连接-TCP 三次握手</h2><p><img src="../../../images/image-20230220134640946.png" alt="image-20230220134640946"></p><p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p><ul><li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li><strong>三次握手</strong>:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li></ul><p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 为什么要三次握手?</h3><p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<mark>双方确认自己与对方的发送与接收是正常的</mark>。</p><ol><li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><p>三次握手就能确认双方收发功能都正常，缺一不可。</p><p>更详细的解答可以看这个：<a href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎open in new window</a> 。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ack-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9Esyn">#</a> 第2次握手传回了ACK，为什么还要传回SYN？</h3><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 <strong>SYN 则是为了建立并确认从服务端到客户端的通信</strong>。</p><blockquote><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote><h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 断开连接-TCP 四次挥手</h2><p><img src="../../../images/image-20230220134646808.png" alt="image-20230220134646808"></p><p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p><ol><li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li><li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li><li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li></ol><p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p><h4 id="ps-tcp状态说明"><a class="markdownIt-Anchor" href="#ps-tcp状态说明"></a> <strong>ps: TCP状态说明</strong></h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：表示初始状态。对服务端和C客户端双方都一样。</span><br><span class="line">LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。</span><br><span class="line">SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。</span><br><span class="line">SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。</span><br><span class="line">ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。</span><br><span class="line">FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。</span><br><span class="line">FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。</span><br><span class="line">TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</span><br><span class="line">CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。</span><br><span class="line">CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。</span><br><span class="line">LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">特别提示的是：为什么TIME_WAIT状态还需要等待2MSL才能回到CLOSED状态？或者为什么TCP要引入TIME_WAIT状态？</span><br><span class="line">《TCP/IP详解》中如此解释：当TCP执行一个主动关闭，并发回最后一个ACK后，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL，这样可以让TCP再次发送最后的ACK以防止这个ACK丢失（另一端超时重发最后的FIN）。</span><br><span class="line">附注：MSL（Maximum Segment Lifetime）即最大生存时间，RFC 793中指出MSL为2分钟，但是实现中的常用值为30秒、1分钟或者2分钟。</span><br></pre></td></tr></tbody></table></figure><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么要四次挥手？</h3><p>TCP是全双工通信，可以双向传输数据。<mark>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接</mark>。</p><p>举个例子：A 和 B 打电话，通话即将结束后。</p><ol><li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li><li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li><li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li><li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li></ol><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ack-%E5%92%8C-fin-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5-%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h3 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p><h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络基础</title>
      <link href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络基础"><a class="markdownIt-Anchor" href="#计算机网络基础"></a> 计算机网络基础</h2><h3 id="osi-和-tcpip-网络分层模型"><a class="markdownIt-Anchor" href="#osi-和-tcpip-网络分层模型"></a> OSI 和 TCP/IP 网络分层模型</h3><p><strong>相关面试题</strong> ：</p><ul><li>OSI 七层模型是什么？每一层的作用是什么？</li><li>TCP/IP 四层模型是什么？每一层的作用是什么？</li><li>为什么网络要分层？</li></ul><p><strong>参考答案</strong> ：<a href="">OSI 和 TCP/IP 网络分层模型详解（基础）</a>。</p><h3 id="应用层有哪些常见的协议"><a class="markdownIt-Anchor" href="#应用层有哪些常见的协议"></a> 应用层有哪些常见的协议？</h3><p><a href="">应用层常见协议总结（应用层）</a></p><h2 id="tcp-与-udp"><a class="markdownIt-Anchor" href="#tcp-与-udp"></a> TCP 与 UDP</h2><p><strong>TCP</strong>: **传输控制协议（TCP，Transmission Control Protocol）**是一种面向连接的、可靠的、基于<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E6%B5%81/3196772?fromModule=lemma_inlink">字节流</a>的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536?fromModule=lemma_inlink">传输层</a><a href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3351624?fromModule=lemma_inlink">通信协议</a>，由<a href="https://baike.baidu.com/item/IETF/2800318?fromModule=lemma_inlink">IETF</a>的<a href="https://baike.baidu.com/item/RFC/2798645?fromModule=lemma_inlink">RFC</a> 定义。</p><p><strong>UDP</strong>: [Internet ](<a href="https://baike.baidu.com/item/Internet">https://baike.baidu.com/item/Internet</a> /272794?fromModule=lemma_inlink)协议集支持一个无连接的<a href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821?fromModule=lemma_inlink">传输协议</a>，该协议称为<strong>用户数据报协议（UDP，User Datagram Protocol）</strong>。UDP 为<a href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>提供了一种<strong>无需建立连接</strong>就可以发送封装的 IP 数据包的方法。RFC 描述了 UDP。</p><h3 id="tcp-与-udp-的区别重要"><a class="markdownIt-Anchor" href="#tcp-与-udp-的区别重要"></a> TCP 与 UDP 的区别（重要）</h3><ol><li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li><li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。<strong>TCP 传输是有状态的</strong>，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态服务</strong>，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li><li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li><li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li><li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li><li>…</li></ol><p>我把上面总结的内容通过表格形式展示出来了！</p><table><thead><tr><th></th><th>TCP</th><th>UDP</th></tr></thead><tbody><tr><td>是否面向连接</td><td>是</td><td>否</td></tr><tr><td>是否可靠</td><td>是</td><td>否</td></tr><tr><td>是否有状态</td><td>是</td><td>否</td></tr><tr><td>传输效率</td><td>较慢</td><td>较快</td></tr><tr><td>传输形式</td><td>字节流</td><td>数据报文段</td></tr><tr><td>首部开销</td><td>20 ～ 60 bytes</td><td>8 bytes</td></tr><tr><td>是否提供广播或多播服务</td><td>否</td><td>是</td></tr></tbody></table><h3 id="什么时候选择-tcp什么时候选-udp"><a class="markdownIt-Anchor" href="#什么时候选择-tcp什么时候选-udp"></a> 什么时候选择 TCP,什么时候选 UDP?</h3><ul><li><strong>UDP 一般用于<mark>即时通信</mark></strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li><li><strong>TCP 用于对传输<mark>准确性要求特别高</mark>的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li></ul><h3 id="http-基于-tcp-还是-udp"><a class="markdownIt-Anchor" href="#http-基于-tcp-还是-udp"></a> HTTP 基于 TCP 还是 UDP？</h3><p><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</p><h3 id="使用-tcp-的协议有哪些使用-udp-的协议有哪些"><a class="markdownIt-Anchor" href="#使用-tcp-的协议有哪些使用-udp-的协议有哪些"></a> 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3><p><strong>运行于 TCP 协议之上的协议</strong> ：</p><ol><li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li><li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li><li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li><li><strong>POP3/IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li><li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li><li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li><li>…</li></ol><p><strong>运行于 UDP 协议之上的协议</strong> ：</p><ol><li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li><li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a href="http://www.baidu.com">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li></ol><h3 id="tcp-三次握手和四次挥手非常重要"><a class="markdownIt-Anchor" href="#tcp-三次握手和四次挥手非常重要"></a> TCP 三次握手和四次挥手（非常重要）</h3><p><strong>相关面试题</strong> ：</p><ul><li>为什么要三次握手?</li><li>第 2 次握手传回了ACK，为什么还要传回SYN？</li><li>为什么要四次挥手？</li><li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li><li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li><li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li></ul><p><strong>参考答案</strong> ：<a href="">TCP 三次握手和四次挥手（传输层）</a> 。</p><h3 id="tcp-如何保证传输的可靠性重要"><a class="markdownIt-Anchor" href="#tcp-如何保证传输的可靠性重要"></a> TCP 如何保证传输的可靠性？（重要）</h3><p><a href="">TCP 传输可靠性保障（传输层）</a></p><h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2><h3 id="从输入url-到页面展示到底发生了什么非常重要"><a class="markdownIt-Anchor" href="#从输入url-到页面展示到底发生了什么非常重要"></a> 从输入URL 到页面展示到底发生了什么？（非常重要）</h3><blockquote><p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>图解（图片来源：《图解 HTTP》）：</p><p><img src="../../../images/image-20230220134232347.png" alt="image-20230220134232347"></p><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么？open in new window</a></li><li><a href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li></ul><h3 id="http-状态码有哪些"><a class="markdownIt-Anchor" href="#http-状态码有哪些"></a> HTTP 状态码有哪些？</h3><p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p><p><img src="../../../images/image-20230220134252269.png" alt="image-20230220134252269"></p><p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="">HTTP 常见状态码总结（应用层）</a>。</p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">#</a> HTTP 和 HTTPS 有什么区别？（重要）</h3><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li></ul><p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP vs HTTPS（应用层）</a> 。</p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#http-1-0-%E5%92%8C-http-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP 1.0 和 HTTP 1.1 有什么区别？</h3><ul><li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段。</li></ul><p>关于 HTTP 1.0 和 HTTP 1.1 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP 1.0 vs HTTP 1.1（应用层）</a> 。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#http-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81">#</a> HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><p><img src="../../../images/image-20230220134259293.png" alt="image-20230220134259293"></p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> URI 和 URL 的区别是什么?</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h2 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#arp">#</a> ARP</h2><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E4%BB%80%E4%B9%88%E6%98%AF-mac-%E5%9C%B0%E5%9D%80">#</a> 什么是 Mac 地址？</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p><p><img src="/.com//../../../../../assets/2008410143049281.3c367990.png" alt="路由器的背面就会注明 MAC 位址"></p><p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p><blockquote><p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p></blockquote><p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p><p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p><p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p><h3 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#arp-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%9C%B0%E4%BD%8D%E5%A6%82%E4%BD%95">#</a> ARP 协议解决了什么问题地位如何？</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p><h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#arp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> ARP 协议的工作原理？</h3><p><a href="">ARP 协议详解(网络层)</a></p><h2 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#%E5%A4%8D%E4%B9%A0%E5%BB%BA%E8%AE%AE">#</a> 复习建议</h2><p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>牛客网java核心基础面试题</title>
      <link href="/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么java代码可以实现一次编写-到处运行"><a class="markdownIt-Anchor" href="#为什么java代码可以实现一次编写-到处运行"></a> 为什么Java代码可以实现一次编写、到处运行？</h2><p><img src="../../images/image-20230222165320333.png" alt="image-20230222165320333"></p><h2 id="遇到过异常吗如何处理"><a class="markdownIt-Anchor" href="#遇到过异常吗如何处理"></a> 遇到过异常吗，如何处理？</h2><p><strong>参考答案</strong></p><p>在Java中，可以按照如下三个步骤处理异常：</p><ol><li><strong>捕获异常</strong></li></ol><p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p><ol start="2"><li><strong>处理异常</strong></li></ol><p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p><ol start="3"><li><strong>回收资源</strong></li></ol><p>如果业务代码打开了某个资源，比如<mark>数据库连接、网络连接、磁盘文件</mark>等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p><h2 id="说一说java的异常机制"><a class="markdownIt-Anchor" href="#说一说java的异常机制"></a> 说一说Java的异常机制？</h2><p><strong>参考答案</strong></p><p><strong>关于异常的处理：</strong></p><p>在Java中，处理异常的语句由try、catch、finally三部分组成。其中，<strong>try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源</strong>。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p><p><strong>关于抛出异常：</strong></p><p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上<strong>通过throws关键字声明抛出异常，则该异常将交给JVM处理</strong>。</p><p><strong>关于异常跟踪栈：</strong></p><p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p><h2 id="finally是无条件执行的吗"><a class="markdownIt-Anchor" href="#finally是无条件执行的吗"></a> finally是无条件执行的吗？</h2><p><strong>参考答案</strong></p><p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p><p><strong>注意事项</strong></p><p>如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p><h2 id="在finally中return会发生什么"><a class="markdownIt-Anchor" href="#在finally中return会发生什么"></a> 在finally中return会发生什么？</h2><p><strong>参考答案</strong></p><p>在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中return、throw语句失效。</p><p><strong>详细解析</strong></p><p>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p><h2 id="static和final有什么区别"><a class="markdownIt-Anchor" href="#static和final有什么区别"></a> static和final有什么区别？</h2><p><img src="../../images/image-20230219163021865.png" alt="image-20230219163021865"></p><p><img src="../../images/image-20230219163033920.png" alt="image-20230219163033920"></p><h2 id="说说你对泛型的理解"><a class="markdownIt-Anchor" href="#说说你对泛型的理解"></a> 说说你对泛型的理解</h2><p><img src="../../images/image-20230219162902190.png" alt="image-20230219162902190"></p><h2 id="list-super-t和list-extends-t有什么区别"><a class="markdownIt-Anchor" href="#list-super-t和list-extends-t有什么区别"></a> List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</h2><p><strong>参考答案</strong></p><ul><li><p>? 是类型通配符， List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List；</p></li><li><p>List&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；</p></li><li><p>List&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。</p></li></ul><p><strong>扩展阅读</strong></p><p>在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<integer> 对象赋值给List<number> 变量。</number></integer></p><p>数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但 G<foo> 不是 G<bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</bar></foo></p><h2 id="说说你对java反射机制的理解"><a class="markdownIt-Anchor" href="#说说你对java反射机制的理解"></a> 说说你对Java反射机制的理解</h2><p><img src="../../images/image-20230219162554595.png" alt="image-20230219162554595"></p><h2 id="java反射在实际项目种有哪些应用场景"><a class="markdownIt-Anchor" href="#java反射在实际项目种有哪些应用场景"></a> Java反射在实际项目种有哪些应用场景？</h2><p><strong>参考答案</strong></p><p>Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p><ul><li><p>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</p></li><li><p>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</p></li><li><p>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</p></li></ul><p><img src="../../images/image-20230219162329199.png" alt="image-20230219162329199"></p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 牛客网java核心基础面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java核心基础面试</title>
      <link href="/2023/02/18/interview/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/02/18/interview/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="java概述"><a class="markdownIt-Anchor" href="#java概述"></a> Java概述</h2><h3 id="何为编程"><a class="markdownIt-Anchor" href="#何为编程"></a> 何为编程</h3><ul><li><strong>编程</strong>就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</li><li>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</li></ul><h3 id="什么是java"><a class="markdownIt-Anchor" href="#什么是java"></a> 什么是Java</h3><ul><li>Java是一门面向对象编程语言，不仅吸收了C<ins>语言的各种优点，还摒弃了C</ins>里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</li></ul><h3 id="jdk15之后的三大版本"><a class="markdownIt-Anchor" href="#jdk15之后的三大版本"></a> jdk1.5之后的三大版本</h3><ul><li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li><li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li><li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li></ul><h3 id="3-jdk和jre和jvm的区别"><a class="markdownIt-Anchor" href="#3-jdk和jre和jvm的区别"></a> 3 Jdk和Jre和JVM的区别</h3><p>看Java官方的图片，<strong>Jdk中包括了Jre，Jre中包括了JVM</strong></p><ul><li><p>JDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p></li><li><p>JRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p><p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p></li><li><p>Jvm：在倒数第二层   由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c434318a82~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="什么是跨平台性原理是什么"><a class="markdownIt-Anchor" href="#什么是跨平台性原理是什么"></a> 什么是跨平台性？原理是什么</h3><ul><li>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</li><li>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</li></ul><h3 id="为什么java代码可以实现一次编写-到处运行"><a class="markdownIt-Anchor" href="#为什么java代码可以实现一次编写-到处运行"></a> 为什么Java代码可以实现一次编写、到处运行？</h3><p><strong>参考答案：</strong></p><p>JVM（Java虚拟机）是Java跨平台的关键。</p><p>在程序运行前，<strong>Java源代码（.java）<strong>需要经过编译器编译成</strong>字节码（.class）</strong>。在程序运行时，JVM负责将字节码翻译成特定平台下的<strong>机器码</strong>并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p><p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p><p><strong>注意事项：</strong></p><ol><li><p>编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；</p></li><li><p>跨平台的是Java程序、而不是JVM，JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。</p></li></ol><h3 id="java语言有哪些特点"><a class="markdownIt-Anchor" href="#java语言有哪些特点"></a> Java语言有哪些特点</h3><ul><li>简单易学（Java语言的语法与C语言和C++语言很接近）</li><li>面向对象（封装，继承，多态）</li><li>平台无关性（Java虚拟机实现平台无关性）</li><li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li><li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任务）</li><li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li><li>安全性好</li></ul><h3 id="什么是字节码采用字节码的最大好处是什么"><a class="markdownIt-Anchor" href="#什么是字节码采用字节码的最大好处是什么"></a> 什么是字节码？采用字节码的最大好处是什么</h3><ul><li><p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p></li><li><p><strong>采用字节码的好处</strong>：</p><p>Java语言通过字节码的方式，在<strong>一定程度上解决了传统解释型语言执行效率低的问题</strong>，</p><p>同时又<strong>保留了解释型语言可移植的特点</strong>。所以Java程序运行时比较高效，</p><p>而且，由于<strong>字节码并不专对一种特定的机器</strong>，因此，Java程序<strong>无须重新编译</strong>便可在多种不同的计算机上运行。</p></li><li><p><strong>先看下java中的编译器和解释器</strong>：</p><p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。<strong>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行</strong>，这就是上面提到的Java的特点的编译与解释并存的解释。</p><p>Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</p></li></ul><h3 id="什么是java程序的主类应用程序和小程序的主类有何不同"><a class="markdownIt-Anchor" href="#什么是java程序的主类应用程序和小程序的主类有何不同"></a> 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3><ul><li>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</li></ul><h3 id="java应用程序与小程序之间有那些差别"><a class="markdownIt-Anchor" href="#java应用程序与小程序之间有那些差别"></a> Java应用程序与小程序之间有那些差别？</h3><ul><li>简单说应用程序是从主线程启动(也就是main()方法)。</li><li>applet小程序没有main方法，主要是<strong>嵌在浏览器</strong>页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</li></ul><h3 id="java和c的区别"><a class="markdownIt-Anchor" href="#java和c的区别"></a> Java和C++的区别</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</span><br></pre></td></tr></tbody></table></figure><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h3 id="oracle-jdk-和-openjdk-的对比"><a class="markdownIt-Anchor" href="#oracle-jdk-和-openjdk-的对比"></a> Oracle JDK 和 OpenJDK 的对比</h3><ol><li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li><li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li><li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li><li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li><li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li><li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li></ol><h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2><h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3><h4 id="java有哪些数据类型"><a class="markdownIt-Anchor" href="#java有哪些数据类型"></a> Java有哪些数据类型</h4><p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p><p><strong>分类</strong></p><ul><li>基本数据类型<ul><li>数值型<ul><li>整数类型(byte,short,int,long)</li><li>浮点类型(float,double)</li></ul></li><li>字符型(char)</li><li>布尔型(boolean)</li></ul></li><li>引用数据类型<ul><li>类(class)</li><li>接口(interface)</li><li>数组([])</li></ul></li></ul><p><strong>Java基本数据类型图</strong></p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c434465b69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h4 id="switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上"><a class="markdownIt-Anchor" href="#switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上"></a> switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4><ul><li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li></ul><h4 id="用最有效率的方法计算-2-乘以-8"><a class="markdownIt-Anchor" href="#用最有效率的方法计算-2-乘以-8"></a> 用最有效率的方法计算 2 乘以 8</h4><ul><li><p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p></li><li><pre class="highlight"><code class="java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;        a = a &lt;&lt; <span class="number">3</span>;        System.out.println( a );  <span class="comment">// a = 8</span>        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">16</span>;        b =  b &gt;&gt; <span class="number">3</span>;        System.out.println( b ); <span class="comment">// b = 2</span>&lt;!--code￼<span class="number">1</span>--&gt;</code></pre></li></ul><p>注意事项：多行和文档注释都不能嵌套使用。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 访问修饰符</span><br><span class="line"></span><br><span class="line">#### 访问修饰符 public,private,protected,以及不写（默认default）时的区别</span><br><span class="line"></span><br><span class="line">- **定义**：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</span><br><span class="line">- **分类**</span><br><span class="line">  - private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</span><br><span class="line">  - default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</span><br><span class="line">  - protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</span><br><span class="line">  - public : 对所有类可见。使用对象：类、接口、变量、方法</span><br><span class="line"></span><br><span class="line">**访问修饰符图**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c433bcfd38~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 运算符</span><br><span class="line"></span><br><span class="line">#### &amp;和&amp;&amp;的区别</span><br><span class="line"></span><br><span class="line">- &amp;运算符有两种用法：(1)按位与；(2)逻辑与。</span><br><span class="line">- &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 关键字</span><br><span class="line"></span><br><span class="line">#### Java 有没有 goto</span><br><span class="line"></span><br><span class="line">- goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</span><br><span class="line"></span><br><span class="line">#### final 有什么用？</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>用于修饰类、属性和方法；</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 被final修饰的类不可以被继承</span><br><span class="line">- 被final修饰的方法不可以被重写</span><br><span class="line">- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</span><br><span class="line"></span><br><span class="line">#### final finally finalize区别</span><br><span class="line"></span><br><span class="line">- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</span><br><span class="line">- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</span><br><span class="line">- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。</span><br><span class="line"></span><br><span class="line">#### this关键字的用法</span><br><span class="line"></span><br><span class="line">- this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</span><br><span class="line"></span><br><span class="line">- this的用法在java中大体可以分为3种：</span><br><span class="line"></span><br><span class="line">  - 1.普通的直接引用，this相当于是指向当前对象本身。</span><br><span class="line"></span><br><span class="line">  - 2.形参与成员名字重名，用this来区分：</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public Person(String name, int age) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><ul><li><p>3.引用本类的构造函数</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="super关键字的用法"><a class="markdownIt-Anchor" href="#super关键字的用法"></a> super关键字的用法</h4><ul><li><p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p></li><li><p>super也有三种用法：</p><ul><li><p>1.普通的直接引用</p><p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p></li><li><p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">String</span> name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Person</span>(<span class="title class_">String</span> name) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Student</span>(<span class="title class_">String</span> name, <span class="title class_">String</span> name1) {</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name1;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">getInfo</span>(<span class="params"></span>){</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span>);      <span class="comment">//Child</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">super</span>.<span class="property">name</span>);     <span class="comment">//Father</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) {</span><br><span class="line">       <span class="title class_">Student</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"Father"</span>,<span class="string">"Child"</span>);</span><br><span class="line">       s1.<span class="title function_">getInfo</span>();</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.引用父类构造函数</p><ul><li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li><li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li></ul></li></ul></li></ul><h4 id="this与super的区别"><a class="markdownIt-Anchor" href="#this与super的区别"></a> this与super的区别</h4><ul><li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li><li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li><li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li><li>super()和this()均需放在构造方法内第一行。</li><li>尽管可以用this调用一个构造器，但却不能调用两个。</li><li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li><li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li><li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li></ul><h4 id="static存在的主要意义"><a class="markdownIt-Anchor" href="#static存在的主要意义"></a> static存在的主要意义</h4><ul><li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li><li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li></ul><h4 id="static的独特之处"><a class="markdownIt-Anchor" href="#static的独特之处"></a> static的独特之处</h4><ul><li>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li></ul><blockquote><p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p></blockquote><ul><li>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li><li>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li><li>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li></ul><h4 id="static应用场景"><a class="markdownIt-Anchor" href="#static应用场景"></a> static应用场景</h4><ul><li>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</li><li>因此比较常见的static应用场景有：</li></ul><blockquote><p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p></blockquote><h4 id="static注意事项"><a class="markdownIt-Anchor" href="#static注意事项"></a> static注意事项</h4><ul><li>1、静态只能访问静态</li><li>2、非静态既可以访问非静态的，也可以访问静态的。</li></ul><h3 id="流程控制语句"><a class="markdownIt-Anchor" href="#流程控制语句"></a> 流程控制语句</h3><h4 id="break-continue-return-的区别及作用"><a class="markdownIt-Anchor" href="#break-continue-return-的区别及作用"></a> break ,continue ,return 的区别及作用</h4><ul><li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li><li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</li><li>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</li></ul><h4 id="在-java-中如何跳出当前的多重嵌套循环"><a class="markdownIt-Anchor" href="#在-java-中如何跳出当前的多重嵌套循环"></a> 在 Java 中，如何跳出当前的多重嵌套循环</h4><ul><li><p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>{</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2><h3 id="面向对象概述"><a class="markdownIt-Anchor" href="#面向对象概述"></a> 面向对象概述</h3><h4 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h4><ul><li><strong>面向过程</strong>：<ul><li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li><li>缺点：没有面向对象易维护、易复用、易扩展</li></ul></li><li><strong>面向对象</strong>：<ul><li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li><li>缺点：性能比面向过程低</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</span><br><span class="line">面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</span><br><span class="line">面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</span><br></pre></td></tr></tbody></table></figure><h3 id="面向对象三大特性"><a class="markdownIt-Anchor" href="#面向对象三大特性"></a> 面向对象三大特性</h3><h4 id="面向对象的特征有哪些方面"><a class="markdownIt-Anchor" href="#面向对象的特征有哪些方面"></a> 面向对象的特征有哪些方面</h4><p><strong>面向对象的特征主要有以下几个方面</strong>：</p><ul><li><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。（抽象类不可实例化）</li><li><strong>封装</strong>：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li><li><strong>继承</strong>：是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。<ul><li>关于继承如下 3 点请记住：<ul><li>子类拥有父类非 private 的属性和方法。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li></ul></li></ul></li><li><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</li></ul><h4 id="什么是多态机制java语言是如何实现多态的"><a class="markdownIt-Anchor" href="#什么是多态机制java语言是如何实现多态的"></a> 什么是多态机制？Java语言是如何实现多态的？</h4><ul><li>所谓<mark>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定</mark>，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li><li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li></ul><p><strong>多态的实现</strong></p><ul><li>Java实现多态有三个必要条件：继承、重写、向上转型。<ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</span><br><span class="line">对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</span><br></pre></td></tr></tbody></table></figure><h4 id="面向对象五大基本原则是什么可选"><a class="markdownIt-Anchor" href="#面向对象五大基本原则是什么可选"></a> 面向对象五大基本原则是什么（可选）</h4><ul><li>单一职责原则SRP(Single Responsibility Principle)<br>类的功能要单一，不能包罗万象，跟杂货铺似的。</li><li>开放封闭原则OCP(Open－Close Principle)<br>一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li><li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li><li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li><li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li></ul><h3 id="类与接口"><a class="markdownIt-Anchor" href="#类与接口"></a> 类与接口</h3><h4 id="抽象类和接口的对比"><a class="markdownIt-Anchor" href="#抽象类和接口的对比"></a> 抽象类和接口的对比</h4><ul><li>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li><li>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li></ul><p><strong>相同点</strong></p><ul><li>接口和抽象类都不能实例化</li><li>都位于继承的顶端，用于被其他实现或继承</li><li>都包含抽象方法，其子类都必须覆写这些抽象方法</li></ul><p><strong>不同点</strong></p><table><thead><tr><th>参数</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>声明</td><td>抽象类使用abstract关键字声明</td><td>接口使用interface关键字声明</td></tr><tr><td>实现</td><td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td><td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td></tr><tr><td>构造器</td><td>抽象类可以有构造器</td><td>接口不能有构造器</td></tr><tr><td>访问修饰符</td><td>抽象类中的方法可以是任意访问修饰符</td><td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td></tr><tr><td>多继承</td><td>一个类最多只能继承一个抽象类</td><td>一个类可以实现多个接口</td></tr><tr><td>字段声明</td><td>抽象类的字段声明可以是任意的</td><td>接口的字段默认都是 static 和 final 的</td></tr></tbody></table><p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</span><br></pre></td></tr></tbody></table></figure><ul><li>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：<ul><li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li><li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li></ul></li></ul><h4 id="普通类和抽象类有哪些区别"><a class="markdownIt-Anchor" href="#普通类和抽象类有哪些区别"></a> 普通类和抽象类有哪些区别？</h4><ul><li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li><li>抽象类不能直接实例化，普通类可以直接实例化。</li></ul><h4 id="抽象类能使用-final-修饰吗"><a class="markdownIt-Anchor" href="#抽象类能使用-final-修饰吗"></a> 抽象类能使用 final 修饰吗？</h4><ul><li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</li></ul><h4 id="创建一个对象用什么关键字对象实例与对象引用有何不同"><a class="markdownIt-Anchor" href="#创建一个对象用什么关键字对象实例与对象引用有何不同"></a> 创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4><ul><li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li></ul><h3 id="变量与方法"><a class="markdownIt-Anchor" href="#变量与方法"></a> 变量与方法</h3><h4 id="成员变量与局部变量的区别有哪些"><a class="markdownIt-Anchor" href="#成员变量与局部变量的区别有哪些"></a> 成员变量与局部变量的区别有哪些</h4><ul><li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li><li>成员变量：方法外部，类内部定义的变量</li><li>局部变量：类的方法中的变量。</li><li>成员变量和局部变量的区别</li></ul><p><strong>作用域</strong></p><ul><li>成员变量：针对整个类有效。</li><li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li></ul><p><strong>存储位置</strong></p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li><li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li></ul><p><strong>生命周期</strong></p><ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li><li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li></ul><p><strong>初始值</strong></p><ul><li>成员变量：有默认初始值。</li><li>局部变量：没有默认初始值，使用前必须赋值。</li></ul><h4 id="在java中定义一个不做事且没有参数的构造方法的作用"><a class="markdownIt-Anchor" href="#在java中定义一个不做事且没有参数的构造方法的作用"></a> 在Java中定义一个不做事且没有参数的构造方法的作用</h4><ul><li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li></ul><h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是"><a class="markdownIt-Anchor" href="#在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是"></a> 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4><ul><li>帮助子类做初始化工作。</li></ul><h4 id="一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么"><a class="markdownIt-Anchor" href="#一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么"></a> 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4><ul><li>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li></ul><h4 id="构造方法有哪些特性"><a class="markdownIt-Anchor" href="#构造方法有哪些特性"></a> 构造方法有哪些特性？</h4><ul><li>名字与类名相同；</li><li>没有返回值，但不能用void声明构造函数；</li><li>生成类的对象时自动执行，无需调用。</li></ul><h4 id="静态变量和实例变量区别"><a class="markdownIt-Anchor" href="#静态变量和实例变量区别"></a> 静态变量和实例变量区别</h4><ul><li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li><li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li></ul><h4 id="静态变量与普通变量区别"><a class="markdownIt-Anchor" href="#静态变量与普通变量区别"></a> 静态变量与普通变量区别</h4><ul><li>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li><li>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</li></ul><h4 id="静态方法和实例方法有何不同"><a class="markdownIt-Anchor" href="#静态方法和实例方法有何不同"></a> 静态方法和实例方法有何不同？</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法和实例方法的区别主要体现在两个方面：</span><br></pre></td></tr></tbody></table></figure><ul><li>在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li><li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li></ul><h4 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a class="markdownIt-Anchor" href="#在一个静态方法内调用一个非静态成员为什么是非法的"></a> 在一个静态方法内调用一个非静态成员为什么是非法的？</h4><ul><li>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</li></ul><h4 id="什么是方法的返回值返回值的作用是什么"><a class="markdownIt-Anchor" href="#什么是方法的返回值返回值的作用是什么"></a> 什么是方法的返回值？返回值的作用是什么？</h4><ul><li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</li></ul><h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3><h4 id="什么是内部类"><a class="markdownIt-Anchor" href="#什么是内部类"></a> 什么是内部类？</h4><ul><li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</li></ul><h4 id="内部类的分类有哪些"><a class="markdownIt-Anchor" href="#内部类的分类有哪些"></a> 内部类的分类有哪些</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部类可以分为四种：**成员内部类、局部内部类、匿名内部类和静态内部类**。</span><br></pre></td></tr></tbody></table></figure><h5 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h5><ul><li><p>定义在类内部的静态类，就是静态内部类。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInner</span> {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span>()</span> {</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span>.StaticInner <span class="keyword">inner</span> = <span class="built_in">new</span> <span class="keyword">Outer</span>.StaticInner();</span><br><span class="line"><span class="keyword">inner</span>.visit();复制代码</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="成员内部类"><a class="markdownIt-Anchor" href="#成员内部类"></a> 成员内部类</h5><ul><li><p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="built_in">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">count</span> =<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> visit() {</span><br><span class="line">            System.out.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">"visit outer   variable:"</span> + <span class="keyword">count</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> <span class="keyword">outer</span> = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line"><span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = <span class="keyword">outer</span>.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line"><span class="keyword">inner</span>.visit();</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="局部内部类"><a class="markdownIt-Anchor" href="#局部内部类"></a> 局部内部类</h5><ul><li><p>定义在方法中的内部类，就是局部内部类。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="built_in">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span>()</span>{</span><br><span class="line">        <span class="built_in">int</span> inner_c =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span>()</span>{</span><br><span class="line">                System.<span class="keyword">out</span>.println(out_a);</span><br><span class="line">                System.<span class="keyword">out</span>.println(STATIC_b);</span><br><span class="line">                System.<span class="keyword">out</span>.println(inner_c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span>()</span>{</span><br><span class="line">        <span class="built_in">int</span> d =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span>()</span>{</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(STATIC_b);</span><br><span class="line">                System.<span class="keyword">out</span>.println(d);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> testStaticFunctionClass(){</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">Inner</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">Inner</span>  <span class="keyword">inner</span> = <span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure></li></ul><h5 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h5><ul><li><p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params">final <span class="built_in">int</span> i</span>)</span> {</span><br><span class="line">        <span class="keyword">new</span> Service() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>()</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"匿名内部类"</span> );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.method();</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="keyword">interface</span> <span class="title">Service</span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>除了没有名字，匿名内部类还有以下特点：</p><ul><li>匿名内部类必须继承一个抽象类或者实现一个接口。</li><li>匿名内部类不能定义任何静态成员和静态方法。</li><li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li><li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li></ul></li><li><p>匿名内部类创建方式：</p><figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type"></span>类/接口{ </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="内部类的优点"><a class="markdownIt-Anchor" href="#内部类的优点"></a> 内部类的优点</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们为什么要使用内部类呢？因为它有以下优点：</span><br></pre></td></tr></tbody></table></figure><ul><li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li><li>内部类不为同一包的其他类所见，具有很好的封装性；</li><li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li><li>匿名内部类可以很方便的定义回调。</li></ul><h4 id="内部类有哪些应用场景"><a class="markdownIt-Anchor" href="#内部类有哪些应用场景"></a> 内部类有哪些应用场景</h4><ol><li>一些多算法场合</li><li>解决一些非面向对象的语句块。</li><li>适当使用内部类，使得代码更加灵活和富有扩展性。</li><li>当某个类除了它的外部类，不再被其他的类使用时。</li></ol><h4 id="局部内部类和匿名内部类访问局部变量的时候为什么变量必须要加上final"><a class="markdownIt-Anchor" href="#局部内部类和匿名内部类访问局部变量的时候为什么变量必须要加上final"></a> 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4><ul><li><p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMethod</span>()</span>{</span><br><span class="line">        final <span class="built_in">int</span> a =<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span>()</span>{</span><br><span class="line">                System.<span class="keyword">out</span>.println(a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p></li></ul><h4 id="内部类相关看程序说出运行结果"><a class="markdownIt-Anchor" href="#内部类相关看程序说出运行结果"></a> 内部类相关，看程序说出运行结果</h4><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">13</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>()</span> {</span><br><span class="line">            <span class="built_in">int</span> age = <span class="number">14</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"局部变量："</span> + age);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"外部类变量："</span> + Outer.<span class="keyword">this</span>.age);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">        Outer.Inner <span class="keyword">in</span> = <span class="keyword">new</span> Outer().<span class="function"><span class="keyword">new</span> <span class="title">Inner</span>()</span>;</span><br><span class="line">        <span class="keyword">in</span>.print();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：14</span><br><span class="line">内部类变量：13</span><br><span class="line">外部类变量：12复制代码</span><br></pre></td></tr></tbody></table></figure><h3 id="重写与重载"><a class="markdownIt-Anchor" href="#重写与重载"></a> 重写与重载</h3><h4 id="构造器constructor是否可被重写override"><a class="markdownIt-Anchor" href="#构造器constructor是否可被重写override"></a> 构造器（constructor）是否可被重写（override）</h4><ul><li>构造器不能被继承，因此不能被重写，但可以被重载。</li></ul><h4 id="重载overload和重写override的区别-重载的方法能否根据返回类型进行区分"><a class="markdownIt-Anchor" href="#重载overload和重写override的区别-重载的方法能否根据返回类型进行区分"></a> 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4><ul><li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li><li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</li><li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li></ul><h3 id="对象相等判断"><a class="markdownIt-Anchor" href="#对象相等判断"></a> 对象相等判断</h3><h4 id="和-equals-的区别是什么"><a class="markdownIt-Anchor" href="#和-equals-的区别是什么"></a> == 和 equals 的区别是什么</h4><ul><li><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p></li><li><p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p><ul><li><p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p></li><li><p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p></li><li><p><strong>举个例子：</strong></p><figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) {</span><br><span class="line">        <span class="title class_">String</span> a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="title class_">String</span> b = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="title class_">String</span> aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="title class_">String</span> bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="title function_">equals</span>(b)) <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) { <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"true"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul></li><li><p><strong>说明：</strong></p><ul><li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li><li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li></ul></li></ul><h4 id="hashcode-与-equals-重要"><a class="markdownIt-Anchor" href="#hashcode-与-equals-重要"></a> hashCode 与 equals (重要)</h4><ul><li>HashSet如何检查重复</li><li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li><li>hashCode和equals方法的关系</li><li>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</li></ul><p><strong>hashCode()介绍</strong></p><ul><li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</li><li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li></ul><p><strong>为什么要有 hashCode</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</span><br></pre></td></tr></tbody></table></figure><ul><li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li></ul><p><strong>hashCode()与equals()的相关规定</strong></p><ul><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等，对两个对象分别调用equals方法都返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</span><br><span class="line">hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</span><br></pre></td></tr></tbody></table></figure><h4 id="对象的相等与指向他们的引用相等两者有什么不同"><a class="markdownIt-Anchor" href="#对象的相等与指向他们的引用相等两者有什么不同"></a> 对象的相等与指向他们的引用相等，两者有什么不同？</h4><ul><li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li></ul><h3 id="值传递"><a class="markdownIt-Anchor" href="#值传递"></a> 值传递</h3><h4 id="当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递"><a class="markdownIt-Anchor" href="#当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递"></a> 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4><ul><li>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</li></ul><h4 id="为什么-java-中只有值传递"><a class="markdownIt-Anchor" href="#为什么-java-中只有值传递"></a> 为什么 Java 中只有值传递</h4><ul><li>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li><li><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong><ul><li><strong>下面通过 3 个例子来给大家说明</strong></li></ul></li></ul><h5 id="example-1"><a class="markdownIt-Anchor" href="#example-1"></a> example 1</h5><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) {</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("num1 = " + num1);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("num2 = " + num2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> static <span class="type">void</span> swap(<span class="type">int</span> a, <span class="type">int</span> b) {</span><br><span class="line">    <span class="type">int</span> <span class="keyword">temp</span> = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("a = " + a);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("b = " + b);</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li><p>结果：</p><p>a = 20 b = 10 num1 = 10 num2 = 20</p></li><li><p>解析：</p></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c436af3af1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example.</span><br></pre></td></tr></tbody></table></figure><h5 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> example 2</h5><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">    <span class="built_in">int</span>[] arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span> {</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li><p>结果：</p><p>1 0</p></li><li><p>解析：</p></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c4372f6ac8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</span><br><span class="line">很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</span><br></pre></td></tr></tbody></table></figure><h5 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> example 3</h5><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test {</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) {</span><br><span class="line">        // TODO Auto-<span class="keyword">generated</span> <span class="keyword">method</span> stub</span><br><span class="line">        Student s1 = <span class="built_in">new</span> Student("小张");</span><br><span class="line">        Student s2 = <span class="built_in">new</span> Student("小李");</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("s1:" + s1.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("s2:" + s2.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> swap(Student x, Student y) {</span><br><span class="line">        Student <span class="keyword">temp</span> = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = <span class="keyword">temp</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("x:" + x.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("y:" + y.getName());</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li><p>结果：</p><p>x:小李 y:小张 s1:小张 s2:小李</p></li><li><p>解析：</p></li><li><p>交换之前：</p></li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c445af6270~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li>交换之后：</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c45facc688~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></li><li>总结<ul><li><code>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</code></li></ul></li><li>下面再总结一下Java中方法参数的使用情况：<ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。</li></ul></li></ul><h4 id="值传递和引用传递有什么区别"><a class="markdownIt-Anchor" href="#值传递和引用传递有什么区别"></a> 值传递和引用传递有什么区别</h4><ul><li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li><li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li></ul><h3 id="java包"><a class="markdownIt-Anchor" href="#java包"></a> Java包</h3><h4 id="jdk-中常用的包有哪些"><a class="markdownIt-Anchor" href="#jdk-中常用的包有哪些"></a> JDK 中常用的包有哪些</h4><ul><li>java.lang：这个是系统的基础类；</li><li><a href="http://java.io">java.io</a>：这里面是所有输入输出有关的类，比如文件操作等；</li><li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li><li><a href="http://java.net">java.net</a>：这里面是与网络有关的类；</li><li>java.util：这个是系统辅助类，特别是集合类；</li><li>java.sql：这个是数据库操作的类。</li></ul><h4 id="import-java和javax有什么区别"><a class="markdownIt-Anchor" href="#import-java和javax有什么区别"></a> import java和javax有什么区别</h4><ul><li>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，实际上java和javax没有区别。这都是一个名字。</span><br></pre></td></tr></tbody></table></figure><h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2><h3 id="java-中-io-流分为几种"><a class="markdownIt-Anchor" href="#java-中-io-流分为几种"></a> java 中 IO 流分为几种?</h3><ul><li>按照流的流向分，可以分为输入流和输出流；</li><li>按照操作单元划分，可以划分为字节流和字符流；</li><li>按照流的角色划分为节点流和处理流。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</span><br></pre></td></tr></tbody></table></figure><ul><li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作方式分类结构图：</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c4799a7a74~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作对象分类结构图：</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c479a04121~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><h3 id="bionioaio-有什么区别"><a class="markdownIt-Anchor" href="#bionioaio-有什么区别"></a> BIO,NIO,AIO 有什么区别?</h3><ul><li>简答<ul><li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li><li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li><li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li></ul></li><li>详细回答<ul><li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li><li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li><li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li></ul></li></ul><h3 id="files的常用方法都有哪些"><a class="markdownIt-Anchor" href="#files的常用方法都有哪些"></a> Files的常用方法都有哪些？</h3><ul><li>Files. exists()：检测文件路径是否存在。</li><li>Files. createFile()：创建文件。</li><li>Files. createDirectory()：创建文件夹。</li><li>Files. delete()：删除一个文件或目录。</li><li>Files. copy()：复制文件。</li><li>Files. move()：移动文件。</li><li>Files. size()：查看文件个数。</li><li>Files. read()：读取文件。</li><li>Files. write()：写入文件。</li></ul><h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2><h3 id="什么是反射机制"><a class="markdownIt-Anchor" href="#什么是反射机制"></a> 什么是反射机制？</h3><ul><li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li><li>静态编译和动态编译<ul><li>静态编译：在编译时确定类型，绑定对象</li><li>动态编译：运行时确定类型，绑定对象</li></ul></li></ul><h3 id="反射机制优缺点"><a class="markdownIt-Anchor" href="#反射机制优缺点"></a> 反射机制优缺点</h3><ul><li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li><li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li></ul><h3 id="反射机制的应用场景有哪些"><a class="markdownIt-Anchor" href="#反射机制的应用场景有哪些"></a> 反射机制的应用场景有哪些？</h3><ul><li>反射是框架设计的灵魂。</li><li>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li><li>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</li></ul><h3 id="java获取反射的三种方法"><a class="markdownIt-Anchor" href="#java获取反射的三种方法"></a> Java获取反射的三种方法</h3><p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Student {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Get {</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">Class</span> classobj1 = stu.getClass();</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        <span class="keyword">Class</span> classobj2 = <span class="keyword">Class</span>.forName(<span class="string">"fanshe.Student"</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        <span class="keyword">Class</span> classobj3 = Student.<span class="keyword">class</span>;</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj3.getName());</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure><h2 id="常用api"><a class="markdownIt-Anchor" href="#常用api"></a> 常用API</h2><h3 id="string相关"><a class="markdownIt-Anchor" href="#string相关"></a> String相关</h3><h4 id="字符型常量和字符串常量的区别"><a class="markdownIt-Anchor" href="#字符型常量和字符串常量的区别"></a> 字符型常量和字符串常量的区别</h4><ol><li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li><li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li><li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li></ol><h4 id="什么是字符串常量池"><a class="markdownIt-Anchor" href="#什么是字符串常量池"></a> 什么是字符串常量池？</h4><ul><li>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li></ul><h4 id="string-是最基本的数据类型吗"><a class="markdownIt-Anchor" href="#string-是最基本的数据类型吗"></a> String 是最基本的数据类型吗</h4><ul><li>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char\[\] chars = {‘你’,‘好’};</span><br><span class="line">但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</span><br></pre></td></tr></tbody></table></figure><h4 id="string有哪些特性"><a class="markdownIt-Anchor" href="#string有哪些特性"></a> String有哪些特性</h4><ul><li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li><li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li><li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li></ul><h4 id="string为什么是不可变的吗"><a class="markdownIt-Anchor" href="#string为什么是不可变的吗"></a> String为什么是不可变的吗？</h4><ul><li><p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p><p>/** The value is used for character storage. */ private final char value[];</p></li></ul><h4 id="string真的是不可变的吗"><a class="markdownIt-Anchor" href="#string真的是不可变的吗"></a> String真的是不可变的吗？</h4><ul><li>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</li></ul><p><strong>1 String不可变但不代表引用不可以变</strong></p><figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">" World"</span>;</span><br><span class="line">System.<span class="property">out</span>.<span class="property">println</span>(<span class="string">"str="</span> + <span class="built_in">str</span>);复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li><p>结果：</p><p>str=Hello World</p></li><li><p>解析：</p></li><li><p>实际上，原来String的内容是不变的，只是str由原来指向"Hello"的内存地址转为指向"Hello World"的内存地址而已，也就是说多开辟了一块内存区域给"Hello World"字符串。</p></li></ul><p><strong>2.通过反射是可以修改所谓的“不可变”对象</strong></p><figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 创建字符串<span class="string">"Hello World"</span>， 并赋给引用s</span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="regexp">//</span> Hello World</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(true);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 获取s对象上的value属性的值</span><br><span class="line">char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 改变value所引用的数组中的第<span class="number">5</span>个字符</span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="regexp">//</span> Hello_World复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li><p>结果：</p><p>s = Hello World s = Hello_World</p></li><li><p>解析：</p></li><li><p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p></li></ul><h4 id="是否可以继承-string-类"><a class="markdownIt-Anchor" href="#是否可以继承-string-类"></a> 是否可以继承 String 类</h4><ul><li>String 类是 final 类，不可以被继承。</li></ul><h4 id="string-stri与-string-strnew-stringi一样吗"><a class="markdownIt-Anchor" href="#string-stri与-string-strnew-stringi一样吗"></a> String str="i"与 String str=new String(“i”)一样吗？</h4><ul><li>不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li></ul><h4 id="string-s-new-stringxyz创建了几个字符串对象"><a class="markdownIt-Anchor" href="#string-s-new-stringxyz创建了几个字符串对象"></a> String s = new String(“xyz”);创建了几个字符串对象</h4><ul><li><p>两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。</p><p>String str1 = “hello”; //str1指向静态区 String str2 = new String(“hello”);  //str2指向堆上的对象 String str3 = “hello”; String str4 = new String(“hello”); System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str4)); //true System.out.println(str1 == str3); //true System.out.println(str1 == str2); //false System.out.println(str2 == str4); //false System.out.println(str2 == “hello”); //false str2 = str1; System.out.println(str2 == “hello”); //true</p></li></ul><h4 id="如何将字符串反转"><a class="markdownIt-Anchor" href="#如何将字符串反转"></a> 如何将字符串反转？</h4><ul><li><p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p></li><li><p>示例代码：</p><p>// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer. append(“abcdefg”); System. out. println(stringBuffer. reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder. append(“abcdefg”); System. out. println(stringBuilder. reverse()); // gfedcba</p></li></ul><h4 id="数组有没有-length方法string-有没有-length方法"><a class="markdownIt-Anchor" href="#数组有没有-length方法string-有没有-length方法"></a> 数组有没有 length()方法？String 有没有 length()方法</h4><ul><li>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li></ul><h4 id="string-类的常用方法都有那些"><a class="markdownIt-Anchor" href="#string-类的常用方法都有那些"></a> String 类的常用方法都有那些？</h4><ul><li>indexOf()：返回指定字符的索引。</li><li>charAt()：返回指定索引处的字符。</li><li>replace()：字符串替换。</li><li>trim()：去除字符串两端空白。</li><li>split()：分割字符串，返回一个分割后的字符串数组。</li><li>getBytes()：返回字符串的 byte 类型数组。</li><li>length()：返回字符串长度。</li><li>toLowerCase()：将字符串转成小写字母。</li><li>toUpperCase()：将字符串转成大写字符。</li><li>substring()：截取字符串。</li><li>equals()：字符串比较。</li></ul><h4 id="在使用-hashmap-的时候用-string-做-key-有什么好处"><a class="markdownIt-Anchor" href="#在使用-hashmap-的时候用-string-做-key-有什么好处"></a> 在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4><ul><li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为<font color="red">字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快</font>。</li></ul><h4 id="string和stringbuffer-stringbuilder的区别是什么string为什么是不可变的"><a class="markdownIt-Anchor" href="#string和stringbuffer-stringbuilder的区别是什么string为什么是不可变的"></a> String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4><p><strong>可变性</strong></p><ul><li>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li></ul><p><strong>线程安全性</strong></p><ul><li>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li></ul><p><strong>性能</strong></p><ul><li>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li></ul><p><strong>对于三者使用的总结</strong></p><ul><li>如果要操作少量的数据用 = String</li><li>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li><li>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li></ul><h3 id="date相关"><a class="markdownIt-Anchor" href="#date相关"></a> Date相关</h3><h3 id="包装类相关"><a class="markdownIt-Anchor" href="#包装类相关"></a> 包装类相关</h3><h4 id="自动装箱与拆箱"><a class="markdownIt-Anchor" href="#自动装箱与拆箱"></a> 自动装箱与拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h4 id="int-和-integer-有什么区别"><a class="markdownIt-Anchor" href="#int-和-integer-有什么区别"></a> int 和 Integer 有什么区别</h4><ul><li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li><li>Java 为每个原始类型提供了包装类型：<ul><li>原始类型: boolean，char，byte，short，int，long，float，double</li><li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li></ul></li></ul><h4 id="integer-a-127-与-integer-b-127相等吗"><a class="markdownIt-Anchor" href="#integer-a-127-与-integer-b-127相等吗"></a> Integer a= 127 与 Integer b = 127相等吗</h4><ul><li>对于对象引用类型：==比较的是对象的内存地址。</li><li>对于基本数据类型：==比较的是值。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">    Integer a = new Integer(3);</span><br><span class="line">    Integer b = 3;  // 将3自动装箱成Integer类型</span><br><span class="line">    int c = 3;</span><br><span class="line">    System.out.println(a == b); // false 两个引用没有引用同一对象</span><br><span class="line">    System.out.println(a == c); // true a自动拆箱成int类型再和c比较</span><br><span class="line">    System.out.println(b == c); // true</span><br><span class="line"></span><br><span class="line">    Integer a1 = 128;</span><br><span class="line">    Integer b1 = 128;</span><br><span class="line">    System.out.println(a1 == b1); // false</span><br><span class="line"></span><br><span class="line">    Integer a2 = 127;</span><br><span class="line">    Integer b2 = 127;</span><br><span class="line">    System.out.println(a2 == b2); // true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>作者：小杰要吃蛋<br>链接：<a href="https://juejin.cn/post/6844904127059738631">https://juejin.cn/post/6844904127059738631</a><br>来源：稀土掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> java核心基础面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合面试</title>
      <link href="/2023/02/18/interview/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/02/18/interview/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="1-集合容器概述"><a class="markdownIt-Anchor" href="#1-集合容器概述"></a> 1. 集合容器概述</h1><h3 id="什么是集合"><a class="markdownIt-Anchor" href="#什么是集合"></a> 什么是集合</h3><ul><li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</li><li>集合类存放的都是对象的引用，而不是对象的本身</li><li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li></ul><h3 id="集合的特点"><a class="markdownIt-Anchor" href="#集合的特点"></a> 集合的特点</h3><ul><li>集合的特点主要有如下两点：<ul><li>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。</li><li>和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小</li></ul></li></ul><h3 id="集合和数组的区别"><a class="markdownIt-Anchor" href="#集合和数组的区别"></a> 集合和数组的区别</h3><ul><li>数组是固定长度的；集合可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；<strong>集合 只能存储 引用数据类型</strong>。</li><li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul><h3 id="使用集合框架的好处"><a class="markdownIt-Anchor" href="#使用集合框架的好处"></a> 使用集合框架的好处</h3><ol><li>容量自增长；</li><li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li><li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li><li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ol><h3 id="常用的集合类有哪些"><a class="markdownIt-Anchor" href="#常用的集合类有哪些"></a> 常用的集合类有哪些？</h3><ul><li>Map接口和Collection接口是所有集合框架的父接口：</li></ul><ol><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ol><h3 id="listsetmap三者的区别"><a class="markdownIt-Anchor" href="#listsetmap三者的区别"></a> List，Set，Map三者的区别？</h3><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e70de4bd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><ul><li>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</li><li>Collection集合主要有List和Set两大接口<ul><li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li></ul></li><li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。<ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul><h3 id="集合框架底层数据结构"><a class="markdownIt-Anchor" href="#集合框架底层数据结构"></a> 集合框架底层数据结构</h3><ul><li>Collection<ol><li>List<ul><li>Arraylist： Object数组</li><li>Vector： Object数组</li><li>LinkedList： 双向循环链表</li></ul></li><li>Set<ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul></li></ol></li><li>Map<ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，<strong>链表则是主要为了解决哈希冲突而存在的</strong>（“<strong>拉链法</strong>”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于<strong>拉链式散列结构</strong>即由<strong>数组</strong>和<strong>链表</strong>或<strong>红黑树</strong>组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li>TreeMap： <strong>红黑树</strong>（自平衡的排序二叉树）</li></ul></li></ul><h3 id="哪些集合类是线程安全的"><a class="markdownIt-Anchor" href="#哪些集合类是线程安全的"></a> 哪些集合类是线程安全的？</h3><ul><li>Vector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。</li><li>hashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li><li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。<strong>一个ConcurrentHashMap里包含一个Segment数组</strong>，Segment的结构和HashMap类似，是一种数组和链表结构；<strong>一个Segment里包含一个HashEntry数组</strong>，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li><li>…</li></ul><h3 id="java集合的快速失败机制-fail-fast"><a class="markdownIt-Anchor" href="#java集合的快速失败机制-fail-fast"></a> Java集合的快速失败机制 “fail-fast”？</h3><ul><li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</li><li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li><li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li><li>解决办法：<ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上<strong>synchronized</strong>。</li><li>使用<strong>CopyOnWriteArrayList</strong>来替换ArrayList</li></ol></li></ul><h3 id="怎么确保一个集合不能被修改"><a class="markdownIt-Anchor" href="#怎么确保一个集合不能被修改"></a> 怎么确保一个集合不能被修改？</h3><ul><li><p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p></li><li><p>示例代码如下：</p><figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. <span class="built_in">add</span>("x");</span><br><span class="line">Collection&lt;String&gt; clist = Collections. <span class="built_in">unmodifiableCollection</span>(list);</span><br><span class="line">clist. <span class="built_in">add</span>("y"); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. <span class="built_in">println</span>(list. size());</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li></ul><h1 id="2-collection接口"><a class="markdownIt-Anchor" href="#2-collection接口"></a> 2. Collection接口</h1><h3 id="list接口"><a class="markdownIt-Anchor" href="#list接口"></a> List接口</h3><h4 id="迭代器-iterator-是什么"><a class="markdownIt-Anchor" href="#迭代器-iterator-是什么"></a> 迭代器 Iterator 是什么？</h4><ul><li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li><li>因为所有Collection接继承了Iterator迭代器</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e6f6342b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><h4 id="iterator-怎么使用有什么特点"><a class="markdownIt-Anchor" href="#iterator-怎么使用有什么特点"></a> Iterator 怎么使用？有什么特点？</h4><ul><li><p>Iterator 使用代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext()){</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p></li></ul><h4 id="如何边遍历边移除-collection-中的元素"><a class="markdownIt-Anchor" href="#如何边遍历边移除-collection-中的元素"></a> 如何边遍历边移除 Collection 中的元素？</h4><ul><li><p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p>一种最常见的<strong>错误</strong>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list){</span><br><span class="line">   list.remove(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</li></ul><h4 id="iterator-和-listiterator-有什么区别"><a class="markdownIt-Anchor" href="#iterator-和-listiterator-有什么区别"></a> Iterator 和 ListIterator 有什么区别？</h4><ul><li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li><li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li><li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li></ul><h4 id="遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么"><a class="markdownIt-Anchor" href="#遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么"></a> 遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4><ul><li>遍历方式有以下几种：<ol><li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li><li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li><li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li></ol></li><li>最佳实践：Java Collections 框架中提供了一个 <strong>RandomAccess</strong> 接口，用来标记 List 实现是否支持 Random Access。<ul><li><strong>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)</strong>，如ArrayList。</li><li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li><li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</li></ul></li></ul><h4 id="说一下-arraylist-的优缺点"><a class="markdownIt-Anchor" href="#说一下-arraylist-的优缺点"></a> 说一下 ArrayList 的优缺点</h4><ul><li>ArrayList的优点如下：<ul><li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li><li>ArrayList 在顺序添加一个元素的时候非常方便。</li></ul></li><li>ArrayList 的缺点如下：<ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li><li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul></li><li>ArrayList 比较适合顺序添加、随机访问的场景。</li></ul><h4 id="如何实现数组和-list-之间的转换"><a class="markdownIt-Anchor" href="#如何实现数组和-list-之间的转换"></a> 如何实现数组和 List 之间的转换？</h4><ul><li><p>数组转 List：使用 Arrays. asList(array) 进行转换。</p></li><li><p>List 转数组：使用 List 自带的 toArray() 方法。</p></li><li><p>代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"123"</span>);</span><br><span class="line">list.add(<span class="string">"456"</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"123"</span>,<span class="string">"456"</span>};</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="arraylist-和-linkedlist-的区别是什么"><a class="markdownIt-Anchor" href="#arraylist-和-linkedlist-的区别是什么"></a> ArrayList 和 LinkedList 的区别是什么？</h4><ul><li><p>数据结构实现：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</p></li><li><p>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p></li><li><p>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p></li><li><p>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p></li><li><p>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p></li><li><p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p></li><li><p>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p></li></ul><h4 id="arraylist-和-vector-的区别是什么"><a class="markdownIt-Anchor" href="#arraylist-和-vector-的区别是什么"></a> ArrayList 和 Vector 的区别是什么？</h4><ul><li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合<ul><li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li><li>性能：ArrayList 在性能方面要优于 Vector。</li><li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li></ul></li><li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li><li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li></ul><h4 id="插入数据时arraylist-linkedlist-vector谁速度较快阐述-arraylist-vector-linkedlist-的存储性能和特性"><a class="markdownIt-Anchor" href="#插入数据时arraylist-linkedlist-vector谁速度较快阐述-arraylist-vector-linkedlist-的存储性能和特性"></a> 插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4><ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li><li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li><li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li></ul><h4 id="多线程场景下如何使用-arraylist"><a class="markdownIt-Anchor" href="#多线程场景下如何使用-arraylist"></a> 多线程场景下如何使用 ArrayList？</h4><ul><li><p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; synchronizedList.size(); i++) {</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="为什么-arraylist-的-elementdata-加上-transient-修饰"><a class="markdownIt-Anchor" href="#为什么-arraylist-的-elementdata-加上-transient-修饰"></a> 为什么 ArrayList 的 elementData 加上 transient 修饰？</h4><ul><li><p>ArrayList 中的数组定义如下：</p><p>private transient Object[] elementData;</p></li><li><p>再看一下 ArrayList 的定义：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></tbody></table></figure></li><li><p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<mark><strong>transient</strong> 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现</mark>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException{</span><br><span class="line">    *<span class="comment">// Write out element count, and any hidden stuff*</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    *<span class="comment">// Write out array length*</span></span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">    *<span class="comment">// Write out all elements in the proper order.*</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p></li></ul><h4 id="list-和-set-的区别"><a class="markdownIt-Anchor" href="#list-和-set-的区别"></a> List 和 Set 的区别</h4><ul><li>List , Set 都是继承自Collection 接口</li><li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li><li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li><li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li><li>Set和List对比<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li><li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li></ul></li></ul><h3 id="set接口"><a class="markdownIt-Anchor" href="#set接口"></a> Set接口</h3><h4 id="说一下-hashset-的实现原理"><a class="markdownIt-Anchor" href="#说一下-hashset-的实现原理"></a> 说一下 HashSet 的实现原理？</h4><ul><li>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li></ul><h4 id="hashset如何检查重复hashset是如何保证数据不可重复的"><a class="markdownIt-Anchor" href="#hashset如何检查重复hashset是如何保证数据不可重复的"></a> HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4><ul><li><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p></li><li><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p></li><li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li><li><p>以下是HashSet 部分源码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> {</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line"><span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>hashCode（）与equals（）的相关规定</strong>：</p><ol><li>如果两个对象相等，则hashcode一定也是相同的<ul><li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li></ul></li><li>两个对象相等,对两个equals方法返回true</li><li><strong>两个对象有相同的hashcode值，它们也不一定是相等的</strong></li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol><p><strong>==与equals的区别</strong></p><ol><li>==是判断两个变量或实例是不是指向同一个<strong>内存空间</strong>；  equals是判断两个变量或实例所指向的**内存空间的<font color="red">值</font>**是不是相同</li><li>==是指对内存地址进行比较； equals()是对字符串的内容进行比较</li></ol><h4 id="hashset与hashmap的区别"><a class="markdownIt-Anchor" href="#hashset与hashmap的区别"></a> HashSet与HashMap的区别</h4><blockquote><table><thead><tr><th>HashMap</th><th>HashSet</th></tr></thead><tbody><tr><td>实现了Map接口</td><td>实现Set接口</td></tr><tr><td>存储键值对</td><td>仅存储对象</td></tr><tr><td>调用put（）向map中添加元素</td><td>调用add（）方法向Set中添加元素</td></tr><tr><td>HashMap使用键（Key）计算Hashcode</td><td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr><tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td><td>HashSet较HashMap来说比较慢</td></tr></tbody></table></blockquote><h1 id="3-map接口"><a class="markdownIt-Anchor" href="#3-map接口"></a> 3. Map接口</h1><h3 id="什么是hash算法"><a class="markdownIt-Anchor" href="#什么是hash算法"></a> 什么是Hash算法</h3><ul><li>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制<strong>值</strong>，这个较小的二进制值叫做哈希值。</li></ul><h3 id="什么是链表"><a class="markdownIt-Anchor" href="#什么是链表"></a> 什么是链表</h3><ul><li><p>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</p></li><li><p>链表大致分为单链表和双向链表</p><ol><li><p>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e72891e5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p></li><li><p>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e73f80b0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p></li></ol></li><li><p>链表的优点</p><ul><li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li><li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li><li>大小没有固定，拓展很灵活。</li></ul></li><li><p>链表的缺点</p><ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul><h3 id="说一下hashmap的实现原理"><a class="markdownIt-Anchor" href="#说一下hashmap的实现原理"></a> 说一下HashMap的实现原理？</h3><ul><li><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li><li><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p></li><li><p>HashMap 基于 Hash 算法实现的</p><ol><li><p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p></li><li><p>存储时，如果出现hash值相同的key，此时有两种情况。</p><p>​(1)如果key相同，则覆盖原始值；</p><p>​(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p></li><li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p></li><li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p></li></ol></li><li><p>需要注意<strong>Jdk 1.8中</strong>对HashMap的实现做了优化，<strong>当链表中的节点数据超过八个之后，该链表会转为<mark>红黑树</mark>来<mark>提高查询效率</mark></strong>，从原来的O(n)到O(logn)</p></li></ul><h3 id="hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现"><a class="markdownIt-Anchor" href="#hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现"></a> HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3><ul><li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。**数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 <font color="red">拉链法</font> **的方式可以解决哈希冲突。</li></ul><h4 id="hashmap-jdk18之前"><a class="markdownIt-Anchor" href="#hashmap-jdk18之前"></a> HashMap JDK1.8之前</h4><ul><li>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e78f59a7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><h4 id="hashmap-jdk18之后"><a class="markdownIt-Anchor" href="#hashmap-jdk18之后"></a> HashMap JDK1.8之后</h4><ul><li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e7c6af15~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><h4 id="jdk17-vs-jdk18-比较"><a class="markdownIt-Anchor" href="#jdk17-vs-jdk18-比较"></a> JDK1.7 VS JDK1.8 比较</h4><ul><li>JDK1.8主要解决或优化了一下问题：<ol><li>resize 扩容优化</li><li>引入了<strong>红黑树</strong>，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li><li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol></li></ul><blockquote><table><thead><tr><th>不同</th><th>JDK 1.7</th><th>JDK 1.8</th></tr></thead><tbody><tr><td>存储结构</td><td>数组 + 链表</td><td>数组 + 链表 + 红黑树</td></tr><tr><td>初始化方式</td><td>单独函数：<code>inflateTable()</code></td><td>直接集成到了扩容函数<code>resize()</code>中</td></tr><tr><td>hash值计算方式</td><td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td><td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr><tr><td>存放数据的规则</td><td>无冲突时，存放数组；冲突时，存放链表</td><td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr><tr><td>插入数据方式</td><td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td><td>尾插法（直接插入到链表尾部/红黑树）</td></tr><tr><td>扩容后存储位置的计算方式</td><td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td><td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table></blockquote><h3 id="什么是红黑树"><a class="markdownIt-Anchor" href="#什么是红黑树"></a> 什么是红黑树</h3><h4 id="说道红黑树先讲什么是二叉树"><a class="markdownIt-Anchor" href="#说道红黑树先讲什么是二叉树"></a> 说道红黑树先讲什么是二叉树</h4><ul><li><p>二叉树简单来说就是 每一个节上可以关联俩个子节点</p><ul><li><pre class="highlight"><code class="css">大概就是这样子：                       <span class="selector-tag">a</span>                    /     \                  <span class="selector-tag">b</span>          c                / \         /  \              d    e       f    g            /  \  / \     / \   / \           h   <span class="selector-tag">i</span>  j  k   l   m n   o&lt;!<span class="attr">--code</span>￼<span class="number">9</span>--&gt;</code></pre></li></ul></li></ul><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li><li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li><li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li><li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li><li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li><li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li></ol><h3 id="hashmap的扩容操作是怎么实现的"><a class="markdownIt-Anchor" href="#hashmap的扩容操作是怎么实现的"></a> HashMap的扩容操作是怎么实现的？</h3><ol><li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</li><li>每次扩展的时候，都是扩展2倍；</li><li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li></ol><ul><li><p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        }<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class="line">    <span class="comment">// 直接将该值赋给新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 新的threshold = 新的cap * 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历新数组的所有桶下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> {             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class="line">                                <span class="comment">// 代表下标保持不变的链表的头元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                <span class="comment">// loTail.next指向当前e</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// loTail指向当前的元素e</span></span><br><span class="line">                            <span class="comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class="line">                            <span class="comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class="line">                            <span class="comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) {</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><h3 id="hashmap是怎么解决哈希冲突的"><a class="markdownIt-Anchor" href="#hashmap是怎么解决哈希冲突的"></a> HashMap是怎么解决哈希冲突的？</h3><ul><li>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</li></ul><h4 id="什么是哈希"><a class="markdownIt-Anchor" href="#什么是哈希"></a> 什么是哈希？</h4><ul><li>Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li></ul><h4 id="什么是哈希冲突"><a class="markdownIt-Anchor" href="#什么是哈希冲突"></a> 什么是哈希冲突？</h4><ul><li><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</li></ul><h4 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h4><ul><li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。<ul><li>数组的特点是：寻址容易，插入和删除困难；</li><li>链表的特点是：寻址困难，但插入和删除容易；</li></ul></li><li>所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521c92dc84~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li><li><strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</li></ul><h4 id="hash函数"><a class="markdownIt-Anchor" href="#hash函数"></a> hash()函数</h4><ul><li><p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p></li></ul><h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4><ul><li>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：<ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li><li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ul></li></ul><h3 id="能否使用任何类作为-map-的-key"><a class="markdownIt-Anchor" href="#能否使用任何类作为-map-的-key"></a> 能否使用任何类作为 Map 的 key？</h3><p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p><ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li><li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li><li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li><li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul><h3 id="为什么hashmap中string-integer这样的包装类适合作为k"><a class="markdownIt-Anchor" href="#为什么hashmap中string-integer这样的包装类适合作为k"></a> 为什么HashMap中String、Integer这样的包装类适合作为K？</h3><ul><li>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率<ul><li>都是<strong>final类型</strong>，即<strong>不可变性</strong>，保证key的不可更改性，不会存在获取hash值不同的情况</li><li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul></li></ul><h3 id="如果使用object作为hashmap的key应该怎么办呢"><a class="markdownIt-Anchor" href="#如果使用object作为hashmap的key应该怎么办呢"></a> 如果使用Object作为HashMap的Key，应该怎么办呢？</h3><ul><li><p>答：重写</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashCode()</span><br></pre></td></tr></tbody></table></figure><p>和</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equals()</span><br></pre></td></tr></tbody></table></figure><p>方法</p><ol><li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li><li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li></ol></li></ul><h3 id="hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标"><a class="markdownIt-Anchor" href="#hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标"></a> HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3><ul><li>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li><li><strong>那怎么解决呢？</strong><ol><li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li><li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li></ol></li></ul><h3 id="hashmap-的长度为什么是2的幂次方"><a class="markdownIt-Anchor" href="#hashmap-的长度为什么是2的幂次方"></a> HashMap 的长度为什么是2的幂次方</h3><ul><li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li><li><strong>这个算法应该如何设计呢？</strong><ul><li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li><li><strong>那为什么是两次扰动呢？</strong><ul><li>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul><h3 id="hashmap-与-hashtable-有什么区别"><a class="markdownIt-Anchor" href="#hashmap-与-hashtable-有什么区别"></a> HashMap 与 HashTable 有什么区别？</h3><ol><li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li><li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li><li>初始容量大小和每次扩充容量大小的不同：<ol><li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>。之后每次扩充，容量变为原来的<strong>2倍</strong>。</li><li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小（为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同）。</li></ol></li><li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li><li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li></ol><h3 id="什么是treemap-简介"><a class="markdownIt-Anchor" href="#什么是treemap-简介"></a> 什么是TreeMap 简介</h3><ul><li>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过红黑树实现的。</li><li>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。</li><li>TreeMap是线程<strong>非同步</strong>的。</li></ul><h3 id="如何决定使用-hashmap-还是-treemap"><a class="markdownIt-Anchor" href="#如何决定使用-hashmap-还是-treemap"></a> 如何决定使用 HashMap 还是 TreeMap？</h3><ul><li>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，<strong>将map换为TreeMap进行有序key的遍历</strong>。</li></ul><h3 id="hashmap-和-concurrenthashmap-的区别"><a class="markdownIt-Anchor" href="#hashmap-和-concurrenthashmap-的区别"></a> HashMap 和 ConcurrentHashMap 的区别</h3><ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li><li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol><h3 id="concurrenthashmap-和-hashtable-的区别"><a class="markdownIt-Anchor" href="#concurrenthashmap-和-hashtable-的区别"></a> ConcurrentHashMap 和 Hashtable 的区别？</h3><ul><li>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。<ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li>实现线程安全的方式：<ol><li><strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li><li>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li></ol></li></ul></li><li><strong>两者的对比图</strong>：</li></ul><h5 id="1-hashtable"><a class="markdownIt-Anchor" href="#1-hashtable"></a> 1、HashTable:</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521ca71b79~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><h5 id="2-jdk17的concurrenthashmap"><a class="markdownIt-Anchor" href="#2-jdk17的concurrenthashmap"></a> 2、 JDK1.7的ConcurrentHashMap：</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521de4886d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><h5 id="3-jdk18的concurrenthashmaptreebin-红黑二叉树节点-node-链表节点"><a class="markdownIt-Anchor" href="#3-jdk18的concurrenthashmaptreebin-红黑二叉树节点-node-链表节点"></a> 3、JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</h5><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735522b19186a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><ul><li>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</li></ul><h3 id="concurrenthashmap-底层具体实现知道吗实现原理是什么"><a class="markdownIt-Anchor" href="#concurrenthashmap-底层具体实现知道吗实现原理是什么"></a> ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3><h4 id="jdk17"><a class="markdownIt-Anchor" href="#jdk17"></a> JDK1.7</h4><ul><li>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li><li>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</li><li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735524c5089b8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li><li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol><h4 id="jdk18"><a class="markdownIt-Anchor" href="#jdk18"></a> JDK1.8</h4><ul><li>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li><li>结构如下：</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173552564c22be~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p><ul><li><p><strong>附加源码，有需要的可以看看</strong></p></li><li><p>插入元素过程（建议去看看源码）：</p></li><li><p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) {</span><br><span class="line">            pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li></ul><ol><li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li><li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li></ol><h1 id="4-辅助工具类"><a class="markdownIt-Anchor" href="#4-辅助工具类"></a> 4. 辅助工具类</h1><h3 id="array-和-arraylist-有何区别"><a class="markdownIt-Anchor" href="#array-和-arraylist-有何区别"></a> Array 和 ArrayList 有何区别？</h3><ul><li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li><li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li><li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></tbody></table></figure><h3 id="如何实现-array-和-list-之间的转换"><a class="markdownIt-Anchor" href="#如何实现-array-和-list-之间的转换"></a> 如何实现 Array 和 List 之间的转换？</h3><ul><li>Array 转 List： Arrays. asList(array) ；</li><li>List 转 Array：List 的 toArray() 方法。</li></ul><h3 id="comparable-和-comparator的区别"><a class="markdownIt-Anchor" href="#comparable-和-comparator的区别"></a> comparable 和 comparator的区别？</h3><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h3 id="collection-和-collections-有什么区别"><a class="markdownIt-Anchor" href="#collection-和-collections-有什么区别"></a> Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素"><a class="markdownIt-Anchor" href="#treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素"></a> TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，</li><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li></ul><p>？</p><ul><li><p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p></li><li><p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p></li><li><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p></li></ul><h3 id="collection-和-collections-有什么区别-2"><a class="markdownIt-Anchor" href="#collection-和-collections-有什么区别-2"></a> Collection 和 Collections 有什么区别？</h3><ul><li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li><li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li></ul><h3 id="treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素-2"><a class="markdownIt-Anchor" href="#treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素-2"></a> TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3><ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li><li>Collections 工具类的 sort 方法有两种重载的形式，<ul><li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li><li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql面试题</title>
      <link href="/2023/02/17/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2023/02/17/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>CSDN的博文：<a href="https://blog.csdn.net/adminpd/article/details/122910606">(9条消息) MySQL数据库面试题总结（2022最新版）_程序猿周周的博客-CSDN博客_mysql 面试题</a></p><p>稀土掘金的博文：<a href="https://juejin.cn/post/6844904127047139335#heading-17">MySQL面试题（总结最全面的面试题） - 掘金 (juejin.cn)</a></p><h1 id="0-基本概念"><a class="markdownIt-Anchor" href="#0-基本概念"></a> 0. 基本概念</h1><h2 id="1-mysql有哪些数据库类型"><a class="markdownIt-Anchor" href="#1-mysql有哪些数据库类型"></a> 1、MySQL有哪些数据库类型？</h2><h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3><p>有包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3 字节、4 字节、8 字节的整数类型。</p><p>1）任何整数类型都可以加上 UNSIGNED 属性，表示无符号整数。</p><p>2）任何整数类型都可以指定长度，但它不会限制数据的合法长度，仅仅限制了显示长度。</p><p>还有包括 FLOAT、DOUBLE、DECIMAL 在内的小数类型。</p><h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3><p>包括 VARCHAR、CHAR、TEXT、BLOB。</p><p>注意：VARCHAR(n) 和 CHAR(n) 中的 n 并不代表字节个数，而是代表字符的个数。</p><h3 id="日期和时间类型"><a class="markdownIt-Anchor" href="#日期和时间类型"></a> 日期和时间类型</h3><p>常用于表示日期和时间类型为 DATETIME、DATE 和 TIMESTAMP。</p><p>尽量使用 TIMESTAMP，空间效率高于 DATETIME。</p><p>ref MySQL 数据类型</p><h2 id="2-char-和-varchar-区别"><a class="markdownIt-Anchor" href="#2-char-和-varchar-区别"></a> 2、CHAR 和 VARCHAR 区别？</h2><p>1）首先可以明确的是 CHAR 是定长的，而 VARCHAR 是可以变长。</p><p>CHAR 会根据声明的字符串长度分配空间，并会使用空格对字符串右边进行尾部填充。所以在检索 CHAR 类型数据时尾部空格会被删除，如保存的是字符串 'char '，但最后查询到的是 ‘char’。又因为长度固定，所以存储效率高于 VARCHAR 类型。</p><p>VARCHAR 在 MySQL 5.0 之后长度支持到 65535 字节，但会在数据开头使用额外 1~2 个字节存储字符串长度（列长度小于 255 字节时使用 1 字节表示，否则 2 字节），在结尾使用 1 字节表示字符串结束。</p><p>2）再者，在存储方式上，CHAR 对英文字符（ASCII）占用 1 字节，对一个汉字使用用 2 字节。而 VARCHAR 对每个字符均使用 2 字节。</p><p>虽然 VARCHAR 是根据字符串长度分配存储空间的，但在内存中依旧使用声明长度进行排序等作业，故在使用时仍需综合考量字段长度。</p><h2 id="3-char-和-varchar-如何选择"><a class="markdownIt-Anchor" href="#3-char-和-varchar-如何选择"></a> 3、CHAR 和 VARCHAR 如何选择？</h2><p>1）对于经常变更的数据来说，CHAR 比 VARCHAR更好，因为 CHAR 不容易产生碎片。</p><p>2）对于非常短的列或固定长度的数据（如 MD5），CHAR 比 VARCHAR 在存储空间上更有效率。</p><p>4）使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p><p>4）尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p><h2 id="4-charvarchar-和-text-的区别"><a class="markdownIt-Anchor" href="#4-charvarchar-和-text-的区别"></a> 4、CHAR，VARCHAR 和 Text 的区别？</h2><p>1）长度区别</p><p>Char 范围是 0～255。</p><p>Varchar 最长是 64k（注意这里的 64k 是整个 row 的长度，要考虑到其它的 column，还有如果存在 not null 的时候也会占用一位，对不同的字符集，有效长度还不一样，比如 utf-8 的，最多 21845，还要除去别的column），但 Varchar 在一般情况下存储都够用了。</p><p>如果遇到了大文本，考虑使用 Text，最大能到 4G（其中 TEXT 长度 65,535 bytes，约 64kb；MEDIUMTEXT 长度 16,777,215 bytes，约 16 Mb；而 LONGTEXT 长度 4,294,967,295 bytes，约 4Gb）。</p><p>2）效率区别</p><p>效率来说基本是 Char &gt; Varchar &gt; Text，但是如果使用的是 Innodb 引擎的话，推荐使用 Varchar 代替 Char。</p><p>3）默认值区别</p><p>Char 和 Varchar 支持设置默认值，而 Text 不能指定默认值。</p><h1 id="1-数据库三大范式是什么"><a class="markdownIt-Anchor" href="#1-数据库三大范式是什么"></a> 1. 数据库三大范式是什么？</h1><p><strong>什么是范式？</strong><br>范式是数据库设计时遵循的一种规范，不同的规范要求遵循不同的范式。</p><p><strong>最常用的三大范式</strong></p><ul><li><p>第一范式(1NF)：<strong>属性不可分割</strong>，即每个属性都是不可分割的原子项。(实体的属性即表中的列)</p></li><li><p>第二范式(2NF)：<strong>满足第一范式；且不存在部分依赖</strong>，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)</p></li><li><p>第三范式(3NF)：<strong>满足第二范式；且不存在传递依赖</strong>，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -&gt; B, B -&gt;C, A -&gt; C）</p></li></ul><p><strong>举例说明3NF：</strong><br><strong>1NF</strong><br>属性不可再分，即表中的每个列都不可以再进行拆分。</p><p>如下学生信息表(student)：</p><p>id、name(姓名)、sex_code(性别代号)、sex_desc(性别描述)、contact(联系方式)</p><p>primary key(id)</p><p><img src="../../images/image-20230217143546366.png" alt="image-20230217143546366"><br>如果在查询学生表时经常用到学生的电话号，则应该将联系方式(contact)这一列分为电话号(phone)和地址(address)两列，这样才符合第一范式。</p><p>修改使表满足1NF后：</p><p><img src="../../images/image-20230217143559491.png" alt="image-20230217143559491"><br>判断表是否符合第一范式，列是否可以再分，得看需求，如果将电话号和地址分开才能满足查询等需求时，那之前的表设计就是不满足1NF的，如果电话号和地址拼接作为一个字段也可以满足查询、存储等需求时，那它就满足1NF。</p><p><strong>2NF</strong><br>在满足1NF的前提下，表中不存在部分依赖，非主键列要完全依赖于主键。(主要是说在联合主键的情况下，非主键列不能只依赖于主键的一部分)</p><p>如下学生成绩表(score)：</p><p>stu_id(学生id)、kc_id(课程id)、score(分数)、kc_name(课程名)</p><p>primary key(stu_id, kc_id)</p><p><img src="../../images/image-20230217143616904.png" alt="image-20230217143616904"><br>表中主键为stu_id和kc_id组成的联合主键。满足1NF；非主键列score完全依赖于主键，stu_id和kc_id两个值才能决定score的值；而kc_name只依赖于kc_id，与stu_id没有依赖关系，它不完全依赖于主键，只依赖于主键的一部分，不符合2NF。</p><p>修改使表满足2NF后：</p><p>成绩表(score)   primary key(stu_id)</p><p><img src="../../images/image-20230217143630898.png" alt="image-20230217143630898"><br>课程表(kc)   primary key(kc_id)</p><p><img src="../../images/image-20230217143724321.png" alt="image-20230217143724321"><br>将原来的成绩表(score)拆分为成绩表(score)和课程表(kc)，而且两个表都符合2NF。</p><p><strong>3NF：</strong><br>在满足2NF的前提下，不存在传递依赖。(A -&gt; B, B -&gt; C, A-&gt;C)</p><p>如下学生信息表(student)：</p><p>primary key(id)</p><p><img src="../../images/image-20230217143739281.png" alt="image-20230217143739281"><br>表中sex_desc依赖于sex_code，而sex_code依赖于id(主键)，从而推出sex_desc依赖于id(主键)；sex_desc不直接依赖于主键，而是通过依赖于非主键列而依赖于主键，属于传递依赖，不符合3NF。</p><p>修改表使满足3NF后：</p><p>学生表(student)   primary key(id)</p><p><img src="../../images/image-20230217143753961.png" alt="image-20230217143753961"><br>性别代码表(sexcode)   primary key(sex_code)</p><p><img src="../../images/image-20230217143810165.png" alt="image-20230217143810165"><br>将原来的student表进行拆分后，两个表都满足3NF。</p><p><strong>什么样的表越容易符合3NF？</strong><br>非主键列越少的表。(1NF强调列不可再分；2NF和3NF强调非主属性列和主属性列之间的关系)</p><p>如代码表(sexcode)，非主键列只有一个sex_desc；</p><p>或者将学生表的主键设计为primary key(id,name,sex_code,phone)，这样非主键列只有address，更容易符合3NF。</p><p><strong>ps:</strong></p><p><strong>除了三大范式外，还有BC范式和第四范式，但其规范过于严苛，在生产中往往使用不到。</strong></p><h1 id="2-什么是范式和反范式以及各自优缺点"><a class="markdownIt-Anchor" href="#2-什么是范式和反范式以及各自优缺点"></a> 2. 什么是范式和反范式，以及各自优缺点？</h1><p>范式是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。</p><p><img src="../../images/image-20230217144222018.png" alt="image-20230217144222018"><br>所以在平时工作中，我们通常是将范式和反范式相互结合使用。</p><h1 id="3-索引"><a class="markdownIt-Anchor" href="#3-索引"></a> 3. 索引</h1><h2 id="1-索引的几种类型或分类"><a class="markdownIt-Anchor" href="#1-索引的几种类型或分类"></a> 1、索引的几种类型或分类？</h2><ul><li><p>从<strong>物理结构</strong>上可以分为聚集索引和非聚集索引两类：</p><ul><li><strong>聚簇索引</strong>指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的<strong>主键索引</strong>；</li><li>非聚簇索引的逻辑顺序则与数据行的物理顺序不一致。</li></ul></li><li><p>从<strong>应用</strong>上可以划分为一下几类：</p><ul><li><strong>普通索引</strong>：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过<mark> ALTER TABLE table_name ADD INDEX index_name (column) </mark>创建；</li><li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。通过 <mark>ALTER TABLE table_name ADD UNIQUE index_name (column)</mark> 创建；</li><li><strong>主键索引</strong>：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li><li><strong>组合索引</strong>：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li><li><strong>全文索引</strong>：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li></ul></li></ul><h2 id="2-索引的优缺点"><a class="markdownIt-Anchor" href="#2-索引的优缺点"></a> 2、索引的优缺点？</h2><p>先来说说**优点：**创建索引可以大大提高系统的性能。</p><ul><li><p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p></li><li><p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p></li><li><p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p></li><li><p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p></li><li><p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p></li></ul><p>既然增加索引有如此多的优点，为什么不对表中的每一个列都创建一个索引呢？这是因为索引也是有<strong>缺点</strong>的：</p><ul><li><p>创建和维护索引需要耗费时间，这种时间随着数据量的增加而增加，这样就降低了数据的维护速度。</p></li><li><p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</p></li></ul><h2 id="3-索引设计的原则"><a class="markdownIt-Anchor" href="#3-索引设计的原则"></a> 3. 索引设计的原则</h2><ul><li><p><strong>选择唯一性索引；</strong></p><ul><li>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li></ul></li><li><p><strong>为常作为查询条件的字段建立索引；</strong></p><ul><li>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</li></ul></li><li><p><strong>为经常需要排序、分组和联合操作的字段建立索引；</strong></p><ul><li>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</li></ul></li><li><p><strong>限制索引的数目；</strong></p><ul><li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。</li></ul></li><li><p><strong>小表不建议索引（如数量级在百万以内）；</strong></p><ul><li>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</li></ul></li><li><p><strong>尽量使用数据量少的索引；</strong></p><ul><li>如果索引的值很长，那么查询的速度会受到影响。此时尽量使用前缀索引。</li></ul></li><li><p><strong>删除不再使用或者很少使用的索引。</strong></p></li></ul><h2 id="4-索引的数据结构"><a class="markdownIt-Anchor" href="#4-索引的数据结构"></a> 4. 索引的数据结构？</h2><p>索引的数据结构和具体存储引擎的实现有关，MySQL中常用的是 <strong>Hash</strong> 和 <strong>B+树</strong> 索引。</p><ul><li><strong>Hash 索引</strong>底层就是 Hash 表，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据.</li><li><strong>B+ 树索引</strong>底层实现原理是多路平衡查找树，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询.</li></ul><h4 id="hash-和-b-树索引的区别"><a class="markdownIt-Anchor" href="#hash-和-b-树索引的区别"></a> Hash 和 B+ 树索引的区别</h4><ul><li><p>Hash</p><ul><li>Hash 进行等值查询更快，但无法进行范围查询。因为经过 Hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，故不能支持范围查询。同理，也不支持使用索引进行排序。</li><li>Hash 不支持模糊查询以及多列索引的最左前缀匹配,因为 Hash 函数的值不可预测，如 AA 和 AB 的算出的值没有相关性。</li><li>Hash 任何时候都避免不了回表查询数据.</li><li>虽然在等值上查询效率高，但性能不稳定，因为当某个键值存在大量重复时，产生 Hash 碰撞，此时查询效率反而可能降低。</li></ul></li><li><p>B+ Tree</p><ul><li>B+ 树本质是一棵查找树，自然支持范围查询和排序。</li><li>在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询，不需要回表。</li><li>查询效率比较稳定，因为每次查询都是从根节点到叶子节点，且为树的高度。</li></ul></li></ul><h2 id="5-为何使用-b-树而非-b-树做索引"><a class="markdownIt-Anchor" href="#5-为何使用-b-树而非-b-树做索引"></a> 5. 为何使用 B+ 树而非 B 树做索引？</h2><h4 id="51-先来了解一下-b-树和-b-树的区别"><a class="markdownIt-Anchor" href="#51-先来了解一下-b-树和-b-树的区别"></a> 5.1.  先来了解一下 B+ 树和 B 树的区别：</h4><ul><li><p>B 树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。而 <strong>B+ 树只在叶子结点存储数据，非叶子结点存储关键字</strong>，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。</p></li><li><p>B+ 树叶子结点之间用<strong>链表</strong>相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B 树只能通过中序遍历。</p></li></ul><h4 id="52-为什么-b-树比-b-树更适合应用于数据库索引"><a class="markdownIt-Anchor" href="#52-为什么-b-树比-b-树更适合应用于数据库索引"></a> 5.2. 为什么 B+ 树比 B 树更适合应用于数据库索引？</h4><ul><li><p>B+ 树减少了 IO 次数。</p><ul><li>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了。</li></ul></li><li><p>B+ 树查询效率更稳定</p><ul><li>由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)，所以 B+ 树的查询效率相比B树更加稳定。</li></ul></li><li><p>B+ 树更加适合范围查找</p><ul><li>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</li></ul></li></ul><h2 id="6-什么是覆盖索引"><a class="markdownIt-Anchor" href="#6-什么是覆盖索引"></a> 6. 什么是覆盖索引？</h2><p>覆盖索引（covering index）指<strong>一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取</strong>。 也可以称之为实现了索引覆盖。 如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 <strong>当一条查询语句符合覆盖索引条件时，sql只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率</strong></p><h2 id="7-什么是索引下推"><a class="markdownIt-Anchor" href="#7-什么是索引下推"></a> 7. 什么是索引下推？</h2><p><strong>索引下推（Index condition pushdown）</strong> 简称 ICP，在 Mysql 5.6 版本上推出的一项用于<mark>优化查询</mark>的技术。</p><p>在不使用索引下推的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器判断数据是否符合条件。</p><p>而有了索引下推之后，如果存在某些被索引列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</p><p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</strong></p><h1 id="4-存储"><a class="markdownIt-Anchor" href="#4-存储"></a> 4. 存储</h1><h2 id="41-有哪些常见的存储引擎"><a class="markdownIt-Anchor" href="#41-有哪些常见的存储引擎"></a> 4.1. 有哪些常见的存储引擎？</h2><ol><li>MyISAM：这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。</li><li>MyISAM Merge引擎：这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。</li><li><strong>InnoDB</strong>：InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能，也是目前<strong>MySQL 默认 的存储引擎。</strong></li><li>Memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。</li><li>archive：这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。</li></ol><h2 id="42-myisam-和-innodb-的区别"><a class="markdownIt-Anchor" href="#42-myisam-和-innodb-的区别"></a> 4.2.  MyISAM 和 InnoDB 的区别？</h2><p>1）InnoDB 支持事务，而 MyISAM 不支持。</p><p>2）InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p><p>3）InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p><p>4）InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p><p>**那为什么 InnoDB 没有使用这样的变量呢？**因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p><p>5）InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。</p><p>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p><p>6）InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p><h2 id="43-innodb引擎四大特性"><a class="markdownIt-Anchor" href="#43-innodb引擎四大特性"></a> 4.3. InnoDB引擎四大特性</h2><ul><li>插入缓冲insert buffer)</li><li>二次写(double write)</li><li>自适应哈希索引(ahi)</li><li>预读(read ahead)</li></ul><h2 id="44-innodb为何推荐使用自增主键"><a class="markdownIt-Anchor" href="#44-innodb为何推荐使用自增主键"></a> 4.4. InnoDB为何推荐使用自增主键？</h2><p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p><h2 id="45-存储结构"><a class="markdownIt-Anchor" href="#45-存储结构"></a> 4.5. 存储结构</h2><h3 id="451-什么是-innodb-的页-区-段"><a class="markdownIt-Anchor" href="#451-什么是-innodb-的页-区-段"></a> 4.5.1. 什么是 InnoDB 的页、区、段？</h3><ul><li><p><strong>页（Page）</strong></p><ul><li>首先，InnoDB 将物理磁盘划分为页（page），每页的大小默认为 16 KB，页是最小的存储单位。页根据上层应用的需要，如索引、日志等，分为很多的格式。我们主要说数据页，也就是存储实际数据的页。</li></ul></li><li><p><strong>区（Extent）</strong></p><ul><li>如果只有页这一个层次的话，页的个数是非常多的，存储空间的分配和回收都会很麻烦，因为要维护这么多的页的状态是非常麻烦的。</li><li>所以，InnoDB 又引入了区（Extent) 的概念。一个区默认是 64 个连续的页组成的，也就是 1MB。通过 Extent 对存储空间的分配和回收就比较容易了。</li></ul></li><li><p><strong>段（Segment）</strong></p><ul><li>为什么要引入段呢，这要从索引说起。我们都知道索引的目的是为了加快查找速度，是一种典型的用空间换时间的方法。</li><li>B+ 树的叶子节点存放的是我们的具体数据，非叶子结点是索引页。所以 B+ 树将数据分为了两部分，叶子节点部分和非叶子节点部分，也就我们要介绍的段 Segment，也就是说 InnoBD 中每一个索引都会创建两个 Segment 来存放对应的两部分数据。</li><li>Segment 是一种逻辑上的组织，其层次结构从上到下一次为 Segment、Extent、Page。</li></ul></li></ul><h1 id="5-事务"><a class="markdownIt-Anchor" href="#5-事务"></a> 5. 事务</h1><h2 id="51-什么是事务的四大特性acid"><a class="markdownIt-Anchor" href="#51-什么是事务的四大特性acid"></a> 5.1.  什么是事务的四大特性（ACID）？</h2><ul><li>Atomicity（<strong>原子性</strong>）：一个事务（transaction）中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li>Consistency（<strong>一致性</strong>）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li><li>Isolation（<strong>隔离性</strong>）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li><li>Durability（<strong>持久性</strong>）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h3 id="52-事务的并发问题"><a class="markdownIt-Anchor" href="#52-事务的并发问题"></a> 5.2. 事务的并发问题？</h3><p>脏读、幻读、不可重复读。</p><h3 id="53-什么是脏读-幻读和不可重复读"><a class="markdownIt-Anchor" href="#53-什么是脏读-幻读和不可重复读"></a> 5.3. 什么是脏读、幻读和不可重复读</h3><ul><li><p><strong>脏读</strong>：一个事务读取到另一个事务<strong>尚未提交</strong>的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p></li><li><p><strong>不可重复读</strong>：一个事务中两次读取的数据的<strong>内容</strong>不一致。 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p></li><li><p><strong>幻读</strong>：一个事务中两次读取的<strong>数据量</strong>不一致。 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p></li></ul><p><strong>不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除</strong>。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p><h3 id="54-事务的隔离级别有哪些"><a class="markdownIt-Anchor" href="#54-事务的隔离级别有哪些"></a> 5.4. 事务的隔离级别有哪些？</h3><p><img src="../../images/image-20230217192636216.png" alt="image-20230217192636216"></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li><strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li><strong>REPEATABLE-READ(可重复读)</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li><strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p>串行化的隔离级别最高，读未提交的级别最低，级别越高，则执行效率就越低，所以在选择隔离级别时应该结合实际情况。</p><p>MySQL 支持以上四种隔离级别，<strong>默认</strong>为 Repeatable read (可重复读)；而 Oracle 只支持 Serializeble(串行化) 级别和 Read committed(读已提交) 两种，其中默认为读已提交。</p><h1 id="6-锁"><a class="markdownIt-Anchor" href="#6-锁"></a> 6. 锁</h1><h2 id="61-数据库锁的作用以及有哪些锁"><a class="markdownIt-Anchor" href="#61-数据库锁的作用以及有哪些锁"></a> 6.1. 数据库锁的作用以及有哪些锁？</h2><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。即锁的作用是解决并发问题。</p><ul><li><p>从<strong>锁的粒度</strong>划分，可以将锁分为表锁、行锁以及页锁。</p><ul><li><p><strong>行级锁</strong>：是锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。<br>行级锁开销大，加锁慢，且会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p></li><li><p><strong>表级锁</strong>：是粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。</p></li><li><p><strong>页级锁</strong>：是粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p></li></ul></li><li><p>从<strong>使用性质</strong>划分，可以分为共享锁、排它锁以及更新锁。</p><ul><li><p><strong>共享锁</strong>（Share Lock）：<strong>S 锁</strong>，又称<strong>读锁</strong>（read lock），用于所有的只读数据操作。<br>S 锁并非独占，允许多个并发事务对同一资源加锁，但加 S 锁的同时不允许加 X 锁，即资源不能被修改。S 锁通常读取结束后立即释放，无需等待事务结束。</p></li><li><p><strong>排他锁</strong>（Exclusive Lock）：<strong>X 锁</strong>，又称<strong>写锁</strong>（write lock），表示对数据进行写操作。<br>X 锁仅允许一个事务对同一资源加锁，且直到事务结束才释放，其他任何事务必须等到 X 锁被释放才能对该页进行访问。使用 <font color="red">select * from table_name <strong>for update</strong>;</font> 语句产生 X 锁。</p></li><li><p><strong>更新锁</strong>：U 锁，用来预定要对资源施加 X 锁，允许其他事务读，但不允许再施加 U 锁或 X 锁。<br>当被读取的页将要被更新时，则升级为 X 锁，U 锁一直到事务结束时才能被释放。故 U 锁用来避免使用共享锁造成的死锁现象。</p><p><img src="../../images/image-20230305131221507.png" alt="image-20230305131221507"></p></li></ul></li><li><p>从<strong>主观</strong>上划分，又可以分为乐观锁和悲观锁。</p><ul><li><strong>乐观锁</strong>（Optimistic Lock）：顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。乐观锁也是CAS的使用场景之一。<br>乐观锁适用于多读的应用类型，可以系统提高吞吐量。</li><li><strong>悲观锁</strong>（Pessimistic Lock）：正如其名，具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁</li></ul></li></ul><h3 id="62-隔离级别和锁的关系"><a class="markdownIt-Anchor" href="#62-隔离级别和锁的关系"></a> 6.2. 隔离级别和锁的关系？</h3><p>1）在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；</p><p>2）在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p><p>3）在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</p><p>4）在 SERIALIZABLE 级别下，限制性最强，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p><h3 id="63-innodb-中的锁算法"><a class="markdownIt-Anchor" href="#63-innodb-中的锁算法"></a> 6.3. InnoDB 中的锁算法？</h3><ul><li><strong>Record lock</strong>：记录锁，单个行记录上的锁</li><li><strong>Gap lock</strong>：间隙锁，锁定一个范围，不包括记录本身</li><li><strong>Next-key lock</strong>：record + gap 锁定一个范围，包含记录本身</li></ul><h3 id="64-什么是快照读和当前读"><a class="markdownIt-Anchor" href="#64-什么是快照读和当前读"></a> 6.4. 什么是快照读和当前读？</h3><p><strong>快照读</strong> 就是读取的是快照数据，不加锁的简单 Select 都属于快照读。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></tbody></table></figure><p><strong>当前读</strong> 就是读的是最新数据，而不是历史的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> player <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> player <span class="keyword">SET</span> ...</span><br></pre></td></tr></tbody></table></figure><h3 id="65-什么是mvcc以及实现"><a class="markdownIt-Anchor" href="#65-什么是mvcc以及实现"></a> 6.5. 什么是MVCC以及实现？</h3><p>MVCC 的英文全称是 Multiversion Concurrency Control，中文意思是多版本并发控制，可以做到读写互相不阻塞，主要用于解决不可重复读和幻读问题时提高并发效率。</p><p>其原理是通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p><h1 id="7-视图"><a class="markdownIt-Anchor" href="#7-视图"></a> 7. 视图</h1><h3 id="71-为什么要使用视图什么是视图"><a class="markdownIt-Anchor" href="#71-为什么要使用视图什么是视图"></a> 7.1. 为什么要使用视图？什么是视图？</h3><ul><li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li><li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li></ul><h3 id="72-视图有哪些特点"><a class="markdownIt-Anchor" href="#72-视图有哪些特点"></a> 7.2. 视图有哪些特点？</h3><p><strong>视图的特点如下:</strong></p><ul><li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li><li>视图是由基本表(实表)产生的表(虚表)。</li><li>视图的建立和删除不影响基本表。</li><li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li><li>当视图来自多个基本表时，不允许添加和删除数据。</li></ul><p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p><h3 id="73-视图的使用场景有哪些"><a class="markdownIt-Anchor" href="#73-视图的使用场景有哪些"></a> 7.3. 视图的使用场景有哪些？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</span><br></pre></td></tr></tbody></table></figure><p><strong>下面是视图的常见使用场景：</strong></p><ul><li>重用SQL语句；</li><li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li><li>使用表的组成部分而不是整个表；</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><h3 id="74-视图的优点"><a class="markdownIt-Anchor" href="#74-视图的优点"></a> 7.4. 视图的优点</h3><ol><li>查询简单化。视图能简化用户的操作</li><li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li><li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li></ol><h3 id="75-视图的缺点"><a class="markdownIt-Anchor" href="#75-视图的缺点"></a> 7.5. 视图的缺点</h3><ol><li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p></li><li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p><p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p></li></ol><h3 id="76-什么是游标"><a class="markdownIt-Anchor" href="#76-什么是游标"></a> 7.6. 什么是游标？</h3><ul><li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li></ul><h1 id="8-存储过程与函数"><a class="markdownIt-Anchor" href="#8-存储过程与函数"></a> 8. 存储过程与函数</h1><h2 id="什么是存储过程"><a class="markdownIt-Anchor" href="#什么是存储过程"></a> 什么是存储过程？</h2><ul><li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li></ul><h2 id="有哪些优缺点"><a class="markdownIt-Anchor" href="#有哪些优缺点"></a> 有哪些优缺点？</h2><p><strong>优点</strong></p><ol><li>存储过程是预编译过的，执行效率高。</li><li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li><li>安全性高，执行存储过程需要有一定权限的用户。</li><li>存储过程可以重复使用，减少数据库开发人员的工作量。</li></ol><p><strong>缺点</strong></p><ol><li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</li><li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li><li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li><li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li></ol><h1 id="9-触发器"><a class="markdownIt-Anchor" href="#9-触发器"></a> 9. 触发器</h1><h3 id="什么是触发器触发器的使用场景有哪些"><a class="markdownIt-Anchor" href="#什么是触发器触发器的使用场景有哪些"></a> 什么是触发器？触发器的使用场景有哪些？</h3><ul><li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。<strong>触发器是指一段代码，当触发某个事件时，自动执行这些代码。</strong></li></ul><p><strong>使用场景</strong></p><ul><li>可以通过数据库中的相关表实现级联更改。</li><li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li><li>例如可以生成某些业务的编号。</li><li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li><li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li></ul><h3 id="mysql中都有哪些触发器"><a class="markdownIt-Anchor" href="#mysql中都有哪些触发器"></a> MySQL中都有哪些触发器？</h3><p><strong>在MySQL数据库中有如下六种触发器：</strong></p><ul><li>Before Insert</li><li>After Insert</li><li>Before Update</li><li>After Update</li><li>Before Delete</li><li>After Delete</li></ul><h1 id="10-常用的sql语句"><a class="markdownIt-Anchor" href="#10-常用的sql语句"></a> 10. 常用的SQL语句</h1><h3 id="sql语句主要分为哪几类"><a class="markdownIt-Anchor" href="#sql语句主要分为哪几类"></a> SQL语句主要分为哪几类</h3><ul><li><p>数据<strong>定义</strong>语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p><p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p></li><li><p>数据<strong>查询</strong>语言DQL（Data Query Language）SELECT</p><p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p></li><li><p>数据<strong>操纵</strong>语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p><p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p></li><li><p>数据<strong>控制</strong>功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p><p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p></li></ul><h3 id="sql语句的语法顺序"><a class="markdownIt-Anchor" href="#sql语句的语法顺序"></a> SQL语句的语法顺序：</h3><ol><li><p>SELECT</p></li><li><p>FROM</p></li><li><p>JOIN</p></li><li><p>ON</p></li><li><p>WHERE</p></li><li><p>GROUP BY</p></li><li><p>HAVING</p></li><li><p>UNION : 将多个查询结果合并（默认去掉重复的记录）</p></li><li><p>ORDER BY</p></li><li><p>LIMIT</p><p><img src="../../images/image-20230217214658212.png" alt="image-20230217214658212"></p></li></ol><h3 id="超键-候选键-主键-外键分别是什么"><a class="markdownIt-Anchor" href="#超键-候选键-主键-外键分别是什么"></a> 超键、候选键、主键、外键分别是什么？</h3><ul><li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li>候选键：是最小超键，即没有冗余元素的超键。</li><li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li><li>外键：在一个表中存在的另一个表的主键称此表的外键。</li></ul><h3 id="sql-约束有哪几种"><a class="markdownIt-Anchor" href="#sql-约束有哪几种"></a> SQL 约束有哪几种？</h3><blockquote><p>SQL 约束有哪几种？</p></blockquote><ul><li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li><li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li><li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li><li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li><li>CHECK: 用于控制字段的值范围。</li></ul><h3 id="六种关联查询"><a class="markdownIt-Anchor" href="#六种关联查询"></a> 六种关联查询</h3><ul><li><p>交叉连接（CROSS JOIN）</p></li><li><p>内连接（INNER JOIN）</p></li><li><p>外连接（LEFT JOIN/RIGHT JOIN）</p></li><li><p>联合查询（UNION与UNION ALL）</p></li><li><p>全连接（FULL JOIN）</p></li><li><p>交叉连接（CROSS JOIN）</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)</span><br><span class="line">#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（<span class="keyword">INNER</span> <span class="keyword">JOIN</span>）<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id<span class="operator">=</span>B.id或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id多表中同时符合某种条件的数据记录的集合，<span class="keyword">INNER</span> <span class="keyword">JOIN</span>可以缩写为<span class="keyword">JOIN</span>复制代码</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>内连接分为三类</strong></p><ul><li>等值连接：ON <a href="http://A.id=B.id">A.id=B.id</a></li><li>不等值连接：ON <a href="http://A.id">A.id</a> &gt; <a href="http://B.id">B.id</a></li><li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li></ul><p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p><ul><li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li><li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li></ul><p><strong>联合查询（UNION与UNION ALL）</strong></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">UNION</span> </span><br></pre></td></tr></tbody></table></figure><ul><li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li><li>如果使用UNION ALL，不会合并重复的记录行</li><li>效率 UNION 高于 UNION ALL</li></ul><p><strong>全连接（FULL JOIN）</strong></p><figure class="highlight n1ql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id UNIONSELECT * <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id复制代码</span><br></pre></td></tr></tbody></table></figure><ul><li>MySQL不支持全连接</li><li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li></ul><h1 id="11-主从复制"><a class="markdownIt-Anchor" href="#11-主从复制"></a> 11. 主从复制</h1><h2 id="1-什么是主从复制"><a class="markdownIt-Anchor" href="#1-什么是主从复制"></a> 1、什么是主从复制？</h2><p><strong>主从复制</strong>是用来建立一个与主数据库完全一样的数据库环境，即从数据库。主数据库一般是准实时的业务数据库。</p><h2 id="2-主从复制的作用"><a class="markdownIt-Anchor" href="#2-主从复制的作用"></a> 2、主从复制的作用？</h2><ul><li>读写分离，使数据库能支撑更大的并发。</li><li>高可用，做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li></ul><h2 id="3-主从复制的架构"><a class="markdownIt-Anchor" href="#3-主从复制的架构"></a> 3、主从复制的架构？</h2><ul><li><p><strong>一主一从或一主多从</strong><br>在主库的请求压力非常大时，可通过配置一主多从复制架构实现读写分离，把大量对实时性要求不是很高的请求通过负载均衡分发到多个从库上去读取数据，降低主库的读取压力。而且在主库出现宕机时，可将一个从库切换为主库继续提供服务。</p></li><li><p><strong>主主复制</strong><br>双主复制架构适用于需要进行主从切换的场景。 两个数据库互为主从，当主库宕机恢复后，由于它还是原来从库（现在主库）的从机，所以它还是会复制新的主库上的数据。那么无论主库的角色怎么切换，原来的主库都不会脱离复制环境。</p></li><li><p>**多主一从（**5.7 开始支持）</p></li><li><p><strong>联级复制</strong><br>因为每个从库在主库上都会有一个独立的 Binlog Dump 线程来推送 binlog 日志，所以随着从库数量的增加，主库的 IO 压力和网络压力也会随之增加，这时，联级复制架构应运而生。</p></li></ul><p>联级复制架构只是在一主多从的基础上，再主库和各个从库之间增加了一个二级主库 Master2，这个二级主库仅仅用来将一级主库推送给它的 Binlog 日志再推送给各个从库，以此来减轻一级主库的推送压力。</p><p><img src="../../images/image-20230217214224766.png" alt="image-20230217214224766"></p><h2 id="4-主从复制的实现原理"><a class="markdownIt-Anchor" href="#4-主从复制的实现原理"></a> 4、主从复制的实现原理？</h2><p>数据库有个 binlog 二进制文件，记录了数据可执行的所有 SQL 语句。主从同步的目标就是把主数据库的 binlog 文件中的 SQL 语句复制到从数据库，让其在从数据的 relaylog 文件中再执行一次这些 SQL 语句即可。</p><p><strong>具体实现需要三个线程：</strong></p><ul><li><p><strong>binlog 输出线程</strong>：每当有从库连接到主库的时候，主库都会创建一个线程然后发送 binlog内 容到从库。<br>在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p></li><li><p><strong>从库 IO 线程</strong>：当 START SLAVE 语句在从库开始执行之后，从库创建一个 IO 线程，该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上。从库 IO 线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件，其中包括 relaylog 文件。</p></li><li><p><strong>从库 SQL 线程</strong>：从库创建一个 SQL 线程，这个线程读取从库 IO 线程写到 relaylog 的更新事件并执行。</p></li></ul><h2 id="5-什么是异步复制和半同步"><a class="markdownIt-Anchor" href="#5-什么是异步复制和半同步"></a> 5、什么是异步复制和半同步？</h2><p>MySQL 的主从复制有两种复制方式，分别是 <strong>异步复制</strong> 和 <strong>半同步复制</strong>：</p><ul><li><p><strong>异步复制</strong><br>MySQL <strong>默认</strong>的主从复制方式就是异步复制，因为 Master 根本不考虑数据是否达到了 Slave，或 Slave 是否成功执行。</p><p>如过需要实现完全同步方式，即 Master 需要等待一个或所有 Slave 执行成功后才响应成功，那集群效率可想而知。故 MySQL 5.6 之后出现了一种折中的方式——半同步。</p></li><li><p><strong>半同步复制</strong><br>一主一从，一主多从情况下，Master 节点只要确认至少有一个 Slave 接受到了事务，即可向发起请求的客户端返回执行成功的操作。同时 Master 是不需要等待 Slave 成功执行完这个事务，<strong>Slave 节点接受到这个事务，并成功写入到本地 relay 日志中就算成功</strong>。</p></li></ul><p>另外，在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，<strong>那 MySQL 会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。</strong></p><p>半同步复制的“半”体现在，虽然主从库的Binlog是同步的，但主库不会等待从库执行完Relay-log后才返回，而是确认从库接收到Binlog，达到主从Binlog同步的目的后就返回了，所以从库的数据对于主库来说还是有延时的，这个延时就是从库执行Relay-log的时间。所以只能称为半同步。</p><h2 id="6-主从中常见问题以及解决"><a class="markdownIt-Anchor" href="#6-主从中常见问题以及解决"></a> 6、主从中常见问题以及解决？</h2><p><strong>问题 :</strong><br>1）主库宕机后，数据可能丢失。</p><p>​2）从库只有一个sql Thread，主库写压力大，复制很可能延时。</p><p>**解决: **<br>1）半同步复制：确保事务提交后 binlog 至少传输到一个从库 ，解决数据丢失的问题。</p><p>​2）并行复制：从库多线程apply binlog，解决从库复制延迟的问题。</p><h1 id="12-font-colorred调优font"><a class="markdownIt-Anchor" href="#12-font-colorred调优font"></a> 12. <font color="red">调优</font></h1><h3 id="说出一些数据库优化方面的经验"><a class="markdownIt-Anchor" href="#说出一些数据库优化方面的经验"></a> 说出一些数据库优化方面的经验?</h3><ol><li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li><li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li><li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li><li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li><li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li></ol><h3 id="怎么优化sql查询语句吗"><a class="markdownIt-Anchor" href="#怎么优化sql查询语句吗"></a> 怎么优化SQL查询语句吗</h3><ol><li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li><li>用索引可以提高查询</li><li>SELECT子句中避免使用*号，尽量全部大写SQL</li><li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li><li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li><li>in 和 not in 也要慎用，否则会导致全表扫描</li></ol><h3 id="你怎么知道sql语句性能是高还是低"><a class="markdownIt-Anchor" href="#你怎么知道sql语句性能是高还是低"></a> 你怎么知道SQL语句性能是高还是低</h3><ol><li>查看SQL的执行时间</li><li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li></ol><h3 id="大表数据查询怎么优化"><a class="markdownIt-Anchor" href="#大表数据查询怎么优化"></a> 大表数据查询，怎么优化</h3><ol><li>优化shema、sql语句+索引；</li><li>第二加缓存，memcached, redis；</li><li>主从复制，读写分离；</li><li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li><li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li></ol><h3 id="超大分页怎么处理"><a class="markdownIt-Anchor" href="#超大分页怎么处理"></a> 超大分页怎么处理？</h3><p><strong>超大的分页一般从两个方向上来解决.</strong></p><ul><li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li><li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li></ul><p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p><h3 id="为什么要尽量设定一个主键"><a class="markdownIt-Anchor" href="#为什么要尽量设定一个主键"></a> 为什么要尽量设定一个主键？</h3><ul><li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li></ul><h3 id="主键使用自增id还是uuid"><a class="markdownIt-Anchor" href="#主键使用自增id还是uuid"></a> 主键使用自增ID还是UUID？</h3><ul><li>推荐使用自增ID，不要使用UUID。</li><li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li></ul><p>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p><h3 id="如果要存储用户的密码散列应该使用什么字段进行存储"><a class="markdownIt-Anchor" href="#如果要存储用户的密码散列应该使用什么字段进行存储"></a> 如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><ul><li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li></ul><h3 id="如何优化查询过程中的数据访问"><a class="markdownIt-Anchor" href="#如何优化查询过程中的数据访问"></a> 如何优化查询过程中的数据访问</h3><ul><li>访问数据太多导致查询性能下降</li><li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li><li>确认MySQL服务器是否在分析大量不必要的数据行</li><li>避免犯如下SQL语句错误</li><li>避免查询不需要的数据。解决办法：使用limit解决</li><li>多表关联返回全部列。解决办法：指定列名</li><li>总是返回全部列。解决办法：避免使用SELECT *</li><li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li><li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li><li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li><li>改变数据库和表的结构，修改数据表范式</li><li>重写SQL语句，让优化器可以以更优的方式执行查询。</li></ul><h3 id="如何优化长难的查询语句"><a class="markdownIt-Anchor" href="#如何优化长难的查询语句"></a> 如何优化长难的查询语句</h3><ul><li>分析是一个复杂查询还是多个简单查询速度快</li><li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li><li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li><li>将一个大的查询分为多个小的相同的查询</li><li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li><li>分解关联查询，让缓存的效率更高。</li><li>执行单个查询可以减少锁的竞争。</li><li>在应用层做关联更容易对数据库进行拆分。</li><li>查询效率会有大幅提升。</li><li>较少冗余记录的查询。</li></ul><h3 id="优化特定类型的查询语句"><a class="markdownIt-Anchor" href="#优化特定类型的查询语句"></a> 优化特定类型的查询语句</h3><ul><li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li><li>MyISAM中，没有任何where条件的count(*)非常快。</li><li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li><li>可以使用explain查询近似值，用近似值替代count(*)</li><li>增加汇总表</li><li>使用缓存</li></ul><h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3><ul><li>确定ON或者USING子句中是否有索引。</li><li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li></ul><h3 id="优化子查询"><a class="markdownIt-Anchor" href="#优化子查询"></a> 优化子查询</h3><ul><li>用关联查询替代</li><li>优化GROUP BY和DISTINCT</li><li>这两种查询据可以使用索引来优化，是最有效的优化方法</li><li>关联查询中，使用标识列分组的效率更高</li><li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li><li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li></ul><h3 id="优化limit分页"><a class="markdownIt-Anchor" href="#优化limit分页"></a> 优化LIMIT分页</h3><ul><li>LIMIT偏移量大的时候，查询效率较低</li><li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li></ul><h3 id="优化union查询"><a class="markdownIt-Anchor" href="#优化union查询"></a> 优化UNION查询</h3><ul><li>UNION ALL的效率高于UNION</li></ul><h3 id="优化where子句"><a class="markdownIt-Anchor" href="#优化where子句"></a> 优化WHERE子句</h3><ul><li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li></ul><h3 id="sql语句优化的一些方法"><a class="markdownIt-Anchor" href="#sql语句优化的一些方法"></a> SQL语句优化的一些方法</h3><ul><li><p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p></li><li><p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">-- 可以在num上设置默认值<span class="number">0</span>，确保表中num列没有<span class="literal">null</span>值，然后这样查询：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p></li><li><p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p><a href="http://5.in">5.in</a> 和 not in 也要慎用，否则会导致全表扫描，如：</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p></li><li><p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">100</span>*<span class="number">2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> substring(<span class="type">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> ‘abc%’</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure></li><li><p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p></li></ul><h2 id="数据库优化"><a class="markdownIt-Anchor" href="#数据库优化"></a> 数据库优化</h2><h3 id="为什么要优化"><a class="markdownIt-Anchor" href="#为什么要优化"></a> 为什么要优化</h3><ul><li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li><li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li><li>数据是存放在磁盘上的，读写速度无法和内存相比</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</span><br></pre></td></tr></tbody></table></figure><h3 id="数据库结构优化"><a class="markdownIt-Anchor" href="#数据库结构优化"></a> 数据库结构优化</h3><ul><li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li><li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li></ul><p><strong>将字段很多的表分解成多个表</strong></p><ul><li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li><li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li></ul><p><strong>增加中间表</strong></p><ul><li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li><li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li></ul><p><strong>增加冗余字段</strong></p><ul><li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li><li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li></ul><p><strong>注意：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</span><br></pre></td></tr></tbody></table></figure><h3 id="mysql数据库cpu飙升到500的话他怎么处理"><a class="markdownIt-Anchor" href="#mysql数据库cpu飙升到500的话他怎么处理"></a> MySQL数据库cpu飙升到500%的话他怎么处理？</h3><ul><li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li><li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li><li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li><li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li></ul><h3 id="大表怎么优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"><a class="markdownIt-Anchor" href="#大表怎么优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"></a> 大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p><ol><li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li><li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li><li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li></ol><p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p><h4 id="1-垂直分区"><a class="markdownIt-Anchor" href="#1-垂直分区"></a> 1、垂直分区</h4><ul><li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li><li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7259992ab~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li><li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li></ul><h4 id="2-垂直分表"><a class="markdownIt-Anchor" href="#2-垂直分表"></a> 2、垂直分表</h4><ul><li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c725b21e8e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p><strong>适用场景</strong></p><ul><li>1、如果一个表中某些列常用，另外一些列不常用</li><li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li></ul><p><strong>缺点</strong></p><ul><li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li><li>对于应用层来说，逻辑算法增加开发成本</li><li>管理冗余列，查询所有数据需要join操作</li></ul><h4 id="3-水平分区"><a class="markdownIt-Anchor" href="#3-水平分区"></a> 3、水平分区</h4><ul><li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li><li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7300b465e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><ul><li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li><li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</span><br></pre></td></tr></tbody></table></figure><h4 id="4-水平分表"><a class="markdownIt-Anchor" href="#4-水平分表"></a> 4、水平分表：</h4><ul><li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li></ul><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c744498a9a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p><p><strong>适用场景</strong></p><ul><li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li><li>2、需要把数据存放在多个介质上。</li></ul><p><strong>水平切分的缺点</strong></p><ul><li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li><li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li></ul><h4 id="数据库分片的两种常见方案"><a class="markdownIt-Anchor" href="#数据库分片的两种常见方案"></a> 数据库分片的两种常见方案：</h4><ul><li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li><li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li></ul><h4 id="分库分表后面临的问题"><a class="markdownIt-Anchor" href="#分库分表后面临的问题"></a> 分库分表后面临的问题</h4><ul><li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p></li><li><p><strong>跨库join</strong></p><p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p></li><li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p></li><li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p></li><li><p><strong>ID问题</strong></p></li><li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p><ul><li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li></ul></li><li><p><strong>跨分片的排序分页问题</strong></p><p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c750f5b2cc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程语言</title>
      <link href="/2023/02/16/interview/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/02/16/interview/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-请你说说多线程"><a class="markdownIt-Anchor" href="#1-请你说说多线程"></a> 1. <strong>请你说说多线程</strong></h2><p>**得分点 **   线程和进程的关系、为什么使用多线程</p><p><strong>标准回答</strong></p><p>​线程是操作系统调度的最小单元,它可以让一个进程并发地处理多个任务,也叫轻量级进程。所以,在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。 总的来说,<strong>操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程</strong>。<strong>一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程</strong>。 使用多线程会给开发人员带来显著的好处,而使用多线程的原因主要有以下几点：</p><ol><li><p>更多的CPU核心 现代计算机处理器性能的提升方式,已经从追求更高的主频向追求更多的核心发展,所以<strong>处理器的核心数量会越来越多,充分地利用处理器的核心则会显著地提高程序的性能</strong>。**而程序使用多线程技术,就可以将计算逻辑分配到多个处理器核心上,显著减少程序的处理时间,**从而随着更多处理器核心的加入而变得更有效率。</p></li><li><p>更快的响应时间 我们经常要针对复杂的业务编写出复杂的代码,如果使用多线程技术,就可以将数据一致性不强的操作派发给其他线程处理（也可以是消息队列）,如上传图片、发送邮件、生成订单等。这样响应用户请求的线程就能够尽快地完成处理,大大地缩短了响应时间,从而提升了用户体验。</p></li><li><p>更好的编程模型 Java为多线程编程提供了良好且一致的编程模型,使开发人员能够更加专注于问题的解决,开发者只需为此问题建立合适的业务模型,而无需绞尽脑汁地考虑如何实现多线程。一旦开发人员建立好了业务模型,稍作修改就可以将其方便地映射到Java提供的多线程编程模型上。</p></li></ol><h2 id="2-请你说说hashmap和hashtable的区别"><a class="markdownIt-Anchor" href="#2-请你说说hashmap和hashtable的区别"></a> 2. 请你说说HashMap和Hashtable的区别</h2><p>得分点： 线程安全、null</p><p><strong>标准回答</strong></p><p>HashMap和Hashtable都是典型的Map实现,它们的区别在于是否线程安全,是否可以存入null值。</p><ol><li><p>Hashtable在实现Map接口时保证了线程安全性,而HashMap则是非线程安全的。所以,Hashtable的性能不如HashMap,因为为了保证线程安全它牺牲了一些性能。</p></li><li><p>Hashtable不允许存入null,无论是以null作为key或value,都会引发异常。而HashMap是允许存入null的,无论是以null作为key或value,都是可以的。</p></li></ol><p><strong>加分回答</strong></p><p>虽然Hashtable是线程安全的,但仍然不建议在多线程环境下使用Hashtable。因为它是一个古老的API,从Java 1.0开始就出现了,它的同步方案还不成熟,性能不好。如果要在多线程环下使用HashMap,建议使用ConcurrentHashMap。它不但保证了线程安全,也通过降低锁的粒度提高了并发访问时的性能。</p><h2 id="3-请说说你对反射的了解"><a class="markdownIt-Anchor" href="#3-请说说你对反射的了解"></a> 3. 请说说你对反射的了解</h2><p>得分点 ： 反射概念, 通过反射机制可以实现什么</p><p><strong>标准回答</strong></p><p>Java程序中,许多对象在运行时都会有编译时异常和运行时异常两种,例如多态情况下Car c = new Audi(); 这行代码运行时会生成一个c变量,在编译时该变量的类型是Car,运行时该变量类型为Audi；另外还有更极端的情况,例如程序在运行时接收到了外部传入的一个对象,这个对象的编译时类型是Object,但程序又需要调用这个对象运行时类型的方法,这种情况下,有两种解决方法：第一种做法是假设在编译时和运行时都完全知道类型的具体信息,在这种情况下,可以先使用instanceof运算符进行判断,再利用强制类型转换将其转换成其运行时类型的变量。第二种做法是编译时根本无法预知该对象和类可能属于哪些类,程序只依靠运行时信息来发现该对象和类的真实信息,这就必须使用反射。 具体来说,通过反射机制,我们可以实现如下的操作：</p><ul><li>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的信息；</li><li>程序运行时,可以通过反射创建任意一个类的实例,并访问该实例的成员；</li><li>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。</li></ul><p><strong>加分回答</strong></p><p>Java的反射机制在实际项目中应用广泛,常见的应用场景有：</p><ul><li>使用JDBC时,如果要创建数据库的连接,则需要先通过反射机制加载数据库的驱动程序；</li><li>多数框架都支持注解/XML配置,从配置中解析出来的类是字符串,需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案,是在程序运行时创建目标对象的代理类,这必须由反射机制来实现。</li></ul><h2 id="4-请你说说arraylist和linkedlist的区别"><a class="markdownIt-Anchor" href="#4-请你说说arraylist和linkedlist的区别"></a> 4. 请你说说ArrayList和LinkedList的区别</h2><p>得分点 ：数据结构、访问效率</p><p><strong>标准回答</strong></p><ol><li>ArrayList的实现是基于<strong>数组</strong>, LinkedList的实现是基于<strong>双向链表</strong>。</li><li>对于随机访问ArrayList要优于LinkedList,ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问,而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起,查找某个元素的时间复杂度是O(N)。</li><li>对于插入和删除操作,LinkedList要优于ArrayList,因为当元素被添加到LinkedList任意位置的时候,不需要像ArrayList那样重新计算大小或者是更新索引。</li><li>LinkedList比ArrayList更占内存,因为LinkedList的节点除了存储数据,还存储了两个引用,一个指向前一个元素,一个指向后一个元素。</li></ol><h2 id="5-你知道哪些线程安全的集合"><a class="markdownIt-Anchor" href="#5-你知道哪些线程安全的集合"></a> 5. 你知道哪些线程安全的集合？</h2><p>得分点： Collections、java.util.concurrent (JUC)</p><p><strong>标准回答</strong></p><p>java.util包下的集合类中,大部分都是非线程安全的,但也有少数的线程安全的集合类, 例如Vector、Hashtable,它们都是非常古老的API。虽然它们是线程安全的,但是性能很差,已经不推荐使用了。对于这个包下非线程安全的集合,可以利用Collections工具类,该工具类提供的synchronizedXxx()方法,可以将这些集合类包装成线程安全的集合类（如：<strong>List<integer> list = Collections.synchronizedList( new ArrayList&lt;&gt;() );</integer></strong>），查看源码可知，其在所有的方法上加了synchronized修饰，从而达到同步的效果。</p><p>从JDK 1.5开始,并发包下新增了大量高效的并发的容器,这些容器按照实现机制可以分为三类。</p><ul><li>第一类是以降低锁粒度来提高并发性能的容器,它们的类名以Concurrent开头,如ConcurrentHashMap。</li><li>第二类是采用写时复制技术实现的并发容器,它们的类名以CopyOnWrite开头,如CopyOnWriteArrayList。</li><li>第三类是采用Lock实现的阻塞队列,内部创建两个Condition分别用于生产者和消费者的等待,这些类都实现了BlockingQueue接口,如ArrayBlockingQueue。</li></ul><p><strong>加分回答</strong></p><p>Collections还提供了如下三类方法来返回一个不可变的集合,这三类方法的参数是原有的集合对象,返回值是该集合的“只读”版本。通过Collections提供的三类方法,可以生成“只读”的Collection或Map。 emptyXxx()：返回一个空的不可变的集合对象 singletonXxx()：返回一个只包含指定对象的不可变的集合对象 unmodifiableXxx()：返回指定集合对象的不可变视图</p><p><strong>减少锁粒度</strong>，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。 举例：ConcurentHashmap 中使用分段锁提高 put () 操作的并发能力，默认情况下 ConcurentHashmap 有16个段，理想情况下，它可以同时接受16个线程同时插入。</p><h2 id="6-请你说说concurrenthashmap"><a class="markdownIt-Anchor" href="#6-请你说说concurrenthashmap"></a> 6. 请你说说ConcurrentHashMap</h2><p>得分点 ：数组+链表+红黑树、锁的粒度</p><p><strong>标准回答</strong></p><p>在JDK8中,ConcurrentHashMap的底层数据结构与HashMap一样,也是采用“数组+链表+红黑树”的形式。同时,<strong>它又采用锁定头节点的方式降低了锁粒度</strong>, <strong>以较低的性能代价实现了线程安全。</strong></p><p>底层数据结构的逻辑可以参考HashMap的实现,下面我重点介绍它的线程安全的实现机制。</p><ol><li><strong>初始化数组或头节点时,ConcurrentHashMap并没有加锁,而是CAS的方式进行原子替换</strong>（<strong>原子操作</strong>,基于Unsafe类的原子操作API）</li><li><strong>插入数据时会进行加锁处理,但锁定的不是整个数组,而是槽中的头节点</strong>。所以,ConcurrentHashMap中<strong>锁的粒度是槽</strong>,而不是整个数组,并发的性能很好。</li><li><strong>扩容时会进行加锁处理,锁定的仍然是头节点</strong>。并且,<strong>支持多个线程同时对数组扩容,提高并发能力</strong>。每个线程需先以<strong>CAS</strong>操作抢任务,争抢一段连续槽位的数据转移权。抢到任务后,该线程会锁定槽内的头节点,然后将链表或树中的数据迁移到新的数组里。</li><li>**查找数据时并不会加锁,所以性能很好。**另外,在扩容的过程中,依然可以支持查找操作。如果某个槽还未进行迁移,则直接可以从旧数组里找到数据。如果某个槽已经迁移完毕,但是整个扩容还没结束,则扩容线程会创建一个转发节点存入旧数组,届时查找线程根据转发节点的提示,从新数组中找到目标数据。</li></ol><p><strong>加分回答</strong></p><p>ConcurrentHashMap实现线程安全的难点在于多线程并发扩容,即当一个线程在插入数据时,若发现数组正在扩容,那么它就会立即参与扩容操作,完成扩容后再插入数据到新数组。在扩容的时候,多个线程共同分担数据迁移任务,每个线程负责的迁移数量是 <code>(数组长度 &gt;&gt;&gt; 3) / CPU核心数</code>。 也就是说,为线程分配的迁移任务,是充分考虑了硬件的处理能力的。多个线程依据硬件的处理能力,平均分摊一部分槽的迁移工作。另外,如果计算出来的迁移数量小于16,则强制将其改为16,这是考虑到目前服务器领域主流的CPU运行速度,每次处理的任务过少,对于CPU的算力也是一种浪费。</p><h2 id="7-为啥要有包装类"><a class="markdownIt-Anchor" href="#7-为啥要有包装类"></a> 7. 为啥要有包装类？</h2><p>参考答案：<br>Java语言是面向对象的语言，其设计理念是”一切皆对象“。但8种基本数据类型却出现了例外，它们不具备对象的特征。正是为了解决这个问题，Java为每个基本数据类型都定义了一个对应的应用类型，这就是包装类。</p><p>扩展阅读：</p><p>Java之所以提供8种基本数据类型，主要是为了照顾程序员的传统习惯。这8种基本数据类型的确带来了一定的方便性，但在某些时候也会受到一些制约。比如，所有的引用类型的变量都继承于Object类，都可以当做Object类型的变量使用，但基本数据类型却不可以。如果某个方法需要Object类型的参数，但实际传入的值确实数字的话，就需要做特殊的处理了。有了包装类，这种问题就可以得以简化了。</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/2023/02/15/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2023/02/15/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="和-运算符-null-合并操作符"><a class="markdownIt-Anchor" href="#和-运算符-null-合并操作符"></a> ?? 和 ??= 运算符 - Null 合并操作符</h1><p>如果左操作数的值不为 <code>null</code>，则 null 合并运算符 <code>??</code> 返回该值；否则，它会计算右操作数并返回其结果。 如果左操作数的计算结果为非 null，则 <code>??</code> 运算符不会计算其右操作数。 仅当左操作数的计算结果为 <code>null</code> 时，Null 合并赋值运算符 <code>??=</code> 才会将其右操作数的值赋值给其左操作数。 如果左操作数的计算结果为非 null，则 <code>??=</code> 运算符不会计算其右操作数。</p><p><code>??=</code> 运算符的左操作数必须是变量、<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/classes-and-structs/properties">属性</a>或<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/indexers/">索引器</a>元素。</p><p><code>??</code> 和 <code>??=</code> 运算符的左操作数的类型必须是可以为 null 的值类型。 特别是，可以使用具有无约束类型参数的 null 合并运算符：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Display</span>&lt;<span class="title">T</span>&gt;(<span class="params">T a, T backup</span>)</span>{</span><br><span class="line">    Console.WriteLine(a ?? backup);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>null 合并运算符是右结合运算符。 也就是说，是窗体的表达式</p><p>C#复制</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ?? b ?? c</span><br><span class="line">d ??= e ??= f</span><br></pre></td></tr></tbody></table></figure><p>会像这样求值</p><p>C#复制</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a ?? (b ?? c)</span><br><span class="line">d ??= (e ??= f)</span><br></pre></td></tr></tbody></table></figure><h2 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例</h2><p><code>??</code> 和 <code>??=</code> 运算符在以下应用场景中很有用：</p><ul><li><p>在包含 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/operators/member-access-operators#null-conditional-operators--and-">null 条件运算符 <code>?.</code> 和 <code>?[\]</code></a> 的表达式中，当包含 null 条件运算的表达式结果为 <code>null</code> 时，可以使用 <code>??</code> 运算符来提供替代表达式用于求值：</p><p>C#复制运行</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">double</span> <span class="title">SumNumbers</span>(<span class="params">List&lt;<span class="built_in">double</span>[]&gt; setsOfNumbers, <span class="built_in">int</span> indexOfSetToSum</span>)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">return</span> setsOfNumbers?[indexOfSetToSum]?.Sum() ?? <span class="built_in">double</span>.NaN;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = SumNumbers(<span class="literal">null</span>, <span class="number">0</span>);</span><br><span class="line">Console.WriteLine(sum);  <span class="comment">// output: NaN</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>当使用<a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/builtin-types/nullable-value-types">可以为 null 值类型</a>并且需要提供基础值类型的值时，可以使用 <code>??</code> 运算符指定当可以为 null 的类型的值为 <code>null</code> 时要提供的值：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>? a = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">int</span> b = a ?? <span class="number">-1</span>;</span><br><span class="line">Console.WriteLine(b);  <span class="comment">// output: -1</span></span><br></pre></td></tr></tbody></table></figure><p>如果可以为 null 的类型的值为 <code>null</code> 时要使用的值应为基础值类型的默认值，请使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/api/system.nullable-1.getvalueordefault#system-nullable-1-getvalueordefault">Nullable.GetValueOrDefault()</a> 方法。</p></li><li><p>可以使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/throw#the-throw-expression"><code>throw</code> 表达式</a>作为 <code>??</code> 运算符的右操作数，以使参数检查代码更简洁：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">get</span> =&gt; name;</span><br><span class="line">    <span class="keyword">set</span> =&gt; name = <span class="keyword">value</span> ?? <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentNullException(<span class="keyword">nameof</span>(<span class="keyword">value</span>), <span class="string">"Name cannot be null"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>前面的示例还演示了如何使用 <a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/programming-guide/statements-expressions-operators/expression-bodied-members">expression-bodied 成员</a>来定义属性。</p></li><li><p>可以使用 <code>??=</code> 运算符替换窗体的代码</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (variable <span class="keyword">is</span> <span class="literal">null</span>)</span><br><span class="line">{</span><br><span class="line">    variable = expression;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>替换为以下代码：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable ??= expression;</span><br></pre></td></tr></tbody></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 零碎知识&amp;笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎知识&amp;笔记 </tag>
            
            <tag> 运算符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud微服务~面试题</title>
      <link href="/2023/02/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9D%A2%E8%AF%95%E7%AF%87/"/>
      <url>/2023/02/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E9%9D%A2%E8%AF%95%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="1-springcloud常见组件有哪些"><a class="markdownIt-Anchor" href="#1-springcloud常见组件有哪些"></a> 1. SpringCloud常见组件有哪些？</h1><p>**问题说明：**这个题目主要考察对SpringCloud的组件基本了解</p><p>**难易程度：**简单</p><p><strong>参考话术：</strong></p><p>SpringCloud包含的组件很多，有很多功能是重复的。其中最常用组件包括：</p><ul><li>注册中心组件：Eureka、Nacos等</li><li>负载均衡组件：Ribbon</li><li>远程调用组件：OpenFeign</li><li>网关组件：Zuul、GateWay</li><li>服务保护组件：Hystrix、Sentinel</li><li>服务配置管理组件：SpringCloudConfig、Nacos</li></ul><h1 id="2-nacos的服务注册表结构是怎样的"><a class="markdownIt-Anchor" href="#2-nacos的服务注册表结构是怎样的"></a> 2. Nacos的服务注册表结构是怎样的？</h1><p>​什么叫做注册表结构啊，我们知道Naocs首先它是一个注册中心，我们所有的微服务在启动时，就会提交自己的信息到Nacos当中，我们Nacos保存当前服务的一些信息。那么保持在哪里呢？就是保存在这个注册表当中，只有把所有的服务信息都保存下来了，将来消费者想要去获取服务时，才能够从这个注册表里得到对应服务的信息、IP端口才能进行访问。那么问题就来了，Nacos它是如何创建这样一个表，那么这个注册表结构是什么样子呢？面试官问这个问题其实就是考查两个东西，第一，就是你对于他的这个服务分级存储的一个模型是否了解，第二呢，就是Nacos的源码</p><p><img src="../../images/image-20230210005624585.png" alt="image-20230210005624585"></p><p>Nacos采用了数据的分级存储模型，最外层是Namespace，用来隔离环境。然后是Group，用来对服务分组。接下来就是服务（Service）了，一个服务包含多个实例，但是可能处于不同机房，因此Service下有多个集群（Cluster），Cluster下是不同的实例（Instance）。</p><p>对应到Java代码中，Nacos采用了一个多层的Map来表示。结构为Map&lt;String, Map&lt;String, Service&gt;&gt;，其中最外层Map的key就是namespaceId，值是一个Map。内层Map的key是group拼接serviceName，值是Service对象。Service对象内部又是一个Map，key是集群名称，值是Cluster对象。而Cluster对象内部维护了Instance的集合。</p><h1 id="3-nacos如何支撑数十万服务注册压力"><a class="markdownIt-Anchor" href="#3-nacos如何支撑数十万服务注册压力"></a> 3. Nacos如何支撑数十万服务注册压力？</h1><p>Nacos内部接收到注册的请求时，不会立即写数据，而是将服务注册的任务放入一个<mark>阻塞队列</mark>就立即响应给客户端。然后利用<mark>线程池</mark>读取阻塞队列中的任务，<mark>异步</mark>来完成实例更新，从而提高并发写能力。</p><h1 id="4-nacos如何避免并发读写冲突问题"><a class="markdownIt-Anchor" href="#4-nacos如何避免并发读写冲突问题"></a> 4. Nacos如何避免并发读写冲突问题？</h1><p>Nacos在更新实例列表时，会采用CopyOnWrite技术，首先将旧的实例列表拷贝一份，然后更新拷贝的实例列表，再用更新后的实例列表来覆盖旧的实例列表。</p><p>这样在更新的过程中，就不会对读实例列表的请求产生影响，也不会出现脏读问题了。</p><h1 id="5-nacos与eureka的区别有哪些"><a class="markdownIt-Anchor" href="#5-nacos与eureka的区别有哪些"></a> 5. Nacos与Eureka的区别有哪些？</h1><p>Nacos与Eureka有相同点，也有不同之处，可以从以下几点来描述：</p><ul><li>接口方式：Nacos与Eureka都对外暴露了Rest风格的API接口，用来实现服务注册、发现等功能</li><li>实例类型：Nacos的实例有永久和临时实例之分；而Eureka只支持临时实例</li><li>健康检测：Nacos对临时实例采用心跳模式检测，对永久实例采用主动请求来检测；Eureka只支持心跳模式</li><li>服务发现：Nacos支持定时拉取和订阅推送两种模式；Eureka只支持定时拉取模式</li></ul><h1 id="6-sentinel的限流与gateway的限流有什么差别"><a class="markdownIt-Anchor" href="#6-sentinel的限流与gateway的限流有什么差别"></a> 6. Sentinel的限流与Gateway的限流有什么差别？</h1><p>考察对限流算法的掌握情况</p><p>限流算法常见的有三种实现：滑动时间窗口、令牌桶算法、漏桶算法。Gateway则采用了基于Redis实现的<mark>令牌桶算法</mark>。</p><p>而Sentinel内部却比较复杂：</p><ul><li>默认限流模式是基于<mark>滑动时间窗口</mark>算法</li><li>排队等待的限流模式则基于<mark>漏桶算法</mark></li><li>而热点参数限流则是基于<mark>令牌桶算法</mark></li></ul><h1 id="7-sentinel的线程隔离与hystix的线程隔离有什么差别"><a class="markdownIt-Anchor" href="#7-sentinel的线程隔离与hystix的线程隔离有什么差别"></a> 7. Sentinel的线程隔离与Hystix的线程隔离有什么差别？</h1><p>Hystix默认是基于线程池实现的线程隔离，每一个被隔离的业务都要创建一个独立的线程池，线程过多会带来额外的CPU开销，性能一般，但是隔离性更强。</p><p>Sentinel是基于信号量（计数器）实现的线程隔离，不用创建线程池，性能较好，但是隔离性一般。</p><p><img src="../../images/image-20230210011501205.png" alt="image-20230210011501205"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 面试 </category>
          
          <category> 面试 </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feign的介绍和使用</title>
      <link href="/2023/02/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/Feign/Feign%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/02/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/Feign/Feign%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="一-feign介绍和简单基本使用流程"><a class="markdownIt-Anchor" href="#一-feign介绍和简单基本使用流程"></a> 一、Feign介绍和简单基本使用流程</h1><p><img src="../../../../images/image-20230207213746760.png" alt="image-20230207213746760"></p><p><img src="../../../../images/image-20230207213755922.png" alt="image-20230207213755922"></p><p>​ Feign是一种负载均衡的HTTP客户端, 使用Feign调用API就像调用本地方法一样，从避免了调用目标微服务时，需要不断的解析/封装json 数据的繁琐。Feign集成了Ribbon。Ribbon+eureka是面向微服务编程，而Feign是面向接口编程。</p><pre><code>Fegin是一个声明似的web服务客户端，它使得编写web服务客户端变得更加容易。使用Fegin创建一个接口并对它进行注解。它具有可插拔的注解支持包括Feign注解与JAX-RS注解，Feign还支持可插拔的编码器与解码器，Spring Cloud 增加了对 Spring MVC的注解，Spring Web 默认使用了HttpMessageConverters, Spring Cloud 集成 Ribbon 和 Eureka 提供的负载均衡的HTTP客户端 Feign。</code></pre><p><img src="../../../../images/image-20230207213838171.png" alt="image-20230207213838171"></p><p><img src="../../../../images/image-20230207213949255.png" alt="image-20230207213949255"></p><p><img src="../../../../images/image-20230207215026899.png" alt="image-20230207215026899"></p><p><font color="red"><strong>Feign内部集成了ribbon,自动实现了负载均衡</strong></font></p><p><img src="../../../../images/image-20230207215002005.png" alt="image-20230207215002005"></p><h1 id="二-feign自定义配置"><a class="markdownIt-Anchor" href="#二-feign自定义配置"></a> 二、Feign自定义配置</h1><p><img src="../../../../images/image-20230207215233270.png" alt="image-20230207215233270"></p><p><img src="../../../../images/image-20230207215305103.png" alt="image-20230207215305103"></p><p><img src="../../../../images/image-20230207215415792.png" alt="image-20230207215415792"></p><p><img src="../../../../images/image-20230207215550021.png" alt="image-20230207215550021"></p><p>如果要调试的时候可以使用FULL，但平时建议一般使用BASIC或NONE，因为记录日志还是会消耗一定的性能的</p><h1 id="设置超时"><a class="markdownIt-Anchor" href="#设置超时"></a> 设置超时：</h1><ul><li>设置openFeign的超时时间</li><li>设置Ribbon的超时时间</li></ul><h3 id="1-设置ribbon的超时时间不推荐"><a class="markdownIt-Anchor" href="#1-设置ribbon的超时时间不推荐"></a> 1、设置Ribbon的超时时间（不推荐）</h3><p>设置很简单，在配置文件中添加如下设置：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="comment"># 值的是建立链接所用的时间，适用于网络状况正常的情况下， 两端链接所用的时间</span></span><br><span class="line">  <span class="attr">ReadTimeout:</span> <span class="number">5000</span></span><br><span class="line">  <span class="comment"># 指的是建立链接后从服务器读取可用资源所用的时间</span></span><br><span class="line">  <span class="attr">ConectTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-设置openfeign的超时时间推荐"><a class="markdownIt-Anchor" href="#2-设置openfeign的超时时间推荐"></a> 2、设置openFeign的超时时间（推荐）</h3><p>openFeign设置超时时间非常简单，只需要在配置文件中配置，如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment">## default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>default设置的是全局超时时间，对所有的openFeign接口服务都生效</p></blockquote><p>但是正常的业务逻辑中可能涉及到多个openFeign接口的调用，如下图：</p><p><img src="https://gitee.com/chenjiabing666/BlogImage/raw/master/openFeign/7.png" alt="img"></p><p>上图中的伪代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">invoke</span><span class="params">()</span>{</span><br><span class="line">    <span class="comment">//1. 调用serviceA</span></span><br><span class="line">    serviceA();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 调用serviceA</span></span><br><span class="line">    serviceB();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 调用serviceA</span></span><br><span class="line">    serviceC();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>那么上面配置的全局超时时间能不能通过呢？很显然是<code>serviceA</code>、<code>serviceB</code>能够成功调用，但是<code>serviceC</code>并不能成功执行，肯定报超时。</p><p>此时我们可以给<code>serviceC</code>这个服务单独配置一个超时时间，配置如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="comment">## default 设置的全局超时时间，指定服务名称可以设置单个服务的超时时间</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">5000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">5000</span></span><br><span class="line">      <span class="comment">## 为serviceC这个服务单独配置超时时间</span></span><br><span class="line">      <span class="attr">serviceC:</span></span><br><span class="line">        <span class="attr">connectTimeout:</span> <span class="number">30000</span></span><br><span class="line">        <span class="attr">readTimeout:</span> <span class="number">30000</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>注意</strong>：单个配置的超时时间将会覆盖全局配置。</p></blockquote><h1 id="三-feign的性能调优"><a class="markdownIt-Anchor" href="#三-feign的性能调优"></a> 三、Feign的性能调优</h1><p>Feign是一个声明式客户端，它只是把我们的声明变成http请求，最后发送http请求时还是会应用到一些别的客户端</p><p><img src="../../../../images/image-20230207220231333.png" alt="image-20230207220231333"></p><p><img src="../../../../images/image-20230207220445237.png" alt="image-20230207220445237"></p><p><img src="../../../../images/image-20230207220949115.png" alt="image-20230207220949115"></p><h1 id="四-feign的最佳实践"><a class="markdownIt-Anchor" href="#四-feign的最佳实践"></a> 四、Feign的最佳实践</h1><p><img src="../../../../images/image-20230207221619077.png" alt="image-20230207221619077"></p><p><img src="../../../../images/image-20230207221552791.png" alt="image-20230207221552791"></p><p><img src="../../../../images/image-20230207221538398.png" alt="image-20230207221538398"></p><h2 id="演示feign的最佳实践二抽取feignclient"><a class="markdownIt-Anchor" href="#演示feign的最佳实践二抽取feignclient"></a> 演示Feign的最佳实践二：抽取FeignClient</h2><p>教程视频：<a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=34&amp;vd_source=746b9336d739b80b11820809545b6604">11-Feign-实现Feign最佳实践_哔哩哔哩_bilibili</a></p><p><img src="../../../../images/image-20230207221754929.png" alt="image-20230207221754929"></p>]]></content>
      
      
      <categories>
          
          <category> 远程调用 </category>
          
          <category> Feign </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 远程调用 </tag>
            
            <tag> Feign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-线程隔离和熔断降级</title>
      <link href="/2023/02/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%92%8C%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/"/>
      <url>/2023/02/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E5%92%8C%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="一-线程隔离"><a class="markdownIt-Anchor" href="#一-线程隔离"></a> 一、线程隔离</h1><p><img src="../../../images/image-20230209154610011.png" alt="image-20230209154610011"></p><p><img src="../../../images/image-20230209154514001.png" alt="image-20230209154514001"></p><p><img src="../../../images/image-20230209154637624.png" alt="image-20230209154637624"></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><ul><li><p>线程隔离的两种手段是？</p><ul><li><p>信号量隔离</p></li><li><p>线程池隔离</p></li></ul></li><li><p>信号量隔离的特点是？</p><ul><li>基于计数器模式，简单，开销小</li></ul></li><li><p>线程池隔离的特点是？</p><ul><li>基于线程池模式，有额外开销，但隔离控制更强</li></ul></li></ul><h1 id="二-熔断降级"><a class="markdownIt-Anchor" href="#二-熔断降级"></a> 二、熔断降级</h1><p>​**Sentinel如何去实现熔断降级？**融合降级，它其实就是用一个<mark><font color="red">断路器</font></mark>去统计服务调用时的一个异常比例、慢请求比例，如果说在做服务调用的时候，异常的比例过高，触发了阈值，就会熔断该服务，拦截访问该服务的一切请求。那这样呢，就会把这个故障服务隔离开了，不会让它影响到我们正常的服务。（就像古代啊，这个武侠人士是吧，这手被毒蛇咬了，赶紧手起刀落，把这个手砍掉，那脚还中毒了呢，卡，把脚砍掉，防止这个毒扩散到全身啊。所以壮士断腕就是一种自我保护）。当然，你把手砍了不算本事啊，你要是能接回来才算本事。所以呢，<strong>服务熔断很好做，将来服务如果恢复了，还应该去恢复对该服务的访问。那这个我们的断路器怎么去做呢？</strong></p><p>​它是由内部的一个<strong>状态机</strong>来实现的，这个状态机，包含三个状态，分别是Close、Open、Half-Open。Open绿色代表走，这种状态下，断路器不会拦截任何请求，不管请求是正常的还是异常的，都可以访问，但是我们的断路器会统计这个调用的<strong>异常比例</strong>，如果统计过程中发现异常的比例过高，达到了阈值，它就会从Closed状态切换到Open状态，红色代表停止，那这个时候他就会拦截进入该服务的一些请求了，也就相当于是垄断，但是你不能一直是垄断状态（因为万一这个服务它又恢复了），那因此我们这个熔断的状态会有一个持续的时间，当这个熔断时间结束时，它会从Open状态切换到Half-Open状态，在这个状态下它会放行一次请求，然后根据这次请求的结果来判断接下来干嘛，比如说Half-Open放行了一次请求，结果发现这个请求依然是失败的，那会再次进入Open状态，拦截一切请求，进入熔断，当然同样是持续一段熔断时间，然后再进入Half-Open，那如果放行的这个请求它执行完了，发现是成功的，那么就会从Half-Open切换到Cloesd，这个时候，就等于我们的登录器又开始放行了，那大家随便，然后又开始做数据统计了。那么这三个状态啊，就可以按照这种方式进行一个切换，因此呢，我们不仅能够熔断，还能恢复，就是靠这个来实现的。那在这里面啊，比较关键的两个东西。第一，就是熔断的持续时间（这个将来肯定由我们去配置），第二，失败的阈值，什么情况下你要去熔断。而这个达成熔断的条件啊，在Sentinel里面就叫做<mark>熔断的策略</mark>。</p><p><img src="../../../images/image-20230209161221875.png" alt="image-20230209161221875"></p><h2 id="熔断策略"><a class="markdownIt-Anchor" href="#熔断策略"></a> 熔断策略</h2><p>熔断策略到底有哪些呢？</p><h4 id="断路器熔断策略有三种慢调用-异常比例-异常数"><a class="markdownIt-Anchor" href="#断路器熔断策略有三种慢调用-异常比例-异常数"></a> 断路器熔断策略有三种：慢调用、异常比例、异常数</h4><h5 id="慢调用"><a class="markdownIt-Anchor" href="#慢调用"></a> 慢调用</h5><ul><li><strong>慢调用</strong>：业务的响应时长（RT）大于指定时长的请求认定为慢调用请求。在指定时间内，如果请求数量超过设定的最小数量，慢调用比例大于设定的阈值，则触发熔断。例如：</li></ul><p><img src="../../../images/image-20230209164421742.png" alt="image-20230209164421742"></p><p>上面降级规则配置的解读：RT超过500ms的调用是慢调用，统计最近10000ms内的请求，如果请求量超过10次，并且慢调用比例不低于0.5，则触发熔断，熔断时长为5秒。然后进入half-open状态，放行一次请求做测试。</p><p><strong>案例：</strong></p><p><img src="../../../images/image-20230209164715829.png" alt="image-20230209164715829"></p><p><img src="../../../images/image-20230209165230617.png" alt="image-20230209165230617"></p><h5 id="异常比例-异常数"><a class="markdownIt-Anchor" href="#异常比例-异常数"></a> 异常比例、异常数</h5><p><img src="../../../images/image-20230209165608275.png" alt="image-20230209165608275"></p><h2 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h2><p>Sentinel熔断降级的策略有哪些？</p><ul><li><p>慢调用比例：超过指定时长的调用为慢调用，统计单位时长内慢调用的比例，超过阈值则熔断</p></li><li><p>异常比例：统计单位时长内异常调用的比例，超过阈值则熔断</p></li><li><p>异常数：统计单位时长内异常调用的次数，超过阈值则熔断</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-集群搭建</title>
      <link href="/2023/02/09/Nacos/Nacos-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/02/09/Nacos/Nacos-%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="nacos集群搭建"><a class="markdownIt-Anchor" href="#nacos集群搭建"></a> Nacos集群搭建</h1><h1 id="1集群结构图"><a class="markdownIt-Anchor" href="#1集群结构图"></a> 1.集群结构图</h1><p>官方给出的Nacos集群图：</p><p><img src="../../images/image-20210409210621117.png" alt="image-20210409210621117"></p><p>其中包含3个nacos节点，然后一个负载均衡器代理3个Nacos。这里负载均衡器可以使用nginx。</p><p>我们计划的集群结构：</p><p><img src="../../images/image-20210409211355037.png" alt="image-20210409211355037"></p><p>三个nacos节点的地址：</p><table><thead><tr><th>节点</th><th>ip</th><th>port</th></tr></thead><tbody><tr><td>nacos1</td><td>192.168.150.1</td><td>8845</td></tr><tr><td>nacos2</td><td>192.168.150.1</td><td>8846</td></tr><tr><td>nacos3</td><td>192.168.150.1</td><td>8847</td></tr></tbody></table><h1 id="2搭建集群"><a class="markdownIt-Anchor" href="#2搭建集群"></a> 2.搭建集群</h1><p>搭建集群的基本步骤：</p><ul><li>搭建数据库，初始化数据库表结构</li><li>下载nacos安装包</li><li>配置nacos</li><li>启动nacos集群</li><li>nginx反向代理</li></ul><h2 id="21初始化数据库"><a class="markdownIt-Anchor" href="#21初始化数据库"></a> 2.1.初始化数据库</h2><p>Nacos默认数据存储在内嵌数据库Derby中，不属于生产可用的数据库。</p><p>官方推荐的最佳实践是使用带有主从的高可用数据库集群，主从模式的高可用数据库可以参考<strong>传智教育</strong>的后续高手课程。</p><p>这里我们以单点的数据库为例来讲解。</p><p>首先新建一个数据库，命名为nacos，而后导入下面的SQL：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'data_id'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'content'</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'md5'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">'source user'</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'source ip'</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'租户字段'</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'config_info'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'data_id'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'group_id'</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'datum_id'</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'内容'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'租户字段'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'增加租户字段'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'data_id'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'group_id'</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'app_name'</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'content'</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'betaIps'</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'md5'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">'source user'</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'source ip'</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'租户字段'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'config_info_beta'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'data_id'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'group_id'</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'tenant_id'</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'tag_id'</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'app_name'</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'content'</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'md5'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">'source user'</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'source ip'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'config_info_tag'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'tag_name'</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'tag_type'</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'data_id'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'group_id'</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'tenant_id'</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'config_tag_relation'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'主键ID'</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'Group ID，空字符表示整个集群'</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'配额，0表示使用默认值'</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'使用量'</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'单个配置大小上限，单位为字节，0表示使用默认值'</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'聚合子配置最大个数，，0表示使用默认值'</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'最大变更历史数量'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'集群、各Group容量信息表'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'app_name'</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'租户字段'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'多租户改造'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'主键ID'</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'Tenant ID'</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'配额，0表示使用默认值'</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'使用量'</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'单个配置大小上限，单位为字节，0表示使用默认值'</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'聚合子配置最大个数'</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值'</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">'0'</span> COMMENT <span class="string">'最大变更历史数量'</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'租户容量信息表'</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">'id'</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'kp'</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">''</span> COMMENT <span class="string">'tenant_id'</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">''</span> COMMENT <span class="string">'tenant_name'</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'tenant_desc'</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'create_source'</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'创建时间'</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">'修改时间'</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">'tenant_info'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `users` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">`password` <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`enabled` <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `roles` (</span><br><span class="line">`username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">`role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line"><span class="keyword">UNIQUE</span> INDEX `idx_user_role` (`username` <span class="keyword">ASC</span>, `role` <span class="keyword">ASC</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `permissions` (</span><br><span class="line">    `role` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `resource` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    `action` <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">UNIQUE</span> INDEX `uk_role_permission` (`role`,`resource`,`action`) <span class="keyword">USING</span> BTREE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">'nacos'</span>, <span class="string">'$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu'</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">'nacos'</span>, <span class="string">'ROLE_ADMIN'</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="22下载nacos"><a class="markdownIt-Anchor" href="#22下载nacos"></a> 2.2.下载nacos</h2><p>nacos在GitHub上有下载地址：<a href="https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p><p>本例中才用1.4.1版本：</p><p><img src="../../images/image-20210409212119411.png" alt="image-20210409212119411"></p><h2 id="23配置nacos"><a class="markdownIt-Anchor" href="#23配置nacos"></a> 2.3.配置Nacos</h2><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="../../images/image-20210402161843337.png" alt="image-20210402161843337"></p><p>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>进入nacos的conf目录，修改配置文件cluster.conf.example，重命名为cluster.conf：</p><p><img src="../../images/image-20210409212459292.png" alt="image-20210409212459292"></p><p>然后添加内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:8845</span><br><span class="line">127.0.0.1.8846</span><br><span class="line">127.0.0.1.8847</span><br></pre></td></tr></tbody></table></figure><p>然后修改application.properties文件，添加数据库配置</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">db.user.0</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password.0</span>=<span class="string">123</span></span><br></pre></td></tr></tbody></table></figure><h2 id="24启动"><a class="markdownIt-Anchor" href="#24启动"></a> 2.4.启动</h2><p>将nacos文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p><p><img src="../../images/image-20210409213335538.png" alt="image-20210409213335538"></p><p>然后分别修改三个文件夹中的application.properties，</p><p>nacos1:</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8845</span></span><br></pre></td></tr></tbody></table></figure><p>nacos2:</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8846</span></span><br></pre></td></tr></tbody></table></figure><p>nacos3:</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server.port</span>=<span class="string">8847</span></span><br></pre></td></tr></tbody></table></figure><p>然后分别启动三个nacos节点：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startup.cmd</span><br></pre></td></tr></tbody></table></figure><h2 id="25nginx反向代理"><a class="markdownIt-Anchor" href="#25nginx反向代理"></a> 2.5.nginx反向代理</h2><p>找到课前资料提供的nginx安装包：</p><p><img src="../../images/image-20210410103253355.png" alt="image-20210410103253355"></p><p>解压到任意非中文目录下：</p><p><img src="../../images/image-20210410103322874.png" alt="image-20210410103322874"></p><p>修改conf/nginx.conf文件，配置如下：</p><figure class="highlight nginx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> nacos-cluster {</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:8845</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8846</span>;</span><br><span class="line"><span class="attribute">server</span> <span class="number">127.0.0.1:8847</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="section">server</span> {</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> /nacos {</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://nacos-cluster;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>而后在浏览器访问：<a href="http://localhost/nacos%E5%8D%B3%E5%8F%AF%E3%80%82">http://localhost/nacos即可。</a></p><p>代码中application.yml文件配置如下：</p><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:80</span> <span class="comment"># Nacos地址</span></span><br></pre></td></tr></tbody></table></figure><h2 id="26优化"><a class="markdownIt-Anchor" href="#26优化"></a> 2.6.优化</h2><ul><li><p>实际部署时，需要给做反向代理的nginx服务器设置一个域名，这样后续如果有服务器迁移nacos的客户端也无需更改配置.</p></li><li><p>Nacos的各个节点应该部署到多个不同服务器，做好容灾和隔离</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-注册细节以及与Eureka的比较</title>
      <link href="/2023/02/08/Nacos/Nacos-%E6%B3%A8%E5%86%8C%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E4%B8%8EEureka%E7%9A%84%E6%AF%94%E8%BE%83/"/>
      <url>/2023/02/08/Nacos/Nacos-%E6%B3%A8%E5%86%8C%E7%BB%86%E8%8A%82%E4%BB%A5%E5%8F%8A%E4%B8%8EEureka%E7%9A%84%E6%AF%94%E8%BE%83/</url>
      
        <content type="html"><![CDATA[<h1 id="nacos注册细节"><a class="markdownIt-Anchor" href="#nacos注册细节"></a> Nacos注册细节</h1><p><img src="../../images/image-20230208175614453.png" alt="image-20230208175614453"></p><p>相比Eureka，Nacos可以主动推送变更消息push，nacos注册中心一当发现有服务挂了，会立即向服务消费者发送服务变更消息，让服务消费者能及时跟新，跟新的效率更高些，时效性好些。</p><p><img src="https://img-blog.csdnimg.cn/074d5bbb3df044b3b5c6a133d3cd438b.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c37456abdf8c41a2905ee82b932a3d4f.png" alt="img"></p><p>不是临时实例，即便服务程序关闭之后，还在这里，只是标红表示不是健康状态，等待着我们启动它</p><p><img src="https://img-blog.csdnimg.cn/e6b8655861b34857b9c742dfbfc3b45d.png" alt="img"></p><p>再重新启动服务，上面的服务就会恢复健康状态了</p><p><img src="../../images/image-20230208180456332.png" alt="image-20230208180456332"></p><ol><li>Nacos与eureka的共同点<ol><li>都支持服务注册和服务拉取</li><li>都支持服务提供者心跳方式做健康检测<br>总结</li></ol></li><li>Nacos与Eureka的区别<ol><li>Nacos支持服务端主动检测提供者状态 : 临时实例采用心跳模式，非临时实例采用主动检测模式<font color="red">（但是主动检测对服务器压力会比较大，所以更建议使用临时实例）</font></li><li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li><li>Naco支持<mark>主动服务列表变更的消息推送模式</mark>，服务列表更新更及时&lt;</li><li>Nacos集群默认采用AP（强调数据的可用性）方式，当集群中存在非临时实例时，采用CP（强调数据可靠性和一致性）模式; Eureka采用AP方式</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-实现配置管理</title>
      <link href="/2023/02/08/Nacos/Nacos-%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/"/>
      <url>/2023/02/08/Nacos/Nacos-%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><img src="../../images/image-20230209095809931.png" alt="image-20230209095809931"></p><p><img src="../../images/image-20230209095828746.png" alt="image-20230209095828746"></p><p><img src="https://img-blog.csdnimg.cn/942f070893c4461f928a6eeb279898fa.png" alt="img"></p><p>配置好后就会出现在配置列表中</p><p><img src="https://img-blog.csdnimg.cn/cf66c3257bff4b67b557eec90e9748b8.png" alt="img"></p><p>上面就是已经把部分的配置放到了Nacos的服务器了，下面介绍微服务怎样得到Nacos上那些配置</p><p>首先项目要知道，去哪读取，读取谁？</p><p>bootstrap.yml的优先级会比application.yml的优先级高很多</p><p>与Nacos的地址和配置文件有关的信息都应该放到bootstrap.yml文件中</p><p><img src="../../images/image-20230209104626994.png" alt="image-20230209104626994"></p><p><img src="../../images/image-20230209105137315.png" alt="image-20230209105137315"></p><p><img src="../../images/image-20230209105741565.png" alt="image-20230209105741565"></p><p><img src="../../images/image-20230209105801342.png" alt="image-20230209105801342"></p><h1 id="配置热更新"><a class="markdownIt-Anchor" href="#配置热更新"></a> 配置热更新</h1><p><img src="../../images/image-20230209111159685.png" alt="image-20230209111159685"></p><p>在开发中也比较建议用方式二</p><p><img src="../../images/image-20230209111901087.png" alt="image-20230209111901087"></p><p><img src="../../images/image-20230209111637920.png" alt="image-20230209111637920"></p><p><img src="../../images/image-20230209111420871.png" alt="image-20230209111420871"></p><h1 id="多环境配置共享"><a class="markdownIt-Anchor" href="#多环境配置共享"></a> 多环境配置共享</h1><p><img src="../../images/image-20230209112532846.png" alt="image-20230209112532846"></p><p>添加多环境共享配置</p><p><img src="../../images/image-20230209112740490.png" alt="image-20230209112740490"></p><p><strong>多种配置的优先级：</strong></p><p><img src="../../images/image-20230209113541179.png" alt="image-20230209113541179"></p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h1><p>微服务会从nacos读取的配置文件：</p><ul><li>[服义名]-[spring.profile.active].yaml，环境配置</li><li>[服务名].yaml，默认配置，多环境共享</li></ul><p>优先级：</p><ul><li>[服务名]-[环境].yaml &gt; [服务名].yaml &gt; 本地配置</li></ul>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-namespace环境隔离</title>
      <link href="/2023/02/08/Nacos/Nacos-namespace%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB/"/>
      <url>/2023/02/08/Nacos/Nacos-namespace%E7%8E%AF%E5%A2%83%E9%9A%94%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<p><img src="../../images/image-20230208173305495.png" alt="image-20230208173305495"></p><ul><li><p>Nacos环境隔离</p><ul><li><p>namespace用来做环境隔离</p></li><li><p>每个namespace都有唯一id</p></li><li><p>不同namespace下的服务不可见不可互相访问</p></li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/0fa6f9d42a6740618e152a64f7292fb3.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/0b3283fbe1794b9f9056e92c342f09cd.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/37a8ed0a6a804172bd36326c3f7c785d.png" alt="img"></p><p>不同namespace（命名空间）下的服务是不可见的，要想访问，必须放到同一个namespace下</p><p><img src="https://img-blog.csdnimg.cn/1e23788df7e24d9fa46e202b7a82b334.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/14c23a2504cb4f4fa6f585e425ab4099.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-服务实例的权重设置</title>
      <link href="/2023/02/08/Nacos/Nacos-%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%9D%83%E9%87%8D%E8%AE%BE%E7%BD%AE/"/>
      <url>/2023/02/08/Nacos/Nacos-%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E7%9A%84%E6%9D%83%E9%87%8D%E8%AE%BE%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="先分析为何要用权重设置"><a class="markdownIt-Anchor" href="#先分析为何要用权重设置"></a> 先分析为何要用权重设置：</h2><p>​集群优先的负载均衡，不过呢，我们部署的时候啊，可能会存在这么一种情况，因为企业里服务器设备啊，会更新迭代，有一些机器呢，性能比较好，还有一些属于是祖传设备了，性能非常的差，可以说是老弱病残，这个时候呢，我们肯定是希望这些性能好的机器，它承担更多的用户请求，而那些性能差一点的，自然是承担少一点的请求，正所谓能者多劳嘛。但是我们目前看来，NacosRule做到的是集群优先，而后做随机，当用户请求来了以后，它可不管你是性格好的还是差，这个身强力壮的还是老弱病残拉过来就一顿造，那这个时候那些性能差的肯定就会出问题。那么我们该怎样去控制不同服务它的一个请求量呢？哎，Nacos，给我们提供了一个权重的配置，通过修改服务实力的权重，可以控制访问频率，权重越大，访问到的频率就越高，那我们就可以<mark>把性能好的机器全都设得大一点，性能差一些呢，设置的小一点。</mark></p><p><img src="../../images/image-20230208162844861.png" alt="image-20230208162844861"></p><p><strong>权重设置为0时</strong>，该实例就不会被访问了，也就是说权重调整0时，它压根儿就不会被访问。</p><h2 id="font-colorred那设置权重为0有什么作用font"><a class="markdownIt-Anchor" href="#font-colorred那设置权重为0有什么作用font"></a> <font color="red">那设置权重为0有什么作用？</font></h2><p>​我们以前一个服务，我们想要对它做一个版本的升级，我们该怎么办？我们是不是要把它重启啊，但是你光天化日之下，你去重启个服务器，是不好的，因为用户都还在访问，你一重启别人就反应不了“哎，你这服务怎么挂了？”，就有问题了！对不对，所以说呢，我们是不能随便重启的。往往呀，每次版本升级都是搞得跟那个什么谍战片一样，要找一个月黑风高无人之夜是吧，然后等用户都下线儿了，我们偷偷的把服务停机，然后呢，去做版本的一个升级。但是你想看，如果现在有了这个权重，我可不可以这么做？我有多个服务器，8081、8082、8083各自部署，我先将8081这个服务的权重调成零。然后呢，大白天也没事儿啊，这个时候呢，渐渐的8081就不承担用户请求了，那这个时候我对它做停机，用户就不会有感知了，那么这个时候对8081停机完了以后，就可以去做一些这个版本的升级，升级完成以后我再重启，我给它权重先不着急调太大，先调小一点，调到零点多，0.01什么之类的，这个时候呢，我们放出少数用户进来做个测试，看看行不行，如果没什么问题，我们就可以逐渐扩大比例，一次升级，这个时候用户是无感知的，你可以做到平滑升级。非常优雅，那么这样呢，这种升级方式啊，其实就是比较比较顺滑这种方式了，你就不用去大半夜去加班的去搞了。所以呢，这是我们这个权重的一些作用。</p><p><img src="../../images/image-20230208163704237.png" alt="image-20230208163704237"></p>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nacos-服务多级存储模式 &amp; 集群 &amp; 优先本地集群访问的负载均衡的实现</title>
      <link href="/2023/02/08/Nacos/Nacos-%E6%9C%8D%E5%8A%A1%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/"/>
      <url>/2023/02/08/Nacos/Nacos-%E6%9C%8D%E5%8A%A1%E5%A4%9A%E7%BA%A7%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>​之前我们有服务的概念，我们提供用户查询的userservice服务，还有提供订单查询的orderservice服务。然后，userservice还部署了多个实例，我们有8081 、8082、8083，这三个呢，都是userservice的实例，所以我们之前是有两层概念的，一层是服务，而第二层就是实例。一个服务，可以包含多个实例。不过呀，随着我们这个业务规模越来越扩大，那么我们就会考虑更多的问题了。比如说我们现在的，我们把所有的实力都部署在一个地方，就像你把鸡蛋都放在一个篮子里，哪天你不小心篮子翻了，那所有的鸡蛋不就都打碎了吗？**那你的机房放在那里同一个地方，哪天天灾人祸出了问题，整个服务不就完了？**所以呀，为了解决这个问l题，我们会将一个服务的多个实例部署到多个机房，特别是像阿里京东这些财大气粗的，哎，我给全国各地，上海、杭州、北京都整一个，这俩送到杭州，这俩到上海，再来几个给它扔到北京，这就像我们把鸡蛋分散开了，一个打了是不是还有好几栏儿呢，对不对？那这样呢，就能够做到一种叫容灾。而我们的那个服务分级存储模型，就是引入了这样一个机房的概念，或者叫地域的概念，把同在一个机房的多个实例称为一个集群。比如，杭州机房的两个userservice实例就称之为杭州的userservice集群，那北京的userservice实例就称为北京的userservice集群。所以呢，在Nacos的服务分级模型中啊，一级是服务，往下是集群，再往下是实例。</p><p>​**那为什么Nacos要引入这样的一个服务分级的？**我原来直接服务找实例不好吗？为什么要多加一个地域划分集群的一个概念？我们设想这么一种情况，比方说我有一个杭州的地方，里面有orderservice的集群，还有一个userservice集群，然后呢，我还有一个上海的地方，也是一样的配置，将来还有广东地方，这个北京地方等等。现在呢，我的orderservice需要访问userservice，那么它有两种选择，一种是在自己本地局域网内访问，另一种是去外边的机房访问。那你觉得他该选哪个呀？那不用说呀，肯定选本地啊，因为外边的野花不要采嘛。当然啦，还有更重要的原因，我们局域网内的访问呢，它的距离比较短，所以呢，速度比较快，延迟比较低，而你跨越了这种集群的访问，比如说你从杭州访问到广州或者北京，那么达到数百公里上千公里，那么这个时候延迟是非常高的，所以啊，在服务调用时，应该尽可能的去访问本地集群，只有在本地集群不可用的情况下，我们才会考虑去访问其集群。我们的Nacos引入这个集训概念，其实就是为了防止出现跨集群调用啊，尽可能的避免。</p><p><img src="../../images/image-20230208114620776.png" alt="image-20230208114620776"></p><p><img src="../../images/image-20230208114536926.png" alt="image-20230208114536926"></p><p><img src="../../images/image-20230208114842391.png" alt="image-20230208114842391"></p><p>演示：</p><p><img src="../../images/image-20230208115409758.png" alt="image-20230208115409758"></p><p><img src="../../images/image-20230208115731341.png" alt="image-20230208115731341"></p><p>然后去Nacos控制台就可以看到有两个集群，以及集群各自有的实例</p><p><img src="../../images/image-20230208115947584.png" alt="image-20230208115947584"></p><p><img src="../../images/image-20230208115826327.png" alt="image-20230208115826327"></p><p>orderservice想访问本地集群HZ中的userservice的那两个实例服务，那么首先就需要将orderservice也注册到HZ集群</p><p><img src="../../images/image-20230208120609913.png" alt="image-20230208120609913"></p><p><img src="../../images/image-20230208120553443.png" alt="image-20230208120553443"></p><p>到这个时候，如果orderservice去访问3次userservice服务时，userservice的三个实例都会被访问到，因为依然采用的是轮询的方式。服务在选择实例时的规则都是由负载均衡的规则来决定的，也就是Irule，因为还没有配置Irule，所以还是默认的轮询方式。所以要想实现优先同集群访问的这种负载均衡的规则，我们必须去修改负载均衡。</p><p><img src="../../images/image-20230208121356082.png" alt="image-20230208121356082"></p><p>在orderservice的yml配置文件中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">userservice: # 要做配置的微服务名称</span><br><span class="line">  ribbon:</span><br><span class="line">    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule  # 负载均衡规矩（优先同集群访问）</span><br></pre></td></tr></tbody></table></figure><p>这样之后，orderservice去访问多次userservice服务，就会发现都是访问的是8081、8082的实例（在idea的控制台可以看各实例日志，8083是没有日志输出的）。</p><ul><li><p>那么有一个问题，本地同集群的8081、8082两个实例的被访问的比例是怎么的呢？</p><ul><li>其实是随机的，NacosRule的一个特点，优先使用本地同集群，在集群内的多个服务当中再采用随机方式来负载均衡</li></ul></li><li><p>那么又有一个问题，如果我们把orderservice的同集群的userservice服务都停了，这样就只剩下不同集群的SH内的userservice实例，这个时候再去通过oerservice访问userservice时会怎样呢？</p></li></ul><p><img src="../../images/image-20230208122809011.png" alt="image-20230208122809011"></p><p><img src="../../images/image-20230208122900770.png" alt="image-20230208122900770"></p><p>这是orderservice去访问userservice就会去跨集群访问了，即访问到8083端口的实例。idea，看一下日志。我们发现，这次请求是8083给承担了，那在order当中会出现一个警告信息什么，显示一次跨集群访问发生了，谁呀？就是userservice，那么你想访问的是杭州，但是呢，实际上你访问的是上海。那通过这个啊，我们就知道了，NacosRule其实优先访问本地，本地没有，它才会跨境访问，跨域访问时，它会有一个警告，将来我们的运维人员如果看到了这样的警告信息，就能够清楚的知道发生了什么问题了，那么他就会及时的去重新启动我们的挂掉的服务，这样问题就能得到解决了</p><p><img src="../../images/image-20230208123816670.png" alt="image-20230208123816670"></p>]]></content>
      
      
      <categories>
          
          <category> Nacos </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-分析GC日志</title>
      <link href="/2023/02/06/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/5-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/"/>
      <url>/2023/02/06/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/5-%E5%88%86%E6%9E%90GC%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="5-分析-gc-日志"><a class="markdownIt-Anchor" href="#5-分析-gc-日志"></a> 5. 分析 GC 日志</h1><h2 id="51-gc-分类"><a class="markdownIt-Anchor" href="#51-gc-分类"></a> 5.1. GC 分类</h2><p>针对 HotSpot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（Full GC）</p><ul><li><p>部分收集（Partial GC）：不是完整收集整个 Java 堆的垃圾收集。其中又分为：</p><ul><li>新生代收集（Minor GC / Young GC）：只是新生代（Eden / S0, S1）的垃圾收集</li><li>老年代收集（Major GC / Old GC）：只是老年代的垃圾收集。目前，只有 CMS GC 会有单独收集老年代的行为。<mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li><p>混合收集（Mixed GC）：收集整个新生代以及部分老年代的垃圾收集。目前，只有 G1 GC 会有这种行为</p></li><li><p>整堆收集（Full GC）：收集整个 java 堆和方法区的垃圾收集。</p><ul><li>哪些情况会触发 Full GC ?<ul><li>老年代空间不足</li><li>方法区空间不足</li><li>显示调用System.gc()</li><li>Minor GC进入老年代的数据的平均大小 大于 老年代的可用内存</li><li>大对象直接进入老年代，而老年代的可用空间不足</li></ul></li></ul></li></ul><h2 id="52-gc-日志分类"><a class="markdownIt-Anchor" href="#52-gc-日志分类"></a> 5.2. GC 日志分类</h2><p><strong>MinorGC</strong></p><p>MinorGC（或 young GC 或 YGC）日志：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 31744K-&gt;2192K (36864K) ] 31744K-&gt;2200K (121856K), <span class="number">0.0139308</span> secs] [Times: user=<span class="number">0.05</span> sys=<span class="number">0.01</span>, real=<span class="number">0.01</span> secs]</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/df81757685ca21a927d9335273f561c5.png" alt="image-20210506202126562"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b9a7575380bcdb91b54c0556557d8ad9.png" alt="image-20210506202156090"></p><p><strong>FullGC</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen: 5104K-&gt;0K (132096K) ] [Par01dGen: 416K-&gt;5453K (50176K) ]5520K-&gt;5453K (182272K), [Metaspace: 20637K-&gt;20637K (1067008K) ], <span class="number">0.0245883</span> secs] [Times: user=<span class="number">0.06</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0dcb239f0928bc374ac1b376b4189295.png" alt="image-20210506202330868"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/7817f28a52c836d5ed08a4b992823f64.png" alt="image-20210506202349072"></p><h2 id="53-gc-日志结构剖析"><a class="markdownIt-Anchor" href="#53-gc-日志结构剖析"></a> 5.3. GC 日志结构剖析</h2><p><strong>透过日志看垃圾收集器</strong></p><ul><li><p>Serial 收集器：新生代显示 “[DefNew”，即 Default New Generation</p></li><li><p>ParNew 收集器：新生代显示 “[ParNew”，即 Parallel New Generation</p></li><li><p>Parallel Scavenge 收集器：新生代显示"[PSYoungGen"，JDK1.7 使用的即 PSYoungGen</p></li><li><p>Parallel Old 收集器：老年代显示"[ParoldGen"</p></li><li><p>G1 收集器：显示”garbage-first heap“</p></li></ul><p><strong>透过日志看 GC 原因</strong></p><ul><li>Allocation Failure：表明本次引起 GC 的原因是因为新生代中没有足够的区域存放需要分配的数据</li><li>Metadata GCThreshold：Metaspace 区不够用了</li><li>FErgonomics：JVM 自适应调整导致的 GC</li><li>System：调用了 System.gc()方法</li></ul><p><strong>透过日志看 GC 前后情况</strong></p><p>通过图示，我们可以发现 GC 日志格式的规律一般都是：GC 前内存占用-＞ GC 后内存占用（该区域内存总大小）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[PSYoungGen: 5986K-&gt;696K (8704K) ] 5986K-&gt;704K (9216K)</span><br></pre></td></tr></tbody></table></figure><ul><li><p>中括号内：GC 回收前年轻代堆大小，回收后大小，（年轻代堆总大小）</p></li><li><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li></ul><p><mark>注意</mark>：Minor GC 堆内存总容量 = 9/10 年轻代 + 老年代。原因是 Survivor 区只计算 from 部分，而 JVM 默认年轻代中 Eden 区和 Survivor 区的比例关系，Eden:S0:S1=8:1:1。</p><p><strong>透过日志看 GC 时间</strong></p><p>GC 日志中有三个时间：user，sys 和 real</p><ul><li>user：进程执行用户态代码（核心之外）所使用的时间。这是执行此进程所使用的实际 CPU 时间，其他进程和此进程阻塞的时间并不包括在内。在垃圾收集的情况下，表示 GC 线程执行所使用的 CPU 总时间。</li><li>sys：进程在内核态消耗的 CPU 时间，即在内核执行系统调用或等待系统事件所使用的 CPU 时间</li><li>real：程序从开始到结束所用的时钟时间。这个时间包括其他进程使用的时间片和进程阻塞的时间（比如等待 I/O 完成）。对于并行 gc，这个数字应该接近（用户时间＋系统时间）除以垃圾收集器使用的线程数。</li></ul><p>由于多核的原因，一般的 GC 事件中，real time 是小于 sys time ＋ user time 的，因为一般是多个线程并发的去做 GC，所以 real time 是要小于 sys ＋ user time 的。如果 real ＞ sys ＋ user 的话，则你的应用可能存在下列问题：IO 负载非常重或 CPU 不够用。</p><h2 id="54-gc-日志分析工具"><a class="markdownIt-Anchor" href="#54-gc-日志分析工具"></a> 5.4. GC 日志分析工具</h2><p><strong>GCEasy</strong></p><p>GCEasy 是一款在线的 GC 日志分析器，可以通过 GC 日志分析进行内存泄露检测、GC 暂停原因分析、JVM 配置建议优化等功能，大多数功能是免费的。</p><p>官网地址：<a href="https://gceasy.io/">https://gceasy.io/</a></p><p><strong>GCViewer</strong></p><p>GCViewer 是一款离线的 GC 日志分析器，用于可视化 Java VM 选项 -verbose:gc 和 .NET 生成的数据 -Xloggc:&lt;file&gt;。还可以计算与垃圾回收相关的性能指标（吞吐量、累积的暂停、最长的暂停等）。当通过更改世代大小或设置初始堆大小来调整特定应用程序的垃圾回收时，此功能非常有用。</p><p>源码下载：<a href="https://github.com/chewiebug/GCViewer">https://github.com/chewiebug/GCViewer</a></p><p>运行版本下载：<a href="https://github.com/chewiebug/GCViewer/wiki/Changelog">https://github.com/chewiebug/GCViewer/wiki/Changelog</a></p><p><strong>GChisto</strong></p><ul><li>官网上没有下载的地方，需要自己从 SVN 上拉下来编译</li><li>不过这个工具似乎没怎么维护了，存在不少 bug</li></ul><p><strong>HPjmeter</strong></p><ul><li>工具很强大，但是只能打开由以下参数生成的 GC log，-verbose:gc -Xloggc:gc.log。添加其他参数生成的 gc.log 无法打开</li><li>HPjmeter 集成了以前的 HPjtune 功能，可以分析在 HP 机器上产生的垃圾回收日志文件</li></ul>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-JVM运行时参数</title>
      <link href="/2023/02/06/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/4-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/"/>
      <url>/2023/02/06/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/4-JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="4-jvm-运行时参数"><a class="markdownIt-Anchor" href="#4-jvm-运行时参数"></a> 4. JVM 运行时参数</h1><h2 id="41-jvm-参数选项"><a class="markdownIt-Anchor" href="#41-jvm-参数选项"></a> 4.1. JVM 参数选项</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><h3 id="411-类型一标准参数选项"><a class="markdownIt-Anchor" href="#411-类型一标准参数选项"></a> 4.1.1. 类型一：标准参数选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java -<span class="built_in">help</span></span></span><br><span class="line">用法: java [-options] class [args...]</span><br><span class="line">           (执行类)</span><br><span class="line">   或  java [-options] -jar jarfile [args...]</span><br><span class="line">           (执行 jar 文件)</span><br><span class="line">其中选项包括:</span><br><span class="line">    -d32          使用 32 位数据模型 (如果可用)</span><br><span class="line">    -d64          使用 64 位数据模型 (如果可用)</span><br><span class="line">    -server       选择 "server" VM</span><br><span class="line">                  默认 VM 是 server.</span><br><span class="line"></span><br><span class="line">    -cp &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">    -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt;</span><br><span class="line">                  用 ; 分隔的目录, JAR 档案</span><br><span class="line">                  和 ZIP 档案列表, 用于搜索类文件。</span><br><span class="line">    -D&lt;名称&gt;=&lt;值&gt;</span><br><span class="line">                  设置系统属性</span><br><span class="line">    -verbose:[class|gc|jni]</span><br><span class="line">                  启用详细输出</span><br><span class="line">    -version      输出产品版本并退出</span><br><span class="line">    -version:&lt;值&gt;</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  需要指定的版本才能运行</span><br><span class="line">    -showversion  输出产品版本并继续</span><br><span class="line">    -jre-restrict-search | -no-jre-restrict-search</span><br><span class="line">                  警告: 此功能已过时, 将在</span><br><span class="line">                  未来发行版中删除。</span><br><span class="line">                  在版本搜索中包括/排除用户专用 JRE</span><br><span class="line">    -? -help      输出此帮助消息</span><br><span class="line">    -X            输出非标准选项的帮助</span><br><span class="line">    -ea[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  按指定的粒度启用断言</span><br><span class="line">    -da[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">    -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;]</span><br><span class="line">                  禁用具有指定粒度的断言</span><br><span class="line">    -esa | -enablesystemassertions</span><br><span class="line">                  启用系统断言</span><br><span class="line">    -dsa | -disablesystemassertions</span><br><span class="line">                  禁用系统断言</span><br><span class="line">    -agentlib:&lt;libname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof</span><br><span class="line">                  另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help</span><br><span class="line">    -agentpath:&lt;pathname&gt;[=&lt;选项&gt;]</span><br><span class="line">                  按完整路径名加载本机代理库</span><br><span class="line">    -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;]</span><br><span class="line">                  加载 Java 编程语言代理, 请参阅 java.lang.instrument</span><br><span class="line">    -splash:&lt;imagepath&gt;</span><br><span class="line">                  使用指定的图像显示启动屏幕</span><br><span class="line">有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。</span><br></pre></td></tr></tbody></table></figure><p><strong>Server 模式和 Client 模式</strong></p><p>Hotspot JVM 有两种模式，分别是 server 和 client，分别通过-server 和-client 模式设置</p><ul><li>32 位系统上，默认使用 Client 类型的 JVM。要想使用 Server 模式，机器配置至少有 2 个以上的 CPU 和 2G 以上的物理内存。client 模式适用于对内存要求较小的桌面应用程序，默认使用 Serial 串行垃圾收集器</li><li>64 位系统上，只支持 server 模式的 JVM，适用于需要大内存的应用程序，默认使用并行垃圾收集器</li></ul><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/server-class.html</a></p><p>如何知道系统默认使用的是那种模式呢？</p><p>通过 java -version 命令：可以看到 Server VM 字样，代表当前系统使用是 Server 模式</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java -version</span></span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></tbody></table></figure><h3 id="412-类型二-x-参数选项"><a class="markdownIt-Anchor" href="#412-类型二-x-参数选项"></a> 4.1.2. 类型二：-X 参数选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">java -X</span></span><br><span class="line">    -Xmixed           混合模式执行 (默认)</span><br><span class="line">    -Xint             仅解释模式执行</span><br><span class="line">    -Xbootclasspath:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      设置搜索路径以引导类和资源</span><br><span class="line">    -Xbootclasspath/a:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      附加在引导类路径末尾</span><br><span class="line">    -Xbootclasspath/p:&lt;用 ; 分隔的目录和 zip/jar 文件&gt;</span><br><span class="line">                      置于引导类路径之前</span><br><span class="line">    -Xdiag            显示附加诊断消息</span><br><span class="line">    -Xnoclassgc       禁用类垃圾收集</span><br><span class="line">    -Xincgc           启用增量垃圾收集</span><br><span class="line">    -Xloggc:&lt;file&gt;    将 GC 状态记录在文件中 (带时间戳)</span><br><span class="line">    -Xbatch           禁用后台编译</span><br><span class="line">    -Xms&lt;size&gt;        设置初始 Java 堆大小</span><br><span class="line">    -Xmx&lt;size&gt;        设置最大 Java 堆大小</span><br><span class="line">    -Xss&lt;size&gt;        设置 Java 线程堆栈大小</span><br><span class="line">    -Xprof            输出 cpu 配置文件数据</span><br><span class="line">    -Xfuture          启用最严格的检查, 预期将来的默认值</span><br><span class="line">    -Xrs              减少 Java/VM 对操作系统信号的使用 (请参阅文档)</span><br><span class="line">    -Xcheck:jni       对 JNI 函数执行其他检查</span><br><span class="line">    -Xshare:off       不尝试使用共享类数据</span><br><span class="line">    -Xshare:auto      在可能的情况下使用共享类数据 (默认)</span><br><span class="line">    -Xshare:on        要求使用共享类数据, 否则将失败。</span><br><span class="line">    -XshowSettings    显示所有设置并继续</span><br><span class="line">    -XshowSettings:all</span><br><span class="line">                      显示所有设置并继续</span><br><span class="line">    -XshowSettings:vm 显示所有与 vm 相关的设置并继续</span><br><span class="line">    -XshowSettings:properties</span><br><span class="line">                      显示所有属性设置并继续</span><br><span class="line">    -XshowSettings:locale</span><br><span class="line">                      显示所有与区域设置相关的设置并继续</span><br><span class="line"></span><br><span class="line">-X 选项是非标准选项, 如有更改, 恕不另行通知。</span><br></pre></td></tr></tbody></table></figure><p>如何知道 JVM 默认使用的是混合模式呢？</p><p>同样地，通过 java -version 命令：可以看到 mixed mode 字样，代表当前系统使用的是混合模式</p><h3 id="413-类型三-xx-参数选项"><a class="markdownIt-Anchor" href="#413-类型三-xx-参数选项"></a> 4.1.3. 类型三：-XX 参数选项</h3><p><strong>Boolean 类型格式</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+&lt;option&gt;  启用option属性</span><br><span class="line">-XX:-&lt;option&gt;  禁用option属性</span><br></pre></td></tr></tbody></table></figure><p><strong>非 Boolean 类型格式</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:&lt;option&gt;=&lt;number&gt;  设置option数值，可以带单位如k/K/m/M/g/G</span><br><span class="line">-XX:&lt;option&gt;=&lt;string&gt;  设置option字符值</span><br></pre></td></tr></tbody></table></figure><h2 id="42-添加-jvm-参数选项"><a class="markdownIt-Anchor" href="#42-添加-jvm-参数选项"></a> 4.2. 添加 JVM 参数选项</h2><p>eclipse 和 idea 中配置不必多说，在 Run Configurations 中 VM Options 中配置即可，大同小异</p><p><strong>运行 jar 包</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms100m -Xmx100m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -jar demo.jar</span><br></pre></td></tr></tbody></table></figure><p><strong>Tomcat 运行 war 包</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">linux下catalina.sh添加</span></span><br><span class="line">JAVA_OPTS="-Xms512M -Xmx1024M"</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">windows下catalina.bat添加</span></span><br><span class="line">set "JAVA_OPTS=-Xms512M -Xmx1024M"</span><br></pre></td></tr></tbody></table></figure><p><strong>程序运行中</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置Boolean类型参数</span></span><br><span class="line">jinfo -flag [+|-]&lt;name&gt; &lt;pid&gt;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置非Boolean类型参数</span></span><br><span class="line">jinfo -flag &lt;name&gt;=&lt;value&gt; &lt;pid&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="43-常用的-jvm-参数选项"><a class="markdownIt-Anchor" href="#43-常用的-jvm-参数选项"></a> 4.3. 常用的 JVM 参数选项</h2><h3 id="431-打印设置的-xx-选项及值"><a class="markdownIt-Anchor" href="#431-打印设置的-xx-选项及值"></a> 4.3.1. 打印设置的 XX 选项及值</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintCommandLineFlags 程序运行时JVM默认设置或用户手动设置的XX选项</span><br><span class="line">-XX:+PrintFlagsInitial 打印所有XX选项的默认值</span><br><span class="line">-XX:+PrintFlagsFinal 打印所有XX选项的实际值</span><br><span class="line">-XX:+PrintVMOptions 打印JVM的参数</span><br></pre></td></tr></tbody></table></figure><h3 id="432-堆-栈-方法区等内存大小设置"><a class="markdownIt-Anchor" href="#432-堆-栈-方法区等内存大小设置"></a> 4.3.2. 堆、栈、方法区等内存大小设置</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">栈</span></span><br><span class="line">-Xss128k &lt;==&gt; -XX:ThreadStackSize=128k 设置线程栈的大小为128K</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">堆</span></span><br><span class="line">-Xms2048m &lt;==&gt; -XX:InitialHeapSize=2048m 设置JVM初始堆内存为2048M</span><br><span class="line">-Xmx2048m &lt;==&gt; -XX:MaxHeapSize=2048m 设置JVM最大堆内存为2048M</span><br><span class="line">-Xmn2g &lt;==&gt; -XX:NewSize=2g -XX:MaxNewSize=2g 设置年轻代大小为2G</span><br><span class="line">-XX:SurvivorRatio=8 设置Eden区与Survivor区的比值，默认为8</span><br><span class="line">-XX:NewRatio=2 设置老年代与年轻代的比例，默认为2</span><br><span class="line">-XX:+UseAdaptiveSizePolicy 设置大小比例自适应，默认开启</span><br><span class="line">-XX:PretenureSizeThreadshold=1024 设置让大于此阈值的对象直接分配在老年代，只对Serial、ParNew收集器有效</span><br><span class="line">-XX:MaxTenuringThreshold=15 设置新生代晋升老年代的年龄限制，默认为15</span><br><span class="line">-XX:TargetSurvivorRatio 设置MinorGC结束后Survivor区占用空间的期望比例</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方法区</span></span><br><span class="line">-XX:MetaspaceSize / -XX:PermSize=256m 设置元空间/永久代初始值为256M</span><br><span class="line">-XX:MaxMetaspaceSize / -XX:MaxPermSize=256m 设置元空间/永久代最大值为256M</span><br><span class="line">-XX:+UseCompressedOops 使用压缩对象</span><br><span class="line">-XX:+UseCompressedClassPointers 使用压缩类指针</span><br><span class="line">-XX:CompressedClassSpaceSize 设置Klass Metaspace的大小，默认1G</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">直接内存</span></span><br><span class="line">-XX:MaxDirectMemorySize 指定DirectMemory容量，默认等于Java堆最大值</span><br></pre></td></tr></tbody></table></figure><h3 id="433-outofmemory-相关的选项"><a class="markdownIt-Anchor" href="#433-outofmemory-相关的选项"></a> 4.3.3. OutOfMemory 相关的选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutMemoryError 内存出现OOM时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:+HeapDumpBeforeFullGC 出现FullGC时生成Heap转储文件，两者互斥</span><br><span class="line">-XX:HeapDumpPath=&lt;path&gt; 指定heap转储文件的存储路径，默认当前目录</span><br><span class="line">-XX:OnOutOfMemoryError=&lt;path&gt; 指定可行性程序或脚本的路径，当发生OOM时执行脚本</span><br></pre></td></tr></tbody></table></figure><h3 id="434-垃圾收集器相关选项"><a class="markdownIt-Anchor" href="#434-垃圾收集器相关选项"></a> 4.3.4. 垃圾收集器相关选项</h3><p>首先需了解垃圾收集器之间的搭配使用关系</p><ul><li>红色虚线表示在 jdk8 时被 Deprecate，jdk9 时被删除</li><li>绿色虚线表示在 jdk14 时被 Deprecate</li><li>绿色虚框表示在 jdk9 时被 Deprecate，jdk14 时被删除</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/46dec5b346fcc5b147491481787ea8ec.png" alt="image-20210506182458663"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Serial回收器</span></span><br><span class="line">-XX:+UseSerialGC  年轻代使用Serial GC， 老年代使用Serial Old GC</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">ParNew回收器</span></span><br><span class="line">-XX:+UseParNewGC  年轻代使用ParNew GC</span><br><span class="line">-XX:ParallelGCThreads  设置年轻代并行收集器的线程数。</span><br><span class="line">一般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。</span><br></pre></td></tr></tbody></table></figure><p class="katex-block"><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><mi>a</mi><mi>r</mi><mi>a</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>l</mi><mi>G</mi><mi>C</mi><mi>T</mi><mi>h</mi><mi>r</mi><mi>e</mi><mi>a</mi><mi>d</mi><mi>s</mi><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.3599999999999999em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>(</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&lt;</mo><mo>=</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>3</mn><mo>+</mo><mo stretchy="false">(</mo><mn>5</mn><mo>∗</mo><mi>C</mi><mi>P</mi><mi>U</mi><mtext>＿</mtext><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">/</mi><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>(</mtext><mi>C</mi><mi>P</mi><mi>U</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>t</mi><mo>&gt;</mo><mn>8</mn><mo stretchy="false">)</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">ParallelGCThreads =\begin{cases}CPU\_Count &amp; \text (CPU\_Count &lt;= 8) \\3 + (5 * CPU＿Count / 8) &amp; \text (CPU\_Count &gt; 8)\end{cases}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">G</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">h</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal">a</span><span class="mord mathnormal">d</span><span class="mord mathnormal">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0000299999999998em;vertical-align:-1.25003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mopen">(</span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord cjk_fallback">＿</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord">/</span><span class="mord">8</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">(</span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">(</span></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">o</span><span class="mord mathnormal">u</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">8</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Parallel回收器</span></span><br><span class="line">-XX:+UseParallelGC  年轻代使用 Parallel Scavenge GC，互相激活</span><br><span class="line">-XX:+UseParallelOldGC  老年代使用 Parallel Old GC，互相激活</span><br><span class="line">-XX:ParallelGCThreads</span><br><span class="line">-XX:MaxGCPauseMillis  设置垃圾收集器最大停顿时间（即STW的时间），单位是毫秒。</span><br><span class="line">为了尽可能地把停顿时间控制在MaxGCPauseMills以内，收集器在工作时会调整Java堆大小或者其他一些参数。</span><br><span class="line">对于用户来讲，停顿时间越短体验越好；但是服务器端注重高并发，整体的吞吐量。</span><br><span class="line">所以服务器端适合Parallel，进行控制。该参数使用需谨慎。</span><br><span class="line">-XX:GCTimeRatio  垃圾收集时间占总时间的比例（1 / (N＋1)），用于衡量吞吐量的大小</span><br><span class="line">取值范围（0,100），默认值99，也就是垃圾回收时间不超过1％。</span><br><span class="line">与前一个-XX：MaxGCPauseMillis参数有一定矛盾性。暂停时间越长，Radio参数就容易超过设定的比例。</span><br><span class="line">-XX:+UseAdaptiveSizePolicy  设置Parallel Scavenge收集器具有自适应调节策略。</span><br><span class="line">在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，以达到在堆大小、吞吐量和停顿时间之间的平衡点。</span><br><span class="line">在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（GCTimeRatio）和停顿时间（MaxGCPauseMills），让虚拟机自己完成调优工作。</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">CMS回收器</span></span><br><span class="line">-XX:+UseConcMarkSweepGC  年轻代使用CMS GC。</span><br><span class="line">开启该参数后会自动将-XX：＋UseParNewGC打开。即：ParNew（Young区）+ CMS（Old区）+ Serial Old的组合</span><br><span class="line">-XX:CMSInitiatingOccupanyFraction  设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。JDK5及以前版本的默认值为68，DK6及以上版本默认值为92％。</span><br><span class="line">如果内存增长缓慢，则可以设置一个稍大的值，大的阈值可以有效降低CMS的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。</span><br><span class="line">反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。</span><br><span class="line">因此通过该选项便可以有效降低Fu1l GC的执行次数。</span><br><span class="line">-XX:+UseCMSInitiatingOccupancyOnly  是否动态可调，使CMS一直按CMSInitiatingOccupancyFraction设定的值启动</span><br><span class="line">-XX:+UseCMSCompactAtFullCollection  用于指定在执行完Full GC后对内存空间进行压缩整理</span><br><span class="line">以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</span><br><span class="line">-XX:CMSFullGCsBeforeCompaction  设置在执行多少次Full GC后对内存空间进行压缩整理。</span><br><span class="line">-XX:ParallelCMSThreads  设置CMS的线程数量。</span><br><span class="line">CMS 默认启动的线程数是(ParallelGCThreads＋3)/4，ParallelGCThreads 是年轻代并行收集器的线程数。</span><br><span class="line">当CPU 资源比较紧张时，受到CMS收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</span><br><span class="line">-XX:ConcGCThreads  设置并发垃圾收集的线程数，默认该值是基于ParallelGCThreads计算出来的</span><br><span class="line">-XX:+CMSScavengeBeforeRemark  强制hotspot在cms remark阶段之前做一次minor gc，用于提高remark阶段的速度</span><br><span class="line">-XX:+CMSClassUnloadingEnable  如果有的话，启用回收Perm 区（JDK8之前）</span><br><span class="line">-XX:+CMSParallelInitialEnabled  用于开启CMS initial-mark阶段采用多线程的方式进行标记</span><br><span class="line">用于提高标记速度，在Java8开始已经默认开启</span><br><span class="line">-XX:+CMSParallelRemarkEnabled  用户开启CMS remark阶段采用多线程的方式进行重新标记，默认开启</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrent</span><br><span class="line">-XX:+ExplicitGCInvokesConcurrentAndUnloadsClasses</span><br><span class="line">这两个参数用户指定hotspot虚拟在执行System.gc()时使用CMS周期</span><br><span class="line">-XX:+CMSPrecleaningEnabled  指定CMS是否需要进行Pre cleaning阶段</span><br></pre></td></tr></tbody></table></figure><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">G1回收器</span></span><br><span class="line">-XX:+UseG1GC 手动指定使用G1收集器执行内存回收任务。</span><br><span class="line">-XX:G1HeapRegionSize 设置每个Region的大小。</span><br><span class="line">值是2的幂，范围是1MB到32MB之间，目标是根据最小的Java堆大小划分出约2048个区域。默认是堆内存的1/2000。</span><br><span class="line">-XX:MaxGCPauseMillis  设置期望达到的最大GC停顿时间指标（JVM会尽力实现，但不保证达到）。默认值是200ms</span><br><span class="line">-XX:ParallelGCThread  设置STW时GC线程数的值。最多设置为8</span><br><span class="line">-XX:ConcGCThreads  设置并发标记的线程数。将n设置为并行垃圾回收线程数（ParallelGCThreads）的1/4左右。</span><br><span class="line">-XX:InitiatingHeapOccupancyPercent 设置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是45。</span><br><span class="line">-XX:G1NewSizePercent  新生代占用整个堆内存的最小百分比（默认5％）</span><br><span class="line">-XX:G1MaxNewSizePercent  新生代占用整个堆内存的最大百分比（默认60％）</span><br><span class="line">-XX:G1ReservePercent=10  保留内存区域，防止 to space（Survivor中的to区）溢出</span><br></pre></td></tr></tbody></table></figure><p>怎么选择垃圾回收器？</p><ul><li>优先让 JVM 自适应，调整堆的大小</li><li>串行收集器：内存小于 100M；单核、单机程序，并且没有停顿时间的要求</li><li>并行收集器：多 CPU、高吞吐量、允许停顿时间超过 1 秒</li><li>并发收集器：多 CPU、追求低停顿时间、快速响应（比如延迟不能超过 1 秒，如互联网应用）</li><li>官方推荐 G1，性能高。现在互联网的项目，基本都是使用 G1</li></ul><p>特别说明：</p><ul><li>没有最好的收集器，更没有万能的收集器</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ul><h3 id="435-gc-日志相关选项"><a class="markdownIt-Anchor" href="#435-gc-日志相关选项"></a> 4.3.5. GC 日志相关选项</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-XX:+PrintGC &lt;==&gt; -verbose:gc  打印简要日志信息</span><br><span class="line">-XX:+PrintGCDetails            打印详细日志信息</span><br><span class="line">-XX:+PrintGCTimeStamps  打印程序启动到GC发生的时间，需搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintGCDateStamps  打印GC发生时的时间戳，需搭配-XX:+PrintGCDetails使用</span><br><span class="line">-XX:+PrintHeapAtGC  打印GC前后的堆信息</span><br><span class="line">-Xloggc:&lt;file&gt; 输出GC导指定路径下的文件中</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230206151342924.png" alt="image-20230206151342924"></p><p><img src="../../../images/image-20230206151534449.png" alt="image-20230206151534449"></p><p><img src="../../../images/image-20230206151617469.png" alt="image-20230206151617469"></p><p><img src="../../../images/image-20230206151728817.png" alt="image-20230206151728817"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f323dd9b55235ed0a33e6a0af8adbca.png" alt="image-20210506195156935"></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+TraceClassLoading  监控类的加载</span><br><span class="line">-XX:+PrintGCApplicationStoppedTime  打印GC时线程的停顿时间</span><br><span class="line">-XX:+PrintGCApplicationConcurrentTime  打印垃圾收集之前应用未中断的执行时间</span><br><span class="line">-XX:+PrintReferenceGC 打印回收了多少种不同引用类型的引用</span><br><span class="line">-XX:+PrintTenuringDistribution  打印JVM在每次MinorGC后当前使用的Survivor中对象的年龄分布</span><br><span class="line">-XX:+UseGCLogFileRotation 启用GC日志文件的自动转储</span><br><span class="line">-XX:NumberOfGCLogFiles=1  设置GC日志文件的循环数目</span><br><span class="line">-XX:GCLogFileSize=1M  设置GC日志文件的大小</span><br></pre></td></tr></tbody></table></figure><h3 id="436-其他参数"><a class="markdownIt-Anchor" href="#436-其他参数"></a> 4.3.6. 其他参数</h3><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-XX:+DisableExplicitGC  禁用hotspot执行System.gc()，默认禁用</span><br><span class="line">-XX:ReservedCodeCacheSize=&lt;n&gt;[g|m|k]、-XX:InitialCodeCacheSize=&lt;n&gt;[g|m|k]  指定代码缓存的大小</span><br><span class="line">-XX:+UseCodeCacheFlushing  放弃一些被编译的代码，避免代码缓存被占满时JVM切换到interpreted-only的情况</span><br><span class="line">-XX:+DoEscapeAnalysis  开启逃逸分析</span><br><span class="line">-XX:+UseBiasedLocking  开启偏向锁</span><br><span class="line">-XX:+UseLargePages  开启使用大页面</span><br><span class="line">-XX:+PrintTLAB  打印TLAB的使用情况</span><br><span class="line">-XX:TLABSize  设置TLAB大小</span><br></pre></td></tr></tbody></table></figure><h2 id="44-通过-java-代码获取-jvm-参数"><a class="markdownIt-Anchor" href="#44-通过-java-代码获取-jvm-参数"></a> 4.4. 通过 Java 代码获取 JVM 参数</h2><p>Java 提供了 java.lang.management 包用于监视和管理 Java 虚拟机和 Java 运行时中的其他组件，它允许本地或远程监控和管理运行的 Java 虚拟机。其中 ManagementFactory 类较为常用，另外 Runtime 类可获取内存、CPU 核数等相关的数据。通过使用这些 api，可以监控应用服务器的堆内存使用情况，设置一些阈值进行报警等处理。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryMonitor</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">MemoryMXBean</span> <span class="variable">memorymbean</span> <span class="operator">=</span> ManagementFactory.getMemoryMXBean();</span><br><span class="line">        <span class="type">MemoryUsage</span> <span class="variable">usage</span> <span class="operator">=</span> memorymbean.getHeapMemoryUsage();</span><br><span class="line">        System.out.println(<span class="string">"INIT HEAP: "</span> + usage.getInit() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"MAX HEAP: "</span> + usage.getMax() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"USE HEAP: "</span> + usage.getUsed() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);</span><br><span class="line">        System.out.println(<span class="string">"\nFull Information:"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Heap Memory Usage: "</span> + memorymbean.getHeapMemoryUsage());</span><br><span class="line">        System.out.println(<span class="string">"Non-Heap Memory Usage: "</span> + memorymbean.getNonHeapMemoryUsage());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=======================通过java来获取相关系统状态============================ "</span>);</span><br><span class="line">        System.out.println(<span class="string">"当前堆内存大小totalMemory "</span> + (<span class="type">int</span>) Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 当前堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">"空闲堆内存大小freeMemory "</span> + (<span class="type">int</span>) Runtime.getRuntime().freeMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 空闲堆内存大小</span></span><br><span class="line">        System.out.println(<span class="string">"最大可用总堆内存maxMemory "</span> + Runtime.getRuntime().maxMemory() / <span class="number">1024</span> / <span class="number">1024</span> + <span class="string">"m"</span>);<span class="comment">// 最大可用总堆内存大小</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件机制</title>
      <link href="/2023/02/04/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%88%B6/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/02/04/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%88%B6/%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一-一个实例"><a class="markdownIt-Anchor" href="#一-一个实例"></a> 一、一个实例</h2><p>假设你在你家客厅里玩游戏，口渴了，需要到厨房开一壶水，等水开了的时候，为了防止水熬干，你需要及时把火炉关掉。为了及时了解到水是否烧开，你有三种策略可以选择：</p><ol><li>守在厨房内，等水烧开</li></ol><p>这种策略显然是很愚蠢的，采取这种策略，在烧水的过程中你将不能做任何事情，效率极低。</p><ol start="2"><li>呆在客厅玩游戏，每隔一两分钟跑到厨房看一次</li></ol><p>这种策略，在计算机科学中称为轮询，即每隔一定的时间，监测一次。在这里，也是很不明智的，在玩游戏时需要不断的分心。</p><ol start="3"><li>在水壶上安装一个报警器，当水开了的时候，发出警报</li></ol><p>这种策略是最好的，既不耽误自己玩游戏，又能在水开了的时候使自己及时获得通知。这种策略在计算机中通过事件机制来实现。</p><p><img src="https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517142552230-833134027.png" alt="img"></p><h2 id="二-事件机制的组成"><a class="markdownIt-Anchor" href="#二-事件机制的组成"></a> 二、事件机制的组成</h2><p>通过上面的实例，我们可以抽象出一个事件机制有三个组成部分：</p><p>1.<strong>事件源</strong>：即事件的发送者，在上例中为水壶；</p><p>2.<strong>事件</strong>：事件源发出的一种信息或状态，比如上例的警报声，它代表着水开了；</p><p>3.<strong>事件侦听者</strong>：对事件作出反应的对象，比如上例中的你。在设计事件机制时一般把侦听者设计为一个函数，当事件发送时，调用此函数。比如上例中可以把倒水设计为侦听者。</p><p><img src="https://img2018.cnblogs.com/blog/1193092/201905/1193092-20190517142628632-113995479.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 零碎知识&amp;笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎知识&amp;笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）4-优化与源码</title>
      <link href="/2023/02/01/Netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/"/>
      <url>/2023/02/01/Netty/Netty04-%E4%BC%98%E5%8C%96%E4%B8%8E%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="四-优化与源码"><a class="markdownIt-Anchor" href="#四-优化与源码"></a> 四. 优化与源码</h1><h2 id="1-优化"><a class="markdownIt-Anchor" href="#1-优化"></a> 1. 优化</h2><h3 id="11-扩展序列化算法"><a class="markdownIt-Anchor" href="#11-扩展序列化算法"></a> 1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p><ul><li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li><li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li></ul><p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class="line"><span class="type">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></tbody></table></figure><p>为了支持更多序列化算法，抽象一个 Serializer 接口</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> {</span><br><span class="line"><span class="comment">// Java 实现</span></span><br><span class="line">    Java {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            } <span class="keyword">catch</span> (IOException | ClassNotFoundException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"SerializerAlgorithm.Java 反序列化错误"</span>, e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"SerializerAlgorithm.Java 序列化错误"</span>, e);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> {</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">"超过 SerializerAlgorithm 范围"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>增加配置类和配置文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Config</span> {</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">"/application.properties"</span>)) {</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServerPort</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">"server.port"</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.Algorithm <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">"serializer.algorithm"</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>配置文件</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">serializer.algorithm</span>=<span class="string">Json</span></span><br></pre></td></tr></tbody></table></figure><p>修改编解码器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerAlgorithm</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0 或 1</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.<span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug("{}, {}, {}, {}, {}, {}", magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug("{}", message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageType 消息类型字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息 class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; getMessageClass(<span class="type">int</span> messageType) {</span><br><span class="line">        <span class="keyword">return</span> messageClasses.get(messageType);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sequenceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LoginRequestMessage</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LoginResponseMessage</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ChatRequestMessage</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ChatResponseMessage</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupCreateRequestMessage</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupCreateResponseMessage</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupJoinRequestMessage</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupJoinResponseMessage</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupQuitRequestMessage</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupQuitResponseMessage</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupChatRequestMessage</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupChatResponseMessage</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupMembersRequestMessage</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupMembersResponseMessage</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PingMessage</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PongMessage</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt;&gt; messageClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class="line">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class="line">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="12-参数调优"><a class="markdownIt-Anchor" href="#12-参数调优"></a> 1.2 参数调优</h3><h4 id="1connect_timeout_millis"><a class="markdownIt-Anchor" href="#1connect_timeout_millis"></a> 1）CONNECT_TIMEOUT_MILLIS</h4><ul><li>属于 SocketChannal 参数</li><li>用在<strong>客户端</strong>建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间（但是对于netty来说是不需要的，因为netty中的accept、read是非阻塞的）</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionTimeout</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync(); <span class="comment">// 断点1</span></span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">"timeout"</span>);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> {</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) {</span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {                </span><br><span class="line">                <span class="type">ChannelPromise</span> <span class="variable">connectPromise</span> <span class="operator">=</span> AbstractNioChannel.<span class="built_in">this</span>.connectPromise;</span><br><span class="line">                <span class="type">ConnectTimeoutException</span> <span class="variable">cause</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConnectTimeoutException</span>(<span class="string">"connection timed out: "</span> + remoteAddress); <span class="comment">// 断点2</span></span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) {</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2so_backlog"><a class="markdownIt-Anchor" href="#2so_backlog"></a> 2）SO_BACKLOG</h4><ul><li>属于 ServerSocketChannal 参数</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line"></span><br><span class="line">participant c as client</span><br><span class="line">participant s as server</span><br><span class="line">participant sq as syns queue</span><br><span class="line">participant aq as accept queue</span><br><span class="line"></span><br><span class="line">s -&gt;&gt; s : bind()</span><br><span class="line">s -&gt;&gt; s : listen()</span><br><span class="line">c -&gt;&gt; c : connect()</span><br><span class="line">c -&gt;&gt; s : 1. SYN</span><br><span class="line">Note left of c : SYN_SEND</span><br><span class="line">s -&gt;&gt; sq : put</span><br><span class="line">Note right of s : SYN_RCVD</span><br><span class="line">s -&gt;&gt; c : 2. SYN + ACK</span><br><span class="line">Note left of c : ESTABLISHED</span><br><span class="line">c -&gt;&gt; s : 3. ACK</span><br><span class="line">sq -&gt;&gt; aq : put</span><br><span class="line">Note right of s : ESTABLISHED</span><br><span class="line">aq --&gt;&gt; s : </span><br><span class="line">s -&gt;&gt; s : accept()</span><br></pre></td></tr></tbody></table></figure><ol><li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li><li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li><li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求<strong>从 sync queue 放入 accept queue</strong> （完成了三次握手才会进入 accept queue）</li></ol><p><strong>ps :</strong> 三次握手是发生在accept之前的。为什么第三次握手成功后不直接拿去用而是将请求从sync queue当如到 accept queue中呢，是因为服务器端进行accept的能力是有限的，比如客户端连接量特别大，accept就可能忙不过来了，这时就需要将已经完成三次握手的建立成功的信息放入到全连接队列中，服务器就可以从容不迫地accept了。</p><p>其中</p><ul><li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p></li><li><p><strong>sync queue - 半连接队列</strong></p><ul><li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li><p><strong>accept queue - 全连接队列</strong></p><ul><li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><p>netty 中</p><p>可以通过 .option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p><p>可以通过下面源码查看默认大小</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title class_">DefaultChannelConfig</span></span><br><span class="line">                                              <span class="keyword">implements</span> <span class="title class_">ServerSocketChannelConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">backlog</span> <span class="operator">=</span> NetUtil.SOMAXCONN;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><p>oio 中更容易说明，不用 debug 模式</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        System.out.println(accept);</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端启动 4 个</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">" connecting..."</span>);</span><br><span class="line">            s.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8888</span>),<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">" connected..."</span>);</span><br><span class="line">            s.getOutputStream().write(<span class="number">1</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">" connecting timeout..."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connecting...</span><br><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connected...</span><br></pre></td></tr></tbody></table></figure><p>第 4 个客户端连接时</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class="line">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class="line">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></tbody></table></figure><p>查看某一变量的默认值的思路：</p><p>笔记：find usage可查看变量在什么地方被引用 ，然后沿着这个变量的赋值量去找到它初始赋值的位置，Idea右侧光亮处表示当前被选中的变量被使用</p><h4 id="3ulimit-n-允许一个进程能够同时打开文件描述符的数量"><a class="markdownIt-Anchor" href="#3ulimit-n-允许一个进程能够同时打开文件描述符的数量"></a> 3）ulimit -n  （允许一个进程能够同时打开文件描述符的数量）</h4><ul><li>属于操作系统参数（这是在linux系统中配置的）</li></ul><h4 id="4tcp_nodelay"><a class="markdownIt-Anchor" href="#4tcp_nodelay"></a> 4）TCP_NODELAY  （）</h4><ul><li>属于 SocketChannal 参数</li></ul><h4 id="5so_sndbuf-so_rcvbuf"><a class="markdownIt-Anchor" href="#5so_sndbuf-so_rcvbuf"></a> 5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul><li>SO_SNDBUF 属于 SocketChannal 参数</li><li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li></ul><h4 id="6allocator"><a class="markdownIt-Anchor" href="#6allocator"></a> 6）ALLOCATOR</h4><ul><li>属于 SocketChannal 参数</li><li>用来分配 ByteBuf， ctx.alloc()</li></ul><h4 id="7rcvbuf_allocator"><a class="markdownIt-Anchor" href="#7rcvbuf_allocator"></a> 7）RCVBUF_ALLOCATOR</h4><ul><li>属于 SocketChannal 参数</li><li>控制 netty 接收缓冲区大小</li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li></ul><h3 id="13-rpc-框架"><a class="markdownIt-Anchor" href="#13-rpc-框架"></a> 1.3 RPC 框架</h3><h4 id="1准备工作"><a class="markdownIt-Anchor" href="#1准备工作"></a> 1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p><p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略旧的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RPC_MESSAGE_TYPE_REQUEST</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RPC_MESSAGE_TYPE_RESPONSE</span> <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>请求消息</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcRequestMessage</span><span class="params">(<span class="type">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> {</span><br><span class="line">        <span class="built_in">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="built_in">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">        <span class="built_in">this</span>.returnType = returnType;</span><br><span class="line">        <span class="built_in">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="built_in">this</span>.parameterValue = parameterValue;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>响应消息</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>服务器架子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 请求消息处理器，待实现</span></span><br><span class="line">        <span class="type">RpcRequestMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequestMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"server error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端架子</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 响应消息处理器，待实现</span></span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>服务器端的 service 获取</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServicesFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">"/application.properties"</span>)) {</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) {</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">"Service"</span>)) {</span><br><span class="line">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class="line">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class="line">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getService</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> {</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(interfaceClass);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>相关配置 application.properties</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serializer.algorithm=Json</span><br><span class="line">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></tbody></table></figure><h4 id="2服务器-handler"><a class="markdownIt-Anchor" href="#2服务器-handler"></a> 2）服务器 handler</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcRequestMessage&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> {</span><br><span class="line">        <span class="type">RpcResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessage</span>();</span><br><span class="line">        response.setSequenceId(message.getSequenceId());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 获取真正的实现对象</span></span><br><span class="line">            <span class="type">HelloService</span> <span class="variable">service</span> <span class="operator">=</span> (HelloService)</span><br><span class="line">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取要调用的方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(service, message.getParameterValue());</span><br><span class="line">            <span class="comment">// 调用成功</span></span><br><span class="line">            response.setReturnValue(invoke);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 调用异常</span></span><br><span class="line">            response.setExceptionValue(e);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3客户端代码第一版"><a class="markdownIt-Anchor" href="#3客户端代码第一版"></a> 3）客户端代码第一版</h4><p>只发消息</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">RpcRequestMessage</span>(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"cn.itcast.server.service.HelloService"</span>,</span><br><span class="line">               <span class="comment">//  cn.itcast.server.service.HelloService</span></span><br><span class="line">                    <span class="string">"sayHello"</span>,</span><br><span class="line">                    String.class,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]{String.class},</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]{<span class="string">"张三"</span>}</span><br><span class="line">            )).addListener(promise -&gt; {</span><br><span class="line">                <span class="keyword">if</span> (!promise.isSuccess()) {</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> promise.cause();</span><br><span class="line">                    log.error(<span class="string">"error"</span>, cause);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>理一下流程：</p><ol><li>客户端发送请求消息，请求消息就找到 Pipeline 中的出战处理器，从下向上依次执行，比如这里只有两个出战处理器，先通过 MESSAGE_CODEC处理器 对请求消息进行编码，然后记录日志，最后请求消息就发出去了</li></ol><p><img src="../../images/image-20230203121037606.png" alt="image-20230203121037606"></p><ol start="2"><li>消息发出之后，服务器端就拿到消息，就进行入站处理，做半包、黏包处理，记录日志，消息解码，最后交给RPC的请求handler</li></ol><p><img src="../../images/image-20230203121457206.png" alt="image-20230203121457206"></p><ol start="3"><li>拿到rpc请求消息之后，根据消息信息得到接口，根据接口再得到真的实现对象；找到要调用的方法；然后反射进行调用；最后根据成功还是异常来将结果放入response响应消息中，响应消息通过ctx来返回。</li></ol><p><img src="../../images/image-20230203122403827.png" alt="image-20230203122403827"></p><ol start="4"><li>响应消息又会经过服务器端的出战处理，经过消息编码，记录日志，然后发给客户端</li></ol><p><img src="../../images/image-20230203122727101.png" alt="image-20230203122727101"></p><ol start="5"><li>客户端再做入站处理，对消息做黏包半包处理，记录日志，消息解码，最后交给了客户端的RPC的Handler</li></ol><p><img src="../../images/image-20230203123026745.png" alt="image-20230203123026745"></p><ol start="6"><li>客户端的rpc handler最后把消息打印</li></ol><p><img src="../../images/image-20230203123144421.png" alt="image-20230203123144421"></p><h4 id="4客户端-handler-第一版"><a class="markdownIt-Anchor" href="#4客户端-handler-第一版"></a> 4）客户端 handler 第一版</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5客户端代码-第二版"><a class="markdownIt-Anchor" href="#5客户端代码-第二版"></a> 5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.client.Rpc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.message.Rpc.RpcRequestMessage;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.protocol.MessageCodecSharable;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.protocol.ProcotolFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.protocol.SequenceIdGenerator;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.server.handler.Rpc.RpcResponseMessageHandler;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.server.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.Channel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LogLevel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.logging.LoggingHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.DefaultPromise;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/2/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientManager</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">service</span> <span class="operator">=</span> getProxyService(HelloService.class);</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">"zhangsan"</span>));</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">"lisi"</span>));</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">"wangwu"</span>));</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个代理类</span></span><br><span class="line"><span class="comment">     * 实现远程调用的接口，代理类里所有方法的调用，都会多做一件事，就是把本身方法的调用转化成 rpc 的请求消息，</span></span><br><span class="line"><span class="comment">     * 再由代理类去调用channel去发送消息，这样就把复杂的过程屏蔽起来了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxyService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> {</span><br><span class="line">        <span class="comment">// 获取类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> serviceClass.getClassLoader();</span><br><span class="line">        <span class="comment">// 代理类要实现的接口</span></span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">new</span> <span class="title class_">Class</span>[]{serviceClass};</span><br><span class="line"></span><br><span class="line">        <span class="comment">//                      （proxy：代理对象  method：代理类正在执行的方法  args：方法的实际参数）</span></span><br><span class="line">        <span class="comment">// 代理类里的任何一个方法的调用都会进入这个 (proxy, method,args)-&gt;{} lambda表达式</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; {</span><br><span class="line">            <span class="comment">// 1. 将方法调用转换为 消息对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> SequenceIdGenerator.nextId();</span><br><span class="line">            <span class="type">RpcRequestMessage</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequestMessage</span>(</span><br><span class="line">                    sequenceId,  <span class="comment">// 让序列号id唯一</span></span><br><span class="line">                    serviceClass.getName(),        <span class="comment">// 接口类名</span></span><br><span class="line">                    method.getName(),</span><br><span class="line">                    method.getReturnType(),</span><br><span class="line">                    method.getParameterTypes(),    <span class="comment">// 方法的参数类型</span></span><br><span class="line">                    args                           <span class="comment">// 方法的参数</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 2. 将消息对象发送出去</span></span><br><span class="line">            getChannel().writeAndFlush(msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 准备一个空 Promise 对象，来接收结果            指定 promise 对象异步接收的结果线程</span></span><br><span class="line">            DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(getChannel().eventLoop());</span><br><span class="line">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 等来 promise 的结果</span></span><br><span class="line">            <span class="comment">// ( 这个结果其实就是 异步的网络调用，通过同步的方式来等待结果，其中用到了promise )</span></span><br><span class="line">            <span class="comment">// 因为要等promise中有结果了才返回，所以这里要用promise的同步方法</span></span><br><span class="line">            <span class="comment">// await()将来无论有成功失败都不会抛异常，而sync()失败会抛异常</span></span><br><span class="line">            promise.await();</span><br><span class="line">            <span class="keyword">if</span> (promise.isSuccess()) {</span><br><span class="line">                <span class="comment">// 调用正常</span></span><br><span class="line">                <span class="keyword">return</span> promise.getNow();</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// 调用失败</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(promise.cause());</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用单例模式来 实现 channel 只被初始化一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取唯一的channel对像</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        }</span><br><span class="line">        initChannel();</span><br><span class="line">        <span class="keyword">return</span> channel;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化 channel 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// rpc 响应消息处理器，待实现</span></span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            channel = bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里必须用异步，否则 getChannel 永远返回不了而一直处于阻塞直达 channel 关闭</span></span><br><span class="line">            channel.closeFuture().addListener(future -&gt; {</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="6客户端-handler-第二版"><a class="markdownIt-Anchor" href="#6客户端-handler-第二版"></a> 6）客户端 handler 第二版</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cn.itcast.message.Rpc.RpcResponseMessage;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.Promise;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ConcurrentHashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/2/3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="comment">/** 设置为Sharable前提是（考虑到）线程安全的 */</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**                      序号    用来接收共享的 promise 对象     ConcurrentHashMap 是线程安全的                */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, msg);</span><br><span class="line">        <span class="comment">// 拿到空的 promise                 remove返回并移除（避免promise越积越多）</span></span><br><span class="line">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="literal">null</span>) {</span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> msg.getReturnValue();</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">exceptionValue</span> <span class="operator">=</span> msg.getExceptionValue();</span><br><span class="line">            <span class="keyword">if</span> (exceptionValue != <span class="literal">null</span>) {</span><br><span class="line">                promise.setFailure(exceptionValue);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                promise.setSuccess(returnValue);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230204143132005.png" alt="image-20230204143132005"></p><p>首先，消息的发送方将消息对象发送出去，但是一时半会结果回不来那么快，所以需要一个Promise对象来接收消息，而Promise对象放在了PROMISES集合当中，Promise对象调用同步方法来等结果；这是就到了RpcResonseMessageHandler，假如它接收到了服务器端返回来的消息，它就根据消息队列号来从Promise集合中取出还未填充结果的promise，如果promise != null，就判断结果中是正常还是异常（根据exceptionValue，如果不为null就证明有异常，否则没有异常），而无论是否有异常，都会让同步等待结果中的 await() 结束等待，恢复运行，然后再通过.isSuccess()来判断结果是否异常（因为await无论结果成功失败它都不会抛异常的）</p><p><img src="../../images/image-20230204161347823.png" alt="image-20230204161347823"></p><p>我悟了！代理类创建好容器放入map中。handler处理完毕将结果放入map中。main线程从map中取</p><h2 id="2-源码分析"><a class="markdownIt-Anchor" href="#2-源码分析"></a> 2. 源码分析</h2><h3 id="21-启动剖析"><a class="markdownIt-Anchor" href="#21-启动剖析"></a> 2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class="line"><span class="type">NioServerSocketChannel</span> <span class="variable">attachment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioServerSocketChannel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open(); </span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> serverSocketChannel.register(selector, <span class="number">0</span>, attachment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class="line">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></tbody></table></figure><p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> {</span><br><span class="line"><span class="comment">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class="line">    <span class="comment">// 2.1 如果已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) {</span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        <span class="comment">// 3.1 立刻调用 doBind0</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">// 2.2 还没有完成</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">        <span class="comment">// 3.2 回调 doBind0</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) {</span><br><span class="line">                    <span class="comment">// 处理异常...</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    promise.registered();</span><br><span class="line"><span class="comment">// 3. 由注册线程去执行 doBind0</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class="line">        init(channel);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) {</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) {</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) {</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) {</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) {</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> {</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) {</span><br><span class="line">        register0(promise);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class="line">            <span class="comment">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    register0(promise);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) {</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) {</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) {</span><br><span class="line">                beginRead();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) { <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 1.2.2.1 执行初始化</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="comment">// 1.2.2.2 移除初始化器</span></span><br><span class="line">            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="built_in">this</span>) != <span class="literal">null</span>) {</span><br><span class="line">                pipeline.remove(<span class="built_in">this</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3.1 或 3.2 执行 doBind0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> {</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) {</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> {</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) {</span><br><span class="line">        <span class="comment">// 记录日志...</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 3.3 执行端口绑定</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) {</span><br><span class="line">        invokeLater(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                <span class="comment">// 3.4 触发 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) {</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> {</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"><span class="comment">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) {</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="22-nioeventloop-剖析"><a class="markdownIt-Anchor" href="#22-nioeventloop-剖析"></a> 2.2 NioEventLoop 剖析</h3><p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p><p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> {</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"task"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    <span class="comment">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) {</span><br><span class="line">        <span class="comment">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line">            <span class="comment">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) {</span><br><span class="line">        <span class="comment">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">boolean</span> inEventLoop)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) {</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="comment">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) {</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line"><span class="comment">// 清理工作，代码略...</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="comment">// calculateStrategy 的逻辑如下：</span></span><br><span class="line">                <span class="comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class="line">                <span class="comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        <span class="comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class="line">                        <span class="comment">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">oldWakenUp</span> <span class="operator">=</span> wakenUp.getAndSet(<span class="literal">false</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class="line">                        <span class="comment">// 下面的 select 方法不会阻塞</span></span><br><span class="line">                        <span class="comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class="line">                        <span class="comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class="line">                        <span class="comment">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class="line">                        select(oldWakenUp);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) {</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        }</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// ioRatio 默认是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {                </span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// 记录 io 事件处理耗时</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) {</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="️-注意"><a class="markdownIt-Anchor" href="#️-注意"></a> ⚠️ 注意</h4><blockquote><p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p><ul><li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li><li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li></ul></blockquote><p>参考下图</p><img src="../../images/0032.png"><p><code>io.netty.channel.nio.NioEventLoop#select</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(<span class="type">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 计算等待时间</span></span><br><span class="line">        <span class="comment">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class="line">        <span class="comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">selectDeadLineNanos</span> <span class="operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果超时，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) {</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class="line">            <span class="comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) {</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">// select 有限时阻塞</span></span><br><span class="line">            <span class="comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.select(timeoutMillis);</span><br><span class="line">            <span class="comment">// 计数加 1</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">               <span class="comment">// 线程被打断，退出循环</span></span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) {</span><br><span class="line">                <span class="comment">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            } </span><br><span class="line">            <span class="comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class="line">            <span class="comment">// 这是为了解决 nio 空轮询 bug</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) {</span><br><span class="line">                <span class="comment">// 重建 selector</span></span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) {</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (CancelledKeyException e) {</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class="line">        <span class="comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> {</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">    <span class="comment">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) {</span><br><span class="line">        <span class="comment">// 无效时处理...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="comment">// 连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) {</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读或可接入事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) {</span><br><span class="line">            <span class="comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class="line">            <span class="comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (CancelledKeyException ignored) {</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-accept-剖析"><a class="markdownIt-Anchor" href="#23-accept-剖析"></a> 2.3 accept 剖析</h3><p>nio 中如下代码，在 netty 中的流程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 阻塞直到事件发生</span></span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) {    </span><br><span class="line">    <span class="comment">//2 拿到一个事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 如果是 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4 执行 accept</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5 关注 read 事件</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>先来看可接入事件处理（accept）</p><p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> pipeline();    </span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line"><span class="comment">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class="line">                <span class="comment">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">localRead</span> <span class="operator">=</span> doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) {</span><br><span class="line">                    closed = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line"><span class="comment">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            } <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            exception = t;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) {</span><br><span class="line">            readPending = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class="line">            <span class="comment">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        }</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="literal">null</span>) {</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) {</span><br><span class="line">            inputShutdown = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) {</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) {</span><br><span class="line">            removeReadOp();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">    <span class="comment">// 这时的 msg 是 NioSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) {</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> {</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) {</span><br><span class="line">        register0(promise);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                    register0(promise);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) {</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) {</span><br><span class="line">                <span class="comment">// 触发 pipeline 上 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) {</span><br><span class="line">                beginRead();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> {</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line"><span class="comment">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 这时候 interestOps 是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 关注 read 事件</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="24-read-剖析"><a class="markdownIt-Anchor" href="#24-read-剖析"></a> 2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) {</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> pipeline();</span><br><span class="line">    <span class="comment">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">close</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">do</span> {</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) {</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="literal">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) {</span><br><span class="line">                    readPending = <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="literal">null</span>;</span><br><span class="line">        } </span><br><span class="line">        <span class="comment">// 是否要继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 触发 read complete 事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) {</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) {</span><br><span class="line">            removeReadOp();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> {</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">           <span class="comment">// 一般为 true</span></span><br><span class="line">           config.isAutoRead() &amp;&amp;</span><br><span class="line">           <span class="comment">// respectMaybeMoreData 默认为 true</span></span><br><span class="line">           <span class="comment">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           <span class="comment">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           <span class="comment">// 实际读到了数据</span></span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）2-进阶</title>
      <link href="/2023/01/18/Netty/Netty03-%E8%BF%9B%E9%98%B6/"/>
      <url>/2023/01/18/Netty/Netty03-%E8%BF%9B%E9%98%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="三-netty-进阶"><a class="markdownIt-Anchor" href="#三-netty-进阶"></a> 三. Netty 进阶</h1><h2 id="1-粘包与半包"><a class="markdownIt-Anchor" href="#1-粘包与半包"></a> 1. 粘包与半包</h2><h3 id="11-粘包现象"><a class="markdownIt-Anchor" href="#11-粘包现象"></a> 1.1 粘包现象</h3><p>服务端代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"connected {}"</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"disconnect {}"</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">"{} binding..."</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">"{} bound..."</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"server error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">"stoped"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    log.debug(<span class="string">"connetted..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"sending..."</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>});</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></tbody></table></figure><h3 id="12-半包现象"><a class="markdownIt-Anchor" href="#12-半包现象"></a> 1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>});</span><br><span class="line">}</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></tbody></table></figure><p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>注意</strong></p><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p></blockquote><h3 id="13-现象分析"><a class="markdownIt-Anchor" href="#13-现象分析"></a> 1.3 现象分析</h3><h4 id="粘包"><a class="markdownIt-Anchor" href="#粘包"></a> 粘包</h4><ul><li>现象，发送 abc def，接收 abcdef</li><li>原因<ul><li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）  [ <mark>接收方的ByteBuf比较大，但发送的包比较小，容易产生黏包</mark> ]</li><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，<mark><strong>当滑动窗口中缓冲了多个报文就会粘包</strong></mark></li><li>Nagle 算法：会造成粘包   [<mark> Nagle算法 就是想尽多的去发送数据，攒够了一批才发，不想因为数据太少就发送这样速率比较低</mark> ]</li></ul></li></ul><h4 id="半包"><a class="markdownIt-Anchor" href="#半包"></a> 半包</h4><ul><li>现象，发送 abcdef，接收 abc def</li><li>原因<ul><li>应用层：接收方 ByteBuf 小于实际发送数据量</li><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包<ul><li>MSS 是TCP用来限制<strong>application层最大的发送字节数</strong>，是tcp能发送的分组的最大长度。 MSS 是系统默认的，就是系统TCP / IP栈所能允许的最大包。</li></ul></li></ul></li></ul><p>综上所述，产生这个黏包、半包，跟网络和应用层都有关系，所以这是TCP编程时不可回避的问题</p><p>本质是因为 <font color="red">TCP 是流式协议，消息无边界</font></p><blockquote><p>滑动窗口</p><ul><li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次 <font color="red"><strong>确认应答（ack）</strong></font>处理，但如果这么做，缺点是包的往返时间越长性能就越差</p><p><img src="../../images/0049.png" alt=""></p></li><li><p>为了解决此问题，引入了<strong>窗口概念</strong>，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p><p><img src="../../images/0051.png" alt=""></p></li><li><p>窗口实际就起到一个<mark>缓冲区</mark>的作用，同时也能起到<mark>流量控制</mark>的作用</p><ul><li>图中深色的部分即要发送的数据，高亮的部分即窗口</li><li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li><li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul></li></ul></blockquote><blockquote><p>MSS 限制</p><ul><li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p></li><li><p>以太网的 MTU 是 1500</p></li><li><p>FDDI（光纤分布式数据接口）的 MTU 是 4352</p></li><li><p>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</p></li><li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p></li><li><p>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</p></li><li><p>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</p></li><li><p>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</p></li></ul>  <img src="../../images/0031.jpg" style="zoom:50%;"></blockquote><blockquote><p>Nagle 算法</p><ul><li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li><li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul><li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li><li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li><li>如果 TCP_NODELAY = true，则需要发送</li><li>已发送的数据都收到 ack 时，则需要发送</li><li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li><li>除上述情况，延迟发送</li></ul></li></ul></blockquote><h3 id="14-半包黏包解决方案"><a class="markdownIt-Anchor" href="#14-半包黏包解决方案"></a> 1.4 半包黏包解决方案</h3><ol><li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li><li>每一条消息采用固定长度，缺点浪费空间</li><li>每一条消息采用分隔符，例如 \n，缺点需要转义</li><li>每一条消息分为 head 和 body，head 中包含 body 的长度</li></ol><h4 id="方法1短链接"><a class="markdownIt-Anchor" href="#方法1短链接"></a> 方法1，短链接</h4><p>以解决粘包为例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">            send();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    log.debug(<span class="string">"conneted..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"sending..."</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>});</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出，略</p><blockquote><p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p></blockquote><h4 id="方法2固定长度"><a class="markdownIt-Anchor" href="#方法2固定长度"></a> 方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></tbody></table></figure><p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    log.debug(<span class="string">"connetted..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"sending..."</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) {</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                }</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            }</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"192.168.0.103"</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class="line">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class="line">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class="line">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class="line">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></tbody></table></figure><p>服务端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></tbody></table></figure><p>缺点是，数据包的大小不好把握</p><ul><li>长度定的太大，浪费</li><li>长度定的太小，对某些数据包又显得不够</li></ul><h4 id="方法3固定分隔符"><a class="markdownIt-Anchor" href="#方法3固定分隔符"></a> 方法3，固定分隔符</h4><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></tbody></table></figure><p>客户端在每条消息之后，加入 \n 分隔符</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    log.debug(<span class="string">"connetted..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"sending..."</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) {</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                }</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            }</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"192.168.0.103"</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class="line">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class="line">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class="line">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></tbody></table></figure><p>服务端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61                                              |a               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63                                        |ccc             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64                                           |dd              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66                                           |ff              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></tbody></table></figure><p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p><h4 id="方法4预设长度"><a class="markdownIt-Anchor" href="#方法4预设长度"></a> 方法4，预设长度</h4><p><a href="https://www.bilibili.com/video/BV1py4y1E7oA/?p=98&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">第3章_08-netty进阶-黏包半包-解决-LTC解码器_哔哩哔哩_bilibili</a></p><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></tbody></table></figure><p>客户端代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    log.debug(<span class="string">"connetted..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"sending..."</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">'a'</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">                                <span class="type">byte</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length; j++) {</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                }</span><br><span class="line">                                c++;</span><br><span class="line">                            }</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"192.168.0.103"</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class="line">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class="line">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class="line">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class="line">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class="line">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class="line">|00000060| 6a                                              |j               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></tbody></table></figure><p>服务端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class="line">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67                                           |gg              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68                                           |hh              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="2-协议设计与解析"><a class="markdownIt-Anchor" href="#2-协议设计与解析"></a> 2. 协议设计与解析</h2><h3 id="21-为什么需要协议"><a class="markdownIt-Anchor" href="#21-为什么需要协议"></a> 2.1 为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p><p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p><p>例如：在网络上传输</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下雨天留客天留我不留</span><br></pre></td></tr></tbody></table></figure><p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p><p>一种解读</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下雨天留客，天留，我不留</span><br></pre></td></tr></tbody></table></figure><p>另一种解读</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">下雨天，留客天，留我不？留</span><br></pre></td></tr></tbody></table></figure><p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></tbody></table></figure><p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0f下雨天留客06天留09我不留</span><br></pre></td></tr></tbody></table></figure><blockquote><p>小故事</p><p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p><p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p><p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p><p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p><p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p></blockquote><h3 id="22-redis-协议举例"><a class="markdownIt-Anchor" href="#22-redis-协议举例"></a> 2.2 redis 协议举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = {<span class="number">13</span>, <span class="number">10</span>};</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> {</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">"*2"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"$3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"get"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"$3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"aaa"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">"*3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"$3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"set"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"$3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"aaa"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"$3"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">"bbb"</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-http-协议举例"><a class="markdownIt-Anchor" href="#23-http-协议举例"></a> 2.3 http 协议举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">    serverBootstrap.group(boss, worker);</span><br><span class="line">    serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());   <span class="comment">// </span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// SimpleChannelInboundHandler 可以根据消息的类型加以区分，进行选择处理</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    <span class="comment">// 获取请求</span></span><br><span class="line">                    log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回响应</span></span><br><span class="line">                    <span class="comment">// msg.protocolVersion() 得到协议的版本</span></span><br><span class="line">                    <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="string">"&lt;h1&gt;Hello, world!&lt;/h1&gt;"</span>.getBytes();</span><br><span class="line"><span class="comment">// 告诉浏览器我的响应长度（有多少个字节），就不用往下一直读了</span></span><br><span class="line">                    response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                    <span class="comment">// </span></span><br><span class="line">                    response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 写回响应</span></span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() {</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {</span></span><br><span class="line"><span class="comment">                    log.debug("{}", msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    if (msg instanceof HttpRequest) { // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    } else if (msg instanceof HttpContent) { //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    }</span></span><br><span class="line"><span class="comment">                }</span></span><br><span class="line"><span class="comment">            });*/</span></span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">} <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">    log.error(<span class="string">"server error"</span>, e);</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    boss.shutdownGracefully();</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="24-自定义协议要素"><a class="markdownIt-Anchor" href="#24-自定义协议要素"></a> 2.4 自定义协议要素</h3><ul><li>魔数，用来在第一时间判定是否是无效数据包</li><li>版本号，可以支持协议的升级</li><li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li><li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li><li>请求序号，为了双工通信，提供异步能力</li><li>正文长度  （通过此可以知道接下来要读多少字节）</li><li>消息正文</li></ul><h4 id="编解码器"><a class="markdownIt-Anchor" href="#编解码器"></a> 编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();<span class="comment">// 获取字节的魔数</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();<span class="comment">// 获取字节的版本</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();<span class="comment">// 获取字节的序列号类型</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();<span class="comment">// 获取字节的指令类型</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();<span class="comment">// 4个字节</span></span><br><span class="line">        in.readByte();<span class="comment">// 一个无意义的字节，用于填充的，跳过就行</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);         <span class="comment">// 从 0 开始读到bytes里面</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        </span><br><span class="line">        log.debug(<span class="string">"{}, {}, {}, {}, {}, {}"</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, message);</span><br><span class="line">        out.add(message);    <span class="comment">// 为了给下一个handler用</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="comment">// 五个参数分别为：maxFrameLength、lengthFieldOffset、lengthFieldLength、lengthAdjustment、initialBytesToStrip</span></span><br><span class="line">    <span class="comment">// 加了这个 LengthFieldBasedFrameDecoder 半包黏包处理器就可以解决半包黏包问题了， 要等数据等完整了再往下走</span></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>( <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">"zhangsan"</span>, <span class="string">"123"</span>, <span class="string">"张三"</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);   <span class="comment">// 将 message 的消息填充到 buf 中</span></span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2  【这一步很重要，一定要加】</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></tbody></table></figure><p>解读</p><p><img src="../../images/image-20230127095922011.png" alt="image-20230127095922011"></p><h4 id="什么时候可以加-sharable"><a class="markdownIt-Anchor" href="#什么时候可以加-sharable"></a> 💡 什么时候可以加 @Sharable</h4><ul><li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li><li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li><li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">"{}, {}, {}, {}, {}, {}"</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-聊天室案例"><a class="markdownIt-Anchor" href="#3-聊天室案例"></a> 3. 聊天室案例</h2><h3 id="31-聊天室业务介绍"><a class="markdownIt-Anchor" href="#31-聊天室业务介绍"></a> 3.1 聊天室业务介绍</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Session</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Channel channel, String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unbind</span><span class="params">(Channel channel)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getAttribute</span><span class="params">(Channel channel, String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Channel <span class="title function_">getChannel</span><span class="params">(String username)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天组会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupSession</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">joinMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeGroup</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">getMembers</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Channel&gt; <span class="title function_">getMembersChannel</span><span class="params">(String name)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="32-聊天室业务-登录"><a class="markdownIt-Anchor" href="#32-聊天室业务-登录"></a> 3.2 聊天室业务-登录</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());  <span class="comment">// 半包处理器</span></span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);    <span class="comment">// 记录日志</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);      <span class="comment">// 消息编码器 编译成 byte数组</span></span><br><span class="line">                    <span class="comment">// 添加业务相关的handler</span></span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span>(login) {</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">                            } <span class="keyword">else</span> {</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">"用户名或密码不正确"</span>);</span><br><span class="line">                            }</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            log.error(<span class="string">"server error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">"client handler"</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            log.debug(<span class="string">"msg: {}"</span>, msg);</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) {</span><br><span class="line">                                <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) {</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                }</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">                                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                System.out.println(<span class="string">"请输入用户名:"</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">"请输入密码:"</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(username, password);</span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">"等待后续操作..."</span>);</span><br><span class="line">                                <span class="keyword">try</span> {</span><br><span class="line">                                    WAIT_FOR_LOGIN.await();</span><br><span class="line">                                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                }</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) {</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                }</span><br><span class="line">                                <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                                    System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"send [username] [content]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"gsend [group name] [content]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"gcreate [group name] [m1,m2,m3...]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"gmembers [group name]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"gjoin [group name]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"gquit [group name]"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"quit"</span>);</span><br><span class="line">                                    System.out.println(<span class="string">"=================================="</span>);</span><br><span class="line">                                    <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">" "</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>]){</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"send"</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatRequestMessage</span>(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"gsend"</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatRequestMessage</span>(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"gcreate"</span>:</span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">","</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateRequestMessage</span>(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"gmembers"</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersRequestMessage</span>(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"gjoin"</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinRequestMessage</span>(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"gquit"</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupQuitRequestMessage</span>(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">"quit"</span>:</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    }</span><br><span class="line">                                }</span><br><span class="line">                            }, <span class="string">"system in"</span>).start();</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">"localhost"</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            log.error(<span class="string">"client error"</span>, e);</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="33-聊天室业务-单聊"><a class="markdownIt-Anchor" href="#33-聊天室业务-单聊"></a> 3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p><p>登录 handler</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span>(login) {</span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">            message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">"登录成功"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">"用户名或密码不正确"</span>);</span><br><span class="line">        }</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>单聊 handler</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> msg.getTo();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> SessionFactory.getSession().getChannel(to);</span><br><span class="line">        <span class="comment">// 在线</span></span><br><span class="line">        <span class="keyword">if</span>(channel != <span class="literal">null</span>) {</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 不在线</span></span><br><span class="line">        <span class="keyword">else</span> {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatResponseMessage</span>(<span class="literal">false</span>, <span class="string">"对方用户不存在或者不在线"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="34-聊天室业务-群聊"><a class="markdownIt-Anchor" href="#34-聊天室业务-群聊"></a> 3.4 聊天室业务-群聊</h3><p>创建群聊</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 群管理器</span></span><br><span class="line">        <span class="type">GroupSession</span> <span class="variable">groupSession</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 发生成功消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>, groupName + <span class="string">"创建成功"</span>));</span><br><span class="line">            <span class="comment">// 发送拉群消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) {</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>, <span class="string">"您已被拉入"</span> + groupName));</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">false</span>, groupName + <span class="string">"已经存在"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>群聊</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) {</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>加入群聊</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupJoinRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">"群加入成功"</span>));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">"群不存在"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>退出群聊</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupQuitRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, <span class="string">"已退出群"</span> + msg.getGroupName()));</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">"群不存在"</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>查看成员</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupMembersRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembers(msg.getGroupName());</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersResponseMessage</span>(members));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="35-聊天室业务-退出"><a class="markdownIt-Anchor" href="#35-聊天室业务-退出"></a> 3.5 聊天室业务-退出</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class QuitHandler extends ChannelInboundHandlerAdapter {</span><br><span class="line"></span><br><span class="line">    // 当连接断开时触发 inactive 事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception {</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug("{} 已经断开", ctx.channel());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">// 当出现异常时触发</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug("{} 已经异常断开 异常是{}", ctx.channel(), cause.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="36-聊天室业务-空闲检测"><a class="markdownIt-Anchor" href="#36-聊天室业务-空闲检测"></a> 3.6 聊天室业务-空闲检测</h3><h4 id="连接假死"><a class="markdownIt-Anchor" href="#连接假死"></a> 连接假死</h4><p>原因</p><ul><li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li><li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p>问题</p><ul><li>假死的连接占用的资源不能自动释放</li><li>向假死的连接发送数据，得到的反馈是发送超时</li></ul><p>服务器端解决</p><ul><li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() {</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) {</span><br><span class="line">            log.debug(<span class="string">"已经 5s 没有读到数据了"</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>客户端定时心跳</p><ul><li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() {</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) {</span><br><span class="line">            <span class="comment">//                                log.debug("3s 没有写数据了，发送一个心跳包");</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）Handler &amp; Pipeline</title>
      <link href="/2023/01/18/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/%EF%BC%88netty%EF%BC%89Handler%20&amp;%20Pipeline/"/>
      <url>/2023/01/18/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/%EF%BC%88netty%EF%BC%89Handler%20&amp;%20Pipeline/</url>
      
        <content type="html"><![CDATA[<h3 id="handler-pipeline"><a class="markdownIt-Anchor" href="#handler-pipeline"></a> Handler &amp; Pipeline</h3><p><strong>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</strong></p><ul><li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><p>先搞清楚顺序，服务端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1 将数据传递给下一个 handler（在这里的下一个就是h2），如果不调用，调用链会断开</span></span><br><span class="line">                    <span class="comment">// super.channelRead(ctx, msg); // 和上面的语句是一样的作用，上面的是这个内部实现</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 只有向channel写入数据才会触发，没写入就不能触发</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; {</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">"hello,world"</span>);</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><p>服务器端打印：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure><p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p><p><img src="../../../images/0008.png" alt=""></p><ul><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul></li><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul></li><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul></li><li>ctx.channel().write(msg)  <strong>VS</strong>  ctx.write(msg)<ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li></ul></li></ul><p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><p><img src="../../../images/0009.png" alt=""></p><p>演示<strong>EmbeddedChannel</strong>，方便debug和模拟</p><p><img src="../../../images/image-20230118155525347.png" alt="image-20230118155525347"></p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）2-入门</title>
      <link href="/2023/01/15/Netty/Netty02-%E5%85%A5%E9%97%A8/"/>
      <url>/2023/01/15/Netty/Netty02-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="二-netty-入门"><a class="markdownIt-Anchor" href="#二-netty-入门"></a> 二. Netty 入门</h1><h2 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h2><h3 id="11-netty-是什么"><a class="markdownIt-Anchor" href="#11-netty-是什么"></a> 1.1 Netty 是什么？</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></tbody></table></figure><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p>解析：</p><p>【 这里的<strong>异步</strong> ( 并不是异步io，netty没有采用异步io )，  主要指的是netty采用多线程来完成一些方法调用和处理结果相分离，你调用方法的线程如果跟处理结果的线程是同一个，那就意味着阻塞、同步，二如果调用方法的线程和处理结果的线程是两个，那就是异步，就可以解放调用方法的线程，让调用方法的线程能腾出手来去干其它的工作。</p><p><strong>基于事件驱动</strong>，就是netty的底层实现是采用的多路复用技术，也就是Selector，它在io发生时才会进行相应的处理，比如可连接、可读、可写 这些事件发生时，netty才会基于这些事件来进行处理 ）】</p><h3 id="12-netty-的作者"><a class="markdownIt-Anchor" href="#12-netty-的作者"></a> 1.2 Netty 的作者</h3><p><img src="../../images/0005.png" alt=""></p><p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p><h3 id="13-netty-的地位"><a class="markdownIt-Anchor" href="#13-netty-的地位"></a> 1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p><p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p><ul><li>Cassandra - nosql 数据库</li><li>Spark - 大数据分布式计算框架</li><li>Hadoop - 大数据分布式存储框架</li><li>RocketMQ - ali 开源的消息队列</li><li>ElasticSearch - 搜索引擎</li><li>gRPC - rpc 框架</li><li>Dubbo - rpc 框架</li><li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li><li>Zookeeper - 分布式协调框架</li></ul><h3 id="14-netty-的优势"><a class="markdownIt-Anchor" href="#14-netty-的优势"></a> 1.4 Netty 的优势</h3><ul><li>Netty vs NIO，工作量大，bug 多<ul><li>需要自己构建协议</li><li>解决 TCP 传输问题，如粘包、半包</li><li>epoll 空轮询导致 CPU 100%</li><li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li></ul></li><li>Netty vs 其它网络应用框架<ul><li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li><li>久经考验，有16年了，Netty 版本<ul><li>2.x 2004</li><li>3.x 2008</li><li>4.x 2013</li><li>5.x 已废弃（没有明显的性能提升，维护成本高）</li></ul></li></ul></li></ul><h2 id="2-hello-world"><a class="markdownIt-Anchor" href="#2-hello-world"></a> 2. Hello World</h2><h3 id="21-目标"><a class="markdownIt-Anchor" href="#21-目标"></a> 2.1 目标</h3><p>开发一个简单的服务器端和客户端</p><ul><li>客户端向服务器端发送 hello, world</li><li>服务器仅接收，不返回</li></ul><p>加入依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="22-服务器端"><a class="markdownIt-Anchor" href="#22-服务器端"></a> 2.2 服务器端</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInboundHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2023/1/16</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 服务器代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 1.启动器，负责组装 netty 组件，启动服务器</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. BossEventLoop, WorkerEventLoop( selector, thread ), group 组</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 3. 选择 服务器的ServerSocketChannel 实现</span></span><br><span class="line">                .channel(NioServerSocketChannel.class)  <span class="comment">// 支持 OIO BIO</span></span><br><span class="line">                <span class="comment">// 4. boss 负责处理连接, worker(child) 负责处理读写。决定了 worker(child) 能执行哪些操作（handler）</span></span><br><span class="line">                .childHandler(</span><br><span class="line">                                <span class="comment">// 5. channel 代表和客户端进行数据读写的通道 Initializer 初始化，负责添加别的handler</span></span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span>  <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                        <span class="comment">// 6. 添加具体 handler</span></span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>());  <span class="comment">// 服务器 的处理器new StringDecoder() 将 ByteBuf 解码成字符串</span></span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() { <span class="comment">// 自定义 handler</span></span><br><span class="line">                            <span class="meta">@Override</span> <span class="comment">// 读事件</span></span><br><span class="line">                            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception{</span><br><span class="line">                                <span class="comment">// 打印上一步转换好的字符串</span></span><br><span class="line">                                System.out.println(msg);</span><br><span class="line">                            }</span><br><span class="line">                        });</span><br><span class="line">                    }</span><br><span class="line">                })</span><br><span class="line">                <span class="comment">// 7. 绑定监听端口</span></span><br><span class="line">                .bind(<span class="number">8080</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p></li><li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p><p><img src="../../images/0006.png" alt=""></p></li><li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，ServerSocketChannel 绑定的监听端口</p></li><li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p></li><li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p></li></ul><h3 id="23-客户端"><a class="markdownIt-Anchor" href="#23-客户端"></a> 2.3 客户端</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        <span class="comment">// 1. 客户端启动类</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                <span class="comment">// 2. 添加 EventLoop</span></span><br><span class="line">                <span class="comment">// 以后服务器发来数据了，客户端的EventLoop就可以从 选择器 里 触发读事件，进行进一步的处理</span></span><br><span class="line">                .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">                <span class="comment">// 3. 选择客户端 channel 实现</span></span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                <span class="comment">// 4. 添加处理器 ( 它会在连接建立后被调用，调用之后就会执行这个initChannel方法)</span></span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                        nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());  <span class="comment">// 客户端的编译器将字编码成ByteBuf 发给服务器（ 服务器 的处理器new StringDecoder() 将 ByteBuf 解码成字符串）</span></span><br><span class="line">                    }</span><br><span class="line">                })</span><br><span class="line">                <span class="comment">// 5. 连接到服务器</span></span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>))</span><br><span class="line">                .sync()</span><br><span class="line">                .channel()</span><br><span class="line">                <span class="comment">// 5. 向服务器发送数据</span></span><br><span class="line">                .writeAndFlush(<span class="string">"hello, world"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码解读</p><ul><li><p>1 处，创建 NioEventLoopGroup，同 Server</p></li><li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p><p><img src="../../images/0007.png" alt=""></p></li><li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p></li><li><p>4 处，指定要连接的服务器和端口</p></li><li><p>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</p></li><li><p>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</p></li><li><p>7 处，写入消息并清空缓冲区</p></li><li><p>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</p></li><li><p>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</p></li></ul><h3 id="24-流程梳理"><a class="markdownIt-Anchor" href="#24-流程梳理"></a> 2.4 流程梳理</h3><p><img src="../../images/image-20230116223813140.png" alt="image-20230116223813140"></p><h4 id="提示"><a class="markdownIt-Anchor" href="#提示"></a> 💡 提示</h4><blockquote><p>一开始需要树立正确的观念</p><ul><li>把 channel 理解为数据的通道</li><li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li><li>把 handler 理解为数据的处理工序<ul><li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li><li>handler 分 Inbound 和 Outbound 两类 （ 入站：客户端先服务器输入数据时用Inbound;  出站：数据向客户端写出时用Outbound ）</li></ul></li><li>把 eventLoop 理解为处理数据的工人<ul><li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li><li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li><li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li></ul></li></ul></blockquote><h2 id="3-组件"><a class="markdownIt-Anchor" href="#3-组件"></a> 3. 组件</h2><h3 id="31-eventloop"><a class="markdownIt-Anchor" href="#31-eventloop"></a> 3.1 EventLoop</h3><p>事件循环对象</p><p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p><p>它的继承关系比较复杂</p><ul><li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p>事件循环组</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><p>以一个简单的实现为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></tbody></table></figure><p>也可以使用 for 循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) {</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) {</span><br><span class="line">        // 1. 创建事件循环组           如果不传参数或是参数传0，就采用默认的线程数（系统的虚拟机所在的电脑的CPU核心数*2）</span><br><span class="line">        EventLoopGroup group = new NioEventLoopGroup(2);  // 能处理： io事件，普通事件，定时任务</span><br><span class="line">//        EventLoopGroup group1 = new DefaultEventLoop();   // 能处理： 普通任务，定时任务</span><br><span class="line"></span><br><span class="line">        // 2. next() 获取下一个事件循环对象</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line">        System.out.println(group.next());</span><br><span class="line"></span><br><span class="line">        // 3. .submit() 或 .execute()执行普通任务</span><br><span class="line">        // 意义：一个代码的执行权需要由一个线程转移到另一个线程时</span><br><span class="line">        //      1） 可以进行进行业务异步处理，比如 比较耗时的任务当前线程不想完成，就可以让 EventLoopGroup 事件循环组里的线程来完成</span><br><span class="line">        //      2） 做一些事件分发的时候，会用到这种提交任务</span><br><span class="line">        group.next().submit(()-&gt;{</span><br><span class="line">            try {</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            } catch (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            log.info("ok");</span><br><span class="line">        });</span><br><span class="line">        log.info("main");</span><br><span class="line"></span><br><span class="line">        // 执行定时任务</span><br><span class="line">        // scheduleAtFixedRate 有四个参数：</span><br><span class="line">        // 参数1:任务对象 2:初始延时时间（延时后才启动这个定时操作，0的话就表示立刻启动） 3:间隔时间 4:时间单位</span><br><span class="line">        group.next().scheduleAtFixedRate(()-&gt;{</span><br><span class="line">            log.info("okk");</span><br><span class="line">        }, 0, 1, TimeUnit.SECONDS);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>.submit() 或 .execute()执行普通任务</p><p>意义：一个代码的执行权需要由一个线程转移到另一个线程时</p><p>1） 可以进行进行业务异步处理，比如 比较耗时的任务当前线程不想完成，就可以让 EventLoopGroup 事件循环组里的线程来完成</p><p>2） 做一些事件分发的时候，会用到这种提交任务</p><h4 id="优雅关闭"><a class="markdownIt-Anchor" href="#优雅关闭"></a> 💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h4 id="演示-nioeventloop-处理-io-事件"><a class="markdownIt-Anchor" href="#演示-nioeventloop-处理-io-事件"></a> 演示 NioEventLoop 处理 io 事件</h4><p>nio线程一旦连接成功，就会建立绑定关系，channel就会跟一个NioEventLoop绑定</p><p>服务器端两个 nio worker 工人</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) {</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></tbody></table></figure><p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                    System.out.println(<span class="string">"init..."</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                }</span><br><span class="line">            })</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">"wangwu"</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">"wangwu"</span>.getBytes()));</span><br></pre></td></tr></tbody></table></figure><p>最后输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230117202631797.png" alt="image-20230117202631797"></p><p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p><p><img src="../../images/0042.png" alt=""></p><p>再增加两个非 nio 工人</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    <span class="comment">// 分工细化：将group的一个new NioEventLoopGroup()参数细化成两个，一个的话它既包含了boss也包含了worker</span></span><br><span class="line">    <span class="comment">//  group 参数1：  boss 只负责 ServerSocketChannel上的 accept 事件。（因为NioServerSocketChannel只有一个，所以设置参数为1，或是不传参）</span></span><br><span class="line">    <span class="comment">//        参数2：  worker 只负责socketChannel上的读写</span></span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">"myhandler"</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) {</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></tbody></table></figure><p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></tbody></table></figure><p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p><p><img src="../../images/0041.png" alt=""></p><p>EvenLoop细分1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    <span class="comment">// 分工细化：将group的一个new NioEventLoopGroup()参数细化成两个，一个的话它既包含了boss也包含了worker</span></span><br><span class="line">    <span class="comment">//  group 参数1：  boss 只负责 ServerSocketChannel上的 accept 事件。（因为NioServerSocketChannel只有一个，所以设置参数为1，或是不传参）</span></span><br><span class="line">    <span class="comment">//        参数2：  worker 只负责socketChannel上的读写</span></span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">"myhandler"</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) {</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></tbody></table></figure><p>为什么要做EvenLoop的细分2？</p><p>nio的线程耗费的时间长，它会影响到其它的很多客户端的上的读写操作，一个worker可能管理很多的channel，而其中一个channel执行到hanlder了花费的时间的比较长花费了好几秒，那么久会导致到同一个worker管理的其它的channel的读写操作都会受到影响。一个channel满就会导致同一个worker检测的其它的channel的操作，所以如果某个handler耗时较长，就最好不要让它占用这个worker的nio线程，免得会影响到nio的读写操作。为此，我们可以再做一次eventloop细分，相当于让不同的人完成不同的事。（如果某个handle执行时间比较长，就可以单独用一个group来负责处理，这样就不会影响io线程。）</p><p><img src="../../images/image-20230117220705167.png" alt="image-20230117220705167"></p><p>两个handler，前一个handler消息处理完后就传给下一个handler处理，但前一个如果不执行 <strong>.fireChannelRead(msg)</strong> 的话，后面的handler就不能继续处理了</p><p><img src="../../images/image-20230117220734991.png" alt="image-20230117220734991"></p><h4 id="handler-执行中如何换人"><a class="markdownIt-Anchor" href="#handler-执行中如何换人"></a> 💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) {</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    } </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> {</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li></ul><p><img src="../../images/image-20230117231436691.png" alt="image-20230117231436691"></p><h4 id="演示-nioeventloop-处理普通任务"><a class="markdownIt-Anchor" href="#演示-nioeventloop-处理普通任务"></a> 演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"server start..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;{</span><br><span class="line">    log.debug(<span class="string">"normal task..."</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以用来执行耗时较长的任务</p></blockquote><h4 id="演示-nioeventloop-处理定时任务"><a class="markdownIt-Anchor" href="#演示-nioeventloop-处理定时任务"></a> 演示 NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"server start..."</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; {</span><br><span class="line">    log.debug(<span class="string">"running..."</span>);</span><br><span class="line">}, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><blockquote><p>可以用来执行定时任务</p></blockquote><h3 id="32-channel"><a class="markdownIt-Anchor" href="#32-channel"></a> 3.2 Channel</h3><p>channel 的主要作用</p><ul><li>close() 可以用来关闭 channel</li><li>closeFuture() 用来处理 channel 的关闭<ul><li>sync 方法作用是同步等待 channel 关闭</li><li>而 addListener 方法是异步等待 channel 关闭</li></ul></li><li>pipeline() 方法添加处理器</li><li>write() 方法将数据写入 （存在缓冲区中，不会直接刷出，后面要执行flush将缓冲区的数据刷出，或是等到缓冲区积累到一定数量时才会自动一次性刷出）</li><li>writeAndFlush() 方法将数据写入并刷出 （写入缓冲区后就立刻刷出）</li></ul><h4 id="channelfuture"><a class="markdownIt-Anchor" href="#channelfuture"></a> ChannelFuture</h4><p>这时刚才的客户端代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">": hello world!"</span>);</span><br></pre></td></tr></tbody></table></figure><p>现在把它拆开来看</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带有 Future,promise的类型都是和异步方法配套使用的，用来处理结果</span></span><br><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">": hello world!"</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li></ul><p><strong>注意</strong> <mark>connect 方法是异步的</mark>，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p><p>实验如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    <span class="comment">// 连接到服务器</span></span><br><span class="line">    <span class="comment">// connect 是异步非阻塞的，main发起了调用，真正执行connect的是nio线程</span></span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2 使用sync方法同步处理结果，进入阻塞，直到前面的异步业务完成（nio线程执行完毕）</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></tbody></table></figure><ul><li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li><li>执行到 2 时，sync 方法是同步等待连接建立完成</li><li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li></ul><p>除了用 sync 方法可以<strong>让异步操作同步</strong>以外，还可以使用回调的方式：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; {</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><ul><li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li><li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li></ul><p><img src="../../images/image-20230117235645597.png" alt="image-20230117235645597"></p><p>ps: 带有 Future,promise的类型都是和异步方法配套使用的，用来处理结果</p><h4 id="closefuture"><a class="markdownIt-Anchor" href="#closefuture"></a> CloseFuture</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));  <span class="comment">// 以日志形式输出，便于调试</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    }</span><br><span class="line">                })</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;{</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"q"</span>.equals(line)) {</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug("处理关闭之后的操作"); // 不能在这里善后，因为前面的close方法是异步操作</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            }</span><br><span class="line">        }, <span class="string">"input"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">/* 方式1： 同步处理关闭</span></span><br><span class="line"><span class="comment">        log.debug("waiting close...");</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug("处理关闭之后的操作");*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 方式2：异步处理关闭</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">                log.debug(<span class="string">"处理关闭之后的操作"</span>);</span><br><span class="line">                group.shutdownGracefully(); <span class="comment">// 优雅地关闭（优雅：拒绝新的任务，等待nio线程中现有的任务处理完，才会关闭线程）</span></span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="comment">/* 上面的代码可以通过lamda表达式来简化，如下：</span></span><br><span class="line"><span class="comment">        closeFuture.addListener((ChannelFutureListener) future -&gt; {</span></span><br><span class="line"><span class="comment">            log.debug("处理关闭之后的操作");</span></span><br><span class="line"><span class="comment">            group.shutdownGracefully(); </span></span><br><span class="line"><span class="comment">        })</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="异步提升的是什么"><a class="markdownIt-Anchor" href="#异步提升的是什么"></a> 💡 异步提升的是什么</h4><ul><li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p></li><li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p></li></ul><p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p><p><img src="../../images/0044.png" alt=""></p><p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p><p><img src="../../images/0048.png" alt=""></p><p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p><p><img src="../../images/0047.png" alt=""></p><p>要点</p><ul><li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li><li>异步并没有缩短响应时间，反而有所增加；这里异步提高的是吞吐量，提高单位时间内处理请求的速率</li><li>合理进行任务拆分，也是利用异步的关键</li></ul><h3 id="33-future-promise"><a class="markdownIt-Anchor" href="#33-future-promise"></a> 3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p><p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li></ul><table><thead><tr><th>功能/名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><p><strong>jdk-future</strong></p><p><img src="../../images/image-20230118114308481.png" alt="image-20230118114308481"></p><p><strong>演示netty-future</strong></p><p><img src="../../images/image-20230118120227134.png" alt="image-20230118120227134"></p><p>future是被动的，它的创建权和结果设置权都不是我们自己控制，它是由eventLoop.submit提交任务时返回的future。那有没有一个更灵活的方式呢？就是promise对象的使用</p><p>对于网络编程中的 RPC 框架，promise就非常有用，而future肯定不行，必须要用promise</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoop;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.util.concurrent.DefaultPromise;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestNettyPromise</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException {</span><br><span class="line">        <span class="comment">// 1. 准备 EventLoop 对象</span></span><br><span class="line">        <span class="type">EventLoop</span> <span class="variable">eventLoop</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>().next();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 可以主动创建 promise，结果容器</span></span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventLoop);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="comment">// 3. 任意一个线程执行计算，计算完毕后向 promise 填充结果</span></span><br><span class="line">            log.debug(<span class="string">"开始计算..."</span>);</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                promise.setSuccess(<span class="number">80</span>); <span class="comment">// 填充成功的结果</span></span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                promise.setFailure(e);  <span class="comment">// 填充失败的异常</span></span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 接收结果的线程</span></span><br><span class="line">        log.debug(<span class="string">"等待结果..."</span>);</span><br><span class="line">        log.debug(<span class="string">"结果是：{}"</span>, promise.get()); <span class="comment">// 获取promise填充的结果</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>int i = 1 / 0 出异常，填充失败结果的运行结果：</p><p><img src="../../images/image-20230118123507395.png" alt="image-20230118123507395"></p><p>int i = 1 / 1 不出异常，填充成功结果的运行结果:</p><p><img src="../../images/image-20230118123733683.png" alt="image-20230118123733683"></p><h4 id="例1"><a class="markdownIt-Anchor" href="#例1"></a> 例1</h4><p>同步处理任务成功</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line"><span class="comment">// 可以主动创建promise</span></span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(()-&gt;{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    log.debug(<span class="string">"set success, {}"</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"start..."</span>);</span><br><span class="line">log.debug(<span class="string">"{}"</span>,promise.getNow()); <span class="comment">// 还没有结果</span></span><br><span class="line">log.debug(<span class="string">"{}"</span>,promise.get());</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></tbody></table></figure><h4 id="例2"><a class="markdownIt-Anchor" href="#例2"></a> 例2</h4><p>异步处理任务成功</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调，异步接收结果</span></span><br><span class="line">promise.addListener(future -&gt; {</span><br><span class="line">    <span class="comment">// 这里的 future 就是上面的 promise</span></span><br><span class="line">    log.debug(<span class="string">"{}"</span>,future.getNow());</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1000 后设置成功结果</span></span><br><span class="line">eventExecutors.execute(()-&gt;{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    log.debug(<span class="string">"set success, {}"</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"start..."</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></tbody></table></figure><h4 id="例3"><a class="markdownIt-Anchor" href="#例3"></a> 例3</h4><p>同步处理任务失败 - sync &amp; get</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">        eventExecutors.execute(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"error..."</span>);</span><br><span class="line">            log.debug(<span class="string">"set failure, {}"</span>, e.toString());</span><br><span class="line">            promise.setFailure(e);</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">"start..."</span>);</span><br><span class="line">        log.debug(<span class="string">"{}"</span>, promise.getNow());</span><br><span class="line">        promise.get(); <span class="comment">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">Exception in thread "main" java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class="line">at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class="line">at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class="line">Caused by: java.lang.RuntimeException: error...</span><br><span class="line">at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class="line">at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></tbody></table></figure><h4 id="例4"><a class="markdownIt-Anchor" href="#例4"></a> 例4</h4><p>同步处理任务失败 - await</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"error..."</span>);</span><br><span class="line">    log.debug(<span class="string">"set failure, {}"</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"start..."</span>);</span><br><span class="line">log.debug(<span class="string">"{}"</span>, promise.getNow());</span><br><span class="line">promise.await(); <span class="comment">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class="line">log.debug(<span class="string">"result {}"</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></tbody></table></figure><h4 id="例5"><a class="markdownIt-Anchor" href="#例5"></a> 例5</h4><p>异步处理任务失败</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">promise.addListener(future -&gt; {</span><br><span class="line">    log.debug(<span class="string">"result {}"</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">"error..."</span>);</span><br><span class="line">    log.debug(<span class="string">"set failure, {}"</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">"start..."</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></tbody></table></figure><h4 id="例6"><a class="markdownIt-Anchor" href="#例6"></a> 例6</h4><p>await 死锁检查</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.submit(()-&gt;{</span><br><span class="line">    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        promise.await();</span><br><span class="line">        <span class="comment">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class="line">        <span class="comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class="line">        <span class="comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) { </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"2"</span>);</span><br><span class="line">});</span><br><span class="line">eventExecutors.submit(()-&gt;{</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        promise.await();</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class="line">at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class="line">at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="34-handler-pipeline"><a class="markdownIt-Anchor" href="#34-handler-pipeline"></a> 3.4 Handler &amp; Pipeline</h3><p><strong>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</strong></p><ul><li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li><li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li></ul><p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p><p>先搞清楚顺序，服务端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1 将数据传递给下一个 handler（在这里的下一个就是h2），如果不调用，调用链会断开</span></span><br><span class="line">                    <span class="comment">// super.channelRead(ctx, msg); // 和上面的语句是一样的作用，上面的是这个内部实现</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3  会 从尾部开始触发 后续 出站处理器 的执行</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 只有向channel写入数据才会触发，没写入就不能触发</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4   是从当前节点找上一个出站处理器</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> {</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        }</span><br><span class="line">    })</span><br><span class="line">    .connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; {</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">"hello,world"</span>);</span><br><span class="line">    });</span><br></pre></td></tr></tbody></table></figure><p>服务器端打印：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></tbody></table></figure><p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p><p><img src="../../images/0008.png" alt=""></p><ul><li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul><li>如果注释掉 1 处代码，则仅会打印 1</li><li>如果注释掉 2 处代码，则仅会打印 1 2</li></ul></li><li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul><li>如果注释掉 3 处代码，则仅会打印 1 2 3</li></ul></li><li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul><li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li></ul></li><li>ctx.channel().write(msg)  <strong>VS</strong>  ctx.write(msg)<ul><li>都是触发出站处理器的执行</li><li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li><li>ctx.write(msg) 是从当前节点找上一个出站处理器</li><li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li><li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li></ul></li></ul><p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p><p><img src="../../images/0009.png" alt=""></p><p>演示<strong>EmbeddedChannel</strong>，方便debug和模拟</p><p><img src="../../images/image-20230118155525347.png" alt="image-20230118155525347"></p><h3 id="35-bytebuf"><a class="markdownIt-Anchor" href="#35-bytebuf"></a> 3.5 ByteBuf</h3><p>是对字节数据的封装</p><h4 id="1创建"><a class="markdownIt-Anchor" href="#1创建"></a> 1）创建</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>); <span class="comment">// 如果不传参，默认是256，而且是可以动态扩容的</span></span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></tbody></table></figure><p>其中 log 方法参考如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buffer)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">"read index:"</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">" write index:"</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">" capacity:"</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230118160814525.png" alt="image-20230118160814525"></p><p>演示动态扩容</p><p><img src="../../images/image-20230118160904981.png" alt="image-20230118160904981"></p><h4 id="2直接内存-vs-堆内存"><a class="markdownIt-Anchor" href="#2直接内存-vs-堆内存"></a> 2）直接内存 vs 堆内存</h4><p><strong>直接内存</strong> 分配效率低读，写效率高（直接内存使用的是系统内存，如果你比如说磁盘中读取文件时，它可以将这个数据直接入系统内存，那么这个系统内存呢，就可以用直接内存方式映射到Java内存，映射到Java中，Java里面访问的跟操作系统访问的是同一块内存，这样就可以减少一次内存复制。所以直接内存的读写效率是高于堆内存发的）；</p><p><strong>堆内存</strong> 分配效率高，读写效率高（因为堆内存要受到GC的影响，GC必然会发生一些对象的很搬迁、复制）</p><p>所以netty默认使用的是直接内存来作为ByteBuf的内存（但也可以通过使用不同的方法来选择 直接内存 or 堆内存）</p><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><h4 id="3池化-vs-非池化"><a class="markdownIt-Anchor" href="#3池化-vs-非池化"></a> 3）池化 vs 非池化</h4><p><mark>池化的最大意义在于可以重用 ByteBuf</mark>，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type={unpooled|pooled}</span><br></pre></td></tr></tbody></table></figure><ul><li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h4 id="4组成"><a class="markdownIt-Anchor" href="#4组成"></a> 4）组成</h4><p>ByteBuf 由四部分组成</p><p><img src="../../images/image-20230118192936067.png" alt="image-20230118192936067"></p><p><img src="../../images/0010.png" alt=""></p><p>最开始读写指针都在 0 位置</p><p>优势：ByteBuf从两方面进行了改进：</p><ol><li>有读、写两个指针，就不用来回切换读写模式了，只要有可写、可读的都可以执行。而ByteBuffer是要读就切换到读模式，要写切换到写模式，</li><li>可以动态扩容。不会因为开始容量计算失误计算少了而导致因为内存不够报异常，ByteBuf只要在最大容量内（ &lt;= 整数的最大值），可扩容部分会根据实际写入的字节进行扩容</li></ol><h4 id="5写入"><a class="markdownIt-Anchor" href="#5写入"></a> 5）写入</h4><p>方法列表，省略一些不重要的方法</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td>用一字节 01|00 代表 true|false</td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 ByteBuffer</td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td></td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li><li>网络传输，默认习惯是 Big Endian</li></ul></blockquote><p>先写入 4 个字节</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>再写入一个 int 整数，也是 4 个字节</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>结果是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p><h4 id="6扩容"><a class="markdownIt-Anchor" href="#6扩容"></a> 6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>扩容规则是</p><ul><li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li><li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2<sup>10=1024（2</sup>9=512 已经不够了）</li><li>扩容不能超过 max capacity 会报错</li></ul><p>结果是</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><h4 id="7读取"><a class="markdownIt-Anchor" href="#7读取"></a> 7）读取</h4><p>例如读了 4 次，每次一个字节</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>如果需要重复读取 int 整数 5，怎么办？</p><p>可以在 read 前先做个标记 mark</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>这时要重复读取的话，重置到标记位置 reset</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></tbody></table></figure><p>这时</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p><h4 id="8retain-release"><a class="markdownIt-Anchor" href="#8retain-release"></a> 8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><blockquote><p>回收内存的源码实现，请关注下面方法的不同实现</p><p><code>protected abstract void deallocate()</code></p></blockquote><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><p>谁来负责 release 呢？</p><p>不是我们想象的（一般情况下）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">    buf.release();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p><ul><li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li><li>入站 ByteBuf 处理原则<ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li><li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li><li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li><li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li>出站 ByteBuf 处理原则<ul><li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li></ul></li><li>异常处理原则<ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li></ul></li></ul><p>TailContext 释放未处理消息逻辑</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">"Discarded inbound message {} that reached at the tail of the pipeline. "</span> +</span><br><span class="line">            <span class="string">"Please check your pipeline configuration."</span>, msg);</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>具体代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> {</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) {</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="9slice"><a class="markdownIt-Anchor" href="#9slice"></a> 9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p><p><img src="../../images/0011.png" alt=""></p><p>例，原始 ByteBuf 进行一些初始操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>});</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，<strong>切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>这时的 slice 不受影响，因为它有独立的读写指针</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>如果 slice 的内容发生了更改</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);   <span class="comment">// 指针位置2的数据设置为5</span></span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>这时，<strong>原始 ByteBuf 也会受影响，因为<font color="red">底层都是同一块内存</font></strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230118205304770.png" alt="image-20230118205304770"></p><p><strong>retain()</strong></p><p><img src="../../images/image-20230118210601043.png" alt="image-20230118210601043"></p><h4 id="10duplicate"><a class="markdownIt-Anchor" href="#10duplicate"></a> 10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p><p><img src="../../images/0012.png" alt=""></p><h4 id="11copy"><a class="markdownIt-Anchor" href="#11copy"></a> 11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p><h4 id="12compositebytebuf"><a class="markdownIt-Anchor" href="#12compositebytebuf"></a> 12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p><p>有两个 ByteBuf 如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>});</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>});</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p><p>方法1：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT</span><br><span class="line">    .buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>这种方法好不好？回答是不太好，因为进行了数据的<strong>内存复制操作</strong></p><p>方法2：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></tbody></table></figure><p>结果是一样的</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p><ul><li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li><li>缺点，复杂了很多，多次操作会带来性能的损耗</li></ul><h4 id="13unpooled"><a class="markdownIt-Anchor" href="#13unpooled"></a> 13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p><p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>});</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>});</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>}, <span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>});</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><h4 id="bytebuf-优势"><a class="markdownIt-Anchor" href="#bytebuf-优势"></a> 💡 ByteBuf 优势</h4><ul><li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li><li>可以自动扩容</li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li></ul><h2 id="4-双向通信"><a class="markdownIt-Anchor" href="#4-双向通信"></a> 4. 双向通信</h2><h3 id="41-练习"><a class="markdownIt-Anchor" href="#41-练习"></a> 4.1 练习</h3><p>实现一个 echo server</p><p>编写 server</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>(){</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                    <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }).bind(<span class="number">8080</span>);</span><br></pre></td></tr></tbody></table></figure><p>编写 client</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> {</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    }).connect(<span class="string">"127.0.0.1"</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; {</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"q"</span>.equals(line)) {</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    }</span><br><span class="line">}).start();</span><br></pre></td></tr></tbody></table></figure><h3 id="读和写的误解"><a class="markdownIt-Anchor" href="#读和写的误解"></a> 💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p><p>例如</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="comment">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"localhost"</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) {</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）nio-Files-walkFileTree 详细相关操作和演示代码，如删除、拷贝（多级）文件目录等</title>
      <link href="/2023/01/15/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/%EF%BC%88nio%EF%BC%89Files%20%E8%AF%A6%E7%BB%86%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E5%88%A0%E9%99%A4%E3%80%81%E6%8B%B7%E8%B4%9D%EF%BC%88%E5%A4%9A%E7%BA%A7%EF%BC%89%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AD%89/"/>
      <url>/2023/01/15/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/%EF%BC%88nio%EF%BC%89Files%20%E8%AF%A6%E7%BB%86%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%92%8C%E6%BC%94%E7%A4%BA%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%A6%82%E5%88%A0%E9%99%A4%E3%80%81%E6%8B%B7%E8%B4%9D%EF%BC%88%E5%A4%9A%E7%BA%A7%EF%BC%89%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AD%89/</url>
      
        <content type="html"><![CDATA[<h3 id="files"><a class="markdownIt-Anchor" href="#files"></a> Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></tbody></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1"</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1/d2"</span>);  <span class="comment">// 即使d1目录不能存在也会创建出来</span></span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></tbody></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/target.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);  <span class="comment">// 从source 拷贝到 target</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></tbody></table></figure><p>要拷贝文件的话，就用这个这个 copy或是 transferTo，这两个方法都是效率比较高的</p><p>移动文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></tbody></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/target.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录（只能删除一个空目录）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1"</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"C:\\Program Files\\Java\\jdk1.8.0_91"</span>);   <span class="comment">// 遍历的其实文件</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">//                       这里的代码模式用到了访问者模式，你要做的操作就通过访问者来加入你的逻辑即可</span></span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException {</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();  <span class="comment">// +1   </span></span><br><span class="line">            <span class="comment">// 注意这里是匿名内部类里的，所以不能用 在外面的 int 来 ++，匿名类要应用外部局部变量实质是个常量来的，是不能改变它的值的</span></span><br><span class="line">            <span class="comment">// 要用要用累加器来计算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException {</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>统计 jar 的数目</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"C:\\Program Files\\Java\\jdk1.8.0_91"</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">".jar"</span>)) {</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></tbody></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"d:\\a"</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="️-删除很危险"><a class="markdownIt-Anchor" href="#️-删除很危险"></a> ⚠️ 删除很危险</h4><blockquote><p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p></blockquote><p>拷贝多级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">"F:\\aaaa"</span>;     <span class="comment">// 被拷贝的原始目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">"F:\\bbbb"</span>;</span><br><span class="line">        <span class="comment">//          起始路径 Paths.get(source)返回的是一个Stream流，所以我们可以用Stream流对应的一些 api 来进行操作</span></span><br><span class="line">        <span class="comment">//                                    path : 就是遍历到的文件目录</span></span><br><span class="line">        Files.walk(Paths.get(source)).forEach(path -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">                System.out.println( <span class="string">" 遍历到的 =====》"</span> +  path );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// targerName就是最终要操作的目录</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 source 目录被替换成target目录，比如 source = F:\\aaaa, target = "F:\\bbbb"</span></span><br><span class="line"><span class="comment">                 那么再拷贝 D:\\aaaa\\bb.txt时，就需要替换成 D:\\bbbb\\bb.txt，即source部分被替换成target</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source, target);</span><br><span class="line">                System.out.println( <span class="string">"替换后的 ------&gt;"</span> +  targetName );</span><br><span class="line">                <span class="comment">// 是目录</span></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path)) {</span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 是普通文件</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) {</span><br><span class="line">                    <span class="comment">// 把</span></span><br><span class="line">                    Files.copy(path, Paths.get(targetName));</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println( <span class="string">"花时 ： "</span> + (end - start)+ <span class="string">"ms"</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时输出：</p><p><img src="../../../images/image-20230114011523888.png" alt="image-20230114011523888"></p><p>拷贝出了bbbb</p><p><img src="../../../images/image-20230114011547604.png" alt="image-20230114011547604"></p>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）nio-Selector-处理消息边界-附件与扩容</title>
      <link href="/2023/01/15/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/nio-Selector-%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C-%E9%99%84%E4%BB%B6%E4%B8%8E%E6%89%A9%E5%AE%B9/"/>
      <url>/2023/01/15/Netty/%E7%AC%94%E8%AE%B0%E6%8A%BD%E5%8F%96/nio-Selector-%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C-%E9%99%84%E4%BB%B6%E4%B8%8E%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="️-不处理边界的问题"><a class="markdownIt-Anchor" href="#️-不处理边界的问题"></a> ⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> in.read(arr);</span><br><span class="line">                <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, read));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"localhost"</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> max.getOutputStream();</span><br><span class="line">        out.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">        max.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hell</span><br><span class="line">owor</span><br><span class="line">ld�</span><br><span class="line">�好</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为什么？</p><h4 id="处理消息的边界-附件与扩容"><a class="markdownIt-Anchor" href="#处理消息的边界-附件与扩容"></a> 处理消息的边界 &amp; 附件与扩容</h4><p><img src="../../../images/0023.png" alt=""></p><p><img src="../../../images/image-20230114233714137.png" alt="image-20230114233714137"></p><ul><li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>另一种思路是按分隔符拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></tbody></table></figure><p>服务器端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> {</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) {</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">'\n'</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) {</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            }</span><br><span class="line">            debugAll(target);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">"sscKey:{}"</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">"key: {}"</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) { <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment附件</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上，让每一个selectionKey具有自己的ByteBuffer</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">"{}"</span>, sc);</span><br><span class="line">                log.debug(<span class="string">"scKey:{}"</span>, scKey);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) { <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) {</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) {</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer); <span class="comment">// 将扩容的ByteBuffer作为新的绑定的附件，覆盖旧的附件</span></span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode("hello\nworld\n"));</span></span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">"0123\n456789abcdef"</span>));</span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">"0123456789abcdef3333\n"</span>));</span><br><span class="line">System.in.read();</span><br></pre></td></tr></tbody></table></figure><p>测试结果图：</p><p><img src="../../../images/image-20230115002433051.png" alt="image-20230115002433051"></p><h4 id="bytebuffer-大小分配"><a class="markdownIt-Anchor" href="#bytebuffer-大小分配"></a> ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（Netty）1-nio</title>
      <link href="/2023/01/14/Netty/Netty01-nio/"/>
      <url>/2023/01/14/Netty/Netty01-nio/</url>
      
        <content type="html"><![CDATA[<h1 id="一-nio-基础"><a class="markdownIt-Anchor" href="#一-nio-基础"></a> 一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p><h2 id="1-三大组件"><a class="markdownIt-Anchor" href="#1-三大组件"></a> 1. 三大组件</h2><h3 id="11-channel-buffer"><a class="markdownIt-Anchor" href="#11-channel-buffer"></a> 1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">channel --&gt; buffer</span><br><span class="line">buffer --&gt; channel</span><br></pre></td></tr></tbody></table></figure><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>buffer 则用来缓冲读写数据，常见的 buffer 有</p><ul><li>ByteBuffer<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul><h3 id="12-selector"><a class="markdownIt-Anchor" href="#12-selector"></a> 1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p><h4 id="多线程版设计"><a class="markdownIt-Anchor" href="#多线程版设计"></a> 多线程版设计</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">t1(thread) --&gt; s1(socket1)</span><br><span class="line">t2(thread) --&gt; s2(socket2)</span><br><span class="line">t3(thread) --&gt; s3(socket3)</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="️-多线程版缺点"><a class="markdownIt-Anchor" href="#️-多线程版缺点"></a> ⚠️ 多线程版缺点</h4><ul><li>内存占用高</li><li>线程上下文切换成本高</li><li>只适合连接数少的场景</li></ul><h4 id="线程池版设计"><a class="markdownIt-Anchor" href="#线程池版设计"></a> 线程池版设计</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">t4(thread) --&gt; s4(socket1)</span><br><span class="line">t5(thread) --&gt; s5(socket2)</span><br><span class="line">t4(thread) -.-&gt; s6(socket3)</span><br><span class="line">t5(thread) -.-&gt; s7(socket4)</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><h4 id="️-线程池版缺点"><a class="markdownIt-Anchor" href="#️-线程池版缺点"></a> ⚠️ 线程池版缺点</h4><ul><li>阻塞模式下，线程仅能处理一个 socket 连接</li><li>仅适合短连接场景</li></ul><h4 id="selector-版设计"><a class="markdownIt-Anchor" href="#selector-版设计"></a> selector 版设计</h4><p>selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p><h2 id="2-bytebuffer"><a class="markdownIt-Anchor" href="#2-bytebuffer"></a> 2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></tbody></table></figure><p>使用 FileChannel 来读取文件内容</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">"helloword/data.txt"</span>, <span class="string">"rw"</span>)) {</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">do</span> {</span><br><span class="line">                <span class="comment">// 向 buffer 写入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">"读到字节数：{}"</span>, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 切换 buffer 读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) {</span><br><span class="line">                    log.debug(<span class="string">"{}"</span>, (<span class="type">char</span>)buffer.get());</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 切换 buffer 写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            } <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></tbody></table></figure><h3 id="21-bytebuffer-正确使用姿势"><a class="markdownIt-Anchor" href="#21-bytebuffer-正确使用姿势"></a> 2.1  ByteBuffer 正确使用姿势</h3><ol><li><p>向 buffer 写入数据，例如调用 channel.read(buffer)</p></li><li><p>调用 flip() 切换至<strong>读模式</strong></p></li><li><p>从 buffer 读取数据，例如调用 buffer.get()</p></li><li><p>调用 clear() 或 compact() 切换至<strong>写模式</strong></p><ol><li>clear（是从头开始写）</li><li>compact（不一定是从头开始写）</li></ol></li><li><p>重复 1~4 步骤</p></li></ol><h3 id="22-bytebuffer-结构"><a class="markdownIt-Anchor" href="#22-bytebuffer-结构"></a> 2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p><ul><li>capacity</li><li>position ：读写指针</li><li>limit</li></ul><p>一开始</p><p><img src="../../images/0021.png" alt=""></p><p><strong>写模式下，position 是写入位置，limit 等于容量</strong>，下图表示写入了 4 个字节后的状态</p><p><img src="../../images/0018.png" alt=""></p><p><strong>flip</strong> 动作发生后，<strong>position 切换为读取位置，limit 切换为读取限制</strong></p><p><img src="../../images/0019.png" alt=""></p><p>读取 4 个字节后，状态</p><p><img src="../../images/0020.png" alt=""></p><p><strong>clear</strong> 动作发生后（读模式 --&gt; 写模式，且是从头开始写），状态</p><p><img src="../../images/0021.png" alt=""></p><p><strong>compact</strong> 方法，是把未读完的部分向前压缩，然后切换至写模式（读模式 --&gt; 写模式，不是从头开始写）</p><p><img src="../../images/0022.png" alt=""></p><h4 id="调试工具类"><a class="markdownIt-Anchor" href="#调试工具类"></a> 💡 调试工具类</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferUtil</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS = <span class="string">"0123456789abcdef"</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) {</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> HEXPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) {</span><br><span class="line">                buf.append(<span class="string">"   "</span>);</span><br><span class="line">            }</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) {</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">'|'</span>);</span><br><span class="line">            buf.append(<span class="string">'|'</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) {</span><br><span class="line">            BYTE2HEX[i] = <span class="string">' '</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> BYTEPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) {</span><br><span class="line">                buf.append(<span class="string">' '</span>);</span><br><span class="line">            }</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) {</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) {</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">'.'</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                BYTE2CHAR[i] = (<span class="type">char</span>) i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugAll</span><span class="params">(ByteBuffer buffer)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldlimit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">"+--------+-------------------- all ------------------------+----------------+"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"position: [%d], limit: [%d]\n"</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugRead</span><span class="params">(ByteBuffer buffer)</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">"+--------+-------------------- read -----------------------+----------------+"</span>);</span><br><span class="line">        System.out.printf(<span class="string">"position: [%d], limit: [%d]\n"</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="type">int</span> offset, <span class="type">int</span> length)</span> {</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(</span><br><span class="line">                    <span class="string">"expected: "</span> + <span class="string">"0 &lt;= offset("</span> + offset + <span class="string">") &lt;= offset + length("</span> + length</span><br><span class="line">                            + <span class="string">") &lt;= "</span> + <span class="string">"buf.capacity("</span> + buf.capacity() + <span class="string">')'</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">"         +-------------------------------------------------+"</span> +</span><br><span class="line">                        NEWLINE + <span class="string">"         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |"</span> +</span><br><span class="line">                        NEWLINE + <span class="string">"+--------+-------------------------------------------------+----------------+"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fullRows</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; fullRows; row++) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) {</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            }</span><br><span class="line">            dump.append(<span class="string">" |"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) {</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            }</span><br><span class="line">            dump.append(<span class="string">'|'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) {</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            }</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">" |"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) {</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            }</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">'|'</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">"+--------+-------------------------------------------------+----------------+"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="type">int</span> row, <span class="type">int</span> rowStartIndex)</span> {</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) {</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">'|'</span>);</span><br><span class="line">            dump.append(<span class="string">'|'</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> {</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="23-bytebuffer-常见方法"><a class="markdownIt-Anchor" href="#23-bytebuffer-常见方法"></a> 2.3 ByteBuffer 常见方法</h3><h4 id="分配空间"><a class="markdownIt-Anchor" href="#分配空间"></a> 分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Bytebuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230113165252827.png" alt="image-20230113165252827"></p><h4 id="向-buffer-写入数据"><a class="markdownIt-Anchor" href="#向-buffer-写入数据"></a> 向 buffer 写入数据</h4><p>有两种办法</p><ul><li>调用 channel 的 read 方法</li><li>调用 buffer 自己的 put 方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br></pre></td></tr></tbody></table></figure><p>和</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></tbody></table></figure><h4 id="从-buffer-读取数据"><a class="markdownIt-Anchor" href="#从-buffer-读取数据"></a> 从 buffer 读取数据</h4><p>同样有两种办法</p><ul><li>调用 channel 的 write 方法</li><li>调用 buffer 自己的 get 方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br></pre></td></tr></tbody></table></figure><p>和</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></tbody></table></figure><p>get 方法会让 position 读指针向后走，如果想重复读取数据</p><ul><li>可以调用 rewind 方法将 position 重新置为 0</li><li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li></ul><p><img src="../../images/image-20230113165811123.png" alt="image-20230113165811123"></p><p><img src="../../images/image-20230113170124305.png" alt="image-20230113170124305"></p><h4 id="mark-和-reset"><a class="markdownIt-Anchor" href="#mark-和-reset"></a> mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p><blockquote><p><strong>注意</strong></p><p>rewind 和 flip 都会清除 mark 位置</p></blockquote><p><img src="../../images/image-20230113170016928.png" alt="image-20230113170016928"></p><h4 id="字符串与-bytebuffer-互转"><a class="markdownIt-Anchor" href="#字符串与-bytebuffer-互转"></a> 字符串与 ByteBuffer 互转</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">"你好"</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> Charset.forName(<span class="string">"utf-8"</span>).encode(<span class="string">"你好"</span>);</span><br><span class="line"></span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"></span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString());</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">class java.nio.HeapCharBuffer</span><br><span class="line">你好</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230113170555113.png" alt="image-20230113170555113"></p><p>Charset :</p><p><img src="../../images/image-20230113172913377.png" alt="image-20230113172913377"></p><p>wrap</p><p><img src="../../images/image-20230113173130588.png" alt="image-20230113173130588"></p><p>decode : 可以将ByteBuffer --&gt; CharBuffer</p><p><img src="../../images/image-20230113174043628.png" alt="image-20230113174043628"></p><h4 id="️-buffer-的线程安全"><a class="markdownIt-Anchor" href="#️-buffer-的线程安全"></a> ⚠️ Buffer 的线程安全</h4><blockquote><p>Buffer 是<strong>非线程安全的</strong></p></blockquote><h3 id="24-scattering-reads分散读"><a class="markdownIt-Anchor" href="#24-scattering-reads分散读"></a> 2.4 Scattering Reads（分散读）</h3><p>分散读取，有一个文本文件 3parts.txt</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></tbody></table></figure><p>使用如下方式读取，可以将数据填充至多个 buffer</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">"helloword/3parts.txt"</span>, <span class="string">"rw"</span>)) {</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">a</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">b</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">c</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]{a, b, c});</span><br><span class="line">    a.flip();</span><br><span class="line">    b.flip();</span><br><span class="line">    c.flip();</span><br><span class="line">    debug(a);</span><br><span class="line">    debug(b);</span><br><span class="line">    debug(c);</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6f 6e 65                                        |one             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 77 6f                                        |two             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>运用分散读集中写，可以减少数据在ByteBuffer之间的一个拷贝复制次数，这样可以变现的提高效率</p><h3 id="25-gathering-writes集中写"><a class="markdownIt-Anchor" href="#25-gathering-writes集中写"></a> 2.5 Gathering Writes（集中写）</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">"helloword/3parts.txt"</span>, <span class="string">"rw"</span>)) {</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">d</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">e</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    d.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'r'</span>});</span><br><span class="line">    e.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]{<span class="string">'f'</span>, <span class="string">'i'</span>, <span class="string">'v'</span>, <span class="string">'e'</span>});</span><br><span class="line">    d.flip();</span><br><span class="line">    e.flip();</span><br><span class="line">    debug(d);</span><br><span class="line">    debug(e);</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]{d, e});</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 69 76 65                                     |five            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>文件内容</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onetwothreefourfive</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230113221640043.png" alt="image-20230113221640043"></p><h3 id="26-练习"><a class="markdownIt-Anchor" href="#26-练习"></a> 2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为：</p><ul><li>Hello,world\n</li><li>I’m zhangsan\n</li><li>How are you?\n</li></ul><p>变成了下面的两个 byteBuffer ( 黏包【两个消息黏在一起了】，半包【消息被截断了】 )</p><ul><li>Hello,world\nI’m zhangsan\nHo</li><li>w are you?\n</li></ul><p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p><p><img src="../../images/image-20230113225033853.png" alt="image-20230113225033853"></p><p>这种方法其实缺点的，比较慢，因为要遍历一个一个字节去判断，所以比较慢。是有其他更好的方法的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">source</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">"Hello,world\nI'm zhangsan\nHo"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">"w are you?\nhaha!\n"</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> {</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLimit</span> <span class="operator">=</span> source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldLimit; i++) {</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">'\n'</span>) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            debugAll(target);</span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 这里不同用clear，因为clear会让position--&gt;0，可能导致由的数据丢失</span></span><br><span class="line">    <span class="comment">// compact是把未读完的部分向前压缩</span></span><br><span class="line">    source.compact();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>ps:</p><p>黏包的原因：主要是效率，为了效率高，一次性将多小数据发送给服务器，从而导致可能产生 黏包现象</p><p>半包的原因：空间问题，一次性只能接收这么大的数据，剩余的数据第二次接收，从而可能导致有的数据被截断了</p><h2 id="3-文件编程"><a class="markdownIt-Anchor" href="#3-文件编程"></a> 3. 文件编程</h2><h3 id="31-filechannel"><a class="markdownIt-Anchor" href="#31-filechannel"></a> 3.1 FileChannel</h3><h4 id="️-filechannel-工作模式"><a class="markdownIt-Anchor" href="#️-filechannel-工作模式"></a> ⚠️ FileChannel 工作模式</h4><blockquote><p>FileChannel 只能工作在阻塞模式下（不可以根Selector一起使用）</p></blockquote><h4 id="获取"><a class="markdownIt-Anchor" href="#获取"></a> 获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p><ul><li>通过 FileInputStream 获取的 channel 只能读</li><li>通过 FileOutputStream 获取的 channel 只能写</li><li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li></ul><h4 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></tbody></table></figure><h4 id="写入"><a class="markdownIt-Anchor" href="#写入"></a> 写入</h4><p>写入的正确姿势如下， SocketChannel</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) {</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p><h4 id="关闭"><a class="markdownIt-Anchor" href="#关闭"></a> 关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p><h4 id="位置"><a class="markdownIt-Anchor" href="#位置"></a> 位置</h4><p>获取当前位置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></tbody></table></figure><p>设置当前位置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></tbody></table></figure><p>设置当前位置时，如果设置为文件的末尾</p><ul><li>这时读取会返回 -1</li><li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li></ul><h4 id="大小"><a class="markdownIt-Anchor" href="#大小"></a> 大小</h4><p>使用 size 方法获取文件的大小</p><h4 id="强制写入"><a class="markdownIt-Anchor" href="#强制写入"></a> 强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p><h3 id="32-两个-channel-传输数据"><a class="markdownIt-Anchor" href="#32-两个-channel-传输数据"></a> 3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">"helloword/data.txt"</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">"helloword/to.txt"</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">) {</span><br><span class="line">    <span class="comment">// 效率高，底层会利用操作系统的 零拷贝 进行优化，这个方法一次性传输的数据的上限是 2g </span></span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">} <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">"transferTo 用时："</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transferTo 用时：8.2011</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230113234155471.png" alt="image-20230113234155471"></p><p>from.transferTo（） 这个方法 效率高，底层会利用操作系统的 零拷贝 进行优化，这个方法一次性传输的数据的上限是 2g</p><p>超过 2g 大小的文件传输，需要用循环</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileChannelTransferTo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">"data.txt"</span>).getChannel();</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"to.txt"</span>).getChannel();</span><br><span class="line">        ) {</span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="comment">// left 变量代表还剩余多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size; left &gt; <span class="number">0</span>; ) {</span><br><span class="line">                System.out.println(<span class="string">"position:"</span> + (size - left) + <span class="string">" left:"</span> + left);</span><br><span class="line">                <span class="comment">// from.transferTo（）返回的是实际传输的字节数</span></span><br><span class="line">                left -= from.transferTo((size - left), left, to);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实际传输一个超大文件 的执行输出如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">position:0 left:7769948160</span><br><span class="line">position:2147483647 left:5622464513</span><br><span class="line">position:4294967294 left:3474980866</span><br><span class="line">position:6442450941 left:1327497219</span><br></pre></td></tr></tbody></table></figure><h3 id="33-path"><a class="markdownIt-Anchor" href="#33-path"></a> 3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p><ul><li>Path 用来表示文件路径</li><li>Paths 是工具类，用来获取 Path 实例</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"1.txt"</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"d:\\1.txt"</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"d:/1.txt"</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"projects"</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></tbody></table></figure><ul><li><code>.</code> 代表了当前路径</li><li><code>..</code> 代表了上一级路径</li></ul><p>例如目录结构如下</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d:</span><br><span class="line">|- data</span><br><span class="line">|- projects</span><br><span class="line">|- a</span><br><span class="line">|- b</span><br></pre></td></tr></tbody></table></figure><p>代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"d:\\data\\projects\\a\\..\\b"</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></tbody></table></figure><p>会输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></tbody></table></figure><h3 id="34-files"><a class="markdownIt-Anchor" href="#34-files"></a> 3.4 Files</h3><p>检查文件是否存在</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></tbody></table></figure><p>创建一级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1"</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目录已存在，会抛异常 FileAlreadyExistsException</li><li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li></ul><p>创建多级目录用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1/d2"</span>);  <span class="comment">// 即使d1目录不能存在也会创建出来</span></span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></tbody></table></figure><p>拷贝文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/target.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);  <span class="comment">// 从source 拷贝到 target</span></span><br></pre></td></tr></tbody></table></figure><ul><li>如果文件已存在，会抛异常 FileAlreadyExistsException</li></ul><p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></tbody></table></figure><p>要拷贝文件的话，就用这个这个 copy或是 transferTo，这两个方法都是效率比较高的</p><p>移动文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></tbody></table></figure><ul><li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li></ul><p>删除文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/target.txt"</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果文件不存在，会抛异常 NoSuchFileException</li></ul><p>删除目录（只能删除一个空目录）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">"helloword/d1"</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></tbody></table></figure><ul><li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li></ul><p>遍历目录文件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"C:\\Program Files\\Java\\jdk1.8.0_91"</span>);   <span class="comment">// 遍历的其实文件</span></span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="comment">//                       这里的代码模式用到了访问者模式，你要做的操作就通过访问者来加入你的逻辑即可</span></span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException {</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();  <span class="comment">// +1   </span></span><br><span class="line">            <span class="comment">// 注意这里是匿名内部类里的，所以不能用 在外面的 int 来 ++，匿名类要应用外部局部变量实质是个常量来的，是不能改变它的值的</span></span><br><span class="line">            <span class="comment">// 要用要用累加器来计算</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException {</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>统计 jar 的数目</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"C:\\Program Files\\Java\\jdk1.8.0_91"</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">".jar"</span>)) {</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></tbody></table></figure><p>删除多级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">"d:\\a"</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;(){</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException {</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h4 id="️-删除很危险"><a class="markdownIt-Anchor" href="#️-删除很危险"></a> ⚠️ 删除很危险</h4><blockquote><p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p></blockquote><p>拷贝多级目录</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">"F:\\aaaa"</span>;     <span class="comment">// 被拷贝的原始目录</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">"F:\\bbbb"</span>;</span><br><span class="line">        <span class="comment">//          起始路径 Paths.get(source)返回的是一个Stream流，所以我们可以用Stream流对应的一些 api 来进行操作</span></span><br><span class="line">        <span class="comment">//                                    path : 就是遍历到的文件目录</span></span><br><span class="line">        Files.walk(Paths.get(source)).forEach(path -&gt; {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line"></span><br><span class="line">                System.out.println( <span class="string">" 遍历到的 =====》"</span> +  path );</span><br><span class="line"></span><br><span class="line">                <span class="comment">// targerName就是最终要操作的目录</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 source 目录被替换成target目录，比如 source = F:\\aaaa, target = "F:\\bbbb"</span></span><br><span class="line"><span class="comment">                 那么再拷贝 D:\\aaaa\\bb.txt时，就需要替换成 D:\\bbbb\\bb.txt，即source部分被替换成target</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source, target);</span><br><span class="line">                System.out.println( <span class="string">"替换后的 ------&gt;"</span> +  targetName );</span><br><span class="line">                <span class="comment">// 是目录</span></span><br><span class="line">                <span class="keyword">if</span> (Files.isDirectory(path)) {</span><br><span class="line">                    Files.createDirectory(Paths.get(targetName));</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 是普通文件</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) {</span><br><span class="line">                    <span class="comment">// 把</span></span><br><span class="line">                    Files.copy(path, Paths.get(targetName));</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println( <span class="string">"花时 ： "</span> + (end - start)+ <span class="string">"ms"</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行时输出：</p><p><img src="../../images/image-20230114011523888.png" alt="image-20230114011523888"></p><p>拷贝出了bbbb</p><p><img src="../../images/image-20230114011547604.png" alt="image-20230114011547604"></p><h2 id="4-网络编程"><a class="markdownIt-Anchor" href="#4-网络编程"></a> 4. 网络编程</h2><h3 id="41-非阻塞-vs-阻塞"><a class="markdownIt-Anchor" href="#41-非阻塞-vs-阻塞"></a> 4.1 非阻塞 vs 阻塞</h3><h4 id="阻塞"><a class="markdownIt-Anchor" href="#阻塞"></a> 阻塞</h4><ul><li>阻塞模式下，相关方法都会导致线程暂停<ul><li>ServerSocketChannel.accept 会在<strong>没有连接建立时</strong>让线程暂停</li><li>SocketChannel.read 会在<strong>没有数据可读时</strong>让线程暂停</li><li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li></ul></li><li>单线程下，阻塞方法之间相互影响（比如accept阻塞就不能执行read，read阻塞就不能执行accept了），几乎不能正常工作，需要多线程支持</li><li>但多线程下，有新的问题，体现在以下方面<ul><li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li><li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li></ul></li></ul><p>服务器端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器对象</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">"connecting..."</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行（要有新的连接建立）</span></span><br><span class="line">    log.debug(<span class="string">"connected... {}"</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) {</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">"before read... {}"</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行（因为客户端并没有向服务端发送数据，要读入数据而又没有数据，就会继续干等）</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">"after read...{}"</span>, channel);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">"waiting..."</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>ps：这里用到了debug模式下的一个功能，通过写一个表达式来传入数据</strong></p><p><img src="../../images/image-20230114100049243.png" alt="image-20230114100049243"></p><p><img src="../../images/image-20230114100425589.png" alt="image-20230114100425589"></p><p><strong>ps：介绍一个idea的功能，idea中可以根据客户端运行多次，设置操作如下：</strong></p><p><img src="../../images/image-20230114101349770.png" alt="image-20230114101349770"></p><p><img src="../../images/image-20230114101439426.png" alt="image-20230114101439426"></p><h4 id="非阻塞"><a class="markdownIt-Anchor" href="#非阻塞"></a> 非阻塞</h4><ul><li>非阻塞模式下，相关方法都会不会让线程暂停<ul><li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li><li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept</li><li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li></ul></li><li>但<strong>非阻塞模式下</strong>，即使没有连接建立，和可读数据，线程仍然在不断运行，白白<strong>浪费了 cpu</strong>（这种非阻塞模式下，在实际开发中是不会用的）</li><li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li></ul><p>服务器端，客户端代码不变，主要添加了代码：</p><p>ssc.configureBlocking(false);  // ServerSocketChannel 切换成 非阻塞模式（会让 accept 变成非阻塞）</p><p>sc.configureBlocking(false);  // 将SocketChannel切换成 非阻塞模式，会将SocketChannel的read方法变成非阻塞</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// ServerSocketChannel 切换成 非阻塞模式（会让 accept 变成非阻塞）</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) {</span><br><span class="line">        log.debug(<span class="string">"connected... {}"</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 将SocketChannel切换成 非阻塞模式，会将SocketChannel的read方法变成非阻塞</span></span><br><span class="line">        channels.add(sc);  <span class="comment">// sc != null 才加入连接集合</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) {</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) {</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">"after read...{}"</span>, channel);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230114102249572.png" alt="image-20230114102249572"></p><p><img src="../../images/image-20230114103041182.png" alt="image-20230114103041182"></p><h4 id="多路复用"><a class="markdownIt-Anchor" href="#多路复用"></a> 多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为<strong>多路复用</strong></p><p>（当有事件发生了Selector才会让你的线程继续向下运行，如果没有事件发生Selector是阻塞的，不会让你的线程白忙活）</p><ul><li>多路复用仅针对网络 IO，而普通文件 IO 没法利用多路复用</li><li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul><li>有可连接事件时才去连接</li><li>有可读事件才去读取</li><li>有可写事件才去写入<ul><li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li></ul></li></ul></li></ul><h3 id="42-selector"><a class="markdownIt-Anchor" href="#42-selector"></a> 4.2 Selector</h3><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph selector 版</span><br><span class="line">thread --&gt; selector</span><br><span class="line">selector --&gt; c1(channel)</span><br><span class="line">selector --&gt; c2(channel)</span><br><span class="line">selector --&gt; c3(channel)</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p>好处</p><ul><li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li><li>让这个线程能够被充分利用</li><li>节约了线程的数量</li><li>减少了线程上下文切换</li></ul><h4 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></tbody></table></figure><h4 id="绑定-channel-事件"><a class="markdownIt-Anchor" href="#绑定-channel-事件"></a> 绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></tbody></table></figure><ul><li>channel 必须工作在非阻塞模式</li><li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li><li>绑定的事件类型可以有<ul><li>connect - 客户端连接成功时触发</li><li>accept - 服务器端成功接受连接时触发</li><li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li><li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li></ul></li></ul><h4 id="监听-channel-事件"><a class="markdownIt-Anchor" href="#监听-channel-事件"></a> 监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p><p>方法1，阻塞，直到绑定事件发生 （即：没有事件时就一直阻塞）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></tbody></table></figure><p>方法2，阻塞，直到绑定事件发生，或是超时（就恢复非阻塞）（时间单位为 ms）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></tbody></table></figure><p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></tbody></table></figure><h4 id="select-何时不阻塞"><a class="markdownIt-Anchor" href="#select-何时不阻塞"></a> 💡 select 何时不阻塞</h4><blockquote><ul><li>事件发生时<ul><li>客户端发起连接请求，会触发 accept 事件</li><li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li><li>channel 可写，会触发 write 事件</li><li>在 linux 下 nio bug 发生时</li></ul></li><li>调用 selector.wakeup()</li><li>调用 selector.close()</li><li>selector 所在线程 interrupt</li></ul></blockquote><h3 id="43-处理-accept-事件"><a class="markdownIt-Anchor" href="#43-处理-accept-事件"></a> 4.3 处理 accept 事件</h3><p>客户端代码为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>)) {</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>服务器端代码为</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) {</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">"select count: {}"</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) {</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">"{}"</span>, sc);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20230114111232980.png" alt="image-20230114111232980"></p><h4 id="事件发生后能否不处理"><a class="markdownIt-Anchor" href="#事件发生后能否不处理"></a> 💡 事件发生后能否不处理</h4><blockquote><p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p></blockquote><p>事件取消：key.cancel();  （即 SelectionKey中的cancel方法）</p><h3 id="44-处理-read-事件"><a class="markdownIt-Anchor" href="#44-处理-read-事件"></a> 4.4 处理 read 事件</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) {</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">"select count: {}"</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) {</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                }</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">"连接已建立: {}"</span>, sc);</span><br><span class="line">                    } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) {</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        } <span class="keyword">else</span> {</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>开启两个客户端，修改一下发送文字，输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><h4 id="为何要-iterremove"><a class="markdownIt-Anchor" href="#为何要-iterremove"></a> 💡 为何要 iter.remove()</h4><blockquote><p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p><ul><li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey</li><li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li></ul></blockquote><p><img src="../../images/image-20230114113039615.png" alt="image-20230114113039615"></p><h4 id="cancel-的作用"><a class="markdownIt-Anchor" href="#cancel-的作用"></a> 💡 cancel 的作用</h4><blockquote><p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p></blockquote><p>不能因为一个客户端断开了，导致服务器停了，所以我们需要把异常捉住</p><p><img src="../../images/image-20230114222711520.png" alt="image-20230114222711520"></p><p>无论<strong>客户端</strong>是正常<strong>断开</strong>（ sc.close() ）还是异常断开（直接停掉客户端），<strong>它总会产生一个<mark>读事件</mark></strong>，异常断开会进入这个catch块里执行key.cancel()，但是正常断开就不会进入了，所以，要区分正常断开和异常断开。平时read()方法返回的是事件数，但当客户端正常断开的时候，触发一次read，会返回一个 -1</p><p><img src="../../images/image-20230114232305987.png" alt="image-20230114232305987"></p><h4 id="️-不处理边界的问题"><a class="markdownIt-Anchor" href="#️-不处理边界的问题"></a> ⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> in.read(arr);</span><br><span class="line">                <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>) {</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, read));</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">"localhost"</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> max.getOutputStream();</span><br><span class="line">        out.write(<span class="string">"hello"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"world"</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">"你好"</span>.getBytes());</span><br><span class="line">        max.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hell</span><br><span class="line">owor</span><br><span class="line">ld�</span><br><span class="line">�好</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>为什么？</p><h4 id="处理消息的边界-附件与扩容"><a class="markdownIt-Anchor" href="#处理消息的边界-附件与扩容"></a> 处理消息的边界 &amp; 附件与扩容</h4><p><img src="../../images/0023.png" alt=""></p><p><img src="../../images/image-20230114233714137.png" alt="image-20230114233714137"></p><ul><li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li><li>另一种思路是按分隔符拆分，缺点是效率低</li><li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul><li>Http 1.1 是 TLV 格式</li><li>Http 2.0 是 LTV 格式</li></ul></li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram </span><br><span class="line">participant c1 as 客户端1</span><br><span class="line">participant s as 服务器</span><br><span class="line">participant b1 as ByteBuffer1</span><br><span class="line">participant b2 as ByteBuffer2</span><br><span class="line">c1 -&gt;&gt; s: 发送 01234567890abcdef3333\r</span><br><span class="line">s -&gt;&gt; b1: 第一次 read 存入 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 扩容</span><br><span class="line">b1 -&gt;&gt; b2: 拷贝 01234567890abcdef</span><br><span class="line">s -&gt;&gt; b2: 第二次 read 存入 3333\r</span><br><span class="line">b2 -&gt;&gt; b2: 01234567890abcdef3333\r</span><br></pre></td></tr></tbody></table></figure><p>服务器端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> {</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) {</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">'\n'</span>) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) {</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            }</span><br><span class="line">            debugAll(target);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">"sscKey:{}"</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复（向下）运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">"key: {}"</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) { <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment附件</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上，让每一个selectionKey具有自己的ByteBuffer</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">"{}"</span>, sc);</span><br><span class="line">                log.debug(<span class="string">"scKey:{}"</span>, scKey);</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) { <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) {</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) {</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer); <span class="comment">// 将扩容的ByteBuffer作为新的绑定的附件，覆盖旧的附件</span></span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode("hello\nworld\n"));</span></span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">"0123\n456789abcdef"</span>));</span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">"0123456789abcdef3333\n"</span>));</span><br><span class="line">System.in.read();</span><br></pre></td></tr></tbody></table></figure><p>测试结果图：</p><p><img src="../../images/image-20230115002433051.png" alt="image-20230115002433051"></p><h4 id="bytebuffer-大小分配"><a class="markdownIt-Anchor" href="#bytebuffer-大小分配"></a> ByteBuffer 大小分配</h4><ul><li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li><li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul><li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li><li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li></ul></li></ul><h3 id="45-处理-write-事件"><a class="markdownIt-Anchor" href="#45-处理-write-事件"></a> 4.5 处理 write 事件</h3><h4 id="一次无法写完例子"><a class="markdownIt-Anchor" href="#一次无法写完例子"></a> 一次无法写完例子</h4><ul><li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li><li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul><li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li><li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li><li>如果不取消，会每次可写均会触发 write 事件</li></ul></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) {</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) {</span><br><span class="line">                        sb.append(<span class="string">"a"</span>);</span><br><span class="line">                    }</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">"实际写入字节:"</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) {</span><br><span class="line">                       </span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// sckey.interestOps(sckey.interestOps() | SelectionKey.OP_WRITE);</span></span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) {</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">"实际写入字节:"</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) { <span class="comment">// 写完了</span></span><br><span class="line">                        key.attach(<span class="literal">null</span>);  <span class="comment">// 需要清理buffer</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);  <span class="comment">// 不需要关注写事件</span></span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) {</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="write-为何要取消"><a class="markdownIt-Anchor" href="#write-为何要取消"></a> 💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p><p>虽然可以全部发送给客户端，但是不好地点是，当还有数据没发送完且缓冲区写满了的时候，一直处于while里面，就卡在一个SocketChannel了，当其它SocketChannel有事件来的时候，无法处理到。我们应该 当发现发送的缓冲区写满写不下时，可以暂时去处理其他别的操作（比如缓冲区写满了，但可以去读啊）</p><p><img src="../../images/image-20230115094800503.png" alt="image-20230115094800503"></p><h3 id="46-更进一步"><a class="markdownIt-Anchor" href="#46-更进一步"></a> 4.6 更进一步</h3><h4 id="利用多线程优化"><a class="markdownIt-Anchor" href="#利用多线程优化"></a> 💡 利用多线程优化</h4><blockquote><p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p></blockquote><p><img src="../../images/image-20230115103133956.png" alt="image-20230115103133956"></p><p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p><p>分两组选择器</p><ul><li>单线程配一个选择器，专门处理 accept 事件</li><li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo7</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BossEventLoop</span>().register();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BossEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">            <span class="keyword">if</span> (!start) {</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">ssckey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">"boss"</span>).start();</span><br><span class="line">                log.debug(<span class="string">"boss start..."</span>);</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() {</span><br><span class="line"><span class="comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerEventLoops.length; i++) {</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>(i);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) {</span><br><span class="line">                            <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            log.debug(<span class="string">"{} connected"</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        }</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> {</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkerEventLoop</span><span class="params">(<span class="type">int</span> index)</span> {</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">            <span class="keyword">if</span> (!start) {</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">"worker-"</span> + index).start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            }</span><br><span class="line">            tasks.add(() -&gt; {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(worker, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> {</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    worker.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) {</span><br><span class="line">                        task.run();</span><br><span class="line">                    }</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) {</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) {</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> {</span><br><span class="line">                                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) {</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                } <span class="keyword">else</span> {</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">"{} message:"</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                }</span><br><span class="line">                            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            }</span><br><span class="line">                        }</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="如何拿到-cpu-个数"><a class="markdownIt-Anchor" href="#如何拿到-cpu-个数"></a> 💡 如何拿到 cpu 个数</h4><blockquote><ul><li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li><li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li></ul></blockquote><h3 id="47-udp教程老师不说不是重点"><a class="markdownIt-Anchor" href="#47-udp教程老师不说不是重点"></a> 4.7 UDP（教程老师不说，不是重点）</h3><ul><li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li><li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li></ul><p>首先启动服务器端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open()) {</span><br><span class="line">            channel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">"waiting..."</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            channel.receive(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debug(buffer);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">waiting...</span><br></pre></td></tr></tbody></table></figure><p>运行客户端</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpClient</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open()) {</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">"localhost"</span>, <span class="number">9999</span>);</span><br><span class="line">            channel.send(buffer, address);</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>接下来服务器端输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><h2 id="5-nio-vs-bio"><a class="markdownIt-Anchor" href="#5-nio-vs-bio"></a> 5. NIO vs BIO</h2><h3 id="51-stream-vs-channel"><a class="markdownIt-Anchor" href="#51-stream-vs-channel"></a> 5.1 stream vs channel</h3><ul><li>stream 不会自动缓冲数据；channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li><li>stream 仅支持阻塞 API；channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li><li>二者均为<strong>全双工</strong>，即读写可以同时进行</li></ul><h3 id="52-io-模型"><a class="markdownIt-Anchor" href="#52-io-模型"></a> 5.2 IO 模型</h3><p>同步阻塞、同步非阻塞、同步多路复用、异步阻塞（没有此情况）、异步非阻塞</p><ul><li>同步：线程自己去获取结果（一个线程）</li><li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li></ul><p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段</li><li>复制数据阶段</li></ul><p><img src="../../images/0033.png" alt=""></p><ul><li><p>阻塞 IO</p><p><img src="../../images/0039.png" alt=""></p></li><li><p>非阻塞  IO</p><p><img src="../../images/0035.png" alt=""></p></li><li><p>多路复用</p><p><img src="../../images/0038.png" alt=""></p></li><li><p>信号驱动</p></li><li><p>异步 IO</p><p><img src="../../images/0037.png" alt=""></p></li><li><p>阻塞 IO vs 多路复用</p><p><img src="../../images/0034.png" alt=""></p><p><img src="../../images/0036.png" alt=""></p></li></ul><h4 id="参考以后想走网络编程方向的可以看看"><a class="markdownIt-Anchor" href="#参考以后想走网络编程方向的可以看看"></a> 🔖 参考（以后想走网络编程方向的可以看看）</h4><p>UNIX 网络编程 - 卷 I</p><h3 id="53-零拷贝"><a class="markdownIt-Anchor" href="#53-零拷贝"></a> 5.3 零拷贝</h3><h4 id="传统-io-问题"><a class="markdownIt-Anchor" href="#传统-io-问题"></a> 传统 IO 问题</h4><p>需求：从服务器的一个文件读取进来，通过socket 的 API 发送给客户端</p><p>传统的 IO 将一个文件通过 socket 写出</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">"helloword/data.txt"</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);  <span class="comment">// 通过read将数据从文件里读到byte[]数组里</span></span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);   </span><br></pre></td></tr></tbody></table></figure><p>内部工作流程是这样的：</p><p><img src="../../images/0024.png" alt=""></p><ol><li><p><font color="red"><strong>java 本身并不具备 IO 读写能力</strong>，</font>因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p><blockquote><p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p></li><li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p></li><li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p></li></ol><p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p><ul><li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li><li>数据拷贝了共 4 次</li></ul><h4 id="nio-优化"><a class="markdownIt-Anchor" href="#nio-优化"></a> NIO 优化</h4><p>通过 DirectByteBuf</p><ul><li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li><li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li></ul><p><img src="../../images/0025.png" alt=""></p><p>大部分步骤与优化前相同，不再赘述。唯有一点：<mark>java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</mark></p><ul><li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li><li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul><li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li><li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li></ul></li><li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li></ul><p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p><p><img src="../../images/0026.png" alt=""></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li><li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>可以看到</p><ul><li>只发生了一次用户态与内核态的切换</li><li>数据拷贝了 3 次</li></ul><p>进一步优化（linux 2.4）</p><p><img src="../../images/0027.png" alt=""></p><ol><li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li><li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li><li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li></ol><p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p><ul><li>更少的用户态与内核态的切换</li><li>不利用 cpu 计算，减少 cpu 缓存伪共享</li><li>零拷贝适合小文件传输</li></ul><h3 id="53-aio不是重点了解就行"><a class="markdownIt-Anchor" href="#53-aio不是重点了解就行"></a> 5.3 AIO（不是重点，了解就行）</h3><p>AIO就是All In One（一体)的意思。AIO：Asynchronous Input/Output<a href="https://baike.baidu.com/item/%E5%BC%82%E6%AD%A5%E8%BE%93%E5%85%A5?fromModule=lemma_inlink">异步输入</a>/输出是任何特殊输入/输出流</p><p>AIO 用来解决数据复制阶段的阻塞问题</p><ul><li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li><li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li></ul><blockquote><p>异步模型需要底层操作系统（Kernel）提供支持</p><ul><li>Windows 系统通过 IOCP 实现了真正的异步 IO</li><li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li></ul></blockquote><h4 id="文件-aio"><a class="markdownIt-Anchor" href="#文件-aio"></a> 文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                Paths.get(<span class="string">"1.txt"</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">"begin..."</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> {</span><br><span class="line">                    log.debug(<span class="string">"read completed...{}"</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> {</span><br><span class="line">                    log.debug(<span class="string">"read failed..."</span>);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line"></span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        log.debug(<span class="string">"do other things..."</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></tbody></table></figure><p>可以看到</p><ul><li>响应文件读取成功的是另一个线程 Thread-5</li><li>主线程并没有 IO 操作阻塞</li></ul><h4 id="守护线程"><a class="markdownIt-Anchor" href="#守护线程"></a> 💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p><h4 id="网络-aio"><a class="markdownIt-Anchor" href="#网络-aio"></a> 网络 AIO</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.printf(<span class="string">"[%s] %s close\n"</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> {</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) {</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">                System.out.printf(<span class="string">"[%s] %s read\n"</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> {</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> {</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> {</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) {</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> {</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; {</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> {</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> {</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                System.out.printf(<span class="string">"[%s] %s connected\n"</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">"server hello!"</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> {</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
          <category> nio </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Netty </tag>
            
            <tag> nio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3-JVM监控及诊断工具-GUI篇</title>
      <link href="/2023/01/13/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/3-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/"/>
      <url>/2023/01/13/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/3-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-GUI%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="3-jvm-监控及诊断工具-gui-篇"><a class="markdownIt-Anchor" href="#3-jvm-监控及诊断工具-gui-篇"></a> 3. JVM 监控及诊断工具-GUI 篇</h1><h2 id="31-工具概述"><a class="markdownIt-Anchor" href="#31-工具概述"></a> 3.1. 工具概述</h2><p>使用上一章命令行工具或组合能帮您获取目标 Java 应用性能相关的基础信息，但它们存在下列局限：</p><ul><li>1．无法获取方法级别的分析数据，如方法间的调用关系、各方法的调用次数和调用时间等（这对定位应用性能瓶颈至关重要）。</li><li>2．要求用户登录到目标 Java 应用所在的宿主机上，使用起来不是很方便。</li><li>3．分析数据通过终端输出，结果展示不够直观。</li></ul><p>为此，JDK 提供了一些内存泄漏的分析工具，如 jconsole，jvisualvm 等，用于辅助开发人员定位问题，但是这些工具很多时候并不足以满足快速定位的需求。所以这里我们介绍的工具相对多一些、丰富一些。</p><p><strong>JDK 自带的工具</strong></p><ul><li><p>jconsole：JDK 自带的可视化监控工具。查看 Java 应用程序的运行概况、监控堆信息、永久区（或元空间）使用情况、类加载情况等</p></li><li><p>Visual VM：Visual VM 是一个工具，它提供了一个可视界面，用于查看 Java 虚拟机上运行的基于 Java 技术的应用程序的详细信息。</p></li><li><p>JMC：Java Mission Control，内置 Java Flight Recorder。能够以极低的性能开销收集 Java 虚拟机的性能数据。</p></li></ul><p><strong>第三方工具</strong></p><ul><li><p>MAT：MAT（Memory Analyzer Tool）是基于 Eclipse 的内存分析工具，是一个快速、功能丰富的 Java heap 分析工具，它可以帮助我们查找内存泄漏和减少内存消耗</p></li><li><p>JProfiler：商业软件，需要付费。功能强大。</p></li></ul><h2 id="32-jconsole"><a class="markdownIt-Anchor" href="#32-jconsole"></a> 3.2. JConsole</h2><p>jconsole：从 Java5 开始，在 JDK 中自带的 java 监控和管理控制台。用于对 JVM 中内存、线程和类等的监控，是一个基于 JMX（java management extensions）的 GUI 性能监控工具。</p><p>官方地址：<a href="https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html">https://docs.oracle.com/javase/7/docs/technotes/guides/management/jconsole.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2a3da9e0684da25f3603859309a31002.png" alt="image-20210505141631635"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/01d1c91e8a41137321af9334a383eeda.png" alt="image-20210505141726143"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fd74276fd1dd7e4542994d1da5768bff.png" alt="image-20210505141924211"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c590dbcfb21edbf73f9b7a4d4e342cb7.png" alt="image-20210505141950000"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0394d3dec7f075f88d1321565e4b0c40.png" alt="image-20210505142050157"></p><h2 id="33-visual-vm"><a class="markdownIt-Anchor" href="#33-visual-vm"></a> 3.3. Visual VM</h2><p>Visual VM 是一个功能强大的多合一故障诊断和性能监控的可视化工具。它集成了多个 JDK 命令行工具，使用 Visual VM 可用于显示虚拟机进程及进程的配置和环境信息（jps，jinfo），监视应用程序的 CPU、GC、堆、方法区及线程的信息（jstat、jstack）等，甚至代替 JConsole。在 JDK 6 Update 7 以后，Visual VM 便作为 JDK 的一部分发布（VisualVM 在 JDK／bin 目录下）即：它完全免费。</p><p><strong>主要功能：</strong></p><ul><li>1.生成/读取堆内存/线程快照</li><li>2.查看 JVM 参数和系统属性</li><li>3.查看运行中的虚拟机进程</li><li>4.程序资源的实时监控</li><li>5.JMX 代理连接、远程环境监控、CPU 分析和内存分析</li></ul><p>官方地址：<a href="https://visualvm.github.io/index.html">https://visualvm.github.io/index.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5778843e25883aed6ee8591e7f57465a.png" alt="image-20210505143844282"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/750e766290dd3ce1c31bece436870f96.png" alt="image-20210505144716064"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/43a8b0745532825ab4a262a953aa5ffd.png" alt="image-20210505144805307"></p><p><img src="../../../images/image-20230115232529855.png" alt="image-20230115232529855"></p><p><img src="../../../images/image-20230115233142987.png" alt="image-20230115233142987"></p><p>举例：生成和分析线程dump文件，可以监视线程死锁等问题</p><p><img src="../../../images/image-20230115233917603.png" alt="image-20230115233917603"></p><p>当我们发现服务器性能急速地变慢，cpu占用率很高，我们就可以查看 抽样器–&gt;CPU–&gt;CPU样例/快照/线程CPU时间</p><p><img src="../../../images/image-20230115235544669.png" alt="image-20230115235544669"></p><p>没有发现OOM，但发现Full GC的次数比较多，这时候可以看看是不是存在内存溢出的问题，可以查看 抽样器–&gt;内存，可以看到哪些线程的相关的数据占有的比较多。且可以生成dump快照文件保存</p><p><img src="../../../images/image-20230115235106767.png" alt="image-20230115235106767"></p><h2 id="34-eclipse-mat"><a class="markdownIt-Anchor" href="#34-eclipse-mat"></a> 3.4. Eclipse MAT</h2><p>**MAT（Memory Analyzer Tool）**工具是一款功能强大的 <strong>Java 堆内存分析器</strong>。可以用于查找内存泄漏以及查看内存消耗情况。MAT 是基于 Eclipse 开发的，不仅可以单独使用，还可以作为插件的形式嵌入在 Eclipse 中使用。是一款免费的性能分析工具，使用起来非常方便。</p><p><mark>MAT 可以（主要）分析 heap dump 文件。</mark>在进行内存分析时，只要获得了反映当前设备内存映像的 hprof 文件，通过 MAT 打开就可以直观地看到当前的内存信息。一般说来，这些内存信息包含：</p><ul><li>所有的对象信息，包括对象实例、成员变量、存储于栈中的基本类型值和存储于堆中的其他对象的引用值。</li><li>所有的类信息，包括 classloader、类名称、父类、静态变量等</li><li>GCRoot 到所有的这些对象的引用路径</li><li>线程信息，包括线程的调用栈及此线程的线程局部变量（TLS）</li></ul><p>MAT 不是一个万能工具，它并不能处理所有类型的堆存储文件。但是比较主流的厂家和格式，例如 Sun，HP，SAP 所采用的 HPROF 二进制堆存储文件，以及 IBM 的 PHD 堆存储文件等都能被很好的解析。</p><p><font color="red">最吸引人的还是能够快速为开发人员生成<mark><strong>内存泄漏报表</strong></mark>，方便定位问题和分析问题。</font>虽然 MAT 有如此强大的功能，但是内存分析也没有简单到一键完成的程度，很多内存问题还是需要我们从 MAT 展现给我们的信息当中通过经验和直觉来判断才能发现。</p><p>官方地址： <a href="https://www.eclipse.org/mat/downloads.php">https://www.eclipse.org/mat/downloads.php</a></p><p>(回顾一下 获取dump文件的几种方式)</p><p><img src="../../../images/image-20230116005955792.png" alt="image-20230116005955792"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/23d0ea8c73c4e7fb57f47fba7ee39f3f.png" alt="image-20210505145708567"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e5dad78d08ba1aee3a9583c33d83c53f.png" alt="image-20210505145826442"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b25b5cb539c1d5622f4855dffb1fd21e.png" alt="image-20210505145945951"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e41893c02f420e50d36c59acf3021b6.png" alt="image-20210505150039376"></p><p><img src="../../../images/image-20230116105849445.png" alt="image-20230116105849445"></p><p><img src="../../../images/image-20230116105921931.png" alt="image-20230116105921931"></p><h2 id="35-jprofiler"><a class="markdownIt-Anchor" href="#35-jprofiler"></a> 3.5. JProfiler</h2><p>在运行 Java 的时候有时候想测试运行时占用内存情况，这时候就需要使用测试工具查看了。在 eclipse 里面有 Eclipse Memory Analyzer tool（MAT）插件可以测试，而在 IDEA 中也有这么一个插件，就是 JProfiler。JProfiler 是由 ej-technologies 公司开发的一款 Java 应用性能诊断工具。功能强大，但是收费。</p><p><strong>特点：</strong></p><ul><li>使用方便、界面操作友好（简单且强大）</li><li>对被分析的应用影响小（提供模板）</li><li>CPU，Thread，Memory 分析功能尤其强大</li><li>支持对 jdbc，noSql，jsp，servlet，socket 等进行分析</li><li>支持多种模式（离线，在线）的分析</li><li>支持监控本地、远程的 JVM</li><li>跨平台，拥有多种操作系统的安装版本</li></ul><p><strong>主要功能：</strong></p><ul><li>1-方法调用：对方法调用的分析可以帮助您了解应用程序正在做什么，并找到提高其性能的方法</li><li>2-内存分配：通过分析堆上对象、引用链和垃圾收集能帮您修复内存泄露问题，优化内存使用</li><li>3-线程和锁：JProfiler 提供多种针对线程和锁的分析视图助您发现多线程问题</li><li>4-高级子系统：许多性能问题都发生在更高的语义级别上。例如，对于 JDBC 调用，您可能希望找出执行最慢的 SQL 语句。JProfiler 支持对这些子系统进行集成分析</li></ul><p>官网地址：<a href="https://www.ej-technologies.com/products/jprofiler/overview.html">https://www.ej-technologies.com/products/jprofiler/overview.html</a></p><p><strong>数据采集方式：</strong></p><p>JProfier 数据采集方式分为两种：Sampling（样本采集）和 Instrumentation（重构模式）</p><p><strong>Instrumentation</strong>：这是 JProfiler 全功能模式。在 class 加载之前，JProfier 把相关功能代码写入到需要分析的 class 的 bytecode 中，对正在运行的 jvm 有一定影响。</p><ul><li>优点：功能强大。在此设置中，调用堆栈信息是准确的。</li><li>缺点：若要分析的 class 较多，则对应用的性能影响较大，CPU 开销可能很高（取决于 Filter 的控制）。因此使用此模式一般配合 Filter 使用，只对特定的类或包进行分析</li></ul><p><strong>Sampling</strong>：类似于样本统计，每隔一定时间（5ms）将每个线程栈中方法栈中的信息统计出来。</p><ul><li>优点：对 CPU 的开销非常低，对应用影响小（即使你不配置任何 Filter）</li><li>缺点：一些数据／特性不能提供（例如：方法的调用次数、执行时间）</li></ul><p>注：JProfiler 本身没有指出数据的采集类型，这里的采集类型是针对方法调用的采集类型。因为 JProfiler 的绝大多数核心功能都依赖方法调用采集的数据，所以可以直接认为是 JProfiler 的数据采集类型。</p><p><strong>遥感监测 Telemetries</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b385d959623a0684d1a40700f4bc1243.png" alt="image-20210505164521410"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/aa57ab4a3183801e003546c177ab64ee.png" alt="image-20210505164907312"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/75200c0d6aeaaade33422d40bd64beb3.png" alt="image-20210505164815324"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6342c78f10e0c8d96243ae69c280c742.png" alt="image-20210505164945192"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/eda04270592f6cf5cc53f6300f9f084a.png" alt="image-20210505165010529"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/944971c96b35f20aa4073a39ee8f678e.png" alt="image-20210505165128212"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/983f44592d93befafdb1818ea9fb7603.png" alt="image-20210505165249919"></p><p><strong>内存视图 Live Memory</strong></p><p>Live memory 内存剖析：class／class instance 的相关信息。例如对象的个数，大小，对象创建的方法执行栈，对象创建的热点。</p><ul><li><strong>所有对象 All Objects</strong>：显示所有加载的类的列表和在堆上分配的实例数。只有 Java 1.5（JVMTI）才会显示此视图。</li><li><strong>记录对象 Record Objects</strong>：查看特定时间段对象的分配，并记录分配的调用堆栈。</li><li><strong>分配访问树 Allocation Call Tree</strong>：显示一棵请求树或者方法、类、包或对已选择类有带注释的分配信息的 J2EE 组件。</li><li><strong>分配热点 Allocation Hot Spots</strong>：显示一个列表，包括方法、类、包或分配已选类的 J2EE 组件。你可以标注当前值并且显示差异值。对于每个热点都可以显示它的跟踪记录树。</li><li><strong>类追踪器 Class Tracker</strong>：类跟踪视图可以包含任意数量的图表，显示选定的类和包的实例与时间。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/49b08570bc68a4ccb1b76c610001160e.png" alt="image-20210505164554298"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/12e4a0779da98da28310602aa727fe77.png" alt="image-20210505165519790"></p><p><strong>堆遍历 heap walker</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ffb0632996afc5ab68554c918c6ba5c5.png" alt="image-20210505165710620"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9328465f8078d485d713866676fedddd.png" alt="image-20210505165823201"></p><p><strong>cpu 视图 cpu views</strong></p><p>JProfiler 提供不同的方法来记录访问树以优化性能和细节。线程或者线程组以及线程状况可以被所有的视图选择。所有的视图都可以聚集到方法、类、包或 J2EE 组件等不同层上。</p><ul><li><strong>访问树 Call Tree</strong>：显示一个积累的自顶向下的树，树中包含所有在 JVM 中已记录的访问队列。JDBC，JMS 和 JNDI 服务请求都被注释在请求树中。请求树可以根据 Servlet 和 JSP 对 URL 的不同需要进行拆分。</li><li><strong>热点 Hot Spots</strong>：显示消耗时间最多的方法的列表。对每个热点都能够显示回溯树。该热点可以按照方法请求，JDBC，JMS 和 JNDI 服务请求以及按照 URL 请求来进行计算。</li><li><strong>访问图 Call Graph</strong>：显示一个从已选方法、类、包或 J2EE 组件开始的访问队列的图。</li><li><strong>方法统计 Method Statistis</strong>：显示一段时间内记录的方法的调用时间细节。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/2d40f4905776b879b96ea26323b5437e.png" alt="image-20210505170055722"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/054ba6962384453984936f4dc2fe5f64.png" alt="image-20210505170141278"></p><p><strong>线程视图 threads</strong></p><p>JProfiler 通过对线程历史的监控判断其运行状态，并监控是否有线程阻塞产生，还能将一个线程所管理的方法以树状形式呈现。对线程剖析。</p><ul><li><strong>线程历史 Thread History</strong>：显示一个与线程活动和线程状态在一起的活动时间表。</li><li><strong>线程监控 Thread Monitor</strong>：显示一个列表，包括所有的活动线程以及它们目前的活动状况。</li><li><strong>线程转储 Thread Dumps</strong>：显示所有线程的堆栈跟踪。</li></ul><p>线程分析主要关心三个方面：</p><ul><li>1．web 容器的线程最大数。比如：Tomcat 的线程容量应该略大于最大并发数。</li><li>2．线程阻塞</li><li>3．线程死锁</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/18074c3907f5b0b197cd88802897a758.png" alt="image-20210505170739972"></p><p><strong>监控和锁 Monitors ＆Locks</strong></p><p>所有线程持有锁的情况以及锁的信息。观察 JVM 的内部线程并查看状态：</p><ul><li><strong>死锁探测图表 Current Locking Graph</strong>：显示 JVM 中的当前死锁图表。</li><li><strong>目前使用的监测器 Current Monitors</strong>：显示目前使用的监测器并且包括它们的关联线程。</li><li><strong>锁定历史图表 Locking History Graph</strong>：显示记录在 JVM 中的锁定历史。</li><li><strong>历史检测记录 Monitor History</strong>：显示重大的等待事件和阻塞事件的历史记录。</li><li><strong>监控器使用统计 Monitor Usage Statistics</strong>：显示分组监测，线程和监测类的统计监测数据</li></ul><h2 id="36-arthas"><a class="markdownIt-Anchor" href="#36-arthas"></a> 3.6. Arthas</h2><p>上述工具都必须在服务端项目进程中配置相关的监控参数，然后工具通过远程连接到项目进程，获取相关的数据。这样就会带来一些不便，比如线上环境的网络是隔离的，本地的监控工具根本连不上线上环境。并且类似于 Jprofiler 这样的商业工具，是需要付费的。</p><p>那么有没有一款工具不需要远程连接，也不需要配置监控参数，同时也提供了丰富的性能监控数据呢？</p><p>阿里巴巴开源的性能分析神器 Arthas 应运而生。</p><p>Arthas 是 Alibaba 开源的 Java 诊断工具，深受开发者喜爱。在线排查问题，无需重启；动态跟踪 Java 代码；实时监控 JVM 状态。Arthas 支持 JDK 6 ＋，支持 Linux／Mac／Windows，采用命令行交互模式，同时提供丰富的 Tab 自动补全功能，进一步方便进行问题的定位和诊断。当你遇到以下类似问题而束手无策时，Arthas 可以帮助你解决：</p><ul><li>这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？</li><li>我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？</li><li>遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？</li><li>线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！</li><li>是否有一个全局视角来查看系统的运行状况？</li><li>有什么办法可以监控到 JVM 的实时运行状态？</li><li>怎么快速定位应用的热点，生成火焰图？</li></ul><p>官方地址：<a href="https://arthas.aliyun.com/doc/quick-start.html">https://arthas.aliyun.com/doc/quick-start.html</a></p><p>安装方式：如果速度较慢，可以尝试国内的码云 Gitee 下载。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https://io/arthas/arthas-boot.jar</span><br><span class="line">wget https://arthas/gitee/io/arthas-boot.jar</span><br></pre></td></tr></tbody></table></figure><p>Arthas 只是一个 java 程序，所以可以直接用 java -jar 运行。</p><p>除了在命令行查看外，Arthas 目前还支持 Web Console。在成功启动连接进程之后就已经自动启动,可以直接访问 <a href="http://127.0.0.1:8563/">http://127.0.0.1:8563/</a> 访问，页面上的操作模式和控制台完全一样。</p><p><strong>基础指令</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">quit/exit 退出当前 Arthas客户端，其他 Arthas喜户端不受影响</span><br><span class="line">stop/shutdown 关闭 Arthas服务端，所有 Arthas客户端全部退出</span><br><span class="line">help 查看命令帮助信息</span><br><span class="line">cat 打印文件内容，和linux里的cat命令类似</span><br><span class="line">echo 打印参数，和linux里的echo命令类似</span><br><span class="line">grep 匹配查找，和linux里的gep命令类似</span><br><span class="line">tee 复制标隹输入到标准输出和指定的文件，和linux里的tee命令类似</span><br><span class="line">pwd 返回当前的工作目录，和linux命令类似</span><br><span class="line">cls 清空当前屏幕区域</span><br><span class="line">session 查看当前会话的信息</span><br><span class="line">reset 重置增强类，将被 Arthas增强过的类全部还原, Arthas服务端关闭时会重置所有增强过的类</span><br><span class="line">version 输出当前目标Java进程所加载的 Arthas版本号</span><br><span class="line">history 打印命令历史</span><br><span class="line">keymap Arthas快捷键列表及自定义快捷键</span><br></pre></td></tr></tbody></table></figure><p><strong>jvm 相关</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dashboard 当前系统的实时数据面板</span><br><span class="line">thread 查看当前JVM的线程堆栈信息</span><br><span class="line">jvm 查看当前JVM的信息</span><br><span class="line">sysprop 查看和修改JVM的系统属性</span><br><span class="line">sysem 查看JVM的环境变量</span><br><span class="line">vmoption 查看和修改JVM里诊断相关的option</span><br><span class="line">perfcounter 查看当前JVM的 Perf Counter信息</span><br><span class="line">logger 查看和修改logger</span><br><span class="line">getstatic 查看类的静态属性</span><br><span class="line">ognl 执行ognl表达式</span><br><span class="line">mbean 查看 Mbean的信息</span><br><span class="line">heapdump dump java heap，类似jmap命令的 heap dump功能</span><br></pre></td></tr></tbody></table></figure><p><strong>class/classloader 相关</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sc 查看JVM已加载的类信息</span><br><span class="line">-d 输出当前类的详细信息，包括这个类所加载的原始文件来源、类的声明、加载的Classloader等详细信息。如果一个类被多个Classloader所加载，则会出现多次</span><br><span class="line">-E 开启正则表达式匹配，默认为通配符匹配</span><br><span class="line">-f 输出当前类的成员变量信息（需要配合参数-d一起使用）</span><br><span class="line">-X 指定输出静态变量时属性的遍历深度，默认为0，即直接使用toString输出</span><br><span class="line">sm 查看已加载类的方法信息</span><br><span class="line">-d 展示每个方法的详细信息</span><br><span class="line">-E 开启正则表达式匹配,默认为通配符匹配</span><br><span class="line">jad 反编译指定已加载类的源码</span><br><span class="line">mc 内存编译器，内存编译.java文件为.class文件</span><br><span class="line">retransform 加载外部的.class文件, retransform到JVM里</span><br><span class="line">redefine 加载外部的.class文件，redefine到JVM里</span><br><span class="line">dump dump已加载类的byte code到特定目录</span><br><span class="line">classloader 查看classloader的继承树，urts，类加载信息，使用classloader去getResource</span><br><span class="line">-t 查看classloader的继承树</span><br><span class="line">-l 按类加载实例查看统计信息</span><br><span class="line">-c 用classloader对应的hashcode来查看对应的 Jar urls</span><br></pre></td></tr></tbody></table></figure><p><strong>monitor/watch/trace 相关</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">monitor 方法执行监控，调用次数、执行时间、失败率</span><br><span class="line">-c 统计周期，默认值为120秒</span><br><span class="line">watch 方法执行观测，能观察到的范围为：返回值、抛出异常、入参，通过编写groovy表达式进行对应变量的查看</span><br><span class="line">-b 在方法调用之前观察(默认关闭)</span><br><span class="line">-e 在方法异常之后观察(默认关闭)</span><br><span class="line">-s 在方法返回之后观察(默认关闭)</span><br><span class="line">-f 在方法结束之后(正常返回和异常返回)观察(默认开启)</span><br><span class="line">-x 指定输岀结果的属性遍历深度,默认为0</span><br><span class="line">trace 方法内部调用路径,并输出方法路径上的每个节点上耗时</span><br><span class="line">-n 执行次数限制</span><br><span class="line">stack 输出当前方法被调用的调用路径</span><br><span class="line">tt 方法执行数据的时空隧道,记录下指定方法每次调用的入参和返回信息,并能对这些不同的时间下调用进行观测</span><br></pre></td></tr></tbody></table></figure><p><strong>其他</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jobs 列出所有job</span><br><span class="line">kill 强制终止任务</span><br><span class="line">fg 将暂停的任务拉到前台执行</span><br><span class="line">bg 将暂停的任务放到后台执行</span><br><span class="line">grep 搜索满足条件的结果</span><br><span class="line">plaintext 将命令的结果去除ANSI颜色</span><br><span class="line">wc 按行统计输出结果</span><br><span class="line">options 查看或设置Arthas全局开关</span><br><span class="line">profiler 使用async-profiler对应用采样，生成火焰图</span><br></pre></td></tr></tbody></table></figure><h2 id="37-java-misssion-control"><a class="markdownIt-Anchor" href="#37-java-misssion-control"></a> 3.7. Java Misssion Control</h2><p>在 Oracle 收购 Sun 之前，Oracle 的 JRockit 虚拟机提供了一款叫做 JRockit Mission Control 的虚拟机诊断工具。</p><p>在 Oracle 收购 sun 之后，Oracle 公司同时拥有了 Hotspot 和 JRockit 两款虚拟机。根据 Oracle 对于 Java 的战略，在今后的发展中，会将 JRokit 的优秀特性移植到 Hotspot 上。其中一个重要的改进就是在 Sun 的 JDK 中加入了 JRockit 的支持。</p><p>在 Oracle JDK 7u40 之后，Mission Control 这款工具己经绑定在 Oracle JDK 中发布。</p><p>自 Java11 开始，本节介绍的 JFR 己经开源。但在之前的 Java 版本，JFR 属于 Commercial Feature 通过 Java 虚拟机参数-XX:+UnlockCommercialFeatures 开启。</p><p>Java Mission Control（简称 JMC) ， Java 官方提供的性能强劲的工具，是一个用于对 Java 应用程序进行管理、监视、概要分析和故障排除的工具套件。它包含一个 GUI 客户端以及众多用来收集 Java 虚拟机性能数据的插件如 JMX Console（能够访问用来存放虚拟机齐个于系统运行数据的 MXBeans）以及虚拟机内置的高效 profiling 工具 Java Flight Recorder（JFR）。</p><p>JMC 的另一个优点就是：采用取样，而不是传统的代码植入技术，对应用性能的影响非常非常小，完全可以开着 JMC 来做压测（唯一影响可能是 full gc 多了）。</p><p>官方地址：<a href="https://github.com/JDKMissionControl/jmc">https://github.com/JDKMissionControl/jmc</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/042f2d109ebcf51894f822706963e399.png" alt="image-20210505184358041"></p><p><strong>Java Flight Recorder</strong></p><p>Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。与其他工具相比，JFR 的性能开销很小，在默认配置下平均低于 1%。JFR 能够直接访问虚拟机内的敌据并且不会影响虚拟机的优化。因此它非常适用于生产环境下满负荷运行的 Java 程序。</p><p>Java Flight Recorder 和 JDK Mission Control 共同创建了一个完整的工具链。JDK Mission Control 可对 Java Flight Recorder 连续收集低水平和详细的运行时信息进行高效、详细的分析。</p><p>当启用时 JFR 将记录运行过程中发生的一系列事件。其中包括 Java 层面的事件如线程事件、锁事件，以及 Java 虚拟机内部的事件，如新建对象，垃圾回收和即时编译事件。按照发生时机以及持续时间来划分，JFR 的事件共有四种类型，它们分别为以下四种：</p><ul><li><p>瞬时事件（Instant Event) ，用户关心的是它们发生与否，例如异常、线程启动事件。</p></li><li><p>持续事件(Duration Event) ，用户关心的是它们的持续时间，例如垃圾回收事件。</p></li><li><p>计时事件(Timed Event) ，是时长超出指定阈值的持续事件。</p></li><li><p>取样事件（Sample Event)，是周期性取样的事件。</p></li></ul><p>取样事件的其中一个常见例子便是方法抽样（Method Sampling），即每隔一段时问统计各个线程的栈轨迹。如果在这些抽样取得的栈轨迹中存在一个反复出现的方法，那么我们可以推测该方法是热点方法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d96c890e6187bcfa8d4a558be64354e6.png" alt="image-20210505185941373"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dbaae7f62c614ef03aebb267b4249650.png" alt="image-20210505185954567"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/a0bc985fd0274fc17c9dc2e8e205a8a2.png" alt="image-20210505190009274"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fe38780df6ccf1c3f3206baaa089ff1a.png" alt="image-20210505190023099"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/0e8ab54b4fdc5cd2f4d7e1cda87dfe52.png" alt="image-20210505190037354"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ef07d257c25f15fe7d6bfdbe6ee0f087.png" alt="image-20210505190052561"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3f65159c21e0c6996588c90c7c5ca8e6.png" alt="image-20210505190106004"></p><h2 id="38-其他工具"><a class="markdownIt-Anchor" href="#38-其他工具"></a> 3.8. 其他工具</h2><p><strong>Flame Graphs（火焰图）</strong></p><p>在追求极致性能的场景下，了解你的程序运行过程中 cpu 在干什么很重要，火焰图就是一种非常直观的展示 CPU 在程序整个生命周期过程中时间分配的工具。火焰图对于现代的程序员不应该陌生，这个工具可以非常直观的显示出调用找中的 CPU 消耗瓶颈。</p><p>网上的关于 Java 火焰图的讲解大部分来自于 Brenden Gregg 的博客 <a href="http://new.brendangregg.com/flamegraphs.html">http://new.brendangregg.com/flamegraphs.html </a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c2692cea072a29b00b420933892ae9f9.png" alt="image-20210505190823214"></p><p>火焰图，简单通过 x 轴横条宽度来度量时间指标，y 轴代表线程栈的层次。</p><p><strong>Tprofiler</strong></p><p>案例： 使用 JDK 自身提供的工具进行 JVM 调优可以将下 TPS 由 2.5 提升到 20（提升了 7 倍），并准确 定位系统瓶颈。</p><p>系统瓶颈有：应用里释态对象不是太多、有大量的业务线程在频繁创建一些生命周期很长的临时对象，代码里有问题。</p><p>那么，如何在海量业务代码里边准确定位这些性能代码？这里使用阿里开源工具 Tprofiler 来定位 这些性能代码，成功解决掉了 GC 过于频繁的性能瓶预，并最终在上次优化的基础上将 TPS 再提升了 4 倍，即提升到 100。</p><ul><li>Tprofiler 配置部署、远程操作、 日志阅谈都不太复杂，操作还是很简单的。但是其却是能够 起到一针见血、立竿见影的效果，帮我们解决了 GC 过于频繁的性能瓶预。</li><li>Tprofiler 最重要的特性就是能够统汁出你指定时间段内 JVM 的 top method 这些 top method 极有可能就是造成你 JVM 性能瓶颈的元凶。这是其他大多数 JVM 调优工具所不具备的，包括 JRockit Mission Control。JRokit 首席开发者 Marcus Hirt 在其私人博客《 Lom Overhead Method Profiling cith Java Mission Control》下的评论中曾明确指出 JRMC 井不支持 TOP 方法的统计。</li></ul><p>官方地址：<a href="http://github.com/alibaba/Tprofiler">http://github.com/alibaba/Tprofiler</a></p><p><strong>Btrace</strong></p><p>常见的动态追踪工具有 BTrace、HouseHD（该项目己经停止开发）、Greys-Anatomy（国人开发 个人开发者）、Byteman（JBoss 出品），注意 Java 运行时追踪工具井不限干这几种，但是这几个是相对比较常用的。</p><p>BTrace 是 SUN Kenai 云计算开发平台下的一个开源项目，旨在为 java 提供安全可靠的动态跟踪分析工具。先看一卜日 Trace 的官方定义：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8df058bdfb18387a90cd5dd87a2a2f04.png" alt="image-20210505192042974"></p><p>大概意思是一个 Java 平台的安全的动态追踪工具，可以用来动态地追踪一个运行的 Java 程序。BTrace 动态调整目标应用程序的类以注入跟踪代码（“字节码跟踪“）。</p><p><strong>YourKit</strong></p><p><strong>JProbe</strong></p><p><strong>Spring Insight</strong></p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2-JVM监控及诊断工具-命令行篇</title>
      <link href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/2-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/"/>
      <url>/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/2-JVM%E7%9B%91%E6%8E%A7%E5%8F%8A%E8%AF%8A%E6%96%AD%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="2-jvm-监控及诊断工具-命令行篇"><a class="markdownIt-Anchor" href="#2-jvm-监控及诊断工具-命令行篇"></a> 2. JVM 监控及诊断工具-命令行篇</h1><h2 id="21-概述"><a class="markdownIt-Anchor" href="#21-概述"></a> 2.1. 概述</h2><p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p><p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络 I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p><p><mark>体会 1：使用数据说明问题，使用知识分析问题，使用工具处理问题。</mark></p><p><mark>体会 2：无监控、不调优！</mark></p><p><strong>简单命令行工具</strong></p><p>在我们刚接触 java 学习的时候，大家肯定最先了解的两个命令就是 javac，java，那么除此之外，还有没有其他的命令可以供我们使用呢？</p><p>我们进入到安装 jdk 的 bin 目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决 Java 应用程序的一些疑难杂症。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5b7c5d239e4da192ba65edb0800055c5.png" alt="image-20210504195803526"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fa3c5e41cbf999d261bcf32851731565.png" alt="image-20210504195836342"></p><p>官方源码地址：<a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools">http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p><h2 id="22-jps查看正在运行的-java-进程"><a class="markdownIt-Anchor" href="#22-jps查看正在运行的-java-进程"></a> 2.2. jps：查看正在运行的 Java 进程</h2><p>jps(Java Process Status)：显示指定系统内所有的 HotSpot 虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p><p>说明：对于本地虚拟机进程来说，进程的本地虚拟机 ID 与操作系统的进程 ID 是一致的，是唯一的。</p><p>基本使用语法为：jps [options] [hostid]</p><p>我们还可以通过追加参数，来打印额外的信息。</p><p><strong>options 参数</strong></p><ul><li>-q：仅仅显示 LVMID（local virtual machine id），即<strong>本地虚拟机唯一 id</strong>。不显示主类的名称等</li><li>-l：输出应用程序主类的<strong>全类名</strong> 或 如果进程执行的是 jar 包，则输出 <strong>jar 完整路径</strong></li><li>-m：输出虚拟机进程启动时传递给主类 main()的<strong>参数</strong></li><li>-v：列出虚拟机进程启动时的 JVM 参数。比如：-Xms20m -Xmx50m 是启动程序指定的 jvm 参数。</li></ul><p>说明：以上参数可以综合使用。（ jps -l -v 等同于 jps -lv    。。。，但是-q是独立的 ）</p><p>补充：如果某 Java 进程关闭了默认开启的 UsePerfData 参数（即使用参数-XX：-UsePerfData），那么 jps 命令（以及下面介绍的 jstat）将无法探知该 Java 进程。</p><p><strong>hostid 参数</strong></p><p>RMI 注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 jstatd。</p><p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到 IP 地址欺诈攻击。</p><p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行 jstatd 服务器，而是在本地使用 jstat 和 jps 工具。</p><h2 id="23-jstat查看-jvm-统计信息"><a class="markdownIt-Anchor" href="#23-jstat查看-jvm-统计信息"></a> 2.3. jstat：查看 JVM 统计信息</h2><p><strong>jstat（JVM Statistics Monitoring Tool）</strong>：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT 编译等运行数据。在没有 GUI 图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p><p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p><p>基本使用语法为：<font color="red"><strong>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</strong>&nbsp;&nbsp;</font></p><p>查看命令相关参数：jstat-h 或 jstat-help</p><p>其中 vmid 是进程 id 号，也就是 jps 之后看到的前面的号码，如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/83dddc874824b88d7fd03dab2b3889f1.png" alt="image-20210504201703222"></p><p><strong>option 参数</strong></p><p>选项 option 可以由以下值构成。</p><p><mark>类装载相关的：</mark></p><ul><li>-class：显示 ClassLoader 的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul><p><mark>垃圾回收相关的：</mark></p><ul><li>-gc：显示与 GC 相关的堆信息。包括 Eden 区、两个 Survivor 区、老年代、永久代等的容量、已用空间、GC 时间合计等信息。</li><li>-gccapacity：显示内容与-gc 基本相同，但输出主要关注 Java 堆各个区域使用到的最大、最小空间。</li><li>-gcutil：显示内容与-gc 基本相同，但输出主要关注已使用空间占总空间的百分比。</li><li>-gccause：与-gcutil 功能一样，但是会额外输出导致最后一次或当前正在发生的 GC 产生的原因。</li><li>-gcnew：显示新生代 GC 状况</li><li>-gcnewcapacity：显示内容与-gcnew 基本相同，输出主要关注使用到的最大、最小空间</li><li>-geold：显示老年代 GC 状况</li><li>-gcoldcapacity：显示内容与-gcold 基本相同，输出主要关注使用到的最大、最小空间</li><li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li></ul><p><mark>JIT 相关的：</mark></p><ul><li><p>-compiler：显示 JIT 编译器编译过的方法、耗时等信息</p></li><li><p>-printcompilation：输出已经被 JIT 编译的方法</p></li></ul><p><strong>jstat -class</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9f2cea8b0a9b1bc47c10281b5c140cc4.png" alt="img"></p><p><strong>jstat -compiler</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e11a07ce9b8ff2f73ba5585e11e1da3.png" alt="img"></p><p><strong>jstat -printcompilation</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2a2553eef35293d28ef095feee3bb3b7.png" alt="img"></p><p><strong>jstat -gc</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ea2aa6665c49b4bd35d46152dd2f1aa.png" alt="img"></p><p><strong>jstat -gccapacity</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/be1dbc9fb1100c4ab76fdf802171c000.png" alt="img"></p><p><strong>jstat -gcutil</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/527f347102e0f48036f4e643103a735f.png" alt="img"></p><p><strong>jstat -gccause</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2e5d220a3ceb094b3d6aee8b46867942.png" alt="img"></p><p><strong>jstat -gcnew</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/766a9d8c98c1add9ff60f001fcbe552b.png" alt="img"></p><p><strong>jstat -gcnewcapacity</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d26356900de541c149df9c00852245a1.png" alt="img"></p><p><strong>jstat -gcold</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/64f18adec84996fec58edf7052440610.png" alt="img"></p><p><strong>jstat -gcoldcapacity</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/52bf3b50ba4a48247742caa0aa30be7e.png" alt="img"></p><p><strong>jstat -t</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/61a5c6b9c421ba9ec38db1f132ef4161.png" alt="img"></p><p><strong>jstat -t -h</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/73a294c043f770940daa6a501c1e8d2c.png" alt="img"></p><table><thead><tr><th style="text-align:left">表头</th><th style="text-align:left">含义（字节）</th></tr></thead><tbody><tr><td style="text-align:left">EC</td><td style="text-align:left">Eden 区的大小</td></tr><tr><td style="text-align:left">EU</td><td style="text-align:left">Eden 区已使用的大小</td></tr><tr><td style="text-align:left">S0C</td><td style="text-align:left">幸存者 0 区的大小</td></tr><tr><td style="text-align:left">S1C</td><td style="text-align:left">幸存者 1 区的大小</td></tr><tr><td style="text-align:left">S0U</td><td style="text-align:left">幸存者 0 区已使用的大小</td></tr><tr><td style="text-align:left">S1U</td><td style="text-align:left">幸存者 1 区已使用的大小</td></tr><tr><td style="text-align:left">MC</td><td style="text-align:left">元空间的大小</td></tr><tr><td style="text-align:left">MU</td><td style="text-align:left">元空间已使用的大小</td></tr><tr><td style="text-align:left">OC</td><td style="text-align:left">老年代的大小</td></tr><tr><td style="text-align:left">OU</td><td style="text-align:left">老年代已使用的大小</td></tr><tr><td style="text-align:left">CCSC</td><td style="text-align:left">压缩类空间的大小</td></tr><tr><td style="text-align:left">CCSU</td><td style="text-align:left">压缩类空间已使用的大小</td></tr><tr><td style="text-align:left">YGC</td><td style="text-align:left">从应用程序启动到采样时 young gc 的次数</td></tr><tr><td style="text-align:left">YGCT</td><td style="text-align:left">从应用程序启动到采样时 young gc 消耗时间（秒）</td></tr><tr><td style="text-align:left">FGC</td><td style="text-align:left">从应用程序启动到采样时 full gc 的次数</td></tr><tr><td style="text-align:left">FGCT</td><td style="text-align:left">从应用程序启动到采样时的 full gc 的消耗时间（秒）</td></tr><tr><td style="text-align:left">GCT</td><td style="text-align:left">从应用程序启动到采样时 gc 的总时间</td></tr></tbody></table><p><strong>interval 参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p><p><strong>count 参数：</strong> 用于指定查询的总次数</p><p><strong>-t 参数：</strong> 可以在输出信息前加上一个 Timestamp 列，显示程序的运行时间。单位：秒</p><p><strong>-h 参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p><p><img src="../../../images/image-20230112235314295.png" alt="image-20230112235314295"></p><p><strong>补充：</strong> jstat 还可以用来<mark>判断是否出现内存泄漏。</mark></p><p>第 1 步：在长时间运行的 Java 程序中，我们可以运行 jstat 命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p><p>第 2 步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈<strong>上涨趋势</strong>，则<strong>说明</strong>该 Java 程序的老年代内存已使用量在不断上涨，这意味着<strong>无法回收的对象在不断增加</strong>，因此很有可能存在内存泄漏。</p><h2 id="24-jinfo实时查看和修改-jvm-配置参数"><a class="markdownIt-Anchor" href="#24-jinfo实时查看和修改-jvm-配置参数"></a> 2.4. jinfo：实时查看和修改 JVM 配置参数</h2><p><strong>jinfo(Configuration Info for Java)</strong>：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java 应用程序不会指定所有的 Java 虚拟机参数。而此时，开发人员可能不知道某一个具体的 Java 虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但<strong>有了 jinfo 工具，开发人员可以很方便地找到 Java 虚拟机参数的当前值。</strong></p><p><strong>基本使用语法为：<font color="red">jinfo [options] pid</font></strong></p><p>说明：java 进程 ID 必须要加上</p><table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [±]name</td><td>开启或者关闭对应名称的参数 只有被标记为 manageable 的参数才可以被动态修改</td></tr><tr><td>-flag name=value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table><p><strong>jinfo -sysprops</strong></p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&gt;</span> <span class="string">jinfo -sysprops</span></span><br><span class="line"><span class="attr">jboss.modules.system.pkgs</span> = <span class="string">com.intellij.rt</span></span><br><span class="line"><span class="attr">java.vendor</span> = <span class="string">Oracle Corporation</span></span><br><span class="line"><span class="attr">sun.java.launcher</span> = <span class="string">SUN_STANDARD</span></span><br><span class="line"><span class="attr">sun.management.compiler</span> = <span class="string">HotSpot 64-Bit Tiered Compilers</span></span><br><span class="line"><span class="attr">catalina.useNaming</span> = <span class="string">true</span></span><br><span class="line"><span class="attr">os.name</span> = <span class="string">Windows 10</span></span><br><span class="line"><span class="attr">...</span></span><br></pre></td></tr></tbody></table></figure><p><strong>jinfo -flags</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flags 25592</span></span><br><span class="line">Non-default VM flags: -XX:CICompilerCount=4 -XX:InitialHeapSize=333447168 -XX:MaxHeapSize=5324668928 -XX:MaxNewSize=1774714880 -XX:MinHeapDeltaBytes=524288 -XX:NewSize=111149056 -XX:OldSize=222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">Command line:  -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8040,suspend=y,server=n -Drebel.base=C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version=2021.1.2 -Drebel.env.ide.version=2020.3.3 -Drebel.env.ide.product=IU -Drebel.env.ide=intellij -Drebel.notification.url=http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home=D:\eclipse\env\maven -Didea.modules.paths.file=C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf=C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path=D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding=UTF-8</span><br></pre></td></tr></tbody></table></figure><p><strong>jinfo -flag</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseParallelGC 25592</span></span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseG1GC 25592</span></span><br><span class="line">-XX:-UseG1GC</span><br></pre></td></tr></tbody></table></figure><p><strong>jinfo -flag name</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseParallelGC 25592</span></span><br><span class="line">-XX:+UseParallelGC</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag UseG1GC 25592</span></span><br><span class="line">-XX:-UseG1GC</span><br></pre></td></tr></tbody></table></figure><p><strong>jinfo -flag [±]name</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag +PrintGCDetails 25592</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag PrintGCDetails 25592</span></span><br><span class="line">-XX:+PrintGCDetails</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag -PrintGCDetails 25592</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jinfo -flag PrintGCDetails 25592</span></span><br><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></tbody></table></figure><p><strong>拓展：</strong></p><ul><li><p>java -XX:+PrintFlagsInitial 查看所有 JVM 参数启动的初始值</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  {product}</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   {product}</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  {product}</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   {product}</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure></li><li><p>java -XX:+PrintFlagsFinal 查看所有 JVM 参数的最终值</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  {product}</span><br><span class="line">...</span><br><span class="line">     intx CICompilerCount                          := 4                                   {product}</span><br><span class="line">    uintx InitialHeapSize                          := 333447168                           {product}</span><br><span class="line">    uintx MaxHeapSize                              := 1029701632                          {product}</span><br><span class="line">    uintx MaxNewSize                               := 1774714880                          {product}</span><br></pre></td></tr></tbody></table></figure></li><li><p>java -XX:+PrintCommandLineFlags 查看哪些已经被用户或者 JVM 设置过的详细的 XX 参数的名称和值</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitialHeapSize=332790016 -XX:MaxHeapSize=5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="25-jmap导出内存映像文件内存使用情况"><a class="markdownIt-Anchor" href="#25-jmap导出内存映像文件内存使用情况"></a> 2.5. jmap：导出内存映像文件&amp;内存使用情况</h2><p>jmap（JVM Memory Map）：作用一方面是获取 dump 文件（堆转储快照文件，二进制文件），它还可以获取目标 Java 进程的内存相关信息，包括 Java 堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅 jmap 工具的具体使用方式和一些标准选项配置。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p><p>基本使用语法为：</p><ul><li>jmap [option] &lt;pid&gt;</li><li>jmap [option] &lt;executable &lt;core&gt;</li><li>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</li></ul><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left"><mark>-dump</mark></td><td style="text-align:left">生成 dump 文件（Java 堆转储快照），-dump:live 只保存堆中的存活对象</td></tr><tr><td style="text-align:left"><mark>-heap</mark></td><td style="text-align:left">输出整个堆空间的详细信息，包括 GC 的使用、堆配置信息，以及内存的使用信息等</td></tr><tr><td style="text-align:left"><mark>-histo</mark></td><td style="text-align:left">输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live 只统计堆中的存活对象</td></tr><tr><td style="text-align:left">-J &lt;flag&gt;</td><td style="text-align:left">传递参数给 jmap 启动的 jvm</td></tr><tr><td style="text-align:left">-finalizerinfo</td><td style="text-align:left">显示在 F-Queue 中等待 Finalizer 线程执行 finalize 方法的对象，仅 linux/solaris 平台有效</td></tr><tr><td style="text-align:left">-permstat</td><td style="text-align:left">以 ClassLoader 为统计口径输出永久代的内存状态信息，仅 linux/solaris 平台有效</td></tr><tr><td style="text-align:left">-F</td><td style="text-align:left">当虚拟机进程对-dump 选项没有任何响应时，强制执行生成 dump 文件，仅 linux/solaris 平台有效</td></tr></tbody></table><p>说明：这些参数和 linux 下输入显示的命令多少会有不同，包括也受 jdk 版本的影响。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;&gt; jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>使用1：导出内存映像文件</strong></p><p><img src="../../../images/image-20230113003211040.png" alt="image-20230113003211040"></p><p><img src="../../../images/image-20230113003139159.png" alt="image-20230113003139159"></p><p><strong>手动的方式</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -dump:format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br><span class="line">jmap -dump:live,format=b,file=&lt;filename.hprof&gt; &lt;pid&gt;</span><br></pre></td></tr></tbody></table></figure><p>生产dump文件</p><p><img src="../../../images/image-20230113005352119.png" alt="image-20230113005352119"></p><p>你会发现导出的hprof文件会越来越大,就是因为随着应用的执行,相关的数据也会越来越多,当然如果你参数配置带有-dump:live参数的话,代表hprof只保存堆中存货的对象. , 那么你生成的hprof文件也有可能会变小.<br>在实际的生产环境中,你生成的hprof文件可能会有几百mb大小,这样文件就有点大了,dump指令如果带有live之后,这样hprof文件可能就不会那么大了, 实际情况下oom 情况大多数原因是gc回收不走的对象存活导致的,所以实际生产环境,绝大多数都是用-dump:live指令</p><p><strong>自动的方式：</strong></p><p><img src="../../../images/image-20230113003635968.png" alt="image-20230113003635968"></p><p><img src="../../../images/image-20230113005642550.png" alt="image-20230113005642550"></p><p>启动程序之后等待</p><p><img src="../../../images/image-20230113005510446.png" alt="image-20230113005510446"></p><p>当发生oom的一瞬间，立马就生成了一个hprof文件出来</p><p><strong>注意：手动的方式 和 自动的方式的区别</strong></p><ul><li>对于以上说明中的第1点是自动方式才会这样做，而手动不会在Full GC之后生成Dump</li><li>使用手动方式生成dump文件，一般指令执行之后就会生成，不用等到快出现OOM的时候</li><li>使用自动方式生成dump文件，当出现OOM之前先生成dump文件</li><li>如果使用手动方式，一般使用第2种，毕竟生成堆中存活对象的dump文件是比较小的，便于传输和分析</li></ul><p><img src="../../../images/image-20230113004340895.png" alt="image-20230113004340895"></p><p><strong>小结：</strong></p><p>由于 jmap 将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，<strong>jmap 需要借助<font color="red">安全点机制</font></strong>，让所有线程停留在不改变堆中数据的状态。也就是说，由 jmap 导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p><p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live 选项将无法探知到这些对象。</p><p>另外，如果某个线程长时间无法跑到安全点，jmap 将一直等下去。与前面讲的 jstat 则不同，垃圾回收器会主动将 jstat 所需要的摘要数据保存至固定位置之中，而 jstat 只需直接读取即可。</p><h2 id="26-jhatjdk-自带堆分析工具"><a class="markdownIt-Anchor" href="#26-jhatjdk-自带堆分析工具"></a> 2.6. jhat：JDK 自带堆分析工具</h2><p>jhat(JVM Heap Analysis Tool)：Sun JDK 提供的 jhat 命令与 jmap 命令搭配使用，用于分析 jmap 生成的 heap dump 文件（堆转储快照）。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p><p>使用了 jhat 命令，就启动了一个 http 服务，端口是 7000，即 <a href="http://localhost:7000/%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E5%88%86%E6%9E%90%E3%80%82">http://localhost:7000/，就可以在浏览器里分析。</a></p><p>说明：jhat 命令在 JDK9、JDK10 中已经被删除，官方建议用 VisualVM 代替。</p><p>基本适用语法：jhat &lt;option&gt; &lt;dumpfile&gt;</p><table><thead><tr><th style="text-align:left">option 参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-stack false ｜ true</td><td style="text-align:left">关闭｜打开对象分配调用栈跟踪</td></tr><tr><td style="text-align:left">-refs false ｜ true</td><td style="text-align:left">关闭｜打开对象引用跟踪</td></tr><tr><td style="text-align:left">-port port-number</td><td style="text-align:left">设置 jhat HTTP Server 的端口号，默认 7000</td></tr><tr><td style="text-align:left">-exclude exclude-file</td><td style="text-align:left">执行对象查询时需要排除的数据成员</td></tr><tr><td style="text-align:left">-baseline exclude-file</td><td style="text-align:left">指定一个基准堆转储</td></tr><tr><td style="text-align:left">-debug int</td><td style="text-align:left">设置 debug 级别</td></tr><tr><td style="text-align:left">-version</td><td style="text-align:left">启动后显示版本信息就退出</td></tr><tr><td style="text-align:left">-J &lt;flag&gt;</td><td style="text-align:left">传入启动参数，比如-J-Xmx512m</td></tr></tbody></table><h2 id="27-jstack打印-jvm-中线程快照"><a class="markdownIt-Anchor" href="#27-jstack打印-jvm-中线程快照"></a> 2.7. jstack：打印 JVM 中线程快照</h2><p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程<strong>当前时刻</strong>的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p><p>生成线程快照的作用：<strong>可用于定位线程出现长时间停顿的原因</strong>，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用 jstack 显示各个线程调用的堆栈情况。</p><p>（场景：如果在程序运行中出现停顿时间比较长，就可以用这个 jstack 命令来查看具体原因，看是否是出现了一些线程问题，以及具体代码在哪一行）</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p><p>在 thread dump 中，要留意下面几种状态</p><ul><li><mark>死锁，Deadlock（重点关注）</mark></li><li><mark>等待资源，Waiting on condition（重点关注）</mark></li><li><mark>等待获取监视器，Waiting on monitor entry（重点关注）</mark></li><li><mark>阻塞，Blocked（重点关注）</mark></li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED＿WAITING</li><li>停止，Parked</li></ul><table><thead><tr><th style="text-align:left">option 参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">-F</td><td style="text-align:left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td style="text-align:left">-l</td><td style="text-align:left">除堆栈外，显示关于锁的附加信息</td></tr><tr><td style="text-align:left">-m</td><td style="text-align:left">如果调用本地方法的话，可以显示 C/C++的堆栈</td></tr></tbody></table><h2 id="28-jcmd多功能命令行"><a class="markdownIt-Anchor" href="#28-jcmd多功能命令行"></a> 2.8. jcmd：多功能命令行</h2><p>在 JDK 1.7 以后，新增了一个命令行工具 jcmd。它是一个多功能的工具，可以用来实现前面除了 jstat 之外所有命令的功能。比如：用它来导出堆、内存使用、查看 Java 进程、导出线程信息、执行 GC、JVM 运行时间等。</p><p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p><p>jcmd 拥有 jmap 的大部分功能，并且在 Oracle 的官方网站上也推荐使用 jcmd 命令代 jmap 命令</p><p>**jcmd -l：**列出所有的 JVM 进程</p><p>**jcmd 进程号 help：**针对指定的进程，列出支持的所有具体命令</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f3507ac3e24d40625f6c3d54c25c743b.png" alt="image-20210504213044819"></p><p>**jcmd 进程号 具体命令：**显示指定进程的指令命令的数据</p><ul><li>Thread.print 可以替换 jstack 指令</li><li>GC.class_histogram 可以替换 jmap 中的-histo 操作</li><li>GC.heap_dump 可以替换 jmap 中的-dump 操作</li><li>GC.run 可以查看 GC 的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换 jstat 指令中的-t 操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程 id</li><li>VM.flags 可以获取 JVM 的配置参数信息</li></ul><h2 id="29-jstatd远程主机信息收集"><a class="markdownIt-Anchor" href="#29-jstatd远程主机信息收集"></a> 2.9. jstatd：远程主机信息收集</h2><p>之前的指令只涉及到监控本机的 Java 应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如 jps、jstat）。为了启用远程监控，则需要配合使用 jstatd 工具。命令 jstatd 是一个 RMI 服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd 服务器将本机的 Java 应用程序信息传递到远程计算机。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2225de448c4af005aa0f72e84bba5e57.png" alt="image-20210504213301077"></p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-概述篇</title>
      <link href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/1-%E6%A6%82%E8%BF%B0%E7%AF%87/"/>
      <url>/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/1-%E6%A6%82%E8%BF%B0%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述篇"><a class="markdownIt-Anchor" href="#1-概述篇"></a> 1. 概述篇</h1><h2 id="11-大厂面试题"><a class="markdownIt-Anchor" href="#11-大厂面试题"></a> 1.1. 大厂面试题</h2><blockquote><p><mark>支付宝：</mark></p><p>支付宝三面：JVM 性能调优都做了什么？</p><p><mark>小米：</mark></p><p>有做过 JVM 内存优化吗？</p><p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p><p><mark>蚂蚁金服：</mark></p><p>JVM 的编译优化</p><p>jvm 性能调优都做了什么</p><p>JVM 诊断调优工具用过哪些？</p><p>二面：jvm 怎样调优，堆内存、栈空间设置多少合适</p><p>三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p><p><mark>阿里：</mark></p><p>如何进行 JVM 调优？有哪些方法？</p><p>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</p><p><mark>字节跳动：</mark></p><p>三面：JVM 如何调优、参数怎么调？</p><p><mark>拼多多：</mark></p><p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p><p><mark>京东：</mark></p><p>JVM 诊断调优工具用过哪些？</p><p>每秒几十万并发的秒杀系统为什么会频繁发生 GC？</p><p>日均百万级交易系统如何优化 JVM？</p><p>线上生产系统 OOM 如何监控及定位与解决？</p><p>高并发系统如何基于 G1 垃圾回收器优化性能？</p></blockquote><h2 id="12-背景说明"><a class="markdownIt-Anchor" href="#12-背景说明"></a> 1.2. 背景说明</h2><p><strong>生产环境中的问题</strong></p><ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境 CPU 负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加 log，如何确定请求是否执行了某一行代码？</li><li>不加 log，如何实时查看某个方法的入参与返回值？</li></ul><p><strong>为什么要调优</strong></p><ul><li>防止出现 OOM</li><li>解决 OOM</li><li>减少 Full GC 出现的频率</li></ul><p><strong>不同阶段的考虑</strong></p><ul><li>上线前</li><li>项目运行阶段</li><li>线上出现 OOM</li></ul><h2 id="13-调优概述"><a class="markdownIt-Anchor" href="#13-调优概述"></a> 1.3. 调优概述</h2><p><strong>监控的依据</strong></p><ul><li>运行日志</li><li>异常堆栈</li><li>GC 日志</li><li>线程快照</li><li>堆转储快照</li></ul><p><strong>调优的大方向</strong></p><ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行 JVM 调优</li></ul><h2 id="14-性能优化的步骤"><a class="markdownIt-Anchor" href="#14-性能优化的步骤"></a> 1.4. 性能优化的步骤</h2><p><strong>第 1 步：性能监控</strong></p><p><img src="../../../images/image-20230112214518042.png" alt="image-20230112214518042"></p><ul><li>GC 频繁</li><li>cpu load 过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul><p><strong>第 2 步：性能分析</strong></p><p><img src="../../../images/image-20230112214643733.png" alt="image-20230112214643733"></p><ul><li>打印 GC 日志，通过 GCviewer 或者 <a href="http://gceasy.io">http://gceasy.io</a> 来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo 等</li><li>dump 出堆文件，使用内存分析工具分析文件</li><li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li><li>jstack 查看堆栈信息</li></ul><p><strong>第 3 步：性能调优</strong></p><p><img src="../../../images/image-20230112214713212.png" alt="image-20230112214713212"></p><ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li><li>其他……</li></ul><h2 id="15-性能评价测试指标"><a class="markdownIt-Anchor" href="#15-性能评价测试指标"></a> 1.5. 性能评价/测试指标</h2><p><font color="red"><strong>（1）停顿时间（或响应时间）</strong></font></p><p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p><table><thead><tr><th style="text-align:left">操作</th><th style="text-align:left">响应时间</th></tr></thead><tbody><tr><td style="text-align:left">打开一个站点</td><td style="text-align:left">几秒</td></tr><tr><td style="text-align:left">数据库查询一条记录（有索引）</td><td style="text-align:left">十几毫秒</td></tr><tr><td style="text-align:left">机械磁盘一次寻址定位</td><td style="text-align:left">4 毫秒</td></tr><tr><td style="text-align:left">从机械磁盘顺序读取 1M 数据</td><td style="text-align:left">2 毫秒</td></tr><tr><td style="text-align:left">从 SSD 磁盘顺序读取 1M 数据</td><td style="text-align:left">0.3 毫秒</td></tr><tr><td style="text-align:left">从远程分布式换成 Redis 读取一个数据</td><td style="text-align:left">0.5 毫秒</td></tr><tr><td style="text-align:left">从内存读取 1M 数据</td><td style="text-align:left">十几微妙</td></tr><tr><td style="text-align:left">Java 程序本地方法调用</td><td style="text-align:left">几微妙</td></tr><tr><td style="text-align:left">网络传输 2Kb 数据</td><td style="text-align:left">1 微妙</td></tr></tbody></table><p>在垃圾回收环节中：</p><ul><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>-XX:MaxGCPauseMillis</li></ul><p><font color="red"><strong>（2）吞吐量</strong></font></p><ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在 GC 中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li><font color="red">吞吐量为 1-1/(1+n)，其中-XX::GCTimeRatio=n</font></li></ul><p><strong>（3）并发数</strong></p><ul><li>同一时刻，对服务器有实际交互的请求数</li></ul><p><strong>（4）内存占用</strong></p><ul><li>Java 堆区所占的内存大小</li></ul><p><strong>（5）相互间的关系</strong></p><p>以高速公路通行状况为例</p><ul><li>吞吐量：每天通过高速公路收费站的车辆的数据</li><li>并发数：高速公路上正在行驶的车辆的数目</li><li>响应时间：车速</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用OQL语言查询对象信息</title>
      <link href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/"/>
      <url>/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="补充使用-oql-语言查询对象信息"><a class="markdownIt-Anchor" href="#补充使用-oql-语言查询对象信息"></a> 补充：使用 OQL 语言查询对象信息</h1><p>MAT 支持一种类似于 SQL 的查询语言 OQL（Object Query Language）。OQL 使用类 SQL 语法，可以在堆中进行对象的查找和筛选。</p><h2 id="1-select-子句"><a class="markdownIt-Anchor" href="#1-select-子句"></a> 1. SELECT 子句</h2><p>在 MAT 中，Select 子句的格式与 SQL 基本一致，用于指定要显示的列。Select 子句中可以使用“＊”，查看结果对象的引用实例（相当于 outgoing references）。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></tbody></table></figure><p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure><p>在 Select 子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span><span class="keyword">FROM</span> com.atguigu.mat.Student</span><br></pre></td></tr></tbody></table></figure><p>“DISTINCT”关键字用于在结果集中去除重复对象。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure><h2 id="2-from-子句"><a class="markdownIt-Anchor" href="#2-from-子句"></a> 2. FROM 子句</h2><p>From 子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure><p>使用正则表达式，限定搜索范围，输出所有 com.atguigu 包下所有类的实例</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> "com\.atguigu\..*"</span><br></pre></td></tr></tbody></table></figure><p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同 ClassLoader 加载的同一种类型。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></tbody></table></figure><h2 id="3-where-子句"><a class="markdownIt-Anchor" href="#3-where-子句"></a> 3. WHERE 子句</h2><p>Where 子句用于指定 OQL 的查询条件。OQL 查询将只返回满足 Where 子句指定条件的对象。Where 子句的格式与传统 SQL 极为相似。</p><p>返回长度大于 10 的 char 数组。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure><p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> ".*java.*"</span><br></pre></td></tr></tbody></table></figure><p>返回所有 value 域不为 null 的字符串，使用“＝”操作符。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></span><br></pre></td></tr></tbody></table></figure><p>返回数组长度大于 15，并且深堆大于 1000 字节的所有 Vector 对象。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure><h2 id="4-内置对象与方法"><a class="markdownIt-Anchor" href="#4-内置对象与方法"></a> 4. 内置对象与方法</h2><p>OQL 中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中 alias 为对象名称：</p><p>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</p><p>访问 java.io.File 对象的 path 属性，并进一步访问 path 的 value 属性：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</span><br></pre></td></tr></tbody></table></figure><p>显示 String 对象的内容、objectid 和 objectAddress。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.toString(),s.<span class="variable">@objectId</span>, s.<span class="variable">@objectAddress</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure><p>显示 java.util.Vector 内部数组的长度。</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.elementData.<span class="variable">@length</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></tbody></table></figure><p>显示所有的 java.util.Vector 对象及其子类型</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INSTANCEOF java.util.Vector</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230116162222206.png" alt="image-20230116162222206"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-127.单词接龙</title>
      <link href="/2023/01/12/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/"/>
      <url>/2023/01/12/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/</url>
      
        <content type="html"><![CDATA[<h4 id="127-单词接龙"><a class="markdownIt-Anchor" href="#127-单词接龙"></a> <a href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h4><p>难度 <font color="red">困难</font></p><p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p><ul><li>每一对相邻的单词只差一个字母。</li><li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li><li><code>sk == endWord</code></li></ul><p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord "cog" 不在字典中，所以无法进行转换。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= beginWord.length &lt;= 10</code></li><li><code>endWord.length == beginWord.length</code></li><li><code>1 &lt;= wordList.length &lt;= 5000</code></li><li><code>wordList[i].length == beginWord.length</code></li><li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li><li><code>beginWord != endWord</code></li><li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li></ul><p>超时代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超出时间限制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Map&lt; String, Integer &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[ wordList.size() ];</span><br><span class="line">        Map&lt;String, Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( String s : wordList ) {</span><br><span class="line">            t.put(s, <span class="number">0</span>);</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordList.size(); i ++ ) {</span><br><span class="line">            <span class="keyword">if</span>( nextWord( beginWord,  wordList.get( i ) ) ) {</span><br><span class="line">                bfs( wordList.get( i ), endWord, wordList, i, <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(t) );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, <span class="type">int</span> index, <span class="type">int</span> count, Map&lt;String, Integer&gt; t )</span> {</span><br><span class="line">        <span class="keyword">if</span> ( count &gt;= min )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        t.put( beginWord, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( beginWord.equals( endWord ) ) {</span><br><span class="line">            <span class="comment">// System.out.println("===================================    " + count);</span></span><br><span class="line">            min = count &lt; min ? count : min;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( map.containsKey( beginWord + <span class="string">" "</span> + endWord ) ) {</span><br><span class="line">            <span class="keyword">if</span> ( count &gt;= min )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordList.size(); i ++ ) {</span><br><span class="line">            <span class="keyword">if</span> ( t.get( wordList.get(i) ) == <span class="number">0</span> &amp;&amp; nextWord( beginWord,  wordList.get( i ) ) ) {</span><br><span class="line">                bfs( wordList.get( i ), endWord, wordList, i, count + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;( t ) );</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        map.put( beginWord + <span class="string">" "</span> + endWord, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextWord</span><span class="params">( String beginWord, String word )</span> {</span><br><span class="line">        <span class="keyword">if</span> ( beginWord.equals( word ) || beginWord.length() != word.length() ) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; beginWord.length(); i ++ ) {</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(  beginWord.charAt( i ) != word.charAt( i ) ) {</span><br><span class="line">                n ++;</span><br><span class="line">                <span class="keyword">if</span> ( n &gt; <span class="number">1</span> ) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正解：广度优先搜索</p><p>思路：</p><p>分析题意：</p><p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图；</p><p><img src="https://pic.leetcode-cn.com/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png" alt="image.png"></p><p>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，复杂度是 O(NwordLen)，这里 NN 是单词列表的长度；<br>为此，我们在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，复杂度是 O(26×wordLen)，借助哈希表，找到邻居与 N 无关；<br>使用 BFS 进行遍历，需要的辅助数据结构是：<br>队列；<br>visited 集合。说明：可以直接在 wordSet (由 wordList 放进集合中得到)里做删除。但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于更快地（相对于链表）判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) {</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">                <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) {</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            step++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> {</span><br><span class="line">        <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) {</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) {</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 修改一个字母</span></span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                <span class="comment">// char[] --&gt; String</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) {</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) {</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅堆深堆与内存泄露</title>
      <link href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
      <url>/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="补充浅堆深堆与内存泄露"><a class="markdownIt-Anchor" href="#补充浅堆深堆与内存泄露"></a> 补充：浅堆深堆与内存泄露</h1><h2 id="1-浅堆shallow-heap"><a class="markdownIt-Anchor" href="#1-浅堆shallow-heap"></a> 1. 浅堆（Shallow Heap）</h2><p>浅堆是指一个对象所消耗的内存。在 32 位系统中，一个对象引用会占据 4 个字节，一个 int 类型会占据 4 个字节，long 型变量会占据 8 个字节，每个对象头需要占用 8 个字节。根据堆快照格式不同，对象的大小可能会同 8 字节进行对齐。</p><p>以 String 为例：2 个 int 值共占 8 字节，对象引用占用 4 字节，对象头 8 字节，合计 20 字节，向 8 字节对齐，故占 24 字节。（jdk7 中）</p><table><thead><tr><th>int</th><th>hash32</th><th>0</th></tr></thead><tbody><tr><td><strong>int</strong></td><td><strong>hash</strong></td><td><strong>0</strong></td></tr><tr><td><strong>ref</strong></td><td><strong>value</strong></td><td><strong>C:\Users\Administrat</strong></td></tr></tbody></table><p>这 24 字节为 String 对象的浅堆大小。它与 String 的 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节。</p><h2 id="2-保留集retained-set"><a class="markdownIt-Anchor" href="#2-保留集retained-set"></a> 2. 保留集（Retained Set）</h2><p>对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括对象 A 本身），即对象 A 的保留集可以被认为是只能通过对象 A 被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象 A 所持有的对象的集合。</p><h2 id="3-深堆retained-heap"><a class="markdownIt-Anchor" href="#3-深堆retained-heap"></a> 3. 深堆（Retained Heap）</h2><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p><p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p><h2 id="4-对象的实际大小"><a class="markdownIt-Anchor" href="#4-对象的实际大小"></a> 4. 对象的实际大小</h2><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p><p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，不含 C 和 D，而 A 的实际大小为 A、C、D 三者之和。而 A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到，因此不在对象 A 的深堆范围内。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ecc35ddfcfd13200bbc881333d38ac93.png" alt="image-20210505151123427"></p><h2 id="5-支配树dominator-tree"><a class="markdownIt-Anchor" href="#5-支配树dominator-tree"></a> 5. 支配树（Dominator Tree）</h2><p>支配树的概念源自图论。MAT 提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象 B 的路径都经过对象 A，则认为对象 A 支配对象 B。如果对象 A 是离对象 B 最近的一个支配对象，则认为对象 A 为对象 B 的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p><ul><li>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆。</li><li>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B。</li><li>支配树的边与对象引用图的边不直接对应。</li></ul><p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象 A 和 B 由根对象直接支配，由于在到对象 C 的路径中，可以经过 A，也可以经过 B，因此对象 C 的直接支配者也是根对象。对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此，对象 D 是对象 F 的直接支配者。而到对象 D 的所有路径中，必然经过对象 C，即使是从对象 F 到对象 D 的引用，从根节点出发，也是经过对象 C 的，所以，对象 D 的直接支配者为对象 C。同理，对象 E 支配对象 G。到达对象 H 的可以通过对象 D，也可以通过对象 E，因此对象 D 和 E 都不能支配对象 H，而经过对象 C 既可以到达 D 也可以到达 E，因此对象 C 为对象 H 的直接支配者。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4aea560be1feff266c7cb79c6a3a27ec.png" alt="image-20210505151951136"></p><h2 id="6-内存泄漏memory-leak"><a class="markdownIt-Anchor" href="#6-内存泄漏memory-leak"></a> 6. 内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏）。</p><p>＞ 是否还被使用？是</p><p>＞ 是否还被需要？否</p><p>（ 上面 ：【是，是】不是内存泄漏；但【是，否】就有问题了，属于内存泄漏，比如下图右边的 <strong>Fogotten Reference-&gt;Memory Leak</strong> ）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d5715ef16f3d967f6a79c82909877c15.png" alt="image-20210505152542224"></p><p><font color="red">严格来说，</font><strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</strong></p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的<strong>生命周期变得很长甚至导致 00M</strong>，也可以叫做<font color="red">宽泛意义上的“内存泄漏”。</font></p><p>如下图，对象X引用对象Y，X的生命周期比Y的生命周期长，当 Y 生命周期结束的时候，X 依然引用着 Y，这时候，垃圾回收期是不会回收对象 Y 的；如果对象 X 还引用着生命周期比较短的 A、B、C，对象 A 又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/98ee5c3507d1b8b73f4e12789728c56c.png" alt="image-20210505152704141"></p><p>申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 512M 的内存一直不回收，那么可以用的内存只有 512M 了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉 shi】</p><p><img src="../../../images/image-20230116112741682.png" alt="image-20230116112741682"></p><h2 id="7-内存溢出out-of-memory"><a class="markdownIt-Anchor" href="#7-内存溢出out-of-memory"></a> 7. 内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p><p><mark>泄漏的分类</mark></p><ul><li><strong>经常发生</strong>：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li><li><strong>偶然发生</strong>：在某些特定情况下才会发生（比如再程序中有些资源最后是需要关闭的，但可能因为前面一些异常而没有往下执行到 close关闭，导致资源没有关闭）</li><li><strong>一次性</strong>：发生内存泄露的方法只会执行一次；</li><li><strong>隐式泄漏</strong>：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li></ul><h2 id="8-java-中内存泄露的-8-种情况"><a class="markdownIt-Anchor" href="#8-java-中内存泄露的-8-种情况"></a> 8. Java 中内存泄露的 8 种情况</h2><h3 id="81-静态集合类"><a class="markdownIt-Anchor" href="#81-静态集合类"></a> 8.1. 静态集合类</h3><p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>{</span><br><span class="line">        Object obj＝<span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="82-单例模式"><a class="markdownIt-Anchor" href="#82-单例模式"></a> 8.2. 单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p><h3 id="83-内部类持有外部类"><a class="markdownIt-Anchor" href="#83-内部类持有外部类"></a> 8.3. 内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p><h3 id="84-各种连接如数据库连接-网络连接和-io-连接等"><a class="markdownIt-Anchor" href="#84-各种连接如数据库连接-网络连接和-io-连接等"></a> 8.4. 各种连接，如数据库连接、网络连接和 IO 连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        conn =DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>stmt.executeQuery(<span class="string">"...."</span>);</span><br><span class="line">    } <span class="keyword">catch</span>（Exception e）{<span class="comment">//异常日志</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 1．关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2．关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3．关闭连接 Connection</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="85-变量不合理的作用域"><a class="markdownIt-Anchor" href="#85-变量不合理的作用域"></a> 8.5. 变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，<strong>一个变量的定义的作用范围大于其使用范围</strong>，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为 null，很有可能导致内存泄漏的发生。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> {</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>{</span><br><span class="line">        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">        saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>如上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量 msg 中，然后调用 saveDB 方法把 msg 的内容保存到数据库中，此时 msg 已经就没用了，由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能回收，因此造成了内存泄漏。实际上这个 msg 变量可以放在 receiveMsg 方法内部，当方法使用完，那么 msg 的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</p><p>上面的代码应该改为：</p><p><img src="../../../images/image-20230116153505713.png" alt="image-20230116153505713"></p><h3 id="86-改变哈希值"><a class="markdownIt-Anchor" href="#86-改变哈希值"></a> 8.6. 改变哈希值</h3><p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p><p>否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏。</p><p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把 String 当做 HashMap 的 key 值；</p><p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"AA"</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">"CC"</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"CC"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"AA"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(person.name) : person.name == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Point&gt;();</span><br><span class="line">        <span class="type">Point</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"hs.remove = "</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">"hs.size = "</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Point{"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="87-缓存泄露"><a class="markdownIt-Anchor" href="#87-缓存泄露"></a> 8.7. 缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动极慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p><p>对于这个问题，可以使用 <mark><strong>WeakHashMap</strong> </mark>代表缓存，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">wMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct1"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct2"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct3"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct4"</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">"cacheObject1"</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">"cacheObject2"</span>);</span><br><span class="line">        map.put(ref3, <span class="string">"cacheObject3"</span>);</span><br><span class="line">        map.put(ref4, <span class="string">"cacheObject4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"String引用ref1，ref2，ref3，ref4 消失"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakHashMap</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testHashMap</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230116154929699.png" alt="image-20230116154929699"></p><p>上面代码和图示主演演示 <strong>WeakHashMap 如何自动释放缓存对象</strong>，当 init 函数执行完成后，局部变量字符串引用 weakd1，weakd2，d1，d2 都会消失，此时只有静态 map 中保存中对字符串对象的引用，可以看到，调用 gc 之后，HashMap 的没有被回收，而 WeakHashMap 里面的缓存被回收了。</p><h3 id="88-监听器和其他回调"><a class="markdownIt-Anchor" href="#88-监听器和其他回调"></a> 8.8. 监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。</p><p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为 WeakHashMap 中的键。</p><h2 id="9-内存泄露-案例分析"><a class="markdownIt-Anchor" href="#9-内存泄露-案例分析"></a> 9. 内存泄露 案例分析</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> {</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> { <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> { <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着 GC 活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p><p>代码的主要问题在 pop 函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p><p><img src="https://img-blog.csdnimg.cn/img_convert/36134d739f40208bf54a0b5c89a8f882.png" alt="image-20210505160114618"></p><p>当进行大量的 pop 操作时，由于引用未进行置空，gc 是不会释放的，如下图所示</p><p><img src="https://img-blog.csdnimg.cn/img_convert/52eed9c8a0279db4b1f07fd23c0d5eca.png" alt="image-20210505160158618"></p><p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称<font color="red">过期引用</font>，这个内存泄露很隐蔽。</p><p>将代码中的 pop()方法变成如下方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一旦引用过期，清空这些引用，将引用置空。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/513c31471d30b0458114859524c35adc.png" alt="image-20210505160423289"></p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM下篇：性能监控与调优篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM下篇：性能监控与调优篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5-再谈类的加载器</title>
      <link href="/2023/01/11/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/5-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>/2023/01/11/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/5-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h1><p>类加载器是JVM执行类加载机制的前提。</p><p><strong>ClassLoader的作用：</strong></p><p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fb51cabb2218d857a809a59918c5beec.png" alt="image-20210501102535142"></p><h2 id="11-大厂面试题"><a class="markdownIt-Anchor" href="#11-大厂面试题"></a> 1.1. 大厂面试题</h2><blockquote><p><mark>蚂蚁金服：</mark></p><p>深入分析ClassLoader，双亲委派机制</p><p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p><p><mark>百度：</mark></p><p>都有哪些类加载器，这些类加载器都加载哪些文件？</p><p>手写一个类加载器Demo</p><p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p><p><mark>腾讯：</mark></p><p>什么是双亲委派模型？</p><p>类加载器有哪些？</p><p><mark>小米：</mark></p><p>双亲委派模型介绍一下</p><p><mark>滴滴：</mark></p><p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p><p><mark>字节跳动：</mark></p><p>什么是类加载器，类加载器有哪些？</p><p><mark>京东：</mark></p><p>类加载器的双亲委派模型是什么？</p><p>双亲委派机制可以打破吗？为什么</p></blockquote><h2 id="12-类加载器的分类"><a class="markdownIt-Anchor" href="#12-类加载器的分类"></a> 1.2. 类加载器的分类</h2><p>类的加载分类：显式加载 vs 隐式加载</p><p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p><ul><li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li><li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li></ul><p>在日常开发以上两种方式一般会混合使用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式加载</span></span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//显式加载，并初始化</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"com.test.java.User"</span>);</span><br><span class="line"><span class="comment">//显式加载，但不初始化</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.test.java.Parent"</span>); </span><br></pre></td></tr></tbody></table></figure><h2 id="13-类加载器的必要性"><a class="markdownIt-Anchor" href="#13-类加载器的必要性"></a> 1.3. 类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p><ul><li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li><li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li><li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li></ul><h2 id="14-命名空间"><a class="markdownIt-Anchor" href="#14-命名空间"></a> 1.4. 命名空间</h2><p><strong>何为类的唯一性？</strong></p><p><font color="red">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。</font>每一个类加载器，都拥有一个独立的类名称空间：<font color="red">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</font>否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p><p><strong>命名空间</strong></p><ul><li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</p></li><li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</p></li><li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p></li></ul><p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p><p><img src="../../../images/image-20230111151013926.png" alt="image-20230111151013926"></p><h2 id="15-类加载机制的基本特征"><a class="markdownIt-Anchor" href="#15-类加载机制的基本特征"></a> 1.5. 类加载机制的基本特征</h2><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p><p><mark>可见性</mark>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p><p><mark>单一性</mark>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p><h2 id="16-类加载器之间的关系"><a class="markdownIt-Anchor" href="#16-类加载器之间的关系"></a> 1.6. 类加载器之间的关系</h2><p>Launcher类核心代码</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">} <span class="keyword">catch</span> (IOException var10) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">} <span class="keyword">catch</span> (IOException var9) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>ExtClassLoader的Parent类是null</strong></p></li><li><p><strong>AppClassLoader的Parent类是ExtClassLoader</strong></p></li><li><p><strong>当前线程的ClassLoader是AppClassLoader</strong></p></li></ul><p><font color="red">注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</font></p><hr><h1 id="2-类的加载器分类"><a class="markdownIt-Anchor" href="#2-类的加载器分类"></a> 2. 类的加载器分类</h1><p><img src="../../../images/image-20230111152254983.png" alt="image-20230111152254983"></p><p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0c43fb4a7da20038c8f56b42a1ddf802.png" alt="image-20210501164413665"></p><ul><li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li><li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li></ul><p>父类加载器和子类加载器的关系：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>{</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>{</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>{ <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p><p><strong>注意：</strong></p><p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p><h2 id="21-引导类加载器"><a class="markdownIt-Anchor" href="#21-引导类加载器"></a> 2.1. 引导类加载器</h2><p><mark>启动类加载器（引导类加载器，Bootstrap ClassLoader）</mark></p><ul><li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p></li><li><p>它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p></li><li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p></li><li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p></li><li><p>加载 扩展类和应用程序类加载器，并指定为他们的父类加载器。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/43431a1abff0e5f2bd7bfd20fe91e5f7.png" alt="image-20210501170011811"><br><img src="https://img-blog.csdnimg.cn/img_convert/5cd73234cd993408846ec7b4c2cb7238.png" alt="image-20210501170038212"><br>使用**-XX:+TraceClassLoading**参数得到。</p></li></ul><p>启动类加载器使用C++编写的？Yes！</p><ul><li>C/C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li><li>Java：由C<ins>演变而来，（C</ins>）–版，单继承</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊"</span>);</span><br><span class="line"><span class="comment">// 获取BootstrapclassLoader能够加载的api的路径</span></span><br><span class="line">URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL element : urLs) {</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></tbody></table></figure><p><strong>执行结果：</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/c72286acf05c7f86d1ea24f74e0c2a1e.png" alt="image-20210501170425889"></p><h2 id="22-扩展类加载器"><a class="markdownIt-Anchor" href="#22-扩展类加载器"></a> 2.2. 扩展类加载器</h2><p><mark>扩展类加载器（Extension ClassLoader）</mark></p><ul><li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p></li><li><p>（间接）继承于ClassLoader类</p></li><li><p>父类加载器为启动类加载器</p></li><li><p>从  <strong>java.ext.dirs</strong> 系统属性所指定的目录中加载类库，或从JDK的安装目录的 <strong>jre/lib/ext</strong> 子目录下加载类库。如果用户创建的 <strong>JAR</strong> 放在此目录下，也会自动由扩展类加载器加载。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ba54af96e744eb99a9248d13e55a7e3c.png" alt="在这里插入图片描述"></p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span>System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line"><span class="keyword">for</span> (String path :extDirs.split( regex:<span class="string">";"</span>)){</span><br><span class="line">    System.out.println(path);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span></span><br><span class="line"><span class="type">lassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();</span><br><span class="line">System.out.print1n(classLoader1); <span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br></pre></td></tr></tbody></table></figure><p><strong>执行结果：</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b21313ee65acb4f01f1d03b88529e9f5.png" alt="img"></p><h2 id="23-系统类加载器"><a class="markdownIt-Anchor" href="#23-系统类加载器"></a> 2.3. 系统类加载器</h2><p><mark>应用程序类加载器（系统类加载器，AppClassLoader）</mark>   （使用频率最高的加载器）</p><ul><li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li><li>继承于ClassLoader类</li><li>父类加载器 为 扩展类加载器</li><li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li><li><font color="red">应用程序中的类加载器默认是系统类加载器。</font></li><li>它是用户自定义类加载器的默认父加载器</li><li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/19dd9595afeb6543593ef14161fc1bb8.png" alt="image-20210501171206453"></p><h2 id="24-用户自定义类加载器"><a class="markdownIt-Anchor" href="#24-用户自定义类加载器"></a> 2.4. 用户自定义类加载器</h2><p><mark>用户自定义类加载器</mark></p><ul><li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li><li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，<strong>Java开发者可以自定义类加载器来实现类库的动态加载</strong>，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li><li><font color="red">通过类加载器可以实现非常绝妙的插件机制</font>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li><li>同时，<font color="red">自定义加载器能够实现应用隔离}</font>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C<ins>程序要好太多，想不修改C/C</ins>程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li><li>自定义类加载器通常需要继承于ClassLoader。</li></ul><hr><h1 id="3-测试不同的类的加载器"><a class="markdownIt-Anchor" href="#3-测试不同的类的加载器"></a> 3. 测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。<br><strong>获取ClassLoader的途径</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></tbody></table></figure><p><strong>说明：</strong></p><ul><li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加<br>载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载<br>器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li><li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器<br>来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型<br>是基本数据类型，数组类是没有类加载器的。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span></span><br><span class="line">ClassLoaderTest[] test=<span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="type">int</span>[]ints =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></tbody></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();</span><br><span class="line">        System.out.print1n(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppCLassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span>systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span>extClassLoader.getParent();</span><br><span class="line">        System.out.print1n(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##################################</span></span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="comment">// 获取到的是 引导类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>Class.forName(<span class="string">"java.lang.String"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);  <span class="comment">// null</span></span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1=Class.forName(<span class="string">"com.atguigu.java.ClassLoaderTest1"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrstr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());<span class="comment">//null：表示使用的是引导类加载器</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 自定义的类的数据，还是默认使用系统类加载器</span></span><br><span class="line">            ClassLoaderTest1[] arr1 =<span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc. Launcher$AppcLassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基本数据类型由虚拟机预先定义的（而引用数据类型则需要进行类的加载）</span></span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader()); <span class="comment">//null: 不需要（或是说没有）类加载器</span></span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><hr><h1 id="4-classloader源码解析"><a class="markdownIt-Anchor" href="#4-classloader源码解析"></a> 4. ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p><p><img src="../../../images/image-20230111212620186.png" alt="image-20230111212620186"></p><p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><h2 id="41-classloader的主要方法"><a class="markdownIt-Anchor" href="#41-classloader的主要方法"></a> 4.1. ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></tbody></table></figure><p>返回该类加载器的超类加载器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></tbody></table></figure><p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。<mark>该方法中的逻辑就是双亲委派模式的实现。</mark></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></tbody></table></figure><p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p><ul><li><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</p></li><li><p>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<font color="red">一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</font></p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><br></pre></td></tr></tbody></table></figure><p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p><ul><li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p></li><li><p><font color="red">defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</font></p></li></ul><p><strong>简单举例：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] classData =getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,θ,classData.length);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span><br></pre></td></tr></tbody></table></figure><p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></tbody></table></figure><p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></tbody></table></figure><p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p><p><img src="../../../images/image-20230111214619659.png" alt="image-20230111214619659"></p><p><img src="../../../images/image-20230111214648047.png" alt="image-20230111214648047"></p><h2 id="42-secureclassloader与urlclassloader"><a class="markdownIt-Anchor" href="#42-secureclassloader与urlclassloader"></a> 4.2. SecureClassLoader与URLClassLoader</h2><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p><p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<font color="red">在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</font>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/53f634bada23b3400a303bfcc6e11a31.png" alt="image-20210501174730756"></p><h2 id="43-extclassloader与appclassloader"><a class="markdownIt-Anchor" href="#43-extclassloader与appclassloader"></a> 4.3. ExtClassLoader与AppClassLoader</h2><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p><p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a77b6bca10308e6b9be35b1b2dfc84bc.png" alt="img"></p><p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p><h2 id="44-classforname与classloaderloadclass"><a class="markdownIt-Anchor" href="#44-classforname与classloaderloadclass"></a> 4.4. Class.forName()与ClassLoader.loadClass()</h2><p>( ps : 面试有可能会问这两者的区别 )</p><p><strong>Class.forName()</strong></p><ul><li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p></li><li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.atguigu.java.Helloworld"</span>);</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>ClassLoader.loadClass()</strong></p><ul><li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p></li><li><p>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Classloader</span> <span class="variable">cl</span> <span class="operator">=</span> ......; cl.loadClass(<span class="string">"com.atguigu.java.Helloworld"</span>);</span><br></pre></td></tr></tbody></table></figure><hr></li></ul><h1 id="5-双亲委派模型"><a class="markdownIt-Anchor" href="#5-双亲委派模型"></a> 5. 双亲委派模型</h1><h2 id="51-定义与本质"><a class="markdownIt-Anchor" href="#51-定义与本质"></a> 5.1. 定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p><p><strong>定义</strong></p><p><mark>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</mark></p><p><strong>本质</strong></p><p><font color="red">规定了<strong>类加载的顺序</strong>是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</font></p><p><img src="https://img-blog.csdnimg.cn/img_convert/41cbfd9ba1da676a7f05dae0dac3abae.png" alt="image-20210501175529542"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c1526b63e95852b48551b4f136ebbd6f.png" alt="img"></p><h2 id="52-优势与劣势"><a class="markdownIt-Anchor" href="#52-优势与劣势"></a> 5.2. 优势与劣势</h2><p><strong>双亲委派机制优势</strong></p><ul><li><p>避免类的重复加载，确保一个类的全局唯一性</p><p><font color="red">Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</font></p></li><li><p>保护程序安全，防止核心API被随意篡改</p></li></ul><p><strong>代码支持</strong></p><p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p><p>双亲委派的模型就隐藏在这第2和第3步中。</p><p><img src="../../../images/image-20230111220340860.png" alt="image-20230111220340860"></p><p><strong>举例</strong></p><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><p><strong>思考</strong></p><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p><p><strong>弊端</strong></p><p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<font color="red">应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。</font>比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><p><strong>结论</strong></p><p><font color="red">由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</font>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p><h2 id="53-破坏双亲委派机制"><a class="markdownIt-Anchor" href="#53-破坏双亲委派机制"></a> 5.3. 破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p><p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p><p><strong>第一次破坏双亲委派机制</strong></p><p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。</p><p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<font color="red">为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</font>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p><p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p><p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<font color="red">越基础的类由越上层的加载器进行加载</font>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有<font color="red">基础类型又要调用回用户的代码，那该怎么办呢？</font></p><p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<font color="red">启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</font><u>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</u></p><p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<font color="red">线程上下文类加载器（Thread Context ClassLoader）</font>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p><p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<font color="red">这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经<strong>违背了</strong>双亲委派模型的一般性原则</font>，但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/814235dcce5471c2a527e82bafcf21c7.png" alt="img"></p><p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p><p><strong>第三次破坏双亲委派机制</strong></p><p>双亲委派模型的第三次“被破坏”是由于<strong>用户对程序动态性的追求而导致</strong>的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p><p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<font color="red">网状结构。</font></p><p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p><p>1）<font color="red">将以java.*开头的类，委派给父类加载器加载。</font></p><p>2）<font color="red">否则，将委派列表名单内的类，委派给父类加载器加载。</font></p><p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p><p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p><p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p><p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</p><p>7）否则，类查找失败。</p><p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p><p><strong>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p><p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p><h2 id="54-热替换的实现"><a class="markdownIt-Anchor" href="#54-热替换的实现"></a> 5.4. 热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<font color="red">热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。</font>基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p><p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p><p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p><p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9ae876265c85af4e431932647993dab7.png" alt="image-20210501182003439"></p><hr><p><strong>代码举例：</strong></p><p><img src="../../../images/image-20230111234030296.png" alt="image-20230111234030296"></p><p><img src="../../../images/image-20230111233943314.png" alt="image-20230111233943314"></p><p><img src="../../../images/image-20230111233655889.png" alt="image-20230111233655889"></p><p><img src="../../../images/image-20230111233756937.png" alt="image-20230111233756937"></p><h1 id="6-沙箱安全机制"><a class="markdownIt-Anchor" href="#6-沙箱安全机制"></a> 6. 沙箱安全机制</h1><p>沙箱安全机制</p><ul><li>保证程序安全</li><li>保护Java原生的JDK代码</li></ul><p><font color="red">Java安全模型的核心就是Java沙箱（sandbox）</font>。什么是沙箱？沙箱是一个限制程序运行的环境。</p><p>沙箱机制就是将Java代码<font color="red">限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</font>。通过这样的措施来保证对代码的<strong>有限隔离</strong>，防止对本地系统造成破坏。</p><p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p><p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p><h2 id="61-jdk10时期"><a class="markdownIt-Anchor" href="#61-jdk10时期"></a> 6.1. JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71caf905a0ca13866e24419b7faa14ee.png" alt="image-20210501182608205"></p><h2 id="62-jdk11时期"><a class="markdownIt-Anchor" href="#62-jdk11时期"></a> 6.2. JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p><p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p><p>如下图所示JDK1.1安全模型</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b93f0829e8340131a49738f8843307e4.png" alt="image-20210501182626963"></p><h2 id="63-jdk12时期"><a class="markdownIt-Anchor" href="#63-jdk12时期"></a> 6.3. JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行<strong>权限控制</strong>。如下图所示JDK1.2安全模型：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/81919ed70977f2b57ef5a11481c68abc.png" alt="image-20210501182652378"></p><h2 id="64-jdk16时期"><a class="markdownIt-Anchor" href="#64-jdk16时期"></a> 6.4. JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了**域（Domain）**的概念。</p><p>虚拟机会把所有代码加载到不同的系统域和应用域。<font color="red"><strong>系统域</strong>部分专门负责与关键资源进行交互</font>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/cf22059daec45f370ae3afb33b870c1f.png" alt="image-20210501182740197"></p><hr><h1 id="7-自定义类的加载器"><a class="markdownIt-Anchor" href="#7-自定义类的加载器"></a> 7. 自定义类的加载器</h1><h2 id="71-为什么要自定义类加载器"><a class="markdownIt-Anchor" href="#71-为什么要自定义类加载器"></a> 7.1. 为什么要自定义类加载器？</h2><ul><li><p><font color="red">隔离加载类</font></p><p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p></li><li><p><font color="red">修改类加载的方式</font></p><p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p></li><li><p><font color="red">扩展加载源</font></p><p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p></li><li><p><font color="red">防止源码泄漏</font></p><p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p></li></ul><p><strong>常见的场景</strong></p><ul><li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，<strong>两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰</strong>。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li><li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li></ul><p><strong>注意</strong>：</p><p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。<strong>在做 <mark>Java类型转换</mark> 时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</strong></p><h2 id="72-实现方式"><a class="markdownIt-Anchor" href="#72-实现方式"></a> 7.2. 实现方式</h2><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p><p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p><ul><li>方式一:重写loadClass()方法</li><li>方式二:重写findclass()方法  —&gt;推荐</li></ul><p><strong>对比</strong></p><ul><li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li><li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<font color="red">因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</font>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li><li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li></ul><p><strong>说明</strong></p><ul><li>其父类加载器是系统类加载器</li><li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li></ul><p>自定义类加载器：</p><p><img src="../../../images/image-20230112100726579.png" alt="image-20230112100726579"></p><p>测试：</p><p><img src="../../../images/image-20230112100837437.png" alt="image-20230112100837437"></p><hr><p><img src="../../../images/image-20230112101138225.png" alt="image-20230112101138225"></p><h1 id="8-java9新特性"><a class="markdownIt-Anchor" href="#8-java9新特性"></a> 8. Java9新特性</h1><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p><ol><li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</p><p>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留&lt;JAVA_HOME&gt;\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</p></li><li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。</p><p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png" alt="img"></p><p>​如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p><ol start="3"><li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li><li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li><li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/cb23791a5fb1bf1a4c8a28d6a3179e84.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ef9b83abcdb9f54d0f0ec7d15f0adc44.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/192fda50804d35e7d1b44dc61a65ede1.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f07a455ec275a6503bfad070ae3d9ffb.png" alt="img"></p><p><strong>代码：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader()); </span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());   <span class="comment">// app</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230112102043394.png" alt="image-20230112102043394"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM中篇：字节码与类的加载器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM中篇：字节码与类的加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4-类的加载过程（类的生命周期）详解</title>
      <link href="/2023/01/10/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3/"/>
      <url>/2023/01/10/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h1><p>在 Java 中数据类型分为基本数据类型和引用数据类型。<mark>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</mark></p><p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b73db20eea59665fa3de67e1dec6d4e5.png" alt="image-20210430215050746"></p><p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p><p>从程序中类的使用过程看</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c6e5a63339bb2574b9b52a9ed14ee9c5.png" alt="image-20210430215236716"></p><h2 id="大厂面试题"><a class="markdownIt-Anchor" href="#大厂面试题"></a> 大厂面试题</h2><blockquote><p><mark>蚂蚁金服：</mark></p><p>描述一下 JVM 加载 Class 文件的原理机制？</p><p>一面：类加载过程</p><p><mark>百度：</mark></p><p>类加载的时机</p><p>java 类加载过程？</p><p>简述 java 类加载机制？</p><p><mark>腾讯：</mark></p><p>JVM 中类加载机制，类加载过程？</p><p><mark>滴滴：</mark></p><p>JVM 类加载机制</p><p><mark>美团：</mark></p><p>Java 类加载过程</p><p>描述一下 jvm 加载 class 文件的原理机制</p><p><mark>京东：</mark></p><p>什么是类的加载？</p><p>哪些情况会触发类的加载？</p><p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p></blockquote><hr><h1 id="2-过程一loading加载阶段"><a class="markdownIt-Anchor" href="#2-过程一loading加载阶段"></a> 2. 过程一：Loading（加载）阶段</h1><h2 id="21-加载完成的操作"><a class="markdownIt-Anchor" href="#21-加载完成的操作"></a> 2.1. 加载完成的操作</h2><p><strong>加载的理解</strong></p><p><font color="red">所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象</font>。所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p><p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p><p><strong>加载完成的操作</strong></p><p><font color="red">加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</font></p><p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p><ul><li><p>通过类的全名，获取类的二进制数据流。</p></li><li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p></li><li><p>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p></li></ul><h2 id="22-二进制流的获取方式"><a class="markdownIt-Anchor" href="#22-二进制流的获取方式"></a> 2.2. 二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。<mark>（只要所读取的字节码符合 JVM 规范即可）</mark></p><ul><li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）</li><li>读入 jar、zip 等归档数据包，提取类文件。</li><li>事先存放在数据库中的类的二进制数据</li><li>使用类似于 HTTP 之类的协议通过网络进行加载</li><li>在运行时生成一段 class 的二进制信息等</li><li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li></ul><p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p><h2 id="23-类模型与-class-实例的位置"><a class="markdownIt-Anchor" href="#23-类模型与-class-实例的位置"></a> 2.3. 类模型与 Class 实例的位置</h2><p><strong>类模型的位置</strong></p><p>加载的类在 JVM 中创建相应的类结构，类结构会存储在<strong>方法区</strong>（JDKl.8 之前：永久代；JDKl.8 及之后：元空间）。</p><p><strong>Class 实例的位置</strong></p><p>类将.class 文件加载至元空间后，会在<strong>堆</strong>中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/10969de50477655b954b23bfe550fb1d.png" alt="image-20210430221037898"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">Method[] ms = clazz.getDecla#FF0000Methods();</span><br><span class="line"><span class="keyword">for</span> (Method m : ms) {</span><br><span class="line">    <span class="comment">//获取方法的修饰符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());</span><br><span class="line">    System.out.print(mod + <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> (m.getReturnType()).getSimpleName();</span><br><span class="line">    System.out.print(returnType + <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//获取方法名</span></span><br><span class="line">    System.out.print(m.getName() + <span class="string">"("</span>);</span><br><span class="line">    <span class="comment">//获取方法的参数列表</span></span><br><span class="line">    Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (ps.length == <span class="number">0</span>) {</span><br><span class="line">        System.out.print(<span class="string">')'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">')'</span> : <span class="string">','</span>;</span><br><span class="line">        <span class="comment">//获取参教的类型</span></span><br><span class="line">        System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="24-数组类的加载"><a class="markdownIt-Anchor" href="#24-数组类的加载"></a> 2.4. 数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为<mark>数组类本身并不是由类加载器负责创建</mark>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p><ul><li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li><li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li></ul><p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p><hr><h1 id="3-过程二linking链接阶段"><a class="markdownIt-Anchor" href="#3-过程二linking链接阶段"></a> 3. 过程二：Linking（链接）阶段</h1><h2 id="31-环节-1链接阶段之-verification验证"><a class="markdownIt-Anchor" href="#31-环节-1链接阶段之-verification验证"></a> 3.1. 环节 1：链接阶段之 Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p><p><font color="red">它的目的是保证加载的字节码是合法、合理并符合规范的。</font></p><p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2309ce7d4bdbffb86ae462e967af5dc9.png" alt="image-20210430221736546"></p><p><strong>整体说明：</strong></p><p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p><ul><li><font color="red">其中格式验证会和加载阶段一起执行</font>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li><li><font color="red">格式验证之外的验证操作将会在<strong>方法区</strong>中进行</font>。</li></ul><p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p><p><strong>具体说明：</strong></p><ol><li><p><mark>格式验证</mark>：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p></li><li><p><mark>语义检查</mark>：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p><ul><li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li><li>是否一些被定义为 final 的方法或者类被重写或继承了（final的是不能被被重写或继承的）</li><li>非抽象类是否实现了所有抽象方法或者接口方法</li><li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其它都一样，这种方法会让虚拟机无从下手调度；abstrac情况下的方法，就不能是final的了）</li></ul></li><li><p><mark>字节码验证</mark>：Java 虚拟机还会进行字节码验证，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle mathcolor="red"><mtext>字节码验证也是验证过程中最为复杂的一个过程</mtext></mstyle></mrow><annotation encoding="application/x-tex">\color{red}{字节码验证也是验证过程中最为复杂的一个过程}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord" style="color:red;"><span class="mord cjk_fallback" style="color:red;">字</span><span class="mord cjk_fallback" style="color:red;">节</span><span class="mord cjk_fallback" style="color:red;">码</span><span class="mord cjk_fallback" style="color:red;">验</span><span class="mord cjk_fallback" style="color:red;">证</span><span class="mord cjk_fallback" style="color:red;">也</span><span class="mord cjk_fallback" style="color:red;">是</span><span class="mord cjk_fallback" style="color:red;">验</span><span class="mord cjk_fallback" style="color:red;">证</span><span class="mord cjk_fallback" style="color:red;">过</span><span class="mord cjk_fallback" style="color:red;">程</span><span class="mord cjk_fallback" style="color:red;">中</span><span class="mord cjk_fallback" style="color:red;">最</span><span class="mord cjk_fallback" style="color:red;">为</span><span class="mord cjk_fallback" style="color:red;">复</span><span class="mord cjk_fallback" style="color:red;">杂</span><span class="mord cjk_fallback" style="color:red;">的</span><span class="mord cjk_fallback" style="color:red;">一</span><span class="mord cjk_fallback" style="color:red;">个</span><span class="mord cjk_fallback" style="color:red;">过</span><span class="mord cjk_fallback" style="color:red;">程</span></span></span></span></span>。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p><ul><li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li><li>函数的调用是否传递了正确类型的参数</li><li>变量的赋值是不是给了正确的数据类型等</li></ul><p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p><p><font color="red">在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</font></p></li><li><p><mark>符号引用的验证</mark>：校验器还将进符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<font color="red">虚拟机就会检查这些类或者方法确实是存在的</font>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。此阶段在解析环节才会执行。</p></li></ol><h2 id="32-环节-2链接阶段之-preparation准备"><a class="markdownIt-Anchor" href="#32-环节-2链接阶段之-preparation准备"></a> 3.2. 环节 2：链接阶段之 Preparation（准备）</h2><p><font color="red">准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。</font></p><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">默认初始值</th></tr></thead><tbody><tr><td style="text-align:left">byte</td><td style="text-align:left">(byte)0</td></tr><tr><td style="text-align:left">short</td><td style="text-align:left">(short)0</td></tr><tr><td style="text-align:left">int</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">long</td><td style="text-align:left">0L</td></tr><tr><td style="text-align:left">float</td><td style="text-align:left">0.0f</td></tr><tr><td style="text-align:left">double</td><td style="text-align:left">0.0</td></tr><tr><td style="text-align:left">char</td><td style="text-align:left">\u0000</td></tr><tr><td style="text-align:left">boolean</td><td style="text-align:left">false</td></tr><tr><td style="text-align:left">reference</td><td style="text-align:left">null</td></tr></tbody></table><p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p><p><strong>注意</strong></p><ul><li><p><font color="red">这里不包含基本数据类型的字段用static final修饰的情况，因为<strong>final 在编译的时候</strong>就会分配了，准备阶段会显式赋值。</font></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></tbody></table></figure></li><li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p></li><li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p></li></ul><p><img src="../../../images/image-20230110232531406.png" alt="image-20230110232531406"></p><p>ps: 补充<strong>字面量</strong>的举例：<img src="../../../images/image-20230110232617738.png" alt="image-20230110232617738"></p><h2 id="33-环节-3链接阶段之-resolution解析"><a class="markdownIt-Anchor" href="#33-环节-3链接阶段之-resolution解析"></a> 3.3. 环节 3：链接阶段之 Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的 <strong>符号引用 转为 直接引用</strong>。</p><p><strong>具体描述</strong>：</p><p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是<strong>在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置</strong>。</p><p><strong>举例</strong>：</p><p>输出操作 System.out.println()对应的字节码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #<span class="number">24</span> &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b223d288b413f0ed0732357023a1dc7e.png" alt="image-20210430225015932"></p><p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<font color="red">通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</font></p><p><img src="../../../images/image-20230110234334621.png" alt="image-20230110234334621"></p><hr><h1 id="4-过程三initialization初始化阶段"><a class="markdownIt-Anchor" href="#4-过程三initialization初始化阶段"></a> 4. 过程三：Initialization（初始化）阶段</h1><p><img src="../../../images/image-20230111102047297.png" alt="image-20230111102047297"></p><p><img src="../../../images/image-20230111101919211.png" alt="image-20230111101919211"></p><p><img src="../../../images/image-20230111104107727.png" alt="image-20230111104107727"></p><h2 id="41-static-与-final-的搭配问题"><a class="markdownIt-Anchor" href="#41-static-与-final-的搭配问题"></a> 4.1. static 与 final 的搭配问题</h2><p><strong>说明</strong>：使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p><ul><li><p>情况 1：在链接阶段的准备环节赋值</p></li><li><p>情况 2：在初始化阶段&lt;clinit&gt;()中赋值</p></li></ul><p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p><ul><li><p>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</p></li><li><p>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</p></li><li><p>在初始化阶段&lt;clinit&gt;()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p></li></ul><p><strong>最终结论</strong>：使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;                                <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                  <span class="comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;                                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);     <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);           <span class="comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">"helloworld0"</span>;                            <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"helloworld1"</span>);                <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"hellowrold2"</span>;                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></tbody></table></figure><h2 id="42-clinit的线程安全性"><a class="markdownIt-Anchor" href="#42-clinit的线程安全性"></a> 4.2. &lt;clinit&gt;()的线程安全性</h2><p>对于&lt;clinit&gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p><p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。</p><p>正是<font color="red">因为函数&lt;clinit&gt;()带锁线程安全的</font>，因此，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p><p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt;clinit&gt;()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p><h2 id="43-类的初始化情况主动使用-vs-被动使用"><a class="markdownIt-Anchor" href="#43-类的初始化情况主动使用-vs-被动使用"></a> 4.3. 类的初始化情况：主动使用 vs 被动使用</h2><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p><p><strong>主动使用</strong></p><p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p><ol><li><p><mark>实例化</mark>：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Order <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Order类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"order.dat"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"order.dat"</span>));</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) {</span><br><span class="line">                oos.close();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="literal">null</span>) {</span><br><span class="line">                ois.close();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><mark>静态方法</mark>：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p></li><li><p><mark>静态字段</mark>：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse</span> {</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"User类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230111112706051.png" alt="image-20230111112706051"></p></li><li><p><mark>反射</mark>：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p><p><img src="../../../images/image-20230111113501992.png" alt="image-20230111113501992"></p></li><li><p><mark>继承</mark>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p><blockquote><p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p><ul><li>在初始化一个类时，并不会先初始化它所实现的接口</li><li>在初始化一个接口时，并不会先初始化它的父接口</li><li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。<strong>只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化</strong>。</li></ul></blockquote><p><img src="../../../images/image-20230111113710560.png" alt="image-20230111113710560"></p></li><li><p><mark>default 方法</mark>：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Compare</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() {</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"Compare接口的初始化"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><mark>main 方法</mark>：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</p><blockquote><p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p></blockquote></li><li><p><mark>MethodHandle</mark>：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</p></li></ol><p><strong>被动使用</strong></p><p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<font color="red">被动使用 不会 引起类的&lt;clinit&gt;()初始化。</font></p><p>也就是说：<font color="red">并不是在代码中出现的类，就一定会被加载或者初始化。</font>如果不符合主动使用的条件，类就不会初始化。</p><ol><li><p><mark>静态字段</mark>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> {</span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Child类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Parent类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><mark>数组定义</mark>：通过数组定义类引用，不会触发此类的初始化</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent[] parents= <span class="keyword">new</span> <span class="title class_">Parent</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(parents.getClass());</span><br><span class="line"><span class="comment">// new的话才会初始化</span></span><br><span class="line">parents[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></tbody></table></figure></li><li><p><mark>引用常量</mark>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Serival.num);</span><br><span class="line">        <span class="comment">// 但引用其他类的话还是会初始化</span></span><br><span class="line">        System.out.println(Serival.num2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Serival</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() {</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"Serival初始化"</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li><li><p><mark>loadClass 方法</mark>：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.test.java.Person"</span>);</span><br></pre></td></tr></tbody></table></figure></li></ol><p><strong>扩展</strong></p><blockquote><p>-XX:+TraceClassLoading：追踪打印类的加载信息</p></blockquote><hr><p><img src="../../../images/image-20230111115825353.png" alt="image-20230111115825353"></p><h1 id="5-过程四类的-using使用"><a class="markdownIt-Anchor" href="#5-过程四类的-using使用"></a> 5. 过程四：类的 Using（使用）</h1><p><strong>任何一个类型在使用之前都必须经历过 完整的加载、链接和初始化 3 个类加载 步骤</strong>。一旦一个类型成功经历过这 3 个步骤之后，便 “厉事俱备只欠东风”，就等着开发者使用了。</p><p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p><hr><h1 id="6-过程五类的-unloading卸载"><a class="markdownIt-Anchor" href="#6-过程五类的-unloading卸载"></a> 6. 过程五：类的 Unloading（卸载）</h1><h2 id="61-类-类的加载器-类的实例之间的引用关系"><a class="markdownIt-Anchor" href="#61-类-类的加载器-类的实例之间的引用关系"></a> 6.1. 类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p><p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p><h2 id="62类的生命周期"><a class="markdownIt-Anchor" href="#62类的生命周期"></a> 6.2.类的生命周期</h2><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即<strong>不可触及</strong>时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p><p><font color="red">一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</font></p><h2 id="63-具体例子"><a class="markdownIt-Anchor" href="#63-具体例子"></a> 6.3. 具体例子</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/5aaa031ab1ffc8071fb92a32ead888ef.png" alt="image-20210430235455086"></p><p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p><p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p><p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p><h2 id="64-类的卸载"><a class="markdownIt-Anchor" href="#64-类的卸载"></a> 6.4. 类的卸载</h2><p>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p><p>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p><p>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p><p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p><h2 id="回顾方法区的垃圾回收"><a class="markdownIt-Anchor" href="#回顾方法区的垃圾回收"></a> 回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p><p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><font color="blue">该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</font></li><li><font color="blue">加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</font></li><li><font color="blue">该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</font></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM中篇：字节码与类的加载器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM中篇：字节码与类的加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-134.加油站</title>
      <link href="/2023/01/09/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-134.%E5%8A%A0%E6%B2%B9%E7%AB%99/"/>
      <url>/2023/01/09/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-134.%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a class="markdownIt-Anchor" href="#题目"></a> 题目：</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p><p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></tbody></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></tbody></table></figure><p><strong>提示:</strong></p><ul><li><code>gas.length == n</code></li><li><code>cost.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li></ul><h2 id="解题思路"><a class="markdownIt-Anchor" href="#解题思路"></a> 解题思路：</h2><p>下图的 黑色折线图 即 总油量剩余值，若要满足题目的要求：跑完全程再回到起点，总油量剩余值 的任意部分都需要在 X 轴以上，且跑到终点时：总剩余汽油量 &gt;= 0。</p><p>为了让 黑色折线图 任意部分都在 X 轴以上，我们需要向上移动 黑色折线图，直到所有点都在 X 轴或 X 轴以上。此时，处在 X 轴的点即为出发点。即 黑色折线图 的最低值的位置：index = 3。</p><p><img src="../../../images/image-20230109224824634.png" alt="image-20230109224824634"></p><h2 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        找到最后一个 sum 还是减小状态的下标即可，然后结果就是这个下标的下一个下标，即( index + 1 ) % len</span></span><br><span class="line"><span class="comment">        因为index 是最低点了，后面就是回升的了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++ ) {</span><br><span class="line">            sum += gas[ i ] - cost[ i ];</span><br><span class="line">            <span class="comment">// System.out.println( sum + " " + i );</span></span><br><span class="line">            <span class="keyword">if</span> ( sum &lt; min ) {</span><br><span class="line">                min = sum;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : index % len;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-javap使用</title>
      <link href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/2-javap%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/2-javap%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-解析字节码的作用"><a class="markdownIt-Anchor" href="#1-解析字节码的作用"></a> 1、解析字节码的作用</h2><p><img src="../../../images/image-20230109105233604.png" alt="image-20230109105233604"></p><h2 id="2-javac-g-操作"><a class="markdownIt-Anchor" href="#2-javac-g-操作"></a> 2、javac -g 操作</h2><p><img src="../../../images/image-20230109105203289.png" alt="image-20230109105203289"></p><h2 id="3-javap的用法"><a class="markdownIt-Anchor" href="#3-javap的用法"></a> 3、javap的用法</h2><p><img src="../../../images/image-20230109105401609.png" alt="image-20230109105401609"></p><p><img src="../../../images/image-20230109111148023.png" alt="image-20230109111148023"></p><p><img src="../../../images/image-20230109111249850.png" alt="image-20230109111249850"></p><p><mark>注意：-v虽然包含的信息很全，但是不包含私有private的，用 **-v -p **才可以带上私有的，这样信息就是最全的了</mark></p><p>如：演示javap -s （输出内部类型签名）：</p><p><img src="../../../images/image-20230109110318593.png" alt="image-20230109110318593"></p><p>演示 javap -l （输出行号和本地变量表（局部变量表））：</p><p><img src="../../../images/image-20230109110533368.png" alt="image-20230109110533368"></p><p>-c 和 -v 的内容对比：</p><p><img src="../../../images/image-20230109111622323.png" alt="image-20230109111622323"></p><p><img src="../../../images/image-20230109111550389.png" alt="image-20230109111550389"></p><h2 id="javap解析得到的文件结构的解读"><a class="markdownIt-Anchor" href="#javap解析得到的文件结构的解读"></a> javap解析得到的文件结构的解读</h2><p><img src="../../../images/image-20230109150619055.png" alt="image-20230109150619055"></p><p><img src="../../../images/image-20230109150710937.png" alt="image-20230109150710937"></p><p><img src="../../../images/image-20230109150838112.png" alt="image-20230109150838112"></p><p><img src="../../../images/image-20230109150909746.png" alt="image-20230109150909746"></p><p><img src="../../../images/image-20230109145505307.png" alt="image-20230109145505307"></p><p><img src="../../../images/image-20230109150257068.png" alt="image-20230109150257068"></p><p><img src="../../../images/image-20230109150459817.png" alt="image-20230109150459817"></p><p><img src="../../../images/image-20230109150441824.png" alt="image-20230109150441824"></p><h2 id="javap使用小结"><a class="markdownIt-Anchor" href="#javap使用小结"></a> javap使用小结</h2><p><img src="../../../images/image-20230109151005736.png" alt="image-20230109151005736"></p><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM中篇：字节码与类的加载器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM中篇：字节码与类的加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-字节码指令集</title>
      <link href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
      <url>/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1. 概述</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/630bca9b1bbeeeb4f772fea5f94d43fc.png" alt=""><img src="https://img-blog.csdnimg.cn/img_convert/74bb5f23ad01f05a39f8eb171d205390.png" alt=""><img src="https://img-blog.csdnimg.cn/img_convert/bb3c57508713e377f3f4084409abaa30.png" alt="img"></p><h1 id="2-加载与存储指令"><a class="markdownIt-Anchor" href="#2-加载与存储指令"></a> 2. 加载与存储指令</h1><p><img src="../../../images/image-20230109154720979.png" alt="image-20230109154720979"></p><p><img src="../../../images/image-20230109155158364.png" alt="image-20230109155158364"></p><hr><p><img src="https://img-blog.csdnimg.cn/img_convert/3585fe67d5d83aff5db707d8eedccbae.png" alt="0ca8044c-f78d-4787-aeac-c986a35f9cdf"><br><img src="https://gitee.com/vectorx/ImageCloud/raw/master/img/20210424190846.png" alt="16e3afaf-b7d8-4a23-8897-9fe02586aafd"><img src="https://img-blog.csdnimg.cn/img_convert/8e911caaa5c0502b038af324c16edce8.png" alt="08e01fd0-a33e-47e4-8fd2-34c2935db71d"></p><hr><h2 id="21-局部变量压栈指令"><a class="markdownIt-Anchor" href="#21-局部变量压栈指令"></a> 2.1. 局部变量压栈指令</h2><blockquote><p>iload 从局部变量中装载int类型值</p><p>lload 从局部变量中装载long类型值</p><p>fload 从局部变量中装载float类型值</p><p>dload 从局部变量中装载double类型值</p><p>aload 从局部变量中装载引用类型值（refernce）</p><p>iload_0 从局部变量0中装载int类型值</p><p>iload_1 从局部变量1中装载int类型值</p><p>iload_2 从局部变量2中装载int类型值</p><p>iload_3 从局部变量3中装载int类型值</p><p>lload_0 从局部变量0中装载long类型值</p><p>lload_1 从局部变量1中装载long类型值</p><p>lload_2 从局部变量2中装载long类型值</p><p>lload_3 从局部变量3中装载long类型值</p><p>fload_0 从局部变量0中装载float类型值</p><p>fload_1 从局部变量1中装载float类型值</p><p>fload_2 从局部变量2中装载float类型值</p><p>fload_3 从局部变量3中装载float类型值</p><p>dload_0 从局部变量0中装载double类型值</p><p>dload_1 从局部变量1中装载double类型值</p><p>dload_2 从局部变量2中装载double类型值</p><p>dload_3 从局部变量3中装载double类型值</p><p>aload_0 从局部变量0中装载引用类型值</p><p>aload_1 从局部变量1中装载引用类型值</p><p>aload_2 从局部变量2中装载引用类型值</p><p>aload_3 从局部变量3中装载引用类型值</p><p>iaload 从数组中装载int类型值</p><p>laload 从数组中装载long类型值</p><p>faload 从数组中装载float类型值</p><p>daload 从数组中装载double类型值</p><p>aaload 从数组中装载引用类型值</p><p>baload 从数组中装载byte类型或boolean类型值</p><p>caload 从数组中装载char类型值</p><p>saload 从数组中装载short类型值</p></blockquote><h2 id="局部变量压栈常用指令集"><a class="markdownIt-Anchor" href="#局部变量压栈常用指令集"></a> 局部变量压栈常用指令集</h2><table><thead><tr><th>xload_n</th><th>xload_0</th><th>xload_1</th><th>xload_2</th><th>xload_3</th></tr></thead><tbody><tr><td><b>iload_n</b></td><td>iload_0</td><td>iload_1</td><td>iload_2</td><td>iload_3</td></tr><tr><td><b>lload_n</b></td><td>lload_0</td><td>lload_1</td><td>lload_2</td><td>lload_3</td></tr><tr><td><b>fload_n</b></td><td>fload_0</td><td>fload_1</td><td>fload_2</td><td>fload_3</td></tr><tr><td><b>dload_n</b></td><td>dload_0</td><td>dload_1</td><td>dload_2</td><td>dload_3</td></tr><tr><td><b>aload_n</b></td><td>aload_0</td><td>aload_1</td><td>aload_2</td><td>aload_3</td></tr></tbody></table><h2 id="局部变量压栈指令剖析"><a class="markdownIt-Anchor" href="#局部变量压栈指令剖析"></a> 局部变量压栈指令剖析</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/a34d465c4c8c83b3fcedc3ba31401732.png" alt="1"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> {</span><br><span class="line">System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/deb49e69ed62ed9d71c7059748299b59.png" alt="3"></p><hr><h2 id="22-常量入栈指令"><a class="markdownIt-Anchor" href="#22-常量入栈指令"></a> 2.2. 常量入栈指令</h2><blockquote><p>aconst_null 将null对象引用压入栈</p><p>iconst_m1 将int类型常量-1压入栈</p><p>iconst_0 将int类型常量0压入栈</p><p>iconst_1 将int类型常量1压入栈</p><p>iconst_2 将int类型常量2压入栈</p><p>iconst_3 将int类型常量3压入栈</p><p>iconst_4 将int类型常量4压入栈</p><p>iconst_5 将int类型常量5压入栈</p><p>lconst_0 将long类型常量0压入栈</p><p>lconst_1 将long类型常量1压入栈</p><p>fconst_0 将float类型常量0压入栈</p><p>fconst_1 将float类型常量1压入栈</p><p>dconst_0 将double类型常量0压入栈</p><p>dconst_1 将double类型常量1压入栈</p><p>bipush 将一个8位带符号整数压入栈</p><p>sipush 将16位带符号整数压入栈</p><p>ldc 把常量池中的项压入栈</p><p>ldc_w 把常量池中的项压入栈（使用宽索引）</p><p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p></blockquote><h2 id="常量入栈常用指令集"><a class="markdownIt-Anchor" href="#常量入栈常用指令集"></a> 常量入栈常用指令集</h2><table><thead><tr><th style="text-align:center">xconst_n</th><th>范围</th><th>xconst_null</th><th style="text-align:center">xconst_m1</th><th style="text-align:center">xconst_0</th><th style="text-align:center">xconst_1</th><th style="text-align:center">xconst_2</th><th style="text-align:center">xconst_3</th><th style="text-align:center">xconst_4</th><th style="text-align:center">xconst_5</th></tr></thead><tbody><tr><td style="text-align:center"><strong>iconst_n</strong></td><td>[-1, 5]</td><td></td><td style="text-align:center">iconst_m1</td><td style="text-align:center">iconst_0</td><td style="text-align:center">iconst_1</td><td style="text-align:center">iconst_2</td><td style="text-align:center">iconst_3</td><td style="text-align:center">iconst_4</td><td style="text-align:center">iconst_5</td></tr><tr><td style="text-align:center"><strong>lconst_n</strong></td><td>0, 1</td><td></td><td style="text-align:center"></td><td style="text-align:center">lconst_0</td><td style="text-align:center">lconst_1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>fconst_n</strong></td><td>0, 1, 2</td><td></td><td style="text-align:center"></td><td style="text-align:center">fconst_0</td><td style="text-align:center">fconst_1</td><td style="text-align:center">fconst_2</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>dconst_n</strong></td><td>0, 1</td><td></td><td style="text-align:center"></td><td style="text-align:center">dconst_0</td><td style="text-align:center">dconst_1</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>aconst_n</strong></td><td>null, String literal, Class literal</td><td>aconst_null</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>bipush</strong></td><td>一个字节，2<sup>8</sup>，[-2<sup>7</sup>, 2<sup>7</sup> - 1]，即[-128, 127]</td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>sipush</strong></td><td>两个字节，2<sup>16</sup>，[-2<sup>15</sup>, 2<sup>15</sup> - 1]，即[-32768, 32767]</td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>ldc</strong></td><td>四个字节，2<sup>32</sup>，[-2<sup>31</sup>, 2<sup>31</sup> - 1]</td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>ldc_w</strong></td><td>宽索引</td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>ldc2_w</strong></td><td>宽索引，long或double</td><td></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h2 id="常量入栈指令剖析"><a class="markdownIt-Anchor" href="#常量入栈指令剖析"></a> 常量入栈指令剖析</h2><p>范围：const &lt; push &lt; ldc</p><hr><p><img src="../../../images/image-20230109164556416.png" alt="image-20230109164556416"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/fafa61a6702b5fc88179c404ba736029.png" alt="437a717e-98e2-4847-b52e-e6632d0745a4"><br><img src="https://img-blog.csdnimg.cn/img_convert/c0a6284e1deaf76669089e669916f440.png" alt="ffd7246e-2e46-41e0-9fd6-1e65ace5dbd1"></p><table>    <tbody>          <tr>            <th>类型</th>             <th>常数指令</th>             <th>范围</th>        </tr>       <tr>            <td rowspan="4">int(boolean,byte,char,short)</td>            <td>iconst</td>            <td>[-1, 5]</td>       </tr>       <tr>            <td>bipush</td>            <td>[-128, 127]</td>       </tr>       <tr>            <td>sipush</td>            <td>[-32768, 32767]</td>       </tr>        <tr>            <td>ldc</td>            <td>any int value</td>       </tr>       <tr>            <td rowspan="2">long</td>            <td>lconst</td>            <td>0, 1</td>       </tr>       <tr>            <td>ldc</td>            <td>any long value</td>       </tr>       <tr>            <td rowspan="2">float</td>            <td>fconst</td>            <td>0, 1, 2</td>       </tr>       <tr>            <td>ldc</td>            <td>any float value</td>       </tr>       <tr>            <td rowspan="2">double</td>            <td>dconst</td>            <td>0, 1</td>       </tr>       <tr>            <td>ldc</td>            <td>any double value</td>       </tr>        <tr>            <td rowspan="2">reference</td>            <td>aconst</td>            <td>null</td>       </tr>       <tr>            <td>ldc</td>            <td>String literal, Class literal</td>       </tr>   </tbody><tbody> </tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/59982d71dc70f7d7b873f50130281c21.png" alt="566b9397-5afe-4a3f-9e17-9ebf504dfc80"><br><img src="https://img-blog.csdnimg.cn/img_convert/cd990ebc801bf53b4f7b1966d9974345.png" alt="b59702d2-4c93-44df-87f1-01a5dfe53b61"></p><h2 id="23-出栈装入局部变量表指令"><a class="markdownIt-Anchor" href="#23-出栈装入局部变量表指令"></a> 2.3. 出栈装入局部变量表指令</h2><blockquote><p>istore 将int类型值存入局部变量</p><p>lstore 将long类型值存入局部变量</p><p>fstore 将float类型值存入局部变量</p><p>dstore 将double类型值存入局部变量</p><p>astore 将将引用类型或returnAddress类型值存入局部变量</p><p>istore_0 将int类型值存入局部变量0</p><p>istore_1 将int类型值存入局部变量1</p><p>istore_2 将int类型值存入局部变量2</p><p>istore_3 将int类型值存入局部变量3</p><p>lstore_0 将long类型值存入局部变量0</p><p>lstore_1 将long类型值存入局部变量1</p><p>lstore_2 将long类型值存入局部变量2</p><p>lstore_3 将long类型值存入局部变量3</p><p>fstore_0 将float类型值存入局部变量0</p><p>fstore_1 将float类型值存入局部变量1</p><p>fstore_2 将float类型值存入局部变量2</p><p>fstore_3 将float类型值存入局部变量3</p><p>dstore_0 将double类型值存入局部变量0</p><p>dstore_1 将double类型值存入局部变量1</p><p>dstore_2 将double类型值存入局部变量2</p><p>dstore_3 将double类型值存入局部变量3</p><p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p><p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p><p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p><p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p><p>iastore 将int类型值存入数组中</p><p>lastore 将long类型值存入数组中</p><p>fastore 将float类型值存入数组中</p><p>dastore 将double类型值存入数组中</p><p>aastore 将引用类型值存入数组中</p><p>bastore 将byte类型或者boolean类型值存入数组中</p><p>castore 将char类型值存入数组中</p><p>sastore 将short类型值存入数组中</p><p>wide指令</p><p>wide 使用附加字节扩展局部变量索引</p></blockquote><h2 id="出栈装入局部变量表常用指令集"><a class="markdownIt-Anchor" href="#出栈装入局部变量表常用指令集"></a> 出栈装入局部变量表常用指令集</h2><table><thead><tr><th style="text-align:center">xstore_n</th><th style="text-align:center">xstore_0</th><th style="text-align:center">xstore_1</th><th style="text-align:center">xstore_2</th><th style="text-align:center">xstore_3</th></tr></thead><tbody><tr><td style="text-align:center"><strong>istore_n</strong></td><td style="text-align:center">istore_0</td><td style="text-align:center">istore_1</td><td style="text-align:center">istore_2</td><td style="text-align:center">istore_3</td></tr><tr><td style="text-align:center"><strong>lstore_n</strong></td><td style="text-align:center">lstore_0</td><td style="text-align:center">lstore_1</td><td style="text-align:center">lstore_2</td><td style="text-align:center">lstore_3</td></tr><tr><td style="text-align:center"><strong>fstore_n</strong></td><td style="text-align:center">fstore_0</td><td style="text-align:center">fstore_1</td><td style="text-align:center">fstore_2</td><td style="text-align:center">fstore_3</td></tr><tr><td style="text-align:center"><strong>dstore_n</strong></td><td style="text-align:center">dstore_0</td><td style="text-align:center">dstore_1</td><td style="text-align:center">dstore_2</td><td style="text-align:center">dstore_3</td></tr><tr><td style="text-align:center"><strong>astore_n</strong></td><td style="text-align:center">astore_0</td><td style="text-align:center">astore_1</td><td style="text-align:center">astore_2</td><td style="text-align:center">astore_3</td></tr></tbody></table><h2 id="出栈装入局部变量表指令剖析"><a class="markdownIt-Anchor" href="#出栈装入局部变量表指令剖析"></a> 出栈装入局部变量表指令剖析</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/52b46ba6b57aa1ab8581cb022da7e58e.png" alt="1"><br><img src="https://img-blog.csdnimg.cn/img_convert/4adce45129332dd04b89f4aa8ffc6e28.png" alt="2"><br><img src="https://img-blog.csdnimg.cn/img_convert/e4665e8fc25e2d63bff2e8423b60b1dc.png" alt="3"></p><hr><h1 id="3-算术指令"><a class="markdownIt-Anchor" href="#3-算术指令"></a> 3. 算术指令</h1><blockquote><h2 id="整数运算"><a class="markdownIt-Anchor" href="#整数运算"></a> 整数运算</h2><p>iadd 执行int类型的加法</p><p>ladd 执行long类型的加法</p><p>isub 执行int类型的减法</p><p>lsub 执行long类型的减法</p><p>imul 执行int类型的乘法</p><p>lmul 执行long类型的乘法</p><p>idiv 执行int类型的除法</p><p>ldiv 执行long类型的除法</p><p>irem 计算int类型除法的余数</p><p>lrem 计算long类型除法的余数</p><p>ineg 对一个int类型值进行取反操作</p><p>lneg 对一个long类型值进行取反操作</p><p>iinc 把一个常量值加到一个int类型的局部变量上</p><h2 id="逻辑运算"><a class="markdownIt-Anchor" href="#逻辑运算"></a> 逻辑运算</h2><h3 id="移位操作"><a class="markdownIt-Anchor" href="#移位操作"></a> 移位操作</h3><p>ishl 执行int类型的向左移位操作</p><p>lshl 执行long类型的向左移位操作</p><p>ishr 执行int类型的向右移位操作</p><p>lshr 执行long类型的向右移位操作</p><p>iushr 执行int类型的向右逻辑移位操作</p><p>lushr 执行long类型的向右逻辑移位操作</p><h3 id="按位布尔运算"><a class="markdownIt-Anchor" href="#按位布尔运算"></a> 按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p><p>land 对long类型值进行“逻辑与”操作</p><p>ior 对int类型值进行“逻辑或”操作</p><p>lor 对long类型值进行“逻辑或”操作</p><p>ixor 对int类型值进行“逻辑异或”操作</p><p>lxor 对long类型值进行“逻辑异或”操作</p><h3 id="浮点运算"><a class="markdownIt-Anchor" href="#浮点运算"></a> 浮点运算</h3><p>fadd 执行float类型的加法</p><p>dadd 执行double类型的加法</p><p>fsub 执行float类型的减法</p><p>dsub 执行double类型的减法</p><p>fmul 执行float类型的乘法</p><p>dmul 执行double类型的乘法</p><p>fdiv 执行float类型的除法</p><p>ddiv 执行double类型的除法</p><p>frem 计算float类型除法的余数</p><p>drem 计算double类型除法的余数</p><p>fneg 将一个float类型的数值取反</p><p>dneg 将一个double类型的数值取反</p></blockquote><p><img src="../../../images/image-20230110092705627.png" alt="image-20230110092705627"></p><p><img src="../../../images/image-20230110092628326.png" alt="image-20230110092628326"></p><p><img src="../../../images/image-20230110093117073.png" alt="image-20230110093117073"></p><p><img src="../../../images/image-20230110093414167.png" alt="image-20230110093414167"></p><h2 id="算术指令集"><a class="markdownIt-Anchor" href="#算术指令集"></a> 算术指令集</h2><table>    <tbody>          <tr>            <th colspan="2">算数指令</th>             <th>int(boolean,byte,char,short)</th>             <th>long</th>            <th>float</th>       <th>double</th>        </tr>       <tr>            <td colspan="2">加法指令</td>            <td>iadd</td>            <td>ladd</td>            <td>fadd</td>            <td>dadd</td>       </tr>       <tr>            <td colspan="2">减法指令</td>            <td>isub</td>            <td>lsub</td>            <td>fsub</td>            <td>dsub</td>       </tr>        <tr>            <td colspan="2">乘法指令</td>            <td>imul</td>            <td>lmul</td>            <td>fmul</td>            <td>dmul</td>       </tr>        <tr>            <td colspan="2">除法指令</td>            <td>idiv</td>            <td>ldiv</td>            <td>fdiv</td>            <td>ddiv</td>       </tr>       <tr>            <td colspan="2">求余指令</td>            <td>irem</td>            <td>lrem</td>            <td>frem</td>            <td>drem</td>       </tr>       <tr>            <td colspan="2">取反指令</td>            <td>ineg</td>            <td>lneg</td>            <td>fneg</td>            <td>dneg</td>       </tr>       <tr>            <td colspan="2">自增指令</td>            <td>iinc</td>            <td></td>            <td></td>            <td></td>       </tr>       <tr>            <td rowspan="4">位运算指令</td>            <td>按位或指令</td>            <td>ior</td>            <td>lor</td>            <td></td>            <td></td>       </tr>        <tr>            <td>按位或指令</td>            <td>ior</td>            <td>lor</td>            <td></td>            <td></td>       </tr>        <tr>            <td>按位与指令</td>            <td>iand</td>            <td>land</td>            <td></td>            <td></td>       </tr>       <tr>            <td>按位异或指令</td>            <td>ixor</td>            <td>lxor</td>            <td></td>            <td></td>       </tr>        <tr>            <td colspan="2">比较指令</td>            <td></td>            <td>lcmp</td>            <td>fcmpg / fcmpl</td>            <td>dcmpg / dcmpl</td>       </tr>    </tbody><tbody> </tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/39ac5dc0cb406c2d75b50b10226322b0.png" alt=""></p><blockquote><p>注意：NaN(Not a Number)表示不是一个数字</p></blockquote><h2 id="算术指令举例"><a class="markdownIt-Anchor" href="#算术指令举例"></a> 算术指令举例</h2><h3 id="举例1"><a class="markdownIt-Anchor" href="#举例1"></a> 举例1</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line"><span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/256d8a8ec2309b6d396795e9a7e79959.png" alt="a54c2ac8-dd36-49f4-a49d-9afd725e8365"></p><h3 id="举例2"><a class="markdownIt-Anchor" href="#举例2"></a> 举例2</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line"><span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/58c6064f2d2103610c6e2f9c9472f122.png" alt="image-20210424210710750"><br><img src="https://img-blog.csdnimg.cn/img_convert/d0257760ed00864d7e36421c2df971ca.png" alt="2"><br><img src="https://img-blog.csdnimg.cn/img_convert/df724aebb307c6dda0780bbf5d4e1f92.png" alt="3"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2edaef3312398b63decea146718f2d6.gif" alt="img"></p><h3 id="举例3"><a class="markdownIt-Anchor" href="#举例3"></a> 举例3</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">System.out.println(a + b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/ce924815ec9c6ddc5cd98f18538c250e.png" alt="c43c0407-020f-4ec4-bd27-e4c109640b39"><br><img src="https://img-blog.csdnimg.cn/img_convert/918a9850ced5114086db35ce59e651af.png" alt="04282df1-4e52-4c3d-a47b-84023159b624"></p><hr><h3 id="测定搞定运算符"><a class="markdownIt-Anchor" href="#测定搞定运算符"></a> 测定搞定++运算符</h3><p><strong>例子1：</strong></p><p><img src="../../../images/image-20230110103252540.png" alt="image-20230110103252540"></p><p><strong>例子2：</strong></p><p><img src="../../../images/image-20230110104240767.png" alt="image-20230110104240767"></p><p><img src="../../../images/image-20230110103546598.png" alt="image-20230110103546598"></p><h1 id="4-类型转换指令"><a class="markdownIt-Anchor" href="#4-类型转换指令"></a> 4. 类型转换指令</h1><blockquote><h2 id="宽化类型转换"><a class="markdownIt-Anchor" href="#宽化类型转换"></a> 宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p><p>i2f 把int类型的数据转化为float类型</p><p>i2d 把int类型的数据转化为double类型</p><p>l2f 把long类型的数据转化为float类型</p><p>l2d 把long类型的数据转化为double类型</p><p>f2d 把float类型的数据转化为double类型</p><h2 id="窄化类型转换"><a class="markdownIt-Anchor" href="#窄化类型转换"></a> 窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p><p>i2c 把int类型的数据转化为char类型</p><p>i2s 把int类型的数据转化为short类型</p><p>l2i 把long类型的数据转化为int类型</p><p>f2i 把float类型的数据转化为int类型</p><p>f2l 把float类型的数据转化为long类型</p><p>d2i 把double类型的数据转化为int类型</p><p>d2l 把double类型的数据转化为long类型</p><p>d2f 把double类型的数据转化为float类型</p></blockquote><table><thead><tr><th style="text-align:center"></th><th style="text-align:center"><strong>byte</strong></th><th style="text-align:center"><strong>char</strong></th><th style="text-align:center"><strong>short</strong></th><th style="text-align:center"><strong>int</strong></th><th style="text-align:center"><strong>long</strong></th><th style="text-align:center"><strong>float</strong></th><th style="text-align:center"><strong>double</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>int</strong></td><td style="text-align:center">i2b</td><td style="text-align:center">i2c</td><td style="text-align:center">i2s</td><td style="text-align:center">○</td><td style="text-align:center">i2l</td><td style="text-align:center">i2f</td><td style="text-align:center">i2d</td></tr><tr><td style="text-align:center"><strong>long</strong></td><td style="text-align:center">l2i i2b</td><td style="text-align:center">l2i i2c</td><td style="text-align:center">l2i i2s</td><td style="text-align:center">l2i</td><td style="text-align:center">○</td><td style="text-align:center">l2f</td><td style="text-align:center">l2d</td></tr><tr><td style="text-align:center"><strong>float</strong></td><td style="text-align:center">f2i i2b</td><td style="text-align:center">f2i i2c</td><td style="text-align:center">f2i i2s</td><td style="text-align:center">f2i</td><td style="text-align:center">f2l</td><td style="text-align:center">○</td><td style="text-align:center">f2d</td></tr><tr><td style="text-align:center"><strong>double</strong></td><td style="text-align:center">d2i i2b</td><td style="text-align:center">d2i i2c</td><td style="text-align:center">d2i i2s</td><td style="text-align:center">d2i</td><td style="text-align:center">d2l</td><td style="text-align:center">d2f</td><td style="text-align:center">○</td></tr></tbody></table><p>类型转换指令可以将两种不同的数值类型进行相互转换。这些转换操作一般用于实现用户代码中的<strong>显式类型转換操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与<strong>数据类型</strong>一一对应的问题。</p><h2 id="41-宽化类型转换剖析"><a class="markdownIt-Anchor" href="#41-宽化类型转换剖析"></a> 4.1. 宽化类型转换剖析</h2><blockquote><p>宽化类型转换( Widening Numeric Conversions)</p><ol><li>转换规则</li></ol><p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,<strong>小范围类型向大范围类型的安全转换</strong>）。也就是说，并不需要指令执行，包括</p><blockquote><p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p><p>从long类型到float、 double类型。对应的指令为：i2f、i2d</p><p>从float类型到double类型。对应的指令为：f2d</p></blockquote><p>简化为：int–&gt;long–&gt;float-&gt; double</p><ol start="2"><li>精度损失问题</li></ol><blockquote><p>2.1. 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p><p>2.2. 从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p></blockquote><p>尽管宽化类型转换实际上是<strong>可能发生精度丢失</strong>的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><p>**从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。**对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p><p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而<strong>虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</strong></p><p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p></blockquote><p>举例分析：</p><p><img src="../../../images/image-20230110110140222.png" alt="image-20230110110140222"></p><p><img src="../../../images/image-20230110110253180.png" alt="image-20230110110253180"></p><h2 id="42-窄化类型转换剖析"><a class="markdownIt-Anchor" href="#42-窄化类型转换剖析"></a> 4.2. 窄化类型转换剖析</h2><blockquote><p>窄化类型转换( Narrowing Numeric Conversion)</p><ol><li>转换规则</li></ol><p>Java虚拟机也直接支持以下窄化类型转换：</p><blockquote><p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s</p><p>从long类型到int类型。对应的指令有：l2i</p><p>从float类型到int或者long类型。对应的指令有：f2i、f2l</p><p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p></blockquote><ol start="2"><li>精度损失问题</li></ol><p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p><p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p><ol start="3"><li>补充说明</li></ol><blockquote><p>3.1. 当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p><blockquote><p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p><p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值Vv如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p></blockquote><p>3.2. 当将一个double类型窄化转换为float类型时，将遵循以下转换规则</p><blockquote><p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p><p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p><p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p><p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p></blockquote></blockquote></blockquote><hr><p><img src="../../../images/image-20230110115749195.png" alt="image-20230110115749195"></p><p>精度损失的举例：</p><p><img src="../../../images/image-20230110120128649.png" alt="image-20230110120128649"></p><p><strong>测试NaN，无穷大的情况：</strong></p><p><img src="../../../images/image-20230110120800053.png" alt="image-20230110120800053"></p><h1 id="5-对象的创建与访问指令"><a class="markdownIt-Anchor" href="#5-对象的创建与访问指令"></a> 5. 对象的创建与访问指令</h1><blockquote><h2 id="对象操作指令"><a class="markdownIt-Anchor" href="#对象操作指令"></a> 对象操作指令</h2><p>new 创建一个新对象</p><p>getfield 从对象中获取字段</p><p>putfield 设置对象中字段的值</p><p>getstatic 从类中获取静态字段</p><p>putstatic 设置类中静态字段的值</p><p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p><p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p><h2 id="数组操作指令"><a class="markdownIt-Anchor" href="#数组操作指令"></a> 数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p><p>anewarray 分配数据成员类型为引用类型的新数组</p><p>arraylength 获取数组长度</p><p>multianewarray 分配新的多维数组</p></blockquote><p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p><h2 id="51-创建指令"><a class="markdownIt-Anchor" href="#51-创建指令"></a> 5.1. 创建指令</h2><table><thead><tr><th style="text-align:left">创建指令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">new</td><td style="text-align:left">创建类实例</td></tr><tr><td style="text-align:left">newarray</td><td style="text-align:left">创建基本类型数组</td></tr><tr><td style="text-align:left">anewarray</td><td style="text-align:left">创建引用类型数组</td></tr><tr><td style="text-align:left">multilanewarra</td><td style="text-align:left">创建多维数组</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/44ec8eda0028b78f02951aa5edc14751.png" alt="img"></p><p><img src="../../../images/image-20230110135551913.png" alt="image-20230110135551913"></p><h2 id="52-字段访问指令"><a class="markdownIt-Anchor" href="#52-字段访问指令"></a> 5.2. 字段访问指令</h2><table><thead><tr><th style="text-align:left">字段访问指令</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">getstatic、putstatic</td><td style="text-align:left">访问类字段（static字段，或者称为类变量）的指令</td></tr><tr><td style="text-align:left">getfield、 putfield</td><td style="text-align:left">访问类实例字段（非static字段，或者称为实例变量）的指令</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/c95da4b9bcb174f367617ca977451b14.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/6f7033f9caaf3216c6ca6795de12f6a4.png" alt="img"></p><h2 id="53-数组操作指令"><a class="markdownIt-Anchor" href="#53-数组操作指令"></a> 5.3. 数组操作指令</h2><table><thead><tr><th>数组指令</th><th>byte(boolean)</th><th>char</th><th>short</th><th>long</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xaload</strong></td><td>baload</td><td>caload</td><td>saload</td><td>iaload</td><td>laload</td><td>faload</td><td>daload</td><td>aaload</td></tr><tr><td><strong>xastore</strong></td><td>bastore</td><td>castore</td><td>sastore</td><td>iastore</td><td>lastore</td><td>fastore</td><td>dastore</td><td>aastore</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/a25e46492ce58084d3bb1ee9a4255ac4.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/4d55c1e67881b686d4dcb75118f257c5.png" alt="img"></p><h2 id="54-类型检查指令"><a class="markdownIt-Anchor" href="#54-类型检查指令"></a> 5.4. 类型检查指令</h2><table><thead><tr><th>类型检查指令</th><th>含义</th></tr></thead><tbody><tr><td>instanceof</td><td>检查类型强制转换是否可以进行</td></tr><tr><td>checkcast</td><td>判断给定对象是否是某一个类的实例</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/df1e056d6e977d38b6c5974a428a040a.png" alt="img"></p><hr><h1 id="6-方法调用与返回指令"><a class="markdownIt-Anchor" href="#6-方法调用与返回指令"></a> 6. 方法调用与返回指令</h1><blockquote><h2 id="方法调用指令"><a class="markdownIt-Anchor" href="#方法调用指令"></a> 方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p><p>invokespecial 根据编译时类型来调用实例方法</p><p>invokestatic 调用类（静态）方法</p><p>invokcinterface 调用接口方法</p><h2 id="方法返回指令"><a class="markdownIt-Anchor" href="#方法返回指令"></a> 方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p><p>lreturn 从方法中返回long类型的数据</p><p>freturn 从方法中返回float类型的数据</p><p>dreturn 从方法中返回double类型的数据</p><p>areturn 从方法中返回引用类型的数据</p><p>return 从方法中返回，返回值为void</p></blockquote><h2 id="61-方法调用指令"><a class="markdownIt-Anchor" href="#61-方法调用指令"></a> 6.1. 方法调用指令</h2><table><thead><tr><th>方法调用指令</th><th>含义</th></tr></thead><tbody><tr><td>invokevirtual</td><td>调用对象的实例方法</td></tr><tr><td>invokeinterface</td><td>调用接口方法</td></tr><tr><td>invokespecial</td><td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td></tr><tr><td>invokestatic</td><td>调用命名类中的类方法（static方法）</td></tr><tr><td>invokedynamic</td><td>调用动态绑定的方法</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/6b6c265e506611b1fa05134d7ede3f30.png" alt="img"></p><p><img src="../../../images/image-20230110161847552.png" alt="image-20230110161847552"></p><p><img src="../../../images/image-20230110162226479.png" alt="image-20230110162226479"></p><p><img src="../../../images/image-20230110162743637.png" alt="image-20230110162743637"></p><p><img src="../../../images/image-20230110162820017.png" alt="image-20230110162820017"></p><h2 id="62-方法返回指令"><a class="markdownIt-Anchor" href="#62-方法返回指令"></a> 6.2. 方法返回指令</h2><table><thead><tr><th>方法返回指令</th><th>void</th><th>int</th><th>long</th><th>float</th><th>double</th><th>reference</th></tr></thead><tbody><tr><td><strong>xreturn</strong></td><td>return</td><td>ireturn</td><td>lreturn</td><td>freutrn</td><td>dreturn</td><td>areturn</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/8940d3d81dff02c08bf83cf0c66f3fea.png" alt="image-20210425222017858"><br><img src="https://img-blog.csdnimg.cn/img_convert/386375c9f516af716a5d8dec10177444.png" alt="img"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + j) / k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/3fbd1f2ca9f4300eee5e0c4a0227a441.png" alt="image-20210425222245665"></p><hr><h1 id="7-操作数栈管理指令"><a class="markdownIt-Anchor" href="#7-操作数栈管理指令"></a> 7. 操作数栈管理指令</h1><blockquote><h2 id="通用无类型栈操作"><a class="markdownIt-Anchor" href="#通用无类型栈操作"></a> 通用(无类型）栈操作</h2><p>nop 不做任何操作</p><p>pop 弹出栈顶端一个字长的内容</p><p>pop2 弹出栈顶端两个字长的内容</p><p>dup 复制栈顶部一个字长内容</p><p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p><p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2 复制栈顶部两个字长内容</p><p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p><p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p><p>swap 交换栈顶部两个字长内容</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/316306469dcd1360c16578931cd064fa.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/0d8d5d90fc84398f114eae5d1119cf6b.png" alt="img"></p><hr><h1 id="8-控制转移指令"><a class="markdownIt-Anchor" href="#8-控制转移指令"></a> 8. 控制转移指令</h1><blockquote><h2 id="比较指令"><a class="markdownIt-Anchor" href="#比较指令"></a> 比较指令</h2><p>lcmp 比较long类型值</p><p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p><p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p><p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p><p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p><h2 id="条件分支指令"><a class="markdownIt-Anchor" href="#条件分支指令"></a> 条件分支指令</h2><p>ifeq 如果等于0，则跳转</p><p>ifne 如果不等于0，则跳转</p><p>iflt 如果小于0，则跳转</p><p>ifge 如果大于等于0，则跳转</p><p>ifgt 如果大于0，则跳转</p><p>ifle 如果小于等于0，则跳转</p><h2 id="比较条件分支指令"><a class="markdownIt-Anchor" href="#比较条件分支指令"></a> 比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p><p>if_icmpne 如果两个int类型值不相等，则跳转</p><p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p><p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p><p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p><p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p><p>ifnull 如果等于null，则跳转</p><p>ifnonnull 如果不等于null，则跳转</p><p>if_acmpeq 如果两个对象引用相等，则跳转</p><p>if_acmpne 如果两个对象引用不相等，则跳转</p><h2 id="多条件分支跳转指令"><a class="markdownIt-Anchor" href="#多条件分支跳转指令"></a> 多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p><p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p><h2 id="无条件跳转指令"><a class="markdownIt-Anchor" href="#无条件跳转指令"></a> 无条件跳转指令</h2><p>goto 无条件跳转</p><p>goto_w 无条件跳转（宽索引）</p></blockquote><h2 id="81-比较指令"><a class="markdownIt-Anchor" href="#81-比较指令"></a> 8.1. 比较指令</h2><blockquote><p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p><p>比较指令有： dcmpg,dcmpl、 fcmpg、fcmpl、lcmp</p><p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p><p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p><p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p><p>举例</p><p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,</p><p><strong>若v1=v2, 则压入0；若v1&gt;v2则压入1；若v1&lt;v2则压入-1.</strong></p><p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p></blockquote><h2 id="82-条件跳转指令"><a class="markdownIt-Anchor" href="#82-条件跳转指令"></a> 8.2. 条件跳转指令</h2><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>==</th><th>!=</th><th>&gt;=</th><th>&gt;</th><th>null</th><th>not null</th></tr></thead><tbody><tr><td>iflt</td><td>ifle</td><td>ifeq</td><td>ifng</td><td>ifge</td><td>ifgt</td><td>ifnull</td><td>ifnonnull</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/e59234f41d6946ead781b686455783d9.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/85374206e3cdbb00f45971b1429c6d34.png" alt="img"></p><p><img src="../../../images/image-20230110172437296.png" alt="image-20230110172437296"></p><p><img src="../../../images/image-20230110172558692.png" alt="image-20230110172558692"></p><h2 id="83-比较条件跳转指令"><a class="markdownIt-Anchor" href="#83-比较条件跳转指令"></a> 8.3. 比较条件跳转指令</h2><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>==</th><th>!=</th><th>&gt;=</th><th>&gt;</th></tr></thead><tbody><tr><td>if_icmplt</td><td>if_icmple</td><td>if_icmpeq、if_acmpeq</td><td>if_icmpne、if_acmpne</td><td>if_icmpge</td><td>if_icmpgt</td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/7ffa349a864e62f3e0298b63acb904ae.png" alt="img"></p><h2 id="84-多条件分支跳转"><a class="markdownIt-Anchor" href="#84-多条件分支跳转"></a> 8.4. 多条件分支跳转</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f6f973613d257f1d172e0fcee504cd97.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/57c7b57b096f8a8cfcdcdd1b5d4e179b.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/a709c4fcd4bf627ad47d53ac062db47b.png" alt="img"></p><p><img src="../../../images/image-20230110210256624.png" alt="image-20230110210256624"></p><p><img src="../../../images/image-20230110210450102.png" alt="image-20230110210450102"></p><p><img src="../../../images/image-20230110210833352.png" alt="image-20230110210833352"></p><h2 id="85-无条件跳转"><a class="markdownIt-Anchor" href="#85-无条件跳转"></a> 8.5. 无条件跳转</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/9e86f7429623e68e353ce9d1962a1267.png" alt="img"></p><hr><p><img src="../../../images/image-20230110211303331.png" alt="image-20230110211303331"></p><h1 id="9-异常处理指令"><a class="markdownIt-Anchor" href="#9-异常处理指令"></a> 9. 异常处理指令</h1><blockquote><h2 id="异常处理指令"><a class="markdownIt-Anchor" href="#异常处理指令"></a> 异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p><p>jsr 跳转到子例程</p><p>jsr_w 跳转到子例程（宽索引）</p><p>rct 从子例程返回</p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/196b81557c33474cf2cfa2032aa65340.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/9e9883544cea41b6148e535da4417d78.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/daa25784fc259c12af58bb094d6ffc52.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/cba1429ffc09988d78008f5309a6374a.png" alt="img"></p><hr><h1 id="10-同步控制指令"><a class="markdownIt-Anchor" href="#10-同步控制指令"></a> 10. 同步控制指令</h1><blockquote><h3 id="线程同步"><a class="markdownIt-Anchor" href="#线程同步"></a> 线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p><p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p></blockquote><p>Java虚拟机支持两种同步结构：<strong>方法级的同步</strong>（同步方法） 和 <strong>方法内部一段指令序列的同步</strong>（方法内使用的同步代码块），这两种同步都是使用monitor监听器来支持的</p><h2 id="101-方法级的同步"><a class="markdownIt-Anchor" href="#101-方法级的同步"></a> 10.1. 方法级的同步</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/20b7bf14a51e1be4f90dac5e305d2ea3.png" alt="img"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line">i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/098e9fef1897cf213d14f145db04c9f1.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/84ff4ef05baf1b5774f43b203d6a6e23.png" alt="img"></p><h2 id="102-方法内指令指令序列的同步"><a class="markdownIt-Anchor" href="#102-方法内指令指令序列的同步"></a> 10.2. 方法内指令指令序列的同步</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/697b683f5fba682a6ed9772950f719a7.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/71ab99d8f145e61b31daa03a233f2596.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/ac36b8a792107c77956ef642afba2154.png" alt="img"></p><hr><p><img src="../../../images/image-20230110220327662.png" alt="image-20230110220327662"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM中篇：字节码与类的加载器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM中篇：字节码与类的加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/"/>
      <url>/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/</url>
      
        <content type="html"><![CDATA[<p><strong>为什么学字节码文件的原因：</strong></p><p><img src="../../../images/image-20230103141407495.png" alt="image-20230103141407495"></p><p><img src="../../../images/image-20230103141317313.png" alt="image-20230103141317313"></p><p><img src="../../../images/image-20230103141306367.png" alt="image-20230103141306367"></p><p><img src="../../../images/image-20230103141338248.png" alt="image-20230103141338248"></p><p><strong>java前端编译器</strong></p><p><img src="../../../images/image-20230103142540075.png" alt="image-20230103142540075"></p><p>一个程序的性能是否高效，其实跟语言是没太大的关系的，主要是编译器，比如java在早期的时候，没有编译器只有解释器，然后就很慢，后来又了JIT编译器后，就快很多了。</p><p><strong>前端编译器 vs 后端编译器</strong></p><p><img src="../../../images/image-20230103144208971.png" alt="image-20230103144208971"></p><p><strong>透过字节码指令看代码执行细节：</strong></p><p><img src="../../../images/image-20230103144413285.png" alt="image-20230103144413285"></p><p><img src="../../../images/image-20230103144716615.png" alt="image-20230103144716615"></p><p><img src="../../../images/image-20230103150037755.png" alt="image-20230103150037755"></p><p>例子2：</p><p><img src="../../../images/image-20230103150626861.png" alt="image-20230103150626861"></p><p>例子3：</p><p><img src="../../../images/image-20230105164434790.png" alt="image-20230105164434790"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 成员变量（非静态的）赋值过程：1.默认初始化 - 2.显示初始化 / 代码块中初始化 - 3. 构造器中初始化 -</span><br><span class="line">*                         4.有了对象之后，可以“对象.属性” 或 “对象.方法” 的方式对成员变量进行赋值</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230105162837668.png" alt="image-20230105162837668"></p><p><img src="../../../images/image-20230105163558835.png" alt="image-20230105163558835"></p><p><img src="../../../images/image-20230105164757916.png" alt="image-20230105164757916"></p><h2 id="解读class文件的三种方式"><a class="markdownIt-Anchor" href="#解读class文件的三种方式"></a> 解读Class文件的三种方式</h2><p><img src="../../../images/image-20230106210715710.png" alt="image-20230106210715710"></p><p><img src="../../../images/image-20230106211249422.png" alt="image-20230106211249422"></p><p><img src="../../../images/image-20230106211233536.png" alt="image-20230106211233536"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/12/21/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/%E4%B8%8D%E6%98%8E%E5%BC%82%E5%B8%B8/"/>
      <url>/2022/12/21/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/%E4%B8%8D%E6%98%8E%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<p>当你的实体类实现了序列化接口<img src="../../images/image-20221221005142575.png" alt="image-20221221005142575">，当你去查询数据库的实体类时，有时候会报错，有时候又不会报，我也不知道为什么，报错如下：</p><p>java.ang.ClassCastException: lass com.webloq.entity.User cannot be cast to class javaang,String (com.webloq,entity.User is in unnamed module of loader</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java.lang.ClassNotFoundException lombok.Data</title>
      <link href="/2022/12/17/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/java.lang.ClassNotFoundException%20lombok.Data/"/>
      <url>/2022/12/17/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/java.lang.ClassNotFoundException%20lombok.Data/</url>
      
        <content type="html"><![CDATA[<p>springboot项目启动报错:</p><p><img src="https://img-blog.csdnimg.cn/20191219191118357.png" alt="img"></p><p>原因：mysql <a href="https://so.csdn.net/so/search?q=datetime&amp;spm=1001.2101.3001.7020">datetime</a>类型，实体类 写成了 Data</p><p><img src="https://img-blog.csdnimg.cn/24af0326e2854017a42925a304442132.png" alt="img"></p><p>把Data全部改为Date即可：</p><p><img src="https://img-blog.csdnimg.cn/69878a80687c47238f29cc095bd52d5f.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 异常or报错 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常or报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据同步</title>
      <link href="/2022/12/12/elasticsearch/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/12/12/elasticsearch/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="方案一同步调用"><a class="markdownIt-Anchor" href="#方案一同步调用"></a> 方案一：同步调用</h3><p><img src="../../images/image-20221212170758302.png" alt="image-20221212170758302"></p><p>如果用上面这种同步调用方法的话，就会把业务代码形成耦合，业务耦合必定会影响性能。上面一次新增酒店的总耗时就相当于三个步骤的总耗时，显然这样时间会比较长，而且如果有其中的步骤出异常，那么新增酒店这整个业务就出问题了。这就是耦合带来的问题。</p><h3 id="方案二异步通知"><a class="markdownIt-Anchor" href="#方案二异步通知"></a> 方案二：异步通知</h3><p><img src="../../images/image-20221212171310763.png" alt="image-20221212171310763"></p><p>利用MQ进行异步通知，解出耦合，提高性能。但这种方案比较依靠MQ的可靠性。</p><h3 id="方案三监听binlog"><a class="markdownIt-Anchor" href="#方案三监听binlog"></a> 方案三：监听binlog</h3><p><img src="../../images/image-20221212171812077.png" alt="image-20221212171812077"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p><img src="../../images/image-20221212171713573.png" alt="image-20221212171713573"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot事务回滚</title>
      <link href="/2022/12/03/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/Spring%20Boot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/"/>
      <url>/2022/12/03/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/Spring%20Boot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1><p>我们开发系统的时候经常会遇到一些关于交易的需求，交易的过程大多数都比较繁琐（会包括修改库存、修改余额、记录交易账单等等步骤），这时候我们就不得不考虑其中的潜在风险了，比如我们在交易的过程中修改了库存（库存 -1），接下来需要进行支付操作，但是此时系统突然宕机或者网络突然中断，这也就导致我们无法完成整个交易流程，虽然用户还没付钱，但是我们的库存变少了（商家肯定就不高兴了👿），所以我们就需要用到事务回滚来解决上述的问题。</p><h1 id="spring-boot-事务回滚"><a class="markdownIt-Anchor" href="#spring-boot-事务回滚"></a> Spring Boot 事务回滚</h1><p>我们有两种方式可以实现事务回滚，第一种是自动回滚，第二种是手动回滚，这两种实现方式大同小异，二者都需要使用 @Transactional 注解来实现事务回滚，下面直接上代码，看看二者之间到底哪里不一样。</p><p>在接口实现类中有一个插入会员信息的方法，咱们就对这个方法进行改造，分别实现一下自动回滚和手动回滚👇</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">    cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">    SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">    <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure><h2 id="自动回滚"><a class="markdownIt-Anchor" href="#自动回滚"></a> 自动回滚</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">    cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">    SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">    <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure><p>我们可以看到方法上增加了一个注解 @Transactional(rollbackFor = Exception.class) ，通过该注解可以对异常进行捕获，当发生异常时就可以进行回滚，从而撤销本次的入库操作。</p><p>很多方法中都会用 try-catch 对异常进行处理，如果此时在 catch 中对可能出现的异常进行了处理，但是并没有再手动抛出（throw）异常，Spring 则会认为该方法成功执行，也就不会进行回滚👇。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b9858bcb9f4d22a5cc2931883efe1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"> 正解如下👇：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">        cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">        SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">        <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        System.out.println(<span class="string">"方法出现异常："</span> + e);</span><br><span class="line">        <span class="comment">//手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure><p>P.S. 如果 try-catch 语句在 finally 语句块中进行了 return 操作，那么 catch 语句块中手动抛出的异常也会被覆盖，同样不会自动回滚。</p><h2 id="手动回滚"><a class="markdownIt-Anchor" href="#手动回滚"></a> 手动回滚</h2><p>手动回滚的实现方式也非常简单，只需要添加一句代码即可实现👇</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">        cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">        SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">        <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        System.out.println(<span class="string">"方法出现异常："</span> + e);</span><br><span class="line">        <span class="comment">//实现手动回滚</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure><p>P.S. 这里只是举个例子，手动回滚语句不一定要添加在 catch 代码块中，我们可以在任何一个地方使用手动回滚语句。<strong>需要注意的是，我们虽然可以在其他地方增加手动回滚语句，但是手动回滚语句后的代码还会继续执行，所以不建议在非 catch 代码块中使用手动回滚语句。</strong> 如果非要这么用的话，就一定要好好斟酌一下自己的业务逻辑是不是会有 BUG 了。</p><h1 id="spring-boot-事务回滚注意事项"><a class="markdownIt-Anchor" href="#spring-boot-事务回滚注意事项"></a> Spring Boot 事务回滚注意事项</h1><p>这里我们再简单说几句关于 Spring Boot 事务回滚中的注意事项：</p><ol><li>想实现回滚，首先要保证 Spring Boot 开启了事务（在启动类上增加 @EnableTransactionManagement 注解开启事务（其实 Spring Boot 默认就是开启事务的），其次就是实现回滚的方法必须是 public 的。</li><li>@Transactional(rollbackFor=Exception.class) 表示的是该方法无论抛出什么异常都会进行自动回滚；如果不加 (rollbackFor=Exception.class) 的话，则代表了默认值，也就是只有当该方法抛出了非检查型异常（RuntimeException）时才会进行回滚。</li><li>由于事务的四大特性（原子性、一致性、隔离性、持久性），所以 @Transactional 一般是要加在业务层（也就是接口实现类）中。</li><li>如果将 @Transactional(rollbackFor=Exception.class) 加在了接口实现类上，那么这个类下的所有方法都将会被加上事务管理，即所有方法都会在自己出现异常时进行回滚操作。</li></ol><h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1><p>本人经验有限，有些地方可能讲的没有特别到位，如果您在阅读的时候想到了什么问题，欢迎在评论区留言，我们后续再一一探讨🙇‍</p>]]></content>
      
      
      <categories>
          
          <category> 安全性 </category>
          
          <category> 事务回滚 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全性 </tag>
            
            <tag> 事务回滚 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器docker安装MinIO</title>
      <link href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E5%AE%89%E8%A3%85MinIO/"/>
      <url>/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E5%AE%89%E8%A3%85MinIO/</url>
      
        <content type="html"><![CDATA[<ol><li>执行命令 <code>docker pull minio/minio</code> 下载稳定版本镜像</li></ol><blockquote><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></tbody></table></figure></blockquote><p><img src="https://img-blog.csdnimg.cn/f3ce24819cf1437a959b0009e57124cd.png" alt="img"></p><ol start="2"><li>创建并启动minio容器</li></ol><p>MINIO_ACCESS_KEY是登录的用户名，MINIO_SECRET_KEY是登陆的密码，根据自己的情况来设置登录的用户名和密码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 9001:9001 -d --name minio -v /opt/docker/minio/data:/data -v /opt/docker/minio/config:/root/.minio -e "MINIO_ROOT_USER=minio" -e "MINIO_ROOT_PASSWORD=minio@123456" minio/minio server /data --console-address ":9000" --address ":9001"</span><br></pre></td></tr></tbody></table></figure><p>–console-address “:9000”  中的9000 是可视化界面的访问端口</p><p>–address “:9001” 中的 9001是api端口，在springboot中整合是用到</p><ol start="3"><li>开放9000端口</li></ol><p><img src="https://img-blog.csdnimg.cn/fd189f85c8834e899f4b5e0284876ea7.png" alt="img"></p><p>9001端口也是像上面一样开放即可</p><ol start="4"><li>访问登录，使用IP+9000 登录即可测试，然后输入自己在启动创建容器时设置的账号和密码</li></ol><p><img src="https://img-blog.csdnimg.cn/d6823c8747fb4b8ab196b9f3a892d18a.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/94216afbb986434c9934f8d7d1fe523f.png" alt="img"></p><hr><p>安装和使用，可以参照这个博文：</p><p><a href="https://juejin.cn/post/7101581935486615559">SpringBoot 整合 Minio 上传文件 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 文件服务器 </category>
          
          <category> MinIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件服务器 </tag>
            
            <tag> MinIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Minio设置文件永久访问和下载</title>
      <link href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/Minio%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B0%B8%E4%B9%85%E8%AE%BF%E9%97%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
      <url>/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/Minio%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B0%B8%E4%B9%85%E8%AE%BF%E9%97%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<ol><li></li></ol><blockquote><p>docker pull minio/mc</p></blockquote><p><img src="https://img-blog.csdnimg.cn/8c2815c4dfe14d15b74abcd173b9db9c.png" alt="img"></p><ol start="2"><li></li></ol><blockquote><p>docker run -it --entrypoint=/bin/sh minio/mc</p></blockquote><p><img src="https://img-blog.csdnimg.cn/a26767d7c9d74cc5bee45a1bffd745af.png" alt="img"></p><ol start="3"><li></li></ol><blockquote><p>mc config host add <alias> <your-s3-endpoint> <your-access-key> <your-secret-key> [–api API-SIGNATURE]</your-secret-key></your-access-key></your-s3-endpoint></alias></p></blockquote><blockquote><p>mc ls minio</p></blockquote><ul><li>ALIAS: 别名就是给你的云存储服务起了一个短点的外号。</li><li>S3 endpoint,access key和secret key是你的云存储服务提供的。<ul><li>endpoint</li><li>access key、secret key 到这里大家肯定都知道啦。</li></ul></li><li>API签名是可选参数，默认情况下，它被设置为"S3v4"。</li></ul><p>例如：</p><p><img src="https://img-blog.csdnimg.cn/8d4b5fb05f35420d8342b57906cde36b.png" alt="img"></p><ol start="4"><li>通过下面命令分别设置永久下载和永久分享</li></ol><blockquote><p>mc anonymous set download minio/file</p></blockquote><blockquote><p>mc anonymous set public minio/file</p></blockquote><p><img src="https://img-blog.csdnimg.cn/db7e3502bffc4e729b9cde0ff25c31f3.png" alt="img"></p><p>详细说明参考如下博文：</p><p><a href="https://juejin.cn/post/6992467402877304868">Docker 安装最新Minio Client，还附带解决如何设置永久访问和永久下载链接！！（详图）有需求值得收藏的哈！！！！ - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 文件服务器 </category>
          
          <category> MinIO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件服务器 </tag>
            
            <tag> MinIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1-class文件结构</title>
      <link href="/2022/11/29/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/1-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
      <url>/2022/11/29/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/1-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p><img src="../../../images/image-20230108231953467.png" alt="image-20230108231953467"></p><h1 id="1-class-文件结构"><a class="markdownIt-Anchor" href="#1-class-文件结构"></a> 1. Class 文件结构</h1><h2 id="11-class-字节码文件结构"><a class="markdownIt-Anchor" href="#11-class-字节码文件结构"></a> 1.1. Class 字节码文件结构</h2><table>    <tbody>          <tr>            <th></th>             <th>类型</th>             <th>名称</th>             <th>说明</th>             <th>长度</th>             <th>数量</th>        </tr>       <tr>            <td>魔数</td>            <td>u4</td>            <td>magic</td>            <td>魔数,识别Class文件格式</td>            <td>4个字节</td>                 <td>1</td>       </tr>       <tr>            <td rowspan="2">版本号</td>            <td>u2</td>            <td>minor_version</td>            <td>副版本号(小版本)</td>            <td>2个字节</td>                 <td>1</td>       </tr>       <tr>            <td>u2</td>            <td>major_version</td>            <td>主版本号(大版本)</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="2">常量池集合</td>            <td>u2</td>            <td>constant_pool_count</td>            <td>常量池计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>cp_info</td>            <td>constant_pool</td>            <td>常量池表</td>            <td>n个字节</td>                 <td>constant_pool_count - 1</td>        </tr>        <tr>            <td>访问标识</td>            <td>u2</td>            <td>access_flags</td>            <td>访问标识</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td rowspan="4">索引集合</td>            <td>u2</td>            <td>this_class</td>            <td>类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>super_class</td>            <td>父类索引</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces_count</td>            <td>接口计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>u2</td>            <td>interfaces</td>            <td>接口索引集合</td>            <td>2个字节</td>                 <td>interfaces_count</td>        </tr>            <tr>            <td rowspan="2">字段表集合</td>            <td>u2</td>            <td>fields_count</td>            <td>字段计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>field_info</td>            <td>fields</td>            <td>字段表</td>            <td>n个字节</td>                 <td>fields_count</td>        </tr>        <tr>            <td rowspan="2">方法表集合</td>            <td>u2</td>            <td>methods_count</td>            <td>方法计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>method_info</td>            <td>methods</td>            <td>方法表</td>            <td>n个字节</td>                 <td>methods_count</td>        </tr>        <tr>            <td rowspan="2">属性表集合</td>            <td>u2</td>            <td>attributes_count</td>            <td>属性计数器</td>            <td>2个字节</td>                 <td>1</td>        </tr>        <tr>            <td>attribute_info</td>            <td>attributes</td>            <td>属性表</td>            <td>n个字节</td>                 <td>attributes_count</td>        </tr>   </tbody><tbody> </tbody></table><p><img src="../../../images/image-20230106211846510.png" alt="image-20230106211846510"></p><p><img src="../../../images/image-20230106212954414.png" alt="image-20230106212954414"></p><p><img src="../../../images/image-20230106213322903.png" alt="image-20230106213322903"></p><p><img src="../../../images/image-20230106213238542.png" alt="image-20230106213238542"></p><p><img src="../../../images/image-20230107101026854.png" alt="image-20230107101026854"></p><p><img src="../../../images/image-20230107101258275.png" alt="image-20230107101258275"></p><p><img src="../../../images/image-20230107162311874.png" alt="image-20230107162311874"></p><h2 id="12-class-文件数据类型"><a class="markdownIt-Anchor" href="#12-class-文件数据类型"></a> 1.2. Class 文件数据类型</h2><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">定义</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">无符号数</td><td style="text-align:left">无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td><td style="text-align:left">其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td></tr><tr><td style="text-align:left">表</td><td style="text-align:left">表是由多个无符号数或其他表构成的复合数据结构。</td><td style="text-align:left">所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td></tr></tbody></table><h2 id="13-魔数"><a class="markdownIt-Anchor" href="#13-魔数"></a> 1.3. 魔数</h2><p><strong>Magic Number（魔数）</strong></p><ul><li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）</li><li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：<strong>魔数是 Class 文件的标识符</strong>。</li><li>魔数值固定为 0xCAFEBABE。不会改变。</li><li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">1885430635</span> in <span class="keyword">class</span> <span class="title class_">file</span> StringTest</span><br></pre></td></tr></tbody></table></figure><ul><li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li></ul><h2 id="14-文件版本号"><a class="markdownIt-Anchor" href="#14-文件版本号"></a> 1.4. 文件版本号</h2><p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 <strong>minor_version</strong>，而第 7 个和第 8 个字节就是编译的主版本号 <strong>major_version</strong>。</p><p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p><p>版本号和 Java 编译器的对应关系如下表：</p><h3 id="141-class-文件版本号对应关系"><a class="markdownIt-Anchor" href="#141-class-文件版本号对应关系"></a> 1.4.1. Class 文件版本号对应关系</h3><table><thead><tr><th>主版本（十进制）</th><th>副版本（十进制）</th><th>编译器版本</th></tr></thead><tbody><tr><td>45</td><td>3</td><td>1.1</td></tr><tr><td>46</td><td>0</td><td>1.2</td></tr><tr><td>47</td><td>0</td><td>1.3</td></tr><tr><td>48</td><td>0</td><td>1.4</td></tr><tr><td>49</td><td>0</td><td>1.5</td></tr><tr><td>50</td><td>0</td><td>1.6</td></tr><tr><td>51</td><td>0</td><td>1.7</td></tr><tr><td>52</td><td>0</td><td>1.8</td></tr><tr><td>53</td><td>0</td><td>1.9</td></tr><tr><td>54</td><td>0</td><td>1.10</td></tr><tr><td>55</td><td>0</td><td>1.11</td></tr></tbody></table><p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p><p><mark>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</mark></p><p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p><ul><li>虚拟机 JDK 版本为 1.k（k&gt;=2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li></ul><h2 id="15-常量池集合"><a class="markdownIt-Anchor" href="#15-常量池集合"></a> 1.5. 常量池集合</h2><p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p><p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5c2a8d904287373990cffe9b82428daa.png" alt="image-20210508233536076"></p><p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p><p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2（无符号数）</td><td style="text-align:left">constant_pool_count</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">cp_info（表）</td><td style="text-align:left">constant_pool</td><td style="text-align:left">constant_pool_count - 1</td></tr></tbody></table><p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p><ul><li><mark>常量池表项</mark>中，用于存放编译时期生成的各种<mark>字面量</mark>和<mark>符号引用</mark>，这部分内容将在类加载后进入方法区的<mark>运行时常量池</mark>中存放</li></ul><h3 id="151-常量池计数器"><a class="markdownIt-Anchor" href="#151-常量池计数器"></a> 1.5.1. 常量池计数器</h3><p><strong>constant_pool_count（常量池计数器）</strong></p><ul><li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li><li>常量池容量计数值（u2 类型）：<mark>从 1 开始</mark>，表示常量池中有多少项常量。即 constant_pool_count=1 表示常量池中有 0 个常量项。</li><li>Demo 的值为：</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/a17ef03e0783c664a51491aafde85d2a.png" alt="image-20210508234020104"></p><p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p><p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p><h3 id="152-常量池表"><a class="markdownIt-Anchor" href="#152-常量池表"></a> 1.5.2. 常量池表</h3><p>constant_pool 是一种表结构，以 <strong>1 ~ constant_pool_count - 1</strong> 为索引。表明了后面有多少个常量项。</p><p>常量池主要存放两大类常量：<mark>字面量（Literal）</mark>和<mark>符号引用（Symbolic References）</mark></p><p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">标志(或标识)</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">CONSTANT_Utf8_info</td><td style="text-align:left">1</td><td style="text-align:left">UTF-8 编码的字符串</td></tr><tr><td style="text-align:left">CONSTANT_Integer_info</td><td style="text-align:left">3</td><td style="text-align:left">整型字面量</td></tr><tr><td style="text-align:left">CONSTANT_Float_info</td><td style="text-align:left">4</td><td style="text-align:left">浮点型字面量</td></tr><tr><td style="text-align:left">CONSTANT_Long_info</td><td style="text-align:left">5</td><td style="text-align:left">长整型字面量</td></tr><tr><td style="text-align:left">CONSTANT_Double_info</td><td style="text-align:left">6</td><td style="text-align:left">双精度浮点型字面量</td></tr><tr><td style="text-align:left">CONSTANT_Class_info</td><td style="text-align:left">7</td><td style="text-align:left">类或接口的符号引用</td></tr><tr><td style="text-align:left">CONSTANT_String_info</td><td style="text-align:left">8</td><td style="text-align:left">字符串类型字面量</td></tr><tr><td style="text-align:left">CONSTANT_Fieldref_info</td><td style="text-align:left">9</td><td style="text-align:left">字段的符号引用</td></tr><tr><td style="text-align:left">CONSTANT_Methodref_info</td><td style="text-align:left">10</td><td style="text-align:left">类中方法的符号引用</td></tr><tr><td style="text-align:left">CONSTANT_InterfaceMethodref_info</td><td style="text-align:left">11</td><td style="text-align:left">接口中方法的符号引用</td></tr><tr><td style="text-align:left">CONSTANT_NameAndType_info</td><td style="text-align:left">12</td><td style="text-align:left">字段或方法的符号引用</td></tr><tr><td style="text-align:left">CONSTANT_MethodHandle_info</td><td style="text-align:left">15</td><td style="text-align:left">表示方法句柄</td></tr><tr><td style="text-align:left">CONSTANT_MethodType_info</td><td style="text-align:left">16</td><td style="text-align:left">标志方法类型</td></tr><tr><td style="text-align:left">CONSTANT_InvokeDynamic_info</td><td style="text-align:left">18</td><td style="text-align:left">表示一个动态方法调用点</td></tr></tbody></table><h4 id="i-字面量和符号引用"><a class="markdownIt-Anchor" href="#i-字面量和符号引用"></a> Ⅰ. 字面量和符号引用</h4><p>在对这些常量解读前，我们需要搞清楚几个概念。</p><p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p><table><thead><tr><th style="text-align:left">常量</th><th style="text-align:left">具体的常量</th></tr></thead><tbody><tr><td style="text-align:left">字面量</td><td style="text-align:left">文本字符串</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">声明为 final 的常量值</td></tr><tr><td style="text-align:left">符号引用</td><td style="text-align:left">类和接口的全限定名</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">字段的名称和描述符</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">方法的名称和描述符</td></tr></tbody></table><p><strong>全限定名</strong></p><p>com/atguigu/test/Demo 这个就是类的<strong>全限定名</strong>，仅仅是把包名（全类名）的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p><p><strong>简单名称</strong></p><p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add()方法和 num 字段的简单名称分别是 add 和 num。</p><p><strong>描述符</strong></p><p><mark>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</mark>。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p><table><thead><tr><th style="text-align:left">标志符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">B</td><td style="text-align:left">基本数据类型 byte</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">基本数据类型 char</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">基本数据类型 double</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">基本数据类型 float</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">基本数据类型 int</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">基本数据类型 long</td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">基本数据类型 short</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">基本数据类型 boolean</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">代表 void 类型</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">数组类型，代表一维数组。比如：`double[] is [D</td></tr></tbody></table><p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring()的描述符为()Ljava/lang/String; ，方法 int abc(int[]x, int y)的描述符为([II)I。</p><p><img src="../../../images/image-20230107105451433.png" alt="image-20230107105451433"></p><p><strong>补充说明：</strong></p><p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<mark>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</mark>。</p><p>这里说明下符号引用和直接引用的区别与关联：</p><ul><li>符号引用：符号引用以<mark>一组符号</mark>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<mark>符号引用与虚拟机实现的内存布局无关</mark>，引用的目标并不一定已经加载到了内存中。</li><li>直接引用：直接引用可以是直接<mark>指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</mark>。<mark>直接引用是与虚拟机实现的内存布局相关的</mark>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li></ul><h4 id="ii-常量类型和结构"><a class="markdownIt-Anchor" href="#ii-常量类型和结构"></a> Ⅱ. 常量类型和结构</h4><p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8266c05b4b1506d4c456b427b90b1b75.png" alt="image-20210509001319088"></p><p>常量池表数据的解读视频教程：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=221&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">221-常量池表数据的解读2_哔哩哔哩_bilibili</a></p><p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如:<br>CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p><p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p><p><strong>细节说明:</strong></p><ul><li>CONSTANT_Class_info 结构用于表示类或接口</li><li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li><li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li><li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量</li><li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量<ul><li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li></ul></li><li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li><li>CONSTANT_Utf8_info 用于表示字符常量的值</li><li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li><li>CONSTANT_MethodType_info 结构表示方法类型</li><li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li></ul><p><strong>解析方法：</strong></p><ul><li>一个字节一个字节的解析</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/f3485b5ca6cb750454230270021fc68a.png" alt="image-20210509002525647"></p><ul><li>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</li></ul><p><strong>总结 1：</strong></p><ul><li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li><li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li><li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？<mark>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</mark>，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li></ul><p><strong>总结 2：</strong></p><ul><li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li><li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，<mark>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</mark>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li></ul><h2 id="16-访问标志"><a class="markdownIt-Anchor" href="#16-访问标志"></a> 1.6. 访问标志</h2><p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p><p>在常量池后，紧跟着访问标记。<strong>该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息</strong>，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p><table><thead><tr><th style="text-align:left">标志名称</th><th>标志值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ACC_PUBLIC</td><td>0x0001</td><td style="text-align:left">标志为 public 类型</td></tr><tr><td style="text-align:left">ACC_FINAL</td><td>0x0010</td><td style="text-align:left">标志被声明为 final，只有类可以设置</td></tr><tr><td style="text-align:left">ACC_SUPER</td><td>0x0020</td><td style="text-align:left">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td></tr><tr><td style="text-align:left">ACC_INTERFACE</td><td>0x0200</td><td style="text-align:left">标志这是一个接口</td></tr><tr><td style="text-align:left">ACC_ABSTRACT</td><td>0x0400</td><td style="text-align:left">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td style="text-align:left">ACC_SYNTHETIC</td><td>0x1000</td><td style="text-align:left">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td></tr><tr><td style="text-align:left">ACC_ANNOTATION</td><td>0x2000</td><td style="text-align:left">标志这是一个注解</td></tr><tr><td style="text-align:left">ACC_ENUM</td><td>0x4000</td><td style="text-align:left">标志这是一个枚举</td></tr></tbody></table><p>类的访问权限通常为 ACC_开头的常量。</p><p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p><p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p><p><strong>补充说明：</strong></p><ol><li><p>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。</p><ul><li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li><li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li></ul></li><li><p>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<mark>针对 Java 虚拟机指令集的编译器都应当设置这个标志</mark>。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。</p><ul><li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li></ul></li><li><p>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</p></li><li><p>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</p></li><li><p>ACC_ENUM 标志表明该类或其父类为枚举类型。</p></li></ol><h2 id="17-类索引-父类索引-接口索引"><a class="markdownIt-Anchor" href="#17-类索引-父类索引-接口索引"></a> 1.7. 类索引、父类索引、接口索引</h2><p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p><table><thead><tr><th>长度</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td>u2</td><td style="text-align:left">this_class</td></tr><tr><td>u2</td><td style="text-align:left">super_class</td></tr><tr><td>u2</td><td style="text-align:left">interfaces_count</td></tr><tr><td>u2</td><td style="text-align:left">interfaces[interfaces_count]</td></tr></tbody></table><p>这三项数据来确定这个类的继承关系：</p><ul><li>类索引用于确定这个类的全限定名</li><li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li><li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li></ul><h3 id="171-this_class类索引"><a class="markdownIt-Anchor" href="#171-this_class类索引"></a> 1.7.1. this_class（类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p><h3 id="172-super_class父类索引"><a class="markdownIt-Anchor" href="#172-super_class父类索引"></a> 1.7.2. super_class（父类索引）</h3><p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p><p>super_class 指向的父类不能是 final。</p><h3 id="173-interfaces"><a class="markdownIt-Anchor" href="#173-interfaces"></a> 1.7.3. interfaces</h3><p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p><p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p><h4 id="i-interfaces_count接口计数器"><a class="markdownIt-Anchor" href="#i-interfaces_count接口计数器"></a> Ⅰ. interfaces_count（接口计数器）</h4><p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p><h4 id="ii-interfaces接口索引集合"><a class="markdownIt-Anchor" href="#ii-interfaces接口索引集合"></a> Ⅱ. interfaces[]（接口索引集合）</h4><p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i]必须为 CONSTANT_Class_info 结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口。</p><h2 id="18-字段表集合"><a class="markdownIt-Anchor" href="#18-字段表集合"></a> 1.8. 字段表集合</h2><p><strong>fields</strong></p><p>用于描述接口或类中声明的变量。字段（field）包括<mark>类级变量以及实例级变量</mark>，但是不包括方法内部、代码块内部声明的局部变量。</p><p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p><p>它指向常量池索引集合，它描述了每个字段的完整信息。比如<mark>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</mark>等。</p><p><strong>注意事项：</strong></p><ul><li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li><li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li></ul><h3 id="181-字段计数器"><a class="markdownIt-Anchor" href="#181-字段计数器"></a> 1.8.1. 字段计数器</h3><p><strong>fields_count（字段计数器）</strong></p><p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p><p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags</td><td style="text-align:left">访问标志</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">name_index</td><td style="text-align:left">字段名索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">descriptor_index</td><td style="text-align:left">描述符索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">属性计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">属性集合</td><td style="text-align:left">attributes_count</td></tr></tbody></table><h3 id="182-字段表"><a class="markdownIt-Anchor" href="#182-字段表"></a> 1.8.2. 字段表</h3><h4 id="i-字段表访问标识"><a class="markdownIt-Anchor" href="#i-字段表访问标识"></a> Ⅰ. 字段表访问标识</h4><p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:left">字段是否为 public</td></tr><tr><td style="text-align:left">ACC_PRIVATE</td><td style="text-align:left">0x0002</td><td style="text-align:left">字段是否为 private</td></tr><tr><td style="text-align:left">ACC_PROTECTED</td><td style="text-align:left">0x0004</td><td style="text-align:left">字段是否为 protected</td></tr><tr><td style="text-align:left">ACC_STATIC</td><td style="text-align:left">0x0008</td><td style="text-align:left">字段是否为 static</td></tr><tr><td style="text-align:left">ACC_FINAL</td><td style="text-align:left">0x0010</td><td style="text-align:left">字段是否为 final</td></tr><tr><td style="text-align:left">ACC_VOLATILE</td><td style="text-align:left">0x0040</td><td style="text-align:left">字段是否为 volatile</td></tr><tr><td style="text-align:left">ACC_TRANSTENT</td><td style="text-align:left">0x0080</td><td style="text-align:left">字段是否为 transient</td></tr><tr><td style="text-align:left">ACC_SYNCHETIC</td><td style="text-align:left">0x1000</td><td style="text-align:left">字段是否为由编译器自动产生</td></tr><tr><td style="text-align:left">ACC_ENUM</td><td style="text-align:left">0x4000</td><td style="text-align:left">字段是否为 enum</td></tr></tbody></table><h4 id="ii-描述符索引"><a class="markdownIt-Anchor" href="#ii-描述符索引"></a> Ⅱ. 描述符索引</h4><p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p><table><thead><tr><th style="text-align:left">标志符</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">B</td><td style="text-align:left">基本数据类型 byte</td></tr><tr><td style="text-align:left">C</td><td style="text-align:left">基本数据类型 char</td></tr><tr><td style="text-align:left">D</td><td style="text-align:left">基本数据类型 double</td></tr><tr><td style="text-align:left">F</td><td style="text-align:left">基本数据类型 float</td></tr><tr><td style="text-align:left">I</td><td style="text-align:left">基本数据类型 int</td></tr><tr><td style="text-align:left">J</td><td style="text-align:left">基本数据类型 long</td></tr><tr><td style="text-align:left">S</td><td style="text-align:left">基本数据类型 short</td></tr><tr><td style="text-align:left">Z</td><td style="text-align:left">基本数据类型 boolean</td></tr><tr><td style="text-align:left">V</td><td style="text-align:left">代表 void 类型</td></tr><tr><td style="text-align:left">L</td><td style="text-align:left">对象类型，比如：<code>Ljava/lang/Object;</code></td></tr><tr><td style="text-align:left">[</td><td style="text-align:left">数组类型，代表一维数组。比如：`double[][][] is [[[D</td></tr></tbody></table><h4 id="iii-属性表集合"><a class="markdownIt-Anchor" href="#iii-属性表集合"></a> Ⅲ. 属性表集合</h4><p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以常量属性为例，结构为：</span></span><br><span class="line">ConstantValue_attribute{</span><br><span class="line">u2 attribute_name_index;</span><br><span class="line">u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>说明：对于常量属性而言，attribute_length 值恒为 2。</p><h2 id="19-方法表集合"><a class="markdownIt-Anchor" href="#19-方法表集合"></a> 1.9. 方法表集合</h2><p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p><ul><li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li><li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li><li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法&lt;clinit&gt;()和实例初始化方法&lt;init&gt;()）。</li></ul><p><strong>使用注意事项：</strong></p><p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法<strong>具有相同的简单名称</strong>之外，还要求<strong>必须拥有一个与原方法不同的特征签名</strong>，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p><p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p><h3 id="191-方法计数器"><a class="markdownIt-Anchor" href="#191-方法计数器"></a> 1.9.1. 方法计数器</h3><p><strong>methods_count（方法计数器）</strong></p><p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p><p>methods 表中每个成员都是一个 method_info 结构。</p><h3 id="192-方法表"><a class="markdownIt-Anchor" href="#192-方法表"></a> 1.9.2. 方法表</h3><p><strong>methods[]（方法表）</strong></p><p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p><p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p><p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th><th style="text-align:left">数量</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">access_flags</td><td style="text-align:left">访问标志</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">name_index</td><td style="text-align:left">方法名索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">descriptor_index</td><td style="text-align:left">描述符索引</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">属性计数器</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">属性集合</td><td style="text-align:left">attributes_count</td></tr></tbody></table><p><strong>方法表访问标志</strong></p><p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p><table><thead><tr><th style="text-align:left">标志名称</th><th style="text-align:left">标志值</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">ACC_PUBLIC</td><td style="text-align:left">0x0001</td><td style="text-align:left">public，方法可以从包外访问</td></tr><tr><td style="text-align:left">ACC_PRIVATE</td><td style="text-align:left">0x0002</td><td style="text-align:left">private，方法只能本类访问</td></tr><tr><td style="text-align:left">ACC_PROTECTED</td><td style="text-align:left">0x0004</td><td style="text-align:left">protected，方法在自身和子类可以访问</td></tr><tr><td style="text-align:left">ACC_STATIC</td><td style="text-align:left">0x0008</td><td style="text-align:left">static，静态方法</td></tr></tbody></table><h2 id="110-属性表集合"><a class="markdownIt-Anchor" href="#110-属性表集合"></a> 1.10. 属性表集合</h2><p>方法表集合之后的属性表集合，<mark>指的是 class 文件所携带的辅助信息</mark>，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<mark>一般无须深入了解</mark>。</p><p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p><p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="1101-属性计数器"><a class="markdownIt-Anchor" href="#1101-属性计数器"></a> 1.10.1. 属性计数器</h3><p><strong>attributes_count（属性计数器）</strong></p><p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p><h3 id="1102-属性表"><a class="markdownIt-Anchor" href="#1102-属性表"></a> 1.10.2. 属性表</h3><p><strong>attributes[]（属性表）</strong></p><p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p><p><strong>属性的通用格式</strong></p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">attribute_name_index</td><td style="text-align:left">1</td><td style="text-align:left">属性名索引</td></tr><tr><td style="text-align:left">u4</td><td style="text-align:left">attribute_length</td><td style="text-align:left">1</td><td style="text-align:left">属性长度</td></tr><tr><td style="text-align:left">u1</td><td style="text-align:left">info</td><td style="text-align:left">attribute_length</td><td style="text-align:left">属性表</td></tr></tbody></table><p><strong>属性类型</strong></p><p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p><table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">使用位置</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">Code</td><td style="text-align:left">方法表</td><td style="text-align:left">Java 代码编译成的字节码指令</td></tr><tr><td style="text-align:left">ConstantValue</td><td style="text-align:left">字段表</td><td style="text-align:left">final 关键字定义的常量池</td></tr><tr><td style="text-align:left">Deprecated</td><td style="text-align:left">类，方法，字段表</td><td style="text-align:left">被声明为 deprecated 的方法和字段</td></tr><tr><td style="text-align:left">Exceptions</td><td style="text-align:left">方法表</td><td style="text-align:left">方法抛出的异常</td></tr><tr><td style="text-align:left">EnclosingMethod</td><td style="text-align:left">类文件</td><td style="text-align:left">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td></tr><tr><td style="text-align:left">InnerClass</td><td style="text-align:left">类文件</td><td style="text-align:left">内部类列表</td></tr><tr><td style="text-align:left">LineNumberTable</td><td style="text-align:left">Code 属性</td><td style="text-align:left">Java 源码的行号与字节码指令的对应关系</td></tr><tr><td style="text-align:left">LocalVariableTable</td><td style="text-align:left">Code 属性</td><td style="text-align:left">方法的局部变量描述</td></tr><tr><td style="text-align:left">StackMapTable</td><td style="text-align:left">Code 属性</td><td style="text-align:left">JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td></tr><tr><td style="text-align:left">Signature</td><td style="text-align:left">类，方法表，字段表</td><td style="text-align:left">用于支持泛型情况下的方法签名</td></tr><tr><td style="text-align:left">SourceFile</td><td style="text-align:left">类文件</td><td style="text-align:left">记录源文件名称</td></tr><tr><td style="text-align:left">SourceDebugExtension</td><td style="text-align:left">类文件</td><td style="text-align:left">用于存储额外的调试信息</td></tr><tr><td style="text-align:left">Synthetic</td><td style="text-align:left">类，方法表，字段表</td><td style="text-align:left">标志方法或字段为编译器自动生成的</td></tr><tr><td style="text-align:left">LocalVariableTypeTable</td><td style="text-align:left">类</td><td style="text-align:left">是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td></tr><tr><td style="text-align:left">RuntimeVisibleAnnotations</td><td style="text-align:left">类，方法表，字段表</td><td style="text-align:left">为动态注解提供支持</td></tr><tr><td style="text-align:left">RuntimeInvisibleAnnotations</td><td style="text-align:left">类，方法表，字段表</td><td style="text-align:left">用于指明哪些注解是运行时不可见的</td></tr><tr><td style="text-align:left">RuntimeVisibleParameterAnnotation</td><td style="text-align:left">方法表</td><td style="text-align:left">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td style="text-align:left">RuntimeInvisibleParameterAnnotation</td><td style="text-align:left">方法表</td><td style="text-align:left">作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td></tr><tr><td style="text-align:left">AnnotationDefault</td><td style="text-align:left">方法表</td><td style="text-align:left">用于记录注解类元素的默认值</td></tr><tr><td style="text-align:left">BootstrapMethods</td><td style="text-align:left">类文件</td><td style="text-align:left">用于保存 invokeddynamic 指令引用的引导方法限定符</td></tr></tbody></table><p>或者（查看官网）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/412a7e52bfb1ee0aa8229db1402ae58a.png" alt="image-20210421235232911"></p><p><strong>部分属性详解</strong></p><p><strong>① ConstantValue 属性</strong></p><p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute{</span><br><span class="line">u2 attribute_name_index;</span><br><span class="line">u4 attribute_length;</span><br><span class="line">u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>② Deprecated 属性</strong></p><p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute{</span><br><span class="line">u2 attribute_name_index;</span><br><span class="line">u4 attribute_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>③ Code 属性</strong></p><p>Code 属性就是存放<strong>方法体里面的代码</strong>。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">attribute_name_index</td><td style="text-align:left">1</td><td style="text-align:left">属性名索引</td></tr><tr><td style="text-align:left">u4</td><td style="text-align:left">attribute_length</td><td style="text-align:left">1</td><td style="text-align:left">属性长度</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">max_stack</td><td style="text-align:left">1</td><td style="text-align:left">操作数栈深度的最大值</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">max_locals</td><td style="text-align:left">1</td><td style="text-align:left">局部变量表所需的存续空间</td></tr><tr><td style="text-align:left">u4</td><td style="text-align:left">code_length</td><td style="text-align:left">1</td><td style="text-align:left">字节码指令的长度</td></tr><tr><td style="text-align:left">u1</td><td style="text-align:left">code</td><td style="text-align:left">code_lenth</td><td style="text-align:left">存储字节码指令</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">exception_table_length</td><td style="text-align:left">1</td><td style="text-align:left">异常表长度</td></tr><tr><td style="text-align:left">exception_info</td><td style="text-align:left">exception_table</td><td style="text-align:left">exception_length</td><td style="text-align:left">异常表</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">attributes_count</td><td style="text-align:left">1</td><td style="text-align:left">属性集合计数器</td></tr><tr><td style="text-align:left">attribute_info</td><td style="text-align:left">attributes</td><td style="text-align:left">attributes_count</td><td style="text-align:left">属性集合</td></tr></tbody></table><p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p><p><strong>④ InnerClasses 属性</strong></p><p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p><p><strong>⑤ LineNumberTable 属性</strong></p><p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p><p>LineNumberTable 属性是<mark>用来描述 <strong>Java 源码行号 与 字节码行号</strong>之间的对应关系</mark>。这个属性可以用来在调试的时候定位代码执行的行数。</p><ul><li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li></ul><p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LineNumberTable属性表结构：</span></span><br><span class="line">LineNumberTable_attribute{</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    {</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    } line_number_table[line_number_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>⑥ LocalVariableTable 属性</strong></p><p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p><ul><li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li><li>index 就是这个变量在局部变量表中的槽位<mark>（槽位可复用）</mark></li><li>name 就是变量名</li><li>Descriptor 表示局部变量类型描述</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalVariableTable属性表结构：</span></span><br><span class="line">LocalVariableTable_attribute{</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    {</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    } local_variable_table[local_variable_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20230108220200811.png" alt="image-20230108220200811"></p><p><strong>⑦ Signature 属性</strong></p><p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p><p><strong>⑧ SourceFile 属性</strong></p><p>SourceFile 属性结构</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">名称</th><th style="text-align:left">数量</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">u2</td><td style="text-align:left">attribute_name_index</td><td style="text-align:left">1</td><td style="text-align:left">属性名索引</td></tr><tr><td style="text-align:left">u4</td><td style="text-align:left">attribute_length</td><td style="text-align:left">1</td><td style="text-align:left">属性长度</td></tr><tr><td style="text-align:left">u2</td><td style="text-align:left">sourcefile index</td><td style="text-align:left">1</td><td style="text-align:left">源码文件素引</td></tr></tbody></table><p>可以看到，其长度总是固定的 8 个字节。</p><p><strong>⑨ 其他属性</strong></p><p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p><h2 id="class文件结构小结"><a class="markdownIt-Anchor" href="#class文件结构小结"></a> Class文件结构小结</h2><p><img src="../../../images/image-20230109103959417.png" alt="image-20230109103959417"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> JVM中篇：字节码与类的加载器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> JVM中篇：字节码与类的加载器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz学习笔记</title>
      <link href="/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="../../images/image-20221127205106372.png" alt="image-20221127205106372"></p><p><img src="../../images/image-20221127213810488.png" alt="image-20221127213810488"></p><p><img src="../../images/image-20221128143023074.png" alt="image-20221128143023074"></p><p><img src="../../images/image-20221128130326946.png" alt="image-20221128130326946"></p><p><img src="../../images/image-20221128142414350.png" alt="image-20221128142414350"></p><p><img src="../../images/image-20221128142313901.png" alt="image-20221128142313901"></p><p>quartz 总体架构</p><p><img src="../../images/image-20221127223745383.png" alt="image-20221127223745383"></p><h2 id="quartz的使用"><a class="markdownIt-Anchor" href="#quartz的使用"></a> Quartz的使用</h2><p>导包</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        System.out.println(<span class="string">"MyJob execute:"</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果图</p><p><img src="../../images/image-20221127225021946.png" alt="image-20221127225021946"></p><hr><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobDataMap;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class MyJop implements Job {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span><br><span class="line">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException {</span><br><span class="line">//        System.out.println("MyJob execute:" + new Date());</span><br><span class="line"></span><br><span class="line">        JobDataMap jobDetailMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">        JobDataMap triggerMap = context.getTrigger().getJobDataMap();</span><br><span class="line">        // 获取 JobDetail 和 Trigger 合并，但如果存在相同的键值key,Trigger的会覆盖JobDetail的</span><br><span class="line">        JobDataMap mergeMap = context.getMergedJobDataMap();</span><br><span class="line"></span><br><span class="line">        System.out.println("jobDetailMap:" + jobDetailMap.getString("job"));</span><br><span class="line">        System.out.println("triggerMap:" + triggerMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("job"));</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println( "name : " + name );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package quartz.quartz;</span><br><span class="line"></span><br><span class="line">import org.quartz.*;</span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class TestJob {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJop.class)</span><br><span class="line">                // name: 任务名称（在调度器里不能重复，唯一的） group : 组</span><br><span class="line">                .withIdentity("jop1", "group1")</span><br><span class="line">                .usingJobData("job", "jobDetail1")</span><br><span class="line">                .usingJobData("name", "jobDetail2")</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 触发器</span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity("trigger1", "trigger1")</span><br><span class="line">                .usingJobData("trigger", "trigger")</span><br><span class="line">                // 会覆盖上面JobDetail中的name的值</span><br><span class="line">                .usingJobData("name", "trigger2")</span><br><span class="line">                .startNow()</span><br><span class="line">                //                                                            时间间隔           永久重复执行</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 调度器</span><br><span class="line">        try {</span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            // 启动</span><br><span class="line">            scheduler.start();</span><br><span class="line">        } catch (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果</p><p><img src="../../images/image-20221128103703359.png" alt="image-20221128103703359"></p><hr><h2 id="job-封装成jobdetail设置属性"><a class="markdownIt-Anchor" href="#job-封装成jobdetail设置属性"></a> Job : 封装成JobDetail设置属性</h2><p><img src="../../images/image-20221128132915669.png" alt="image-20221128132915669"></p><p><img src="../../images/image-20221128104234972.png" alt="image-20221128104234972"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span></span><br><span class="line"><span class="comment">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会发现，不加注解的情况下（@DisallowConcurrentExecution）</span></span><br><span class="line">        <span class="comment">// 下面的输出都是不一样的，证明不是同一个 Job 实例</span></span><br><span class="line">        System.out.println( <span class="string">"jobDetail : "</span> + System.identityHashCode(context.getJobDetail()) );</span><br><span class="line">        System.out.println( <span class="string">"job : "</span> + System.identityHashCode(context.getJobInstance()) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不加上注解的话（@DisallowConcurrentExecution），</span></span><br><span class="line">        <span class="comment">// 我们想着是每隔次启动 job 实例之后等待sleep 3秒 之后再重复启动的</span></span><br><span class="line">        <span class="comment">// 但是实际发现，每隔一秒就又有启动了，证明不是同一个job实例，所以它们之间的启动不需要等待sleep的时间</span></span><br><span class="line">        System.out.println(<span class="string">"execute : "</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="../../images/image-20221128110013728.png" alt="image-20221128110013728"></p><hr><p>测试count++</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">triggerMap</span> <span class="operator">=</span> context.getTrigger().getJobDataMap();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDetailMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();</span><br><span class="line">        triggerMap.put(<span class="string">"count"</span>, triggerMap.getInt(<span class="string">"count"</span>) + <span class="number">1</span>);</span><br><span class="line">        jobDetailMap.put(<span class="string">"count1"</span>, jobDetailMap.getInt(<span class="string">"count1"</span>) + <span class="number">1</span>);</span><br><span class="line">        System.out.println( <span class="string">"triggerMap count : "</span> + triggerMap.getInt(<span class="string">"count"</span>) );</span><br><span class="line">        System.out.println( <span class="string">"jobDetailMap count : "</span> + jobDetailMap.getInt(<span class="string">"count1"</span>) );</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"job"</span>, <span class="string">"jobDetail1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"jobDetail2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count1"</span>, <span class="number">0</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"trigger"</span>, <span class="string">"trigger"</span>)</span><br><span class="line">                <span class="comment">// 会覆盖上面JobDetail中的name的值</span></span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"trigger2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count"</span>, count)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果图：</p><p><img src="../../images/image-20221128132552340.png" alt="image-20221128132552340"></p><p>Springboot整合Quartz</p><p><img src="../../images/image-20221128143743504.png" alt="image-20221128143743504"></p><p>Springboot整合Quartz</p><p>使用Springboot里面的监听器，让项目在启动后也启动了调度器</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(context.getScheduler().getSchedulerInstanceId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"taskname : "</span> + context.getJobDetail().getKey().getName() );</span><br><span class="line">            System.out.println(<span class="string">"执行时间 ："</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            scheduler1 = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> scheduler1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> quartz.bootquartz.QuartzJob;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="type">TriggerKey</span> <span class="variable">triggerKey</span> <span class="operator">=</span> TriggerKey.triggerKey(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> scheduler.getTrigger(triggerKey);</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="literal">null</span>) {</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(triggerKey)</span><br><span class="line">                        .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ?"</span>))</span><br><span class="line">                        .startNow()</span><br><span class="line">                        .build();</span><br><span class="line">                <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(QuartzJob.class)</span><br><span class="line">                        .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">                scheduler.start();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="../../images/image-20221128152834236.png" alt="image-20221128152834236"></p><p><img src="../../images/image-20221217151142631.png" alt="image-20221217151142631"></p>]]></content>
      
      
      <categories>
          
          <category> 定时任务 </category>
          
          <category> Quartz </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Quartz </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13. 垃圾回收器</title>
      <link href="/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
      <url>/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="13-垃圾回收器"><a class="markdownIt-Anchor" href="#13-垃圾回收器"></a> 13. 垃圾回收器</h1><h2 id="131-gc-分类与性能指标"><a class="markdownIt-Anchor" href="#131-gc-分类与性能指标"></a> 13.1. GC 分类与性能指标</h2><h3 id="1311-垃圾回收器概述"><a class="markdownIt-Anchor" href="#1311-垃圾回收器概述"></a> 13.1.1. 垃圾回收器概述</h3><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p><p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p><p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p><h3 id="1312-垃圾收集器分类"><a class="markdownIt-Anchor" href="#1312-垃圾收集器分类"></a> 13.1.2. 垃圾收集器分类</h3><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ab10d1899d353ea14797f9ce1778503c.png" alt="image-20210512144253383"></p><p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p><ul><li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li><li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li></ul><p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p><p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p><ul><li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li><li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/6e2c2869a4450dc405bda0ea8a8e7c31.png" alt="image-20200713083443486"></p><p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p><ul><li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li><li>非压缩式的垃圾回收器不进行这步操作。</li></ul><p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p><h3 id="1313-评估-gc-的性能指标"><a class="markdownIt-Anchor" href="#1313-评估-gc-的性能指标"></a> 13.1.3. 评估 GC 的性能指标</h3><p>（加粗的是比较重要的）</p><ul><li><strong><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</strong></li><li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li><li><strong><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li><li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li><li><strong><mark>内存占用</mark>：Java 堆区所占的内存大小。</strong></li><li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li></ul><p><strong>吞吐量、暂停时间、内存占用</strong> 这三者共同构成一个“<strong>不可能三角</strong>”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p><p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p><p>简单来说，主要抓住两点：吞吐量、暂停时间</p><h4 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h4><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p><p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p><p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a05d48c1926a03c3acdebf74d10bf522.png" alt="image-20200713084726176"></p><h4 id="暂停时间"><a class="markdownIt-Anchor" href="#暂停时间"></a> 暂停时间</h4><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p><p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p><p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p><p><img src="https://img-blog.csdnimg.cn/img_convert/de90092e21cbff31926f7cc7dceebf25.png" alt="image-20200713085306400"></p><h4 id="吞吐量-vs-暂停时间"><a class="markdownIt-Anchor" href="#吞吐量-vs-暂停时间"></a> 吞吐量 vs 暂停时间</h4><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p><p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p><p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p><ul><li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li><li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li></ul><p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p><p><strong>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></strong></p><h2 id="132-不同的垃圾回收器概述"><a class="markdownIt-Anchor" href="#132-不同的垃圾回收器概述"></a> 13.2. 不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p><h3 id="1321-垃圾回收器发展史"><a class="markdownIt-Anchor" href="#1321-垃圾回收器发展史"></a> 13.2.1. 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p><ul><li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li><li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li><li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li><li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li><li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li><li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li><li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li><li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li><li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li><li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li></ul><h3 id="1322-7-种经典的垃圾收集器"><a class="markdownIt-Anchor" href="#1322-7-种经典的垃圾收集器"></a> 13.2.2. 7 种经典的垃圾收集器</h3><ul><li>串行回收器：Serial、Serial Old</li><li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li><li>并发回收器：CMS、G1</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/90c3bcdc22cd0b49e10d702c608c4fc6.png" alt="image-20200713093551365"></p><p>官方手册：<a href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c529d76b22212c44275b94675cc56760.png" alt="image-20210512145950897"></p><h3 id="1323-7-款经典收集器与垃圾分代之间的关系"><a class="markdownIt-Anchor" href="#1323-7-款经典收集器与垃圾分代之间的关系"></a> 13.2.3. 7 款经典收集器与垃圾分代之间的关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/fd16701d3e150d5e58d52b7306473a42.png" alt="image-20200713093757644"></p><ul><li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p></li><li><p>老年代收集器：Serial Old、Parallel Old、CMS；</p></li><li><p>整堆收集器：G1；</p></li></ul><h3 id="1324-垃圾收集器的组合关系"><a class="markdownIt-Anchor" href="#1324-垃圾收集器的组合关系"></a> 13.2.4. 垃圾收集器的组合关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/b92c2212bea2907cb75ff9ef26f346fe.png" alt="image-20200713094745366"></p><ol><li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li><li>其中 Serial Old 作为 CMS 出现"<code>Concurrent Mode Failure</code>"失败的后备预案。</li><li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li><li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li><li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li></ol><h3 id="1325-不同的垃圾收集器概述"><a class="markdownIt-Anchor" href="#1325-不同的垃圾收集器概述"></a> 13.2.5. 不同的垃圾收集器概述</h3><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p><p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p><h3 id="1326-如何查看默认垃圾收集器"><a class="markdownIt-Anchor" href="#1326-如何查看默认垃圾收集器"></a> 13.2.6. 如何查看默认垃圾收集器</h3><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p><p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p><h2 id="133-serial-回收器串行回收"><a class="markdownIt-Anchor" href="#133-serial-回收器串行回收"></a> 13.3. Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p><p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p><p><mark>Serial 收集器采用复制算法、串行回收和"stop-the-World"机制的方式执行内存回收。</mark></p><p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和"Stop the World"机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p><ul><li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li><li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d66b612e68381df2101c3e829a18b4f0.png" alt="image-20200713100703799"></p><p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p><p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p><p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p><p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p><p><strong>总结</strong></p><p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p><p>对于交互较强的应用而言，这种垃圾收集器是不能接受的（因为它是串行的，导致用户完全停止了，容易影响用户交互）。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p><h2 id="134-parnew-回收器并行回收"><a class="markdownIt-Anchor" href="#134-parnew-回收器并行回收"></a> 13.4. ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p><p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、"Stop-the-World"机制</mark>。</p><p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/187fdcd46a1cb35be6d88a01a433c0f3.png" alt="image-20200713102030127"></p><ul><li>对于新生代，回收次数频繁，使用并行方式高效。</li><li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li></ul><p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p><ul><li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li><li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li></ul><p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p><p>在程序中，开发人员可以通过选项"<code>-XX:+UseParNewGC</code>"手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p><p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p><h2 id="135-parallel-回收器吞吐量优先"><a class="markdownIt-Anchor" href="#135-parallel-回收器吞吐量优先"></a> 13.5. Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和"Stop the World"机制</mark>。</p><p>那么 Parallel 收集器的出现是否多此一举？</p><ul><li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li><li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li></ul><p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p><p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p><p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和"Stop-the-World"机制</mark>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8a4b655ee277aaf0f9a46754248ce05a.png" alt="image-20200713110359441"></p><p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p><p><strong>参数配置</strong></p><ul><li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p></li><li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p><ul><li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li><li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li></ul></li><li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p><p class="katex-block katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \* at position 80: …= 8) \\ 3 + (5 \̲*̲ CPU＿Count / 8)…">ParallelGCThreads = \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;= 8) \\ 3 + (5 \* CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8) \end{cases} </p></li><li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p><ul><li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li><li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li><li><mark>该参数使用需谨慎</mark>。</li></ul></li><li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p><ul><li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li><li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li></ul></li><li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p><ul><li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li><li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li></ul></li></ul><h2 id="136-cms-回收器低延迟"><a class="markdownIt-Anchor" href="#136-cms-回收器低延迟"></a> 13.6. CMS 回收器：低延迟</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p><p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p><ul><li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li></ul><p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会"Stop-the-World"</p><p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p><p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f84a132db8c56a488e14f51e2c4d7fa7.png" alt="image-20200713205154007"></p><p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p><ul><li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li><li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。</li><li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li><li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<mark>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</mark>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li></ul><p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p><p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p><p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p><p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/052d6ef7655e46e040729082ac36da30.png" alt="image-20200713212230352"></p><p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p><p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p><h3 id="1361-cms-的优点"><a class="markdownIt-Anchor" href="#1361-cms-的优点"></a> 13.6.1. CMS 的优点</h3><ul><li>并发收集</li><li>低延迟</li></ul><h3 id="1362-cms-的弊端"><a class="markdownIt-Anchor" href="#1362-cms-的弊端"></a> 13.6.2. CMS 的弊端</h3><ul><li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC（如果来一次业务高峰，导致提前触发Full GC，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，而单线程的垃圾回收器Serial OId，是性能最差的一个，停顿可能是几秒钟甚至十几秒钟，业务高峰时，停顿时间就很长了，给用户的体验就是很卡）。</li><li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li><li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>"失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li></ul><h3 id="1363-设置的参数"><a class="markdownIt-Anchor" href="#1363-设置的参数"></a> 13.6.3. 设置的参数</h3><ul><li><p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p><p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p></li><li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p><ul><li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li><li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li></ul></li><li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p></li><li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p></li><li><p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p><ul><li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li></ul></li></ul><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p><p>请记住以下口令：</p><ul><li>如果你想要最小化地 使用内存和并行开销，请选 Serial GC；</li><li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li><li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li></ul><h3 id="1364-jdk-后续版本中-cms-的变化"><a class="markdownIt-Anchor" href="#1364-jdk-后续版本中-cms-的变化"></a> 13.6.4. JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p><ul><li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li></ul><p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p><ul><li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li></ul><h2 id="137-g1-回收器区域化分代式"><a class="markdownIt-Anchor" href="#137-g1-回收器区域化分代式"></a> 13.7. G1 回收器：区域化分代式</h2><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p><p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而<strong>经常造成 STW 的 GC 又跟不上实际的需求</strong>，所以才会<strong>不断地尝试对 GC 进行优化</strong>。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p><p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p><p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p><p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p><p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p><p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p><p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p><p>在 JDK1.7 版本正式启用，移除了 Experimental 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p><p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p><h3 id="1371-g1-回收器的特点优势"><a class="markdownIt-Anchor" href="#1371-g1-回收器的特点优势"></a> 13.7.1. G1 回收器的特点（优势）</h3><p>与其他 GC 收集器相比，G1 使用了全新的<strong>分区算法</strong>，其特点如下所示：</p><h4 id="并行与并发"><a class="markdownIt-Anchor" href="#并行与并发"></a> 并行与并发</h4><ul><li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li><li>并发性：G1 拥有与应用程序<strong>交替执行</strong>的能力（就不用考虑STW了），部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li></ul><h4 id="分代收集"><a class="markdownIt-Anchor" href="#分代收集"></a> 分代收集</h4><ul><li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li><li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li><li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/9a71df3a4013da274aa3b28cd95e7d37.png" alt="image-20200713215105293"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8bcd36541731eb308043eba968b7a828.png" alt="image-20200713215133839"></p><h4 id="空间整合"><a class="markdownIt-Anchor" href="#空间整合"></a> 空间整合</h4><ul><li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li><li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li></ul><h4 id="可预测的停顿时间模型即软实时-soft-real-time"><a class="markdownIt-Anchor" href="#可预测的停顿时间模型即软实时-soft-real-time"></a> 可预测的停顿时间模型（即：软实时 soft real-time）</h4><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p><ul><li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li><li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li><li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li></ul><h3 id="1372-g1-垃圾收集器的缺点"><a class="markdownIt-Anchor" href="#1372-g1-垃圾收集器的缺点"></a> 13.7.2. G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p><p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p><h3 id="1373-g1-回收器的参数设置"><a class="markdownIt-Anchor" href="#1373-g1-回收器的参数设置"></a> 13.7.3. G1 回收器的参数设置</h3><ul><li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li><li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li><li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了）</li><li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li><li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li><li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li></ul><h3 id="1374-g1-收集器的常见操作步骤"><a class="markdownIt-Anchor" href="#1374-g1-收集器的常见操作步骤"></a> 13.7.4. G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p><ul><li>第一步：开启 G1 垃圾收集器</li><li>第二步：设置堆的最大内存</li><li>第三步：设置最大的停顿时间</li></ul><p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p><h3 id="1375-g1-收集器的适用场景"><a class="markdownIt-Anchor" href="#1375-g1-收集器的适用场景"></a> 13.7.5. G1 收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p><p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p><p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p><ul><li>超过 50%的 Java 堆被活动数据占用；</li><li>对象分配频率或年代提升频率变化很大；</li><li>GC 停顿时间过长（长于 0.5 至 1 秒）</li></ul><p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p><h3 id="1376-分区-region化整为零"><a class="markdownIt-Anchor" href="#1376-分区-region化整为零"></a> 13.7.6. 分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark><strong>所有的 Region 大小相同</strong>，且在 JVM 生命周期内不会被改变。</mark></p><p>（之所以要分代，就是要对堆内存进行局部清理，缩短停留提升回收效率。尽管分了代，对于新生代和老年代而言内存空间占用还是比较大，所以G1就使用了分区，通过更细的粒度来回收内存，以控制回收停留时间）</p><p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/74c611464ae6cdae3cbfffaef213cfd5.png" alt="image-20200713223244886"></p><p>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p><p>（region在整个jvm生命周期里的角色是可以转变的，比如说，当Eden区满的时候，触发YGC，YGC评判它价值比较高，就优先回收它了，回收完后，就一整个空白了，因为数据就会被提升复制到S幸存区了，就把Eden这区清空，那么这块空白的region就会被放到一个空闲列表中（专门用来记录这些空闲的region的），空闲之后，那么下一刻可能就会从这个空闲列表中将它选出来充当Old区了）</p><p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p><p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p><p>每个 Region 都是通过指针碰撞来分配空间</p><p><img src="https://img-blog.csdnimg.cn/img_convert/049520c5a004b63f750e04d5362a2992.png" alt="image-20200713223509993"></p><h3 id="1377-g1-垃圾回收器的回收过程"><a class="markdownIt-Anchor" href="#1377-g1-垃圾回收器的回收过程"></a> 13.7.7. G1 垃圾回收器的回收过程</h3><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p><ul><li><p>年轻代 GC（Young GC）</p></li><li><p>老年代并发标记过程（Concurrent Marking）</p></li><li><p>混合回收（Mixed GC）（涉及到新生代和老年代混合回收）</p><p>可能第四种情况：（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。情况如：（  <code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了））</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e8f79c3cdeb0969981703f7a026cf581.png" alt="image-20200713224113996"></p><p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p><p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p><p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p><p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p><p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p><h3 id="1378-remembered-set"><a class="markdownIt-Anchor" href="#1378-remembered-set"></a> 13.7.8. Remembered Set</h3><ul><li><p>一个对象被不同区域引用的问题</p></li><li><p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p></li><li><p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</p></li><li><p>这样的话会降低 MinorGC 的效率；</p></li></ul><p><strong>解决方法：</strong></p><ul><li><p>无论 G1 还是其他分代收集器，<strong>JVM 都是使用 Remembered Set 来避免全局扫描：</strong></p></li><li><p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p></li><li><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier （写屏障）暂时中断操作；</p></li><li><p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p></li><li><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p></li><li><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c97de4bdada1da5a9fdd344692ed0957.png" alt="image-20200713224716715"></p><h3 id="1379-g1-回收过程一年轻代-gc"><a class="markdownIt-Anchor" href="#1379-g1-回收过程一年轻代-gc"></a> 13.7.9. G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p><p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p><p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f29fa4dfe3abf4a77be06fdf3378aecf.png" alt="image-20200713225100632"></p><p>然后开始如下回收过程：</p><ol><li><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li><li><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</li><li><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li><li><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li><li><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li></ol><h3 id="13710-g1-回收过程二并发标记过程"><a class="markdownIt-Anchor" href="#13710-g1-回收过程二并发标记过程"></a> 13.7.10. G1 回收过程二：并发标记过程</h3><ol><li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li><li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成 。</li><li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li><li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li><li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li><li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li></ol><h3 id="13711-g1-回收过程三混合回收"><a class="markdownIt-Anchor" href="#13711-g1-回收过程三混合回收"></a> 13.7.11. G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 old region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/766b882cba7e709202005a3baeb596d0.png" alt="image-20200713225810871"></p><p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p><p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p><p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。<font color="blue">垃圾占内存分段比例越高的，越会被先回收</font>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p><p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p><h3 id="13712-g1-回收可选的过程四full-gc"><a class="markdownIt-Anchor" href="#13712-g1-回收可选的过程四full-gc"></a> 13.7.12. G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p><p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p><p>导致 G1 Full GC 的原因可能有两个：</p><ul><li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li><li>并发处理过程完成之前空间耗尽。</li></ul><h3 id="13713-补充"><a class="markdownIt-Anchor" href="#13713-补充"></a> 13.7.13. 补充</h3><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p><h3 id="13714-g1-回收器优化建议"><a class="markdownIt-Anchor" href="#13714-g1-回收器优化建议"></a> 13.7.14. G1 回收器优化建议</h3><p>年轻代大小</p><ul><li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li><li>固定年轻代的大小会覆盖暂停时间目标</li></ul><p>暂停时间目标不要太过严苛</p><ul><li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li><li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li></ul><h2 id="138-垃圾回收器总结"><a class="markdownIt-Anchor" href="#138-垃圾回收器总结"></a> 13.8. 垃圾回收器总结</h2><h3 id="1381-7-种经典垃圾回收器总结"><a class="markdownIt-Anchor" href="#1381-7-种经典垃圾回收器总结"></a> 13.8.1. 7 种经典垃圾回收器总结</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p><table><thead><tr><th style="text-align:left">垃圾收集器</th><th style="text-align:left">分类</th><th style="text-align:left">作用位置</th><th style="text-align:left">使用算法</th><th style="text-align:left">特点</th><th style="text-align:left">适用场景</th></tr></thead><tbody><tr><td style="text-align:left">Serial</td><td style="text-align:left">串行运行</td><td style="text-align:left">作用于新生代</td><td style="text-align:left">复制算法</td><td style="text-align:left">响应速度优先</td><td style="text-align:left">适用于单 CPU 环境下的 client 模式</td></tr><tr><td style="text-align:left">ParNew</td><td style="text-align:left">并行运行</td><td style="text-align:left">作用于新生代</td><td style="text-align:left">复制算法</td><td style="text-align:left">响应速度优先</td><td style="text-align:left">多 CPU 环境 Server 模式下与 CMS 配合使用</td></tr><tr><td style="text-align:left">Parallel</td><td style="text-align:left">并行运行</td><td style="text-align:left">作用于新生代</td><td style="text-align:left">复制算法</td><td style="text-align:left">吞吐量优先</td><td style="text-align:left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td style="text-align:left">Serial Old</td><td style="text-align:left">串行运行</td><td style="text-align:left">作用于老年代</td><td style="text-align:left">标记-压缩算法</td><td style="text-align:left">响应速度优先</td><td style="text-align:left">适用于单 CPU 环境下的 Client 模式</td></tr><tr><td style="text-align:left">Parallel Old</td><td style="text-align:left">并行运行</td><td style="text-align:left">作用于老年代</td><td style="text-align:left">标记-压缩算法</td><td style="text-align:left">吞吐量优先</td><td style="text-align:left">适用于后台运算而不需要太多交互的场景</td></tr><tr><td style="text-align:left">CMS</td><td style="text-align:left">并发运行</td><td style="text-align:left">作用于老年代</td><td style="text-align:left">标记-清除算法</td><td style="text-align:left">响应速度优先</td><td style="text-align:left">适用于互联网或 B／S 业务</td></tr><tr><td style="text-align:left">G1</td><td style="text-align:left">并发、并行运行</td><td style="text-align:left">作用于新生代、老年代</td><td style="text-align:left">标记-压缩算法、复制算法</td><td style="text-align:left">响应速度优先</td><td style="text-align:left">面向服务端应用</td></tr></tbody></table><p>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p><h3 id="1382-垃圾回收器组合"><a class="markdownIt-Anchor" href="#1382-垃圾回收器组合"></a> 13.8.2. 垃圾回收器组合</h3><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5e57edaa3ec7295424480c67daee499e.png" alt="image-20200714080151020"></p><ol><li><p>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p></li><li><p>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</p></li><li><p>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中</p></li></ol><p>完全取消了这些组合的支持（JEP214），即：移除。</p><ol start="4"><li><p>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</p></li><li><p>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</p></li></ol><h3 id="1383-怎么选择垃圾回收器"><a class="markdownIt-Anchor" href="#1383-怎么选择垃圾回收器"></a> 13.8.3. 怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p><p>怎么选择垃圾收集器？</p><ol><li><p>优先调整堆的大小让 JVM 自适应完成。</p></li><li><p>如果内存小于 100M，使用串行收集器</p></li><li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p></li><li><p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</p></li><li><p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</p><p>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</p></li></ol><p>最后需要明确一个观点：</p><ol><li>没有最好的收集器，更没有万能的收集</li><li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li></ol><p><strong>面试</strong></p><p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p><ul><li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p></li><li><p>垃圾收集器工作的基本流程。</p></li></ul><p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p><h2 id="139-gc-日志分析"><a class="markdownIt-Anchor" href="#139-gc-日志分析"></a> 13.9. GC 日志分析</h2><p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p><ul><li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li><li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li><li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li><li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li><li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li><li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li></ul><p>打开 GC 日志</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></tbody></table></figure><p>这个只会显示总的 GC 堆的变化，如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),<span class="number">0.0084018</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="number">0.0184066</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> 21465K-&gt;16716K(201728K),<span class="number">0.0619261</span> secs]</span><br></pre></td></tr></tbody></table></figure><p>参数解析</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。</span><br><span class="line">Allocation Failure：GC发生的原因。</span><br><span class="line">80832K-&gt;19298K：堆在GC前的大小和GC后的大小。</span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line"><span class="number">0.0084018</span> secs：GC持续的时间。</span><br></pre></td></tr></tbody></table></figure><p>打开 GC 日志</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure><p>输入信息如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="number">0.0172573</span> secs] [Times:user=<span class="number">0.03</span> sys=<span class="number">0.00</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="number">0.0151573</span> secs] [Times:user=<span class="number">0.00</span> sys=<span class="number">0.01</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0K(142336K)]</span><br><span class="line">[ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],<span class="number">0.0639732</span> secs]</span><br><span class="line">[Times:user=<span class="number">0.14</span> sys=<span class="number">0.00</span>,real=<span class="number">0.06</span> secs]</span><br></pre></td></tr></tbody></table></figure><p>参数解析</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GC，Full FC：同样是GC的类型</span><br><span class="line">Allocation Failure：GC原因</span><br><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代</span><br><span class="line">xxx secs：指GC花费的时间</span><br><span class="line">Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></tbody></table></figure><p>打开 GC 日志</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</span><br></pre></td></tr></tbody></table></figure><p>输入信息如下</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">24.518</span>+0800: <span class="number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="number">0.0248249</span> secs] [Times:user=<span class="number">0.05</span> sys=<span class="number">0.00</span>,real=<span class="number">0.03</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.559</span>+0800: <span class="number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="number">0.0094071</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>,real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.569</span>+0800: <span class="number">4.338</span>: [Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],<span class="number">0.0494875</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>,real=<span class="number">0.05</span> secs]</span><br></pre></td></tr></tbody></table></figure><p>说明：带上了日期和实践</p><p>如果想把 GC 日志存到文件的话，是下面的参数：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log</span><br></pre></td></tr></tbody></table></figure><p><strong>日志补充说明</strong></p><ul><li><p>“<code>[GC</code>"和”<code>[Full GC</code>"说明了这次垃圾收集的停顿类型，如果有"Full"则说明 GC 发生了"Stop The World"</p></li><li><p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是"<code>[DefNew</code>"</p></li><li><p>使用 ParNew 收集器在新生代的名字会变成"<code>[ParNew</code>"，意思是"Parallel New Generation"</p></li><li><p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>"</p></li><li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p></li><li><p>使用 G1 收集器的话，会显示为"garbage-first heap"</p></li><li><p><mark>Allocation Failure</mark></p><p>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p></li><li><p><mark>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</mark></p><p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p><p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p></li><li><p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heap（堆）</span><br><span class="line">PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"></span><br><span class="line">ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"></span><br><span class="line">PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line">object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="minor-gc-日志"><a class="markdownIt-Anchor" href="#minor-gc-日志"></a> Minor GC 日志</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/9364561fbb81a0e2f9aedc45a383972f.png" alt="image-20200714082555688"></p><h3 id="full-gc-日志"><a class="markdownIt-Anchor" href="#full-gc-日志"></a> Full GC 日志</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/502793e725122b958f2861932e5ef9c1.png" alt="image-20210512194815354"></p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> { </span><br><span class="line">    <span class="type">byte</span> [] allocation1, allocation2, allocation3, allocation4;  </span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {    </span><br><span class="line">    testAllocation();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>设置 JVM 参数</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure><p><strong>图示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/8dada6b73786eb693975593db10ce825.png" alt="image-20200714083332238"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/78f6489bd1a3b74e14ee4a95392df8c2.png" alt="image-20200714083526790"></p><p>（ jdk7是如上图分析所示。但是JDK8和JDK7不一样，大对象来的时候，发现新生代装不下，直接进入老年代 ）</p><p>可以用一些工具去分析这些 GC 日志</p><p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p><h2 id="13x-垃圾回收器的新发展"><a class="markdownIt-Anchor" href="#13x-垃圾回收器的新发展"></a> 13.X. 垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p><p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p><p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p><h3 id="13x1-jdk11-新特性"><a class="markdownIt-Anchor" href="#13x1-jdk11-新特性"></a> 13.X.1. JDK11 新特性</h3><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，"No-Op（无操作）"回收器）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p><p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4aaef244379d75ba838e10d4178b2960.png" alt="image-20210512195426194"></p><p>现在 G1 回收器已成为默认回收器好几年了。</p><p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p><p><img src="https://img-blog.csdnimg.cn/img_convert/00920e4ae2b2c80a8016e6d8f4632545.png" alt="image-20210512195528695"></p><h3 id="13x2-open-jdk12-的-shenandoash-gc"><a class="markdownIt-Anchor" href="#13x2-open-jdk12-的-shenandoash-gc"></a> 13.X.2. Open JDK12 的 Shenandoash GC</h3><p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p><p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p><p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p><p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/01f566c0db04f0e475db05addd94259f.png" alt="image-20200714090608807"></p><p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p><ul><li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li><li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li></ul><p>总结</p><ul><li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li><li>Shenandoah GC 的强项：低延迟时间。</li><li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li></ul><p>【Java12 新特性地址】</p><p><a href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a></p><p>或</p><p><a href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p><h3 id="13x3-令人震惊-革命性的-zgc"><a class="markdownIt-Anchor" href="#13x3-令人震惊-革命性的-zgc"></a> 13.X.3. 令人震惊、革命性的 ZGC</h3><p>官方地址：<a href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f78eebadbabf7450ded984f0f1e3a405.png" alt="image-20210512200236647"></p><p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p><p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p><p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p><p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p><p>测试数据：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b08828b548a255493e934c6fe3308e50.png" alt="image-20200714091201073"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4e648c4e37d84f5d83d965b55f6bc5f9.png" alt="image-20200714091401511"></p><p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p><p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p><p><img src="https://img-blog.csdnimg.cn/img_convert/59b014ca2eeda5332fd40a4a2356f883.png" alt="image-20200714093243028"></p><p><mark>JEP 364：ZGC 应用在 macos 上</mark></p><p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p><p>JDK14 之前，ZGC 仅 Linux 才支持。</p><p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p><p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></tbody></table></figure><h3 id="13x4-其他垃圾回收器aligc"><a class="markdownIt-Anchor" href="#13x4-其他垃圾回收器aligc"></a> 13.X.4. 其他垃圾回收器：AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/835fff5c3a7884de2a1d564b7f332900.png" alt="image-20200714093604012"></p><p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12. 垃圾回收相关概念</title>
      <link href="/2022/11/23/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
      <url>/2022/11/23/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="12-垃圾回收相关概念"><a class="markdownIt-Anchor" href="#12-垃圾回收相关概念"></a> 12. 垃圾回收相关概念</h1><h2 id="121-systemgc的理解"><a class="markdownIt-Anchor" href="#121-systemgc的理解"></a> 12.1. System.gc()的理解</h2><p>在默认情况下，通过 system.gc()或者 Runtime.getRuntime().gc() 的调用，<mark>会显式触发 Full GC</mark>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p><p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p><p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，<mark>无须手动触发，否则就太过于麻烦了</mark>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样，因为System.gc()底层就是它</span></span><br><span class="line"></span><br><span class="line">        System.runFinalization(); <span class="comment">// 强制执行使用引用的对象的finalize()方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"SystemGCTest 重写了finalize()"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面的代码例子，</p><p>不加上System.runFinalization();，运行时，不是每次都会输出"SystemGCTest 重写了finalize()"，证明System.gc()只是提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</p><p>加上<strong>System.runFinalization()</strong>;，就会每次都输出"SystemGCTest 重写了finalize()"，因为它<strong>强制执行</strong>使用引用的对象的finalize()方法</p><h2 id="122-内存溢出与内存泄露"><a class="markdownIt-Anchor" href="#122-内存溢出与内存泄露"></a> 12.2. 内存溢出与内存泄露</h2><h3 id="内存溢出oom"><a class="markdownIt-Anchor" href="#内存溢出oom"></a> 内存溢出（OOM）</h3><ul><li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p></li><li><p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 ooM 的情况。</p></li><li><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p></li><li><p>javadoc 中对 OutOfMemoryError 的解释是，<mark>没有空闲内存，并且垃圾收集器也无法提供更多内存</mark>。</p></li></ul><p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p><ol><li><p><mark>Java 虚拟机的堆内存设置不够。</mark></p><p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整。</p></li><li><p><mark>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</mark></p><p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>"。</p><p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 ooM 有所改观，出现 OOM，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>"。直接内存不足，也会导致 OOM。</p></li></ol><p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p><ul><li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li><li>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li></ul><p>当然，也不是在任何情况下垃圾收集器都会被触发的</p><ul><li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</li></ul><h3 id="内存泄漏memory-leak"><a class="markdownIt-Anchor" href="#内存泄漏memory-leak"></a> 内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，<mark><strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</strong></mark>。</p><p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做<mark>宽泛意义上的“内存泄漏”</mark>。详说如下：</p><p>（一个类里面的方法，把一个变量定义到方法内，作为一个局部变量，那么这个变量出了这个方法它就被回收了。但是你把它定义成成员变量了，生命周期就会长一些，甚至还把这个成员变量定义成了 static ，那么这个静态变量的变量或是类变量就会随着类的加载而加载，随着类的消亡而消亡，这个变量的生命周期就会非常长。如果程序当中出现大量的生命周期很长的对象的时候，加上那些没办法回收的数据的存在，最后导致 OOM 。所以我们把那些生命周期本很长的对象，本来没必要那么长而我们又申明了那么长的对象，也可以理解为<strong>宽泛意义的“内存泄露”</strong>）</p><p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p><p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p><p><img src="../../../images/image-20221123174631209.png" alt="image-20221123174631209"></p><p><strong>举例</strong></p><ol><li><p>单例模式</p><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p></li><li><p>一些提供 close 的资源未关闭导致内存泄漏</p><p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p></li></ol><h2 id="123-stop-the-world"><a class="markdownIt-Anchor" href="#123-stop-the-world"></a> 12.3. Stop The World</h2><p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<mark>停顿产生时整个应用程序线程都会被暂停，没有任何响应</mark>，有点像卡死的感觉，这个停顿称为 STW。</p><p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p><ul><li>分析工作必须在一个能确保一致性的快照中进行</li><li><strong>一致性</strong>指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li><li><mark>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</mark></li></ul><p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p><p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p><p>哪怕是 G1 也不能完全避免 Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p><p>STW 是 JVM 在<mark>后台自动发起和自动完成</mark>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p><p>开发中不要用 System.gc()，否则 会导致 Stop-the-World 的发生。</p><h2 id="124-垃圾回收的并行与并发"><a class="markdownIt-Anchor" href="#124-垃圾回收的并行与并发"></a> 12.4. 垃圾回收的并行与并发</h2><h3 id="并发concurrent"><a class="markdownIt-Anchor" href="#并发concurrent"></a> 并发（Concurrent）</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p><p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5e4a10263a26cb7aa87f1a6615b5b833.png" alt="image-20200712202522051"></p><h3 id="并行parallel"><a class="markdownIt-Anchor" href="#并行parallel"></a> 并行（Parallel）</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p><p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p><p>适合科学计算，后台处理等弱交互场景</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7ea1ebdd0fd0bc3a27c0d745c9bcdff7.png" alt="image-20200712202822129"></p><h3 id="并发-vs-并行"><a class="markdownIt-Anchor" href="#并发-vs-并行"></a> 并发 vs 并行</h3><ul><li><p>并发，指的是多个事情，在<mark>同一时间段内</mark>同时发生了。</p></li><li><p>并行，指的是多个事情，在<mark>同一时间点上</mark>同时发生了。</p></li><li><p>并发的多个任务之间是互相抢占资源的。</p></li><li><p>并行的多个任务之间是不互相抢占资源的。</p></li><li><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p></li><li><p>否则，看似同时发生的事情，其实都是并发执行的。</p></li></ul><h3 id="垃圾回收的并发与并行"><a class="markdownIt-Anchor" href="#垃圾回收的并发与并行"></a> 垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p><h4 id="并行parallel-2"><a class="markdownIt-Anchor" href="#并行parallel-2"></a> 并行（Parallel）</h4><p>指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p><h4 id="串行serial"><a class="markdownIt-Anchor" href="#串行serial"></a> 串行（Serial）</h4><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动 JM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fd2b4f4ece3976fbd73c1039666cf7d7.png" alt="image-20210512112822896"></p><h4 id="并发concurrent-2"><a class="markdownIt-Anchor" href="#并发concurrent-2"></a> 并发（Concurrent）</h4><p>指<mark>用户线程与垃圾收集线程同时执行</mark>（但不一定是并行的，可能会交替执行），<mark>垃圾回收线程在执行时不会停顿用户程序的运行</mark>。用户程序在继续运行，而垃圾收集程序线程运行于<strong>另一个 CPU 上</strong>；如：CMS、G1</p><p><img src="https://img-blog.csdnimg.cn/img_convert/48a4190f4d2ff4b7c8963a75ba2e6182.png" alt="image-20200712203815517"></p><h2 id="125-安全点与安全区域"><a class="markdownIt-Anchor" href="#125-安全点与安全区域"></a> 12.5. 安全点与安全区域</h2><h3 id="安全点"><a class="markdownIt-Anchor" href="#安全点"></a> 安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（Safepoint）”。</p><p>Safe Point 的选择很重要，<mark>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题</mark>。大部分指令的执行时间都非常短暂，通常会根据“<mark>是否具有让程序长时间执行的特征</mark>”为标准。比如：选择一些<strong>执行时间较长</strong>的指令作为 Safe Point，如<mark>方法调用、循环跳转和异常跳转等</mark>。</p><p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p><h4 id="抢先式中断目前没有虚拟机采用了"><a class="markdownIt-Anchor" href="#抢先式中断目前没有虚拟机采用了"></a> 抢先式中断：（目前没有虚拟机采用了）</h4><ul><li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\</li></ul><h4 id="主动式中断"><a class="markdownIt-Anchor" href="#主动式中断"></a> 主动式中断</h4><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p><h3 id="安全区域safe-resion"><a class="markdownIt-Anchor" href="#安全区域safe-resion"></a> 安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p><p><mark>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 Gc 都是安全的。</mark>我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p><h3 id="实际执行时"><a class="markdownIt-Anchor" href="#实际执行时"></a> 实际执行时：</h3><ol><li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li><li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止；</li></ol><h2 id="126-再谈引用强引用"><a class="markdownIt-Anchor" href="#126-再谈引用强引用"></a> 12.6. 再谈引用：强引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p><p>【既<mark>偏门</mark>又非常<mark>高频</mark>的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p><p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这 4 种引用强度依次逐渐减弱。</p><p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p><p>.<img src="https://img-blog.csdnimg.cn/img_convert/1ef8adfbf9082acacc9db47ae48f5b47.png" alt="image-20200712205813321"></p><p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用</p><ul><li><mark>强引用（StrongReference）</mark>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li><li><mark>软引用（SoftReference）</mark>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li><li><mark>弱引用（WeakReference）</mark>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li><li><mark>虚引用（PhantomReference）</mark>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li></ul><h3 id="强引用strong-reference不回收"><a class="markdownIt-Anchor" href="#强引用strong-reference不回收"></a> 强引用（Strong Reference）——不回收</h3><p>在 Java 程序中，最常见的引用类型是强引用（<mark>普通系统 99%以上都是强引用</mark>），也就是我们最常见的普通对象引用，<mark>也是默认的引用类型</mark>。</p><p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p><p><mark>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</mark></p><p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p><p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<mark>强引用是造成 Java 内存泄漏的主要原因之一</mark>。</p><p><strong>强引用例子</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">"hello mogublog"</span>);</span><br></pre></td></tr></tbody></table></figure><p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用</p><p><strong>对应内存结构</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/34ad0a72d2fce1fd6c06b5965c354712.png" alt="image-20200712211501377"></p><p>此时，如果再运行一个赋值语句</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br></pre></td></tr></tbody></table></figure><p><strong>对应的内存结构</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/baf5d789fc28868dfb983adc7265461c.png" alt="image-20200712211732976"></p><p>本例中的两个引用，都是强引用，强引用具备以下特点：</p><ul><li>强引用可以直接访问目标对象。</li><li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li><li>强引用可能导致内存泄漏。</li></ul><h2 id="128-再谈引用-软引用"><a class="markdownIt-Anchor" href="#128-再谈引用-软引用"></a> 12.8. 再谈引用： 软引用</h2><h3 id="软引用soft-reference内存不足即回收"><a class="markdownIt-Anchor" href="#软引用soft-reference内存不足即回收"></a> 软引用（Soft Reference）——内存不足即回收</h3><p>（内存足够 --&gt; 不会回收软引用的可达对象； 内存不够 --&gt; 会回收软引用的可达对象）</p><p>软引用是用来描述一些还有用，但非必需的对象（必须对象由强引用描述）。<mark>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</mark>（一次回收是不可达对象），如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><p>软引用通常用来实现内存敏感的<strong>缓存</strong>。比如：<mark>高速缓存</mark>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p><p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p><p>在 JDK1.2 版之后提供了 java.lang.ref.SoftReference 类来实现软引用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221124152020225.png" alt="image-20221124152020225"></p><h2 id="129-再谈引用弱引用"><a class="markdownIt-Anchor" href="#129-再谈引用弱引用"></a> 12.9. 再谈引用：弱引用</h2><h3 id="弱引用weak-reference发现即回收"><a class="markdownIt-Anchor" href="#弱引用weak-reference发现即回收"></a> 弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，<mark>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</mark>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p><p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<mark>弱引用对象可以存在较长的时间</mark>。</p><p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p><p><mark>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</mark>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。<strong>而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</strong></p><p>在 JDK1.2 版之后提供了 WeakReference 类来实现弱引用</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></tbody></table></figure><p><mark>弱引用对象与软引用对象的最大不同</mark>就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。<mark>弱引用对象更容易、更快被 GC 回收</mark>。</p><p><img src="../../../images/image-20221124153725910.png" alt="image-20221124153725910"></p><p><strong>面试题：你开发中使用过 WeakHashMap 吗？</strong></p><p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM</p><h2 id="12x-再谈引用虚引用"><a class="markdownIt-Anchor" href="#12x-再谈引用虚引用"></a> 12.X. 再谈引用：虚引用</h2><h3 id="虚引用phantom-reference对象回收跟踪"><a class="markdownIt-Anchor" href="#虚引用phantom-reference对象回收跟踪"></a> 虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p><p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p><p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get()方法取得对象时，总是 null</p><p><mark>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</mark></p><p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p><p><mark>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</mark></p><p>在 JDK1.2 版之后提供了 PhantomReference 类来实现虚引用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="1211-终结器引用"><a class="markdownIt-Anchor" href="#1211-终结器引用"></a> 12.11. 终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p><p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize()方法，第二次 GC 时才回收被引用的对象</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配器模式</title>
      <link href="/2022/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="52-适配器模式"><a class="markdownIt-Anchor" href="#52-适配器模式"></a> 5.2 适配器模式</h2><h3 id="521-概述"><a class="markdownIt-Anchor" href="#521-概述"></a> 5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p><p><img src="https://bright-boy.gitee.io/technical-notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/%E8%BD%AC%E6%8E%A5%E5%A4%B4.png" alt="img"></p><p><strong>定义：</strong></p><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h3 id="522-结构"><a class="markdownIt-Anchor" href="#522-结构"></a> 5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h3 id="523-类适配器模式"><a class="markdownIt-Anchor" href="#523-类适配器模式"></a> 5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><p>【例】读卡器</p><p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p><p>类图如下：</p><p><img src="../../../images/image-20221121221506653.png" alt="image-20221121221506653"></p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"sd card read a msg :hello word SD"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"sd card write msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> {</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"sd card null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> {</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">"tf card read msg : hello word tf card"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"tf card write a msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p><h3 id="524-对象适配器模式"><a class="markdownIt-Anchor" href="#524-对象适配器模式"></a> <a href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_524-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">5.2.4 对象适配器模式</a></h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p><p>【例】读卡器</p><p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p><p><img src="https://bright-boy.gitee.io/technical-notes/img/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="img"></p><p>代码如下：</p><p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p></blockquote><h3 id="525-应用场景"><a class="markdownIt-Anchor" href="#525-应用场景"></a> <a href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_525-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">5.2.5 应用场景</a></h3><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h3 id="526-jdk源码解析"><a class="markdownIt-Anchor" href="#526-jdk源码解析"></a> <a href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_526-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">5.2.6 JDK源码解析</a></h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p><p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p><p><img src="https://bright-boy.gitee.io/technical-notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="img"></p><p>从上图可以看出：</p><ul><li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li><li>StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li></ul><p>结论：</p><p>从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
          <category> 适配器模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 结构型模式 </tag>
            
            <tag> 适配器模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11. 垃圾回收概述及算法</title>
      <link href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
      <url>/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="11-垃圾回收概述及算法"><a class="markdownIt-Anchor" href="#11-垃圾回收概述及算法"></a> 11. 垃圾回收概述及算法</h1><h2 id="111-垃圾回收概述"><a class="markdownIt-Anchor" href="#111-垃圾回收概述"></a> 11.1. 垃圾回收概述</h2><h3 id="1111-什么是垃圾"><a class="markdownIt-Anchor" href="#1111-什么是垃圾"></a> 11.1.1. 什么是垃圾？</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7d77b6d955e70ac268b08593078fbbdd.png" alt="image-20200712085456113"></p><p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p><p>关于垃圾收集有三个经典问题：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>垃圾收集机制是 Java 的招牌能力，<mark>极大地提高了开发效率</mark>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p><p><strong>大厂面试题</strong></p><p>CMS的全称是<strong>Mostly Concurrent Mark and Sweep Garbage Collector</strong>（主要并发标记清除垃圾回收器），它在年轻代使用复制算法，在老年代使用标记-清除算法，在老年代比起Mark-Sweep，多了一个并发设计。</p><blockquote><p><mark>蚂蚁金服</mark></p><ul><li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 G1？</p></li><li><p>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</p></li><li><p>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</p></li><li><p>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点</p></li></ul><p><mark>百度</mark></p><ul><li><p>说一下 GC 算法，分代回收说下</p></li><li><p>垃圾收集策略和算法</p></li></ul><p><mark>天猫</mark></p><ul><li><p>JVM GC 原理，JVM 怎么回收内存</p></li><li><p>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</p></li></ul><p><mark>滴滴</mark></p><ul><li>Java 的垃圾回收器都有哪些，说下 g1 的应用场景，平时你是如何搭配使用垃圾回收器的</li></ul><p><mark>京东</mark></p><ul><li><p>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，</p></li><li><p>包括原理，流程，优缺点。垃圾回收算法的实现原理</p></li></ul><p><mark>阿里</mark></p><ul><li><p>讲一讲垃圾回收算法。</p></li><li><p>什么情况下触发垃圾回收？</p></li><li><p>如何选择合适的垃圾收集算法？</p></li><li><p>JVM 有哪三种垃圾回收器？</p></li></ul><p><mark>字节跳动</mark></p><ul><li>常见的垃圾回收器算法有哪些，各有什么优劣？</li><li>System.gc（）和 Runtime.gc（）会做什么事情？</li><li>Java GC 机制？GC Roots 有哪些？</li><li>Java 对象的回收方式，回收算法。</li><li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li><li>CMS 回收停顿了几次，为什么要停顿两次?</li></ul></blockquote><h4 id="什么是垃圾"><a class="markdownIt-Anchor" href="#什么是垃圾"></a> 什么是垃圾？</h4><blockquote><p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p></blockquote><p><strong>垃圾</strong>是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾 。</p><p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p><p><strong>磁盘碎片整理的日子</strong></p><p>机械硬盘需要进行磁盘整理，同时还有坏道</p><p><img src="https://img-blog.csdnimg.cn/img_convert/309e92079f207b99ecb61e0e61f59933.png" alt="image-20200712090848669"></p><h2 id="1112-为什么需要-gc"><a class="markdownIt-Anchor" href="#1112-为什么需要-gc"></a> 11.1.2. 为什么需要 GC</h2><p><strong>想要学习 GC，首先需要理解为什么需要 GC？</strong></p><p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<mark>内存迟早都会被消耗完</mark>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p><p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<mark>JVM 将整理出的内存分配给新的对象</mark>。</p><p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<mark>没有 GC 就不能保证应用程序的正常进行</mark>。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p><h2 id="1113-早期垃圾回收"><a class="markdownIt-Anchor" href="#1113-早期垃圾回收"></a> 11.1.3. 早期垃圾回收</h2><p>在早期的 C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;<span class="built_in">Register</span>(kDestroy) != NO ERROR）</span><br><span class="line"><span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></tbody></table></figure><p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<mark>频繁申请和释放内存的管理负担</mark>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<mark>内存泄漏</mark>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<mark>应用程序崩溃</mark>。</p><p>在有了垃圾回收机制后，上述代码极有可能变成这样</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></tbody></table></figure><p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</p><h2 id="1114-java-垃圾回收机制"><a class="markdownIt-Anchor" href="#1114-java-垃圾回收机制"></a> 11.1.4. Java 垃圾回收机制</h2><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<mark>降低内存泄漏和内存溢出的风险</mark></p><ul><li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li></ul><p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地<mark>专注于业务开发</mark></p><p>oracle 官网关于垃圾回收的介绍 <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p><h4 id="担忧"><a class="markdownIt-Anchor" href="#担忧"></a> 担忧</h4><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<mark>弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力</mark>。</p><p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p><p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<mark>实施必要的监控和调节</mark>。</p><h4 id="gc-主要关注的区域"><a class="markdownIt-Anchor" href="#gc-主要关注的区域"></a> GC 主要关注的区域</h4><p>GC 主要关注于 方法区 和堆中的垃圾收集</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c3e4606c5878ad5ae19f878e2585ee9f.png" alt="image-20200712092427246"></p><p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，<mark>Java 堆是垃圾收集器的工作重点</mark></p><p>从次数上讲：</p><ul><li><mark>频繁收集 Young 区</mark></li><li><mark>较少收集 Old 区</mark></li><li><mark>基本不收集 Perm 区（元空间）</mark></li></ul><h2 id="112-垃圾回收相关算法面试的概率比较高"><a class="markdownIt-Anchor" href="#112-垃圾回收相关算法面试的概率比较高"></a> 11.2. 垃圾回收相关算法（面试的概率比较高）</h2><p><strong>对象存活判断</strong></p><p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<mark>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</mark>。<strong>只有被标记为己经死亡的对象，GC 才会在执行垃圾回收</strong>时，释放掉其所占用的内存空间，因此这个过程我们可以称为<mark>垃圾标记阶段</mark>。</p><p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当<strong>一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</strong></p><p>判断对象存活一般有两种方式：<mark><strong>引用计数算法</strong></mark>和<mark><strong>可达性分析算法</strong></mark>。</p><h3 id="1121-标记阶段引用计数算法"><a class="markdownIt-Anchor" href="#1121-标记阶段引用计数算法"></a> 11.2.1. 标记阶段：引用计数算法</h3><h4 id="方式一引用计数算法"><a class="markdownIt-Anchor" href="#方式一引用计数算法"></a> 方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<mark>引用计数器属性。用于记录对象被引用的情况。</mark></p><p><strong>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</strong></p><p>优点：<mark>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</mark></p><p>缺点：</p><ul><li>它需要单独的字段存储计数器，这样的做法增加了<mark>存储空间的开销</mark>。</li><li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<mark>时间开销</mark>。</li><li>引用计数器有一个严重的问题，即<mark>无法处理循环引用</mark>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中<strong>没有</strong>使用这类算法。</li></ul><h4 id="循环引用"><a class="markdownIt-Anchor" href="#循环引用"></a> 循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1367a58058e6653d53afdea83b937af3.png" alt="image-20200712102205795"></p><p><strong>举例</strong></p><p>测试 Java 中是否采用的是引用计数算法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> {</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></tbody></table></figure><p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p><p><img src="https://img-blog.csdnimg.cn/img_convert/010896600bb4483f35d004dce60cc58b.png" alt="image-20200712103230349"></p><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p><p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p><p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很<font color="red">难处理循环引用关系</font>。</p><p>Python 如何解决循环引用？</p><ul><li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li></ul><h3 id="1122-标记阶段可达性分析算法"><a class="markdownIt-Anchor" href="#1122-标记阶段可达性分析算法"></a> 11.2.2. 标记阶段：可达性分析算法</h3><h4 id="方式二可达性分析算法根搜索算法-追踪性垃圾收集"><a class="markdownIt-Anchor" href="#方式二可达性分析算法根搜索算法-追踪性垃圾收集"></a> 方式二：可达性分析算法（根搜索算法、追踪性垃圾收集）</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<mark>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</mark>。</p><p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<mark>追踪性垃圾收集（Tracing Garbage Collection）</mark></p><p>所谓"GCRoots”根集合就是一组必须活跃的引用。</p><h4 id="基本思路"><a class="markdownIt-Anchor" href="#基本思路"></a> 基本思路</h4><ul><li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>。</li><li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链（Reference Chain）</mark></li><li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li><li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/071039dcf30672f55dfe8e5dab5e8081.png" alt="image-20210511195540451"></p><p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p><ul><li>虚拟机栈中引用的对象<ul><li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li></ul></li><li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li><li>方法区中类静态属性引用的对象<ul><li>比如：Java 类的引用类型静态变量</li></ul></li><li>方法区中常量引用的对象<ul><li>比如：字符串常量池（String Table）里的引用</li></ul></li><li>所有被同步锁 synchronized 持有的对象</li><li>Java 虚拟机内部的引用。<ul><li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li></ul></li><li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d1ce4b570439851d57973a00684c6410.png" alt="image-20200712104622677"></p><p>( 栈，方法区，常量池，如果有引用堆空间里面的实体的话，比如里面那些蓝色的，就都是可达的对象，就不是垃圾。红色的那些就不可达的，就是垃圾 )</p><ul><li><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）。</p><ul><li>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</li><li>比如: 非新生代的，比如说老年代，也会考虑作为GC Roots的一部分，因为单独看新生代的话，也有可能会被老年代的一些引用所指向了</li></ul></li><li><p>小技巧：  由于 Root 采用<strong>栈方式</strong>存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p></li></ul><p><strong>注意</strong></p><p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行（比如，一个对象刚被引用完和表示可达的，就被标记上是垃圾了，这就不是一致性了，那肯定不行不符合的）。这点不满足的话分析结果的准确性就无法保证。</p><p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p><ul><li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li></ul><h3 id="1123-对象的-finalization-机制"><a class="markdownIt-Anchor" href="#1123-对象的-finalization-机制"></a> 11.2.3. 对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<mark>对象被销毁之前的自定义处理逻辑</mark>（就是对象被销毁前加一些逻辑代码进行处理）。</p><p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p><p><img src="../../../images/image-20221122223605544.png" alt="image-20221122223605544"></p><p><strong>finalize() 方法允许在子类中被重写，<mark>用于在对象被回收时进行资源释放</mark>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</strong></p><p>finalize() 方法本来是空的，没有重写finalize方法的话，调用了也没有什么意义，但即便是重写了，也不建议主动去调用，如下说明：</p><p>永远<strong>不要主动调用</strong>某个对象的 finalize()方法 ， 应该<strong>交给垃圾回收机制调用</strong>。理由包括下面三点：</p><ul><li>在 finalize()时可能会导致对象复活。</li><li>finalize()方法的执行时间是没有保障的（你调用它，它也不能保证马上执行），它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li><li>一个糟糕的 finalize()会严重影响 GC的性能。（比如，自己重写时写了个死循环在里面或是执行速度很慢，调用，那么GC的性能就会验证受影响）</li><li>它本来是空的，没有重写finalize方法的话，调用了也没有什么意义</li></ul><p>从功能上来说，finalize()方法与 C<ins>中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C</ins>中的析构函数。</p><p>由于 finalize()方法的存在，<mark>虚拟机中的对象一般处于三种可能的状态</mark>（可触及的，可复活的，不可触及的）。</p><h4 id="生存还是死亡"><a class="markdownIt-Anchor" href="#生存还是死亡"></a> 生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<mark>一个无法触及的对象有可能在某一个条件下“复活”自己</mark>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p><ul><li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li><li><mark>可复活的</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li><li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li></ul><p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p><h4 id="具体过程"><a class="markdownIt-Anchor" href="#具体过程"></a> 具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历<strong>两次标记</strong>过程：</p><ol><li>如果对象 objA 到 GC Roots 没有引用链，则进行<strong>第一次标记</strong>。</li><li>进行筛选，判断此对象是否有必要执行 finalize()方法</li><li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li><li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li><li><mark>finalize()方法是对象逃脱死亡的最后机会</mark>，稍后 GC 会对 F-Queue 队列中的对象进行<strong>第二次标记</strong>。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的 finalize 方法只会被调用一次</strong>。</li></ol><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> {</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        canReliveObj = <span class="built_in">this</span>;   <span class="comment">// 当前待回收的对象在 finalize() 方法中与引用链上的一个对象canReliveObj建立联系</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></tbody></table></figure><p>在第一次 GC 时，执行了 finalize 方法，但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p><h3 id="1124-mat-与-jprofiler-的-gc-roots-溯源"><a class="markdownIt-Anchor" href="#1124-mat-与-jprofiler-的-gc-roots-溯源"></a> 11.2.4. MAT 与 JProfiler 的 GC Roots 溯源</h3><h4 id="mat-是什么"><a class="markdownIt-Anchor" href="#mat-是什么"></a> MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p><p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p><p>大家可以在 <a href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载并使用 MAT</p><h4 id="获取-dump-文件"><a class="markdownIt-Anchor" href="#获取-dump-文件"></a> 获取 dump 文件</h4><h5 id="方式一命令行使用-jmap"><a class="markdownIt-Anchor" href="#方式一命令行使用-jmap"></a> 方式一：命令行使用 jmap</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/f8cc8bd3ef9526b497bcc4335e84e639.png" alt="image-20210512105418987"></p><h5 id="方式二使用-jvisualvm-导出"><a class="markdownIt-Anchor" href="#方式二使用-jvisualvm-导出"></a> 方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p><p>可通过以下方法捕获 heap dump：</p><ul><li><p>在左侧“Application"（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</p></li><li><p>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</p></li></ul><p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p><p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p><h5 id="方式三使用-mat-打开-dump-文件"><a class="markdownIt-Anchor" href="#方式三使用-mat-打开-dump-文件"></a> 方式三：使用 MAT 打开 Dump 文件</h5><p><img src="../../../images/image-20221123091417318.png" alt="image-20221123091417318"></p><h4 id="jprofiler-的-gc-roots-溯源"><a class="markdownIt-Anchor" href="#jprofiler-的-gc-roots-溯源"></a> JProfiler 的 GC Roots 溯源</h4><p>（本身这个对象我已经不想用它了，它已经不再会被使用了，它就是垃圾，但是当我们用Class分析算法时，会发现，它直接或间接地还被GC Roots关联着，导致还没办法将它GC，这就是java真正的内存泄露。那出现内存泄漏， 我们可以溯源，发现它确实和GC Roots连上了，那可以在适当的位置给它断开。所以我们在开发中，一般都会看某个对象上的GC Roots是什么，这就是<strong>GC Roots溯源</strong>）</p><p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p><p><img src="../../../images/image-20221123093811032.png" alt="image-20221123093811032"></p><p>view --&gt; Mark Current Values</p><p><img src="../../../images/image-20221123093839170.png" alt="image-20221123093839170"></p><p><img src="../../../images/image-20221123094354023.png" alt="image-20221123094354023"></p><p>可以将当前对象基于当前节点后的个数的变化的值展现出来，便可以看到有哪些对象变化比较大，变化比较大的就是我们要关注的一些对象了。</p><p>对象个数比较大或是说占用空间比较大，当我们GC（点击Run GC）的时候，我们还始终回收不了它们</p><p><img src="../../../images/image-20221123094522918.png" alt="image-20221123094522918"></p><p>我们发现char数组对象比较多，我们可以鼠标指着–&gt;点右键–&gt;Show Selection In Heap Walker–&gt;ok</p><p><img src="../../../images/image-20221123094721985.png" alt="image-20221123094721985"></p><p>分配，大对象，相关引用。我们更关注的是引用，引用用得比较多</p><p><img src="../../../images/image-20221123095009723.png" alt="image-20221123095009723"></p><p>点击References之后，就可以看到所有的参数。想知道有哪些有内存泄漏问题，就可以做GC Roots溯源</p><p><img src="../../../images/image-20221123095352781.png" alt="image-20221123095352781"></p><p><img src="../../../images/image-20221123092829645.png" alt="image-20221123092829645"></p><p>Outgoing references：定位代码的大概位置</p><p>Incoming references：判断和哪个GC Roots是相关联的</p><p><img src="../../../images/image-20221123093245549.png" alt="image-20221123093245549"></p><h3 id="1125-清除阶段标记-清除算法"><a class="markdownIt-Anchor" href="#1125-清除阶段标记-清除算法"></a> 11.2.5. 清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p><p>目前在 JVM 中比较常见的三种<font color="red">垃圾收集算法</font>是<mark>标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</mark></p><h4 id="标记-清除mark-sweep算法"><a class="markdownIt-Anchor" href="#标记-清除mark-sweep算法"></a> 标记-清除（Mark-Sweep）算法</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p><h4 id="执行过程"><a class="markdownIt-Anchor" href="#执行过程"></a> 执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p><ul><li><p><mark>标记</mark>：Collector 从引用根节点开始遍历，标记所有被引用的对象（即GC Roots可到达的对象）。一般是在对象的 Header 中记录为可达对象。</p></li><li><p><mark>清除</mark>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/8ea506a5c45c10410418ff0403e2b3a8.png" alt="image-20200712150935078"></p><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h4><ul><li>标记清除算法的效率不算高（全部对象都要遍历）</li><li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li><li>这种方式清理出来的<strong>空闲内存是不连续的，产生内碎片</strong>，需要维护一个空闲列表</li></ul><h4 id="何为清除"><a class="markdownIt-Anchor" href="#何为清除"></a> 何为清除？</h4><p>这里所谓的清除并<strong>不是真的置空</strong>，而是<strong>把需要清除的对象地址保存在空闲的地址列表里</strong>。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放，<strong>覆盖原有的地址</strong>。</p><h3 id="1126-清除阶段复制算法"><a class="markdownIt-Anchor" href="#1126-清除阶段复制算法"></a> 11.2.6. 清除阶段：复制算法</h3><h4 id="复制copying算法"><a class="markdownIt-Anchor" href="#复制copying算法"></a> 复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p><h4 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h4><p>将活着的内存<strong>空间分为两块</strong>，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b508a12ff6282839b65f8be9a683e04b.png" alt="image-20200712151916991"></p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4><ul><li>没有标记和清除过程，实现简单，运行高效</li><li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li></ul><h4 id="缺点-2"><a class="markdownIt-Anchor" href="#缺点-2"></a> 缺点</h4><ul><li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li><li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li></ul><h4 id="特别的"><a class="markdownIt-Anchor" href="#特别的"></a> 特别的</h4><p>如果系统中的垃圾对象很多，复制算法不会很理想（复制太多的话，最后发现回收的不多，而且还要维护 region 之间对象引用关系还很多）。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p><h4 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h4><p>在<strong>新生代</strong>，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a911b5f7d17bd00fda883623e4d831a.png" alt="image-20200712152847218"></p><h3 id="1127-清除阶段标记-压缩整理算法"><a class="markdownIt-Anchor" href="#1127-清除阶段标记-压缩整理算法"></a> 11.2.7. 清除阶段：标记-压缩（整理）算法</h3><h4 id="标记-压缩或标记-整理-mark-compact算法"><a class="markdownIt-Anchor" href="#标记-压缩或标记-整理-mark-compact算法"></a> 标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p><p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p><p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p><h4 id="执行过程-2"><a class="markdownIt-Anchor" href="#执行过程-2"></a> 执行过程</h4><ol><li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p></li><li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p></li><li><p>之后，清理边界外所有的空间。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/aac06de20fada1a602f1955010bd969d.png" alt="image-20200712153236508"></p><p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<mark>标记-清除-压缩（Mark-Sweep-Compact）算法</mark>。</p><p>二者的本质差异在于标记-清除算法是一种<mark>非移动式的回收算法</mark>，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，<strong>当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</strong></p><h4 id="指针碰撞bump-the-pointer"><a class="markdownIt-Anchor" href="#指针碰撞bump-the-pointer"></a> 指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p><h4 id="优点-2"><a class="markdownIt-Anchor" href="#优点-2"></a> 优点</h4><ul><li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li><li>消除了复制算法当中，内存减半的高额代价。</li></ul><h4 id="缺点-3"><a class="markdownIt-Anchor" href="#缺点-3"></a> 缺点</h4><ul><li>从效率上来说，标记-整理算法要低于复制算法。</li><li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li><li>移动过程中，需要全程暂停用户应用程序。即：STW</li></ul><h3 id="1128-小结"><a class="markdownIt-Anchor" href="#1128-小结"></a> 11.2.8. 小结</h3><p>对比三种算法</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left">Mark-Sweep</th><th style="text-align:left">Mark-Compact</th><th style="text-align:left">Copying</th></tr></thead><tbody><tr><td style="text-align:left"><strong>速率</strong></td><td style="text-align:left">中等</td><td style="text-align:left">最慢</td><td style="text-align:left">最快</td></tr><tr><td style="text-align:left"><strong>空间开销</strong></td><td style="text-align:left">少（但会堆积碎片）</td><td style="text-align:left">少（不堆积碎片）</td><td style="text-align:left">通常需要活对象的 2 倍空间（不堆积碎片）</td></tr><tr><td style="text-align:left"><strong>移动对象</strong></td><td style="text-align:left">否</td><td style="text-align:left">是</td><td style="text-align:left">是</td></tr></tbody></table><p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p><p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p><p>难道就没有一种最优算法吗？</p><p>回答：无，没有最好的算法，只有最合适的算法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/cdb03d2691d80ca89da2805015ad31e9.png" alt="image-20210512104415281"></p><h3 id="1129-分代收集算法"><a class="markdownIt-Anchor" href="#1129-分代收集算法"></a> 11.2.9. 分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p><p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p><p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<mark>String 对象</mark>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p><p><mark>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</mark></p><p><strong>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</strong></p><h4 id="年轻代young-gen"><a class="markdownIt-Anchor" href="#年轻代young-gen"></a> 年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p><p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而<strong>复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</strong></p><h4 id="老年代tenured-gen"><a class="markdownIt-Anchor" href="#老年代tenured-gen"></a> 老年代（Tenured Gen）</h4><p><mark>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</mark>。</p><p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p><ul><li>Mark 阶段的开销与存活对象的数量成正比。</li><li>Sweep 阶段的开销与所管理区域的大小成正相关。</li><li>Compact 阶段的开销与存活对象的数据成正比。</li></ul><p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p><p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p><h3 id="112x-增量收集算法-分区算法"><a class="markdownIt-Anchor" href="#112x-增量收集算法-分区算法"></a> 11.2.X. 增量收集算法、分区算法</h3><h4 id="增量收集算法"><a class="markdownIt-Anchor" href="#增量收集算法"></a> 增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<mark>严重影响用户体验或者系统的稳定性</mark>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p><h5 id="基本思想"><a class="markdownIt-Anchor" href="#基本思想"></a> 基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<mark>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</mark>。</p><p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<mark>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</mark></p><h5 id="缺点-4"><a class="markdownIt-Anchor" href="#缺点-4"></a> 缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<mark>造成系统吞吐量的下降</mark>。</p><h4 id="分区算法"><a class="markdownIt-Anchor" href="#分区算法"></a> 分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p><p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p><p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/34de5a2cce0c5e9c88f76652b674877d.png" alt="image-20200712165318590"></p><h4 id="写到最后"><a class="markdownIt-Anchor" href="#写到最后"></a> 写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10. StringTable</title>
      <link href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10.%20StringTable/"/>
      <url>/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10.%20StringTable/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="10-stringtable"><a class="markdownIt-Anchor" href="#10-stringtable"></a> 10. StringTable</h1><h2 id="101-string-的基本特性"><a class="markdownIt-Anchor" href="#101-string-的基本特性"></a> 10.1. String 的基本特性</h2><ul><li>String：字符串，使用一对""引起来表示</li><li>String 声明为 final 的，不可被继承</li><li>String 实现了 Serializable 接口：表示字符串是支持序列化的。</li><li>String 实现了 Comparable 接口：表示 string 可以比较大小</li><li>String 在 jdk8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK9 时改为 byte[]</li></ul><h3 id="1011-string-在-jdk9-中存储结构变更"><a class="markdownIt-Anchor" href="#1011-string-在-jdk9-中存储结构变更"></a> 10.1.1. String 在 jdk9 中存储结构变更</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings (java.net)</a></p><blockquote><h2 id="motivation"><a class="markdownIt-Anchor" href="#motivation"></a> Motivation</h2><p>The current implementation of the <code>String</code> class stores characters in a <code>char</code> array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most <code>String</code> objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal <code>char</code> arrays of such <code>String</code> objects is going unused.</p><h2 id="description"><a class="markdownIt-Anchor" href="#description"></a> Description</h2><p>We propose to change the internal representation of the <code>String</code> class from a UTF-16 <code>char</code> array to a <code>byte</code> array plus an encoding-flag field. The new <code>String</code> class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p><p>String-related classes such as <code>AbstractStringBuilder</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p><p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p><p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p></blockquote><p><strong>动机</strong></p><p>目前 String 类的实现将字符存储在一个 char 数组中，每个字符使用两个字节（16 位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含 Latin-1 字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。</p><p><strong>说明</strong></p><p>我们建议将 String 类的内部表示方法从 UTF-16 字符数组改为字节数组加编码标志域。新的 String 类将根据字符串的内容，以 ISO-8859-1/Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p><hr><p>与字符串相关的类，如<mark>AbstractStringBuilder、StringBuilder 和 StringBuffer 将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此</mark>。</p><p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口。</p><p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p><p>结论：<mark><strong>String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</strong></mark></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1012-string-的基本特性"><a class="markdownIt-Anchor" href="#1012-string-的基本特性"></a> 10.1.2. String 的基本特性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p><ul><li>当对字符串<strong>重新赋值</strong>时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当对现有的字符串进行<strong>连接</strong>操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当调用 string 的 **replace()**方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li></ul><p>通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p><p><mark>字符串常量池是不会存储相同内容的字符串的</mark></p><p>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而<strong>链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降</strong>。</p><p>如：通过设置不同长度来测试性能：<img src="../../../images/image-20221121105838424.png" alt="image-20221121105838424"></p><p>使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p><ul><li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li><li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求</li><li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值<ul><li>如果设置小于1009的话，就会报如下错误：<img src="../../../images/image-20221121105440727.png" alt="image-20221121105440727"></li></ul></li></ul><p>例子：（String 的基本使用，体现String的不可变性）</p><p><img src="../../../images/image-20221121102353645.png" alt="image-20221121102353645"></p><p><img src="../../../images/image-20221121100748082.png" alt="image-20221121100748082"></p><p><img src="../../../images/image-20221121102438865.png" alt="image-20221121102438865"></p><p>无论你是char数组还是byte数组，字符串一旦定义好了，其实字符串底层的数组长度就定死了，要想往后面拼接的话，数组扩容本身也不能往后补，就得重新造一个。其二的话，堆空间中的字符串常量池，只要你修改，就得去重新创建，这就体现了不可变性</p><p><img src="../../../images/image-20221121102458111.png" alt="image-20221121102458111"></p><p>面试题：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一道String的面试题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"good"</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = {<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> {</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str); <span class="comment">// good</span></span><br><span class="line">        System.out.println(ex.ch);  <span class="comment">// best</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><a href="https://blog.csdn.net/qq_39552268/article/details/111415291">(5条消息) java 中String到底是值传递还是引用传递的问题_技术无产者的博客-CSDN博客</a></p><h2 id="102-string-的内存分配"><a class="markdownIt-Anchor" href="#102-string-的内存分配"></a> 10.2. String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p><p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，<mark>String 类型的常量池比较特殊。它的主要使用方法有两种。</mark></p><ul><li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</p></li><li><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern()方法。这个后面重点谈</p></li></ul><p>Java 6 及以前，字符串常量池存放在<strong>永久代</strong></p><p>如：字符串常量池装不下时报oom显示永久代PermGen空间：<img src="../../../images/image-20221121111144881.png" alt="image-20221121111144881"></p><p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将<mark>字符串常量池的位置调整到 Java <strong>堆内</strong></mark></p><ul><li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li><li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code>。</li></ul><p>如：字符串常量池装不下时报oom显示堆空间（和jdk8一样）：<img src="../../../images/image-20221121111122217.png" alt="image-20221121111122217"></p><p>Java8 元空间，字符串常量在<strong>堆</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/27b7bf706fc1724baf503eac9b49c7fc.png" alt="image-20200711093546398"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c59830deeebca85d5b2e446211e4e28d.png" alt="image-20200711093558709"></p><p><strong>StringTable 为什么要调整？</strong></p><p>官网地址：<a href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p><blockquote><p><strong>Synopsis:</strong> In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.</p></blockquote><p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但<mark>加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异</mark>。</p><h2 id="103-string-的基本操作"><a class="markdownIt-Anchor" href="#103-string-的基本操作"></a> 10.3. String 的基本操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">    System.out.println();    <span class="comment">//2320</span></span><br><span class="line">    System.out.println(<span class="string">"1"</span>); <span class="comment">//2321</span></span><br><span class="line">    System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(<span class="string">"5"</span>);</span><br><span class="line">    System.out.println(<span class="string">"6"</span>);</span><br><span class="line">    System.out.println(<span class="string">"7"</span>);</span><br><span class="line">    System.out.println(<span class="string">"8"</span>);</span><br><span class="line">    System.out.println(<span class="string">"9"</span>);</span><br><span class="line">    System.out.println(<span class="string">"10"</span>); <span class="comment">//2330</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的字符串就不会再次加载进字符串常量池了，因为上面都已经加载过了，常量池汇中都有了</span></span><br><span class="line">    System.out.println(<span class="string">"1"</span>); <span class="comment">//2321</span></span><br><span class="line">    System.out.println(<span class="string">"2"</span>); <span class="comment">//2322</span></span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(l<span class="string">"5"</span>);</span><br><span class="line">    System.out.println(<span class="string">"6"</span>);</span><br><span class="line">    System.out.println(<span class="string">"7"</span>);</span><br><span class="line">    System.out.println(<span class="string">"8"</span>);</span><br><span class="line">    System.out.println(<span class="string">"9"</span>);</span><br><span class="line">    System.out.println(<span class="string">"10"</span>);<span class="comment">//2330</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>debug模式查看:</p><p><img src="../../../images/image-20221121113447184.png" alt="image-20221121113447184"></p><p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> i= <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//Line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//Line 5</span></span><br><span class="line">    }<span class="comment">//Line 9</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> {<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }<span class="comment">//Line 8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/0ca01e17abb22f0fa16e87dd93b26a65.png" alt="image-20210511111607132"></p><h2 id="104-字符串拼接操作"><a class="markdownIt-Anchor" href="#104-字符串拼接操作"></a> 10.4. 字符串拼接操作</h2><ul><li>常量与常量的拼接结果在<strong>常量池</strong>，原理是<strong>编译期优化</strong></li><li><strong>常量池</strong>中不会存在相同内容的变量</li><li>只要其中有一个是<strong>变量</strong>，结果就在<strong>堆</strong>中。变量拼接的原理是 StringBuilder</li><li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li></ul><p><strong>举例 1</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 都是常量，前端编译期会进行代码优化</span></span><br><span class="line">    <span class="comment">// 通过idea直接看对应的反编译的class文件，会显示 String s1 = "abc"; 说明做了代码优化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"javaEE"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"hadoop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">"javaEE"</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true 编译期优化</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false s1是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false s2是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false s1、s2都是变量</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">// false s5、s6 不同的对象实例</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">// false s5、s7 不同的对象实例</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// false s6、s7 不同的对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true intern之后，s8和s3一样，指向字符串常量池中的"javaEEhadoop"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221121151128082.png" alt="image-20221121151128082"></p><p>虽然 s3 和 s4 的指向的值都是“ab”,但是他们<br>各自存放的地方不一样，也就是地址不一样</p><p><strong>举例 3</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  1. 字符串拼接操作不一定使用的是 StringBuilder （变量拼接的原理是 StringBuilder）</span></span><br><span class="line"><span class="comment">   如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译优化，即非StringBuilder的方式</span></span><br><span class="line"><span class="comment">  2. 针对于 final 修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上 final 的时候建议使用上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">"beijing"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"bei"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"jing"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s0 == s3); <span class="comment">// false s3指向堆空降中的对象实例，s0指向字符串常量池中的"beijing"</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">"shanxi"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"shan"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">"xi"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4 + s5;</span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// true s4和s5是final修饰的，编译期就能确定s6的值了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>不使用 final 修饰，即为变量。如 s3 行的 s1 和 s2，会通过 new StringBuilder 进行拼接</li><li>使用 final 修饰，即为常量。会在编译器进行代码优化。<mark>在实际开发中，能够使用 final 的，尽量使用</mark></li></ul><p><strong>举例 4</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"b"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3==s4);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>字节码</strong></p><p>我们拿例 4 的字节码进行查看，可以发现<code>s1 + s2</code>实际上是 new 了一个 StringBuilder 对象，并使用了 append 方法将 s1 和 s2 添加进来，最后调用了 toString 方法赋给 s4</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;a&gt;</span><br><span class="line"> 2 astore_1</span><br><span class="line"> 3 ldc #3 &lt;b&gt;</span><br><span class="line"> 5 astore_2</span><br><span class="line"> 6 ldc #4 &lt;ab&gt;</span><br><span class="line"> 8 astore_3</span><br><span class="line"> 9 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">12 dup</span><br><span class="line">13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">16 aload_1</span><br><span class="line">17 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">20 aload_2</span><br><span class="line">21 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">27 astore 4</span><br><span class="line">29 getstatic #9 &lt;java/lang/System.out&gt;</span><br><span class="line">32 aload_3</span><br><span class="line">33 aload 4</span><br><span class="line">35 if_acmpne 42 (+7)</span><br><span class="line">38 iconst_1</span><br><span class="line">39 goto 43 (+4)</span><br><span class="line">42 iconst_0</span><br><span class="line">43 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">46 return</span><br></pre></td></tr></tbody></table></figure><p><strong>字符串拼接操作性能对比</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>{   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {  </span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">50000</span>;      </span><br><span class="line">        <span class="comment">// String      </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();     </span><br><span class="line">        testString(times);  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();       </span><br><span class="line">        System.out.println(<span class="string">"String: "</span> + (end-start) + <span class="string">"ms"</span>);     </span><br><span class="line">        <span class="comment">// StringBuilder       </span></span><br><span class="line">        start = System.currentTimeMillis();   </span><br><span class="line">        testStringBuilder(times);      </span><br><span class="line">        end = System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"StringBuilder: "</span> + (end-start) + <span class="string">"ms"</span>);    </span><br><span class="line">        <span class="comment">// StringBuffer      </span></span><br><span class="line">        start = System.currentTimeMillis();      </span><br><span class="line">        testStringBuffer(times);   </span><br><span class="line">        end = System.currentTimeMillis();    </span><br><span class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (end-start) + <span class="string">"ms"</span>);   </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">(<span class="type">int</span> times)</span> { </span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">""</span>;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {     </span><br><span class="line">            str = str + <span class="string">"test"</span>;      </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuilder</span><span class="params">(<span class="type">int</span> times)</span> {     </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {        </span><br><span class="line">            sb.append(<span class="string">"test"</span>);     </span><br><span class="line">        }   </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuffer</span><span class="params">(<span class="type">int</span> times)</span> {   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {        </span><br><span class="line">            sb.append(<span class="string">"test"</span>);      </span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 结果String: 7963msStringBuilder: 1msStringBuffer: 4ms</span></span><br></pre></td></tr></tbody></table></figure><ol><li><p>本实验进行 5 万次循环，String 拼接方式的时间是 StringBuilder.append 方式的约 8000 倍，StringBuffer.append()方式的时间是 StringBuilder.append()方式的约 4 倍（StringBuffer是同步的，会慢些）</p></li><li><p>可以看到，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用“+”拼接的方式<mark>快的不是一点半点</mark></p></li></ol><p>​因为：（1）StringBuiler 的 append()的方式：自始自终只创建过一个StringBuilder的对象</p><p>​使用String的字符串拼接方式：创建过多个 StringBuilder 和 String 的对象</p><p>​（2）使用String 的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费的额外时间。</p><ol start="3"><li><p>那么，在实际开发中，对于需要<mark>多次或大量拼接</mark>的操作，在不考虑线程安全问题时，我们就应该尽可能<mark>使用 StringBuilder 进行 append 操作</mark></p></li><li><p><strong>改进的空间</strong>：除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？（改进的空间）</p></li></ol><p>​在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值hightLevel的情况下，<strong>建议使用<mark>带参构造器</mark>指定 capacity来实例化，以减少扩容的次数，优化程序执行效果</strong>（扩容的逻辑可以自行查看源代码）</p><p>​StringBuilder 空参构造器的初始化大小为 16。</p><p>​StringBuilder s = new StringBuilder(capacity); // new char[capacity]</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a string builder with no characters in it and an * initial capacity of 16 characters. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> { </span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a string builder with no characters in it and an </span></span><br><span class="line"><span class="comment">* initial capacity specified by the {<span class="doctag">@code</span> capacity} argument. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      capacity  the initial capacity. </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>     NegativeArraySizeException  if the {<span class="doctag">@code</span> capacity} </span></span><br><span class="line"><span class="comment">*               argument is less than {<span class="doctag">@code</span> 0}. </span></span><br><span class="line"><span class="comment">*/</span><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(<span class="type">int</span> capacity)</span> {   </span><br><span class="line">    <span class="built_in">super</span>(capacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="105-intern的使用"><a class="markdownIt-Anchor" href="#105-intern的使用"></a> 10.5. intern()的使用</h2><p>官方 API 文档中的解释</p><blockquote><p>public String intern()</p><p>Returns a canonical representation for the string object.</p><p>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.</p><p>When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-"><code>equals(Object)</code></a> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.</p><p>It follows that for any two strings <code>s</code> and <code>t</code>, <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.</p><p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p><ul><li><p><strong>Returns:</strong></p><p>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p></li></ul></blockquote><p>当调用 intern 方法时，如果池子里已经包含了一个与这个 String 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用。</p><p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() == t.intern()为真。</p><p>所有字面字符串和以字符串为值的常量表达式都是 interned。</p><p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p><hr><p>intern 是一个 native 方法，调用的是底层 C 的方法</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">"I love atguigu"</span>).intern();</span><br></pre></td></tr></tbody></table></figure><p>也就是说，如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>).intern() == <span class="string">"abc"</span></span><br></pre></td></tr></tbody></table></figure><p>通俗点讲，Interned string 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p><p><img src="../../../images/image-20221121160359225.png" alt="image-20221121160359225"></p><p>如何保证变量 s 指向的是字符串常量池中的数据呢？</p><p>有两种方式：</p><p>方式一：字面量定义的方式</p><p>​String s = “hhhh”;</p><p>方式二：调用 intern()</p><p>​String s = new String(“hhhh”).intern();</p><p>​String s = new StringBuilder(“hhhh”).toString().intern();</p><p>（用字面量或者intern方法才会在字符串常量池中创建，否则在堆中创建）</p><p><img src="../../../images/image-20221121161348231.png" alt="image-20221121161348231"></p><p><img src="../../../images/image-20221121163558377.png" alt="image-20221121163558377"></p><h3 id="1051-intern-的使用jdk6-vs-jdk78"><a class="markdownIt-Anchor" href="#1051-intern-的使用jdk6-vs-jdk78"></a> 10.5.1. intern 的使用：JDK6 vs JDK7/8</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* ① String s = new String("1")</span></span><br><span class="line"><span class="comment">* 创建了两个对象 </span></span><br><span class="line"><span class="comment">* 堆空间中一个new对象</span></span><br><span class="line"><span class="comment">* 字符串常量池中一个字符串常量"1"（注意：此时字符串常量池中已有"1"）</span></span><br><span class="line"><span class="comment">* ② s.intern(); 调用此方法之前，字符串常量池中已存在了"1" </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* s  指向的是堆空间中的对象地址</span></span><br><span class="line"><span class="comment">* s2 指向的是堆空间中常量池中"1"的地址 </span></span><br><span class="line"><span class="comment">* 所以不相等 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">s.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s==s2);<span class="comment">// jdk1.6 false jdk7/8 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">① String s3 = new String("1") + new String("1") </span></span><br><span class="line"><span class="comment">* s3变量记录的地址为new String（"11"），等价于new String（"11"），但是，常量池中并不生成字符串"11"； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* ② s3.intern() </span></span><br><span class="line"><span class="comment">* 由于此时常量池中并无"11"，所以这里会在字符串常量池中生成"11"，如何理解：</span></span><br><span class="line"><span class="comment">jdk6: 创建了一个新的对象"11"，也就有新的地址</span></span><br><span class="line"><span class="comment">jdk7: 此时常量中并没有创建"11"，则会把 对象的引用地址 复制一份，放入串池，并返回串池中的引用地址。</span></span><br><span class="line"><span class="comment">      即，创建一个指向堆空间中 new String("11") 的地址</span></span><br><span class="line"><span class="comment">* String s4 = "11"; // s4 变量记录的地址：使用的是上一行代码执行时，在常量池中生成的"11"的地址</span></span><br><span class="line"><span class="comment">* 所以s3 和 s4 指向的都是一个地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3==s4);  <span class="comment">//jdk1.6 false jdk7/8 true</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/4c11070481d7c3cdb566163802cf582b.png" alt="image-20210511152240683"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3a3bab69ad3c6302ea00c301dffb5193.png" alt="image-20200711145925091"></p><p>面试题的扩展：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// StringIntern.java中的练习扩展</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 执行完上一行代码以后，字符串常量池中，不存在 "11"</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>; <span class="comment">//在字符串常量池中生成对象"11"</span></span><br><span class="line"></span><br><span class="line">        s3.intern();</span><br><span class="line">        System.out.println( s3 == s4 );  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line">        System.out.println( s5 == s4 );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        s3 = s3.intern();</span><br><span class="line">        System.out.println( s3 == s4 );  <span class="comment">// true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>总结 String 的 intern()的使用：</p><p>JDK1.6 中，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，会把此<mark><strong>对象</strong>复制一份</mark>，放入串池，并返回串池中的对象地址</li></ul><p>JDK1.7 起，将这个字符串对象尝试放入串池。</p><ul><li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li><li>如果没有，则会把<mark>对象的<strong>引用地址</strong></mark>复制一份，放入串池，并返回串池中的引用地址</li></ul><p><strong>练习 1</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"a"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"b"</span>);  <span class="comment">// 变量s记录的地址为new String("ab")</span></span><br><span class="line">        <span class="comment">// 在执行完上一行代码后，字符串常量池中并没有"ab"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * jdk6中：在 字符串常量池 中 创建一个 字符串"ab"</span></span><br><span class="line"><span class="comment">         * jdk8中：字符串常量池 中 没有创建 字符串"ab"，而是 创建 了一个 引用（指向 new String ("ab")）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">"ab"</span>);  <span class="comment">// jdk6: true    jdk8: true</span></span><br><span class="line">        System.out.println(s == <span class="string">"ab"</span>);   <span class="comment">// jdk6: false   jdk8: true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>图解：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bb9abdd927bd9ac80c1c18359d299629.png" alt="image-20200711150859709"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e6c4796fa8d9b5dda9438c799bb45540.png" alt="image-20200711151326909"></p><p><strong>练习 2</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ad465da04603bb228d6dde8950ee95ec.png" alt="image-20200711151433277"></p><p>练习3：（自己设置的）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>);</span><br><span class="line">    System.out.println(s1 == <span class="string">"ab"</span>);  <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    System.out.println(s2 == <span class="string">"ab"</span>);  <span class="comment">// true</span></span><br><span class="line">    System.out.println(s2 == s);     <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1052-intern-的效率测试空间角度"><a class="markdownIt-Anchor" href="#1052-intern-的效率测试空间角度"></a> 10.5.2. intern 的效率测试：空间角度</h3><p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> { </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {      </span><br><span class="line">        Integer [] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};    </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) {         </span><br><span class="line">            <span class="comment">// arr[i] = new String(String.valueOf(data[i%data.length]));    </span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i%data.length])).intern(); </span><br><span class="line">        }       </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start));      </span><br><span class="line">        <span class="keyword">try</span> {         </span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);   </span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {         </span><br><span class="line">            e.getStackTrace();       </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果:   不使用intern：7256ms    使用intern：1395ms</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结论</strong>：</p><p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern()方法能够节省内存空间。</p><p>而 arr[i] = new String(String.valueOf(data[i%data.length])).intern(); 中前面的 new String(String.valueOf(data[i%data.length])) 的对象，在堆空间中，后期被发现不用就会被GC垃圾回收销毁了，所以就不会在内存中创建过多的String</p><p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern()方法，就会很明显降低内存的大小。</p><h2 id="106-stringtable-的垃圾回收"><a class="markdownIt-Anchor" href="#106-stringtable-的垃圾回收"></a> 10.6. StringTable 的垃圾回收</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> {  </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * -Xms15m -Xmx15m -XX:+PrintGCDetails  </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {    </span><br><span class="line">            String.valueOf(i).intern();       </span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>运行结果</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;504K(4608K)] 4096K-&gt;1689K(15872K), <span class="number">0.0581583</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] [GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 5785K-&gt;2310K(15872K), <span class="number">0.0015621</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] [GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 6406K-&gt;2350K(15872K), <span class="number">0.0034849</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">Heap PSYoungGen     </span><br><span class="line">    total 4608K, used 1919K [<span class="number">0x00000000ffb00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)  eden space 4096K, <span class="number">34</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffc61d30</span>,<span class="number">0x00000000fff00000</span>)  from space 512K, <span class="number">98</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7e010</span>,<span class="number">0x00000000fff80000</span>)  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>) ParOldGen       total 11264K, used 1846K [<span class="number">0x00000000ff000000</span>, <span class="number">0x00000000ffb00000</span>, <span class="number">0x00000000ffb00000</span>)  object space 11264K, <span class="number">16</span>% used [<span class="number">0x00000000ff000000</span>,<span class="number">0x00000000ff1cd9b0</span>,<span class="number">0x00000000ffb00000</span>) Metaspace       used 3378K, capacity 4496K, committed 4864K, reserved 1056768K  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></tbody></table></figure><h2 id="107-g1-中的-string-去重操作"><a class="markdownIt-Anchor" href="#107-g1-中的-string-去重操作"></a> 10.7. G1 中的 String 去重操作</h2><p>官网地址：<a href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p><blockquote><h2 id="motivation-2"><a class="markdownIt-Anchor" href="#motivation-2"></a> Motivation</h2><p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by <code>String</code> objects. Further, roughly half of those <code>String</code> objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate <code>String</code> objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous <code>String</code> deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint.</p></blockquote><p>目前，许多大规模的 Java 应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约 25%的 Java 堆实时数据集被<code>String'对象所消耗。此外，这些 "String "对象中大约有一半是重复的，其中重复意味着 "string1.equals(string2) "是真的。在堆上有重复的</code>String’对象，从本质上讲，只是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动和持续的`String’重复数据删除，以避免浪费内存，减少内存占用。</p><hr><p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p><p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p><ul><li>堆存活数据集合里面 string 对象占了 25%</li><li>堆存活数据集合里面重复的 string 对象有 13.5%</li><li>string 对象的平均长度是 45</li></ul><p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<mark>Java 堆中存活的数据集合差不多 25%是 String 对象</mark>。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说： <strong><code>stringl.equals(string2)= true</code></strong>。<mark>堆上存在重复的 String 对象必然是一种内存的浪费</mark>。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p><p><strong>实现</strong></p><ol><li>当垃圾收集器工作的时候，会访问堆上存活的对象。<mark>对每一个访问的对象都会检查是否是候选的要去重的 String 对象</mark></li><li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li><li>使用一个 hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li><li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li><li>如果查找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li></ol><p><strong>命令行选项</strong></p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启String去重，默认是不开启的，需要手动开启。</span> </span><br><span class="line">UseStringDeduplication(bool) </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印详细的去重统计信息</span> </span><br><span class="line">PrintStringDeduplicationStatistics(bool)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">达到这个年龄的String对象被认为是去重的候选对象</span></span><br><span class="line">StringpeDuplicationAgeThreshold(uintx)</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2. 类加载子系统</title>
      <link href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="2-类加载子系统"><a class="markdownIt-Anchor" href="#2-类加载子系统"></a> 2. 类加载子系统</h1><h2 id="21-内存结构概述"><a class="markdownIt-Anchor" href="#21-内存结构概述"></a> 2.1. 内存结构概述</h2><ul><li>Class 文件</li><li><mark>类加载子系统</mark></li><li>运行时数据区<ul><li>方法区</li><li>堆</li><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul></li><li>执行引擎</li><li>本地方法接口</li><li>本地方法库</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/e4bc9ed374db7f35e68f23f4813205bd.png" alt="image-20200705080719531"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5f06cd7e27506a91940c7b87e01d0b46.png" alt="image-20200705080911284"></p><p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><h2 id="22-类加载器与类的加载过程"><a class="markdownIt-Anchor" href="#22-类加载器与类的加载过程"></a> 2.2. 类加载器与类的加载过程</h2><p><strong>类加载器子系统作用</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/3569bfb903e80b66ee7e972a6b4a5036.png" alt="image-20200705081813409"></p><ul><li>类加载器子系统负责<strong>从文件系统或者网络中加载 Class 文件</strong>，class 文件在文件开头有特定的文件标识。</li><li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 <strong>Execution Engine 执行引擎</strong> 决定。</li><li>加载的类信息存放于一块称为<strong>方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li></ul><p><strong>类加载器 ClassLoader 角色</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e8172076eaa7a152408633a353f06b2c.png" alt="image-20200705081913538"></p><ul><li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li><li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li><li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li></ul><p><strong>类的加载过程</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>用流程图表示上述示例代码：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/8cc54647114c456695ac352336c74600.png" alt="image-20200705082255746"></p><h3 id="加载阶段"><a class="markdownIt-Anchor" href="#加载阶段"></a> 加载阶段</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/a9497a1eeb7fae3022846b509186fdcd.png" alt="image-20200705082601441"></p><ul><li><ol><li>通过一个类的全限定名获取定义此类的二进制字节流</li></ol></li><li><ol start="2"><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li></ol></li><li><ol start="3"><li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li></ol></li></ul><p><strong>补充：加载 class 文件的方式</strong></p><ul><li>从<mark>本地系统</mark>中直接加载</li><li>通过<mark>网络</mark>获取，典型场景：Web Applet</li><li>从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础</li><li>运行时计算生成，使用最多的是：<mark>动态代理技术</mark></li><li>由其他文件生成，典型场景：<mark>JSP 应用</mark></li><li>从专有<mark>数据库</mark>中提取.class 文件，比较少见</li><li>从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施</li></ul><h3 id="链接阶段"><a class="markdownIt-Anchor" href="#链接阶段"></a> 链接阶段</h3><ul><li><strong>验证（Verify）</strong>：<ul><li>目的在于<strong>确保 Class 文件的字节流中包含信息符合当前虚拟机要求</strong>，<strong>保证被加载类的正确性，不会危害虚拟机自身安全。</strong></li><li>主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark></li></ul></li><li><strong>准备（Prepare）</strong>：<ul><li><strong>为类变量分配内存</strong>并且<strong>设置该类变量的默认初始值</strong>，即零值。</li><li><mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</mark></li><li><mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li></ul></li><li><strong>解析（Resolve）</strong>：<ul><li>将<strong>常量池内</strong>的<mark>符号引用转换为直接引用</mark>的过程。</li><li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li><li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li><li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li></ul></li></ul><h3 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h3><ul><li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li><li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被<strong>同步加锁</strong>。</li></ul><h2 id="23-类加载器分类"><a class="markdownIt-Anchor" href="#23-类加载器分类"></a> 2.3. 类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。</p><p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。</p><p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1e553c6d5254f827d2dfab537bea3ab9.png" alt="image-20200705094149223"></p><p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p><h3 id="231-虚拟机自带的加载器"><a class="markdownIt-Anchor" href="#231-虚拟机自带的加载器"></a> 2.3.1. 虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p><ul><li>这个类加载使用 <strong>C/C++语言</strong>实现的，嵌套在 JVM 内部。</li><li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li><li>并不继承自 java.lang.ClassLoader，没有父加载器。</li><li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li><li>出于安全考虑，Bootstrap 启动类加载器只加载包名为<font color="red"> <strong>java、javax、sun</strong> </font>等开头的类</li></ul><p><strong>扩展类加载器（Extension ClassLoader）</strong></p><ul><li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li><li>派生于 ClassLoader 类</li><li>父类加载器为启动类加载器</li><li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li></ul><p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p><ul><li>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</li><li>派生于 ClassLoader 类</li><li>父类加载器为扩展类加载器</li><li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li><li><mark>该类加载是程序中<strong>默认</strong>的类加载器</mark>，一般来说，Java 应用的类都是由它来完成加载</li><li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li></ul><h3 id="232-用户自定义类加载器"><a class="markdownIt-Anchor" href="#232-用户自定义类加载器"></a> 2.3.2. 用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p><p>为什么要自定义类加载器？</p><ul><li>隔离加载类</li><li>修改类加载的方式</li><li>扩展加载源</li><li>防止源码泄漏</li></ul><p>用户自定义类加载器实现步骤：</p><ol><li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li><li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li><li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li></ol><h2 id="24-classloader-的使用说明"><a class="markdownIt-Anchor" href="#24-classloader-的使用说明"></a> 2.4. ClassLoader 的使用说明</h2><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/876534b3c2f447d3fc33e6f1db218068.png" alt="image-20200705103516138"></p><p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p><p><img src="https://img-blog.csdnimg.cn/img_convert/a22114b608dffe484041b591d486a7fd.png" alt="image-20200705103636003"></p><p><strong>获取 ClassLoader 的途径</strong></p><ul><li><p>方式一：获取当前 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式二：获取当前线程上下文的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式三：获取系统的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式四：获取调用者的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="25-双亲委派机制"><a class="markdownIt-Anchor" href="#25-双亲委派机制"></a> 2.5. 双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p><p><strong>工作原理</strong></p><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p><p><strong>举例</strong></p><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p><p><strong>优势</strong></p><ul><li>避免类的重复加载</li><li>保护程序安全，防止核心 API 被随意篡改<ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><strong>沙箱安全机制</strong></p><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h2 id="26-其他"><a class="markdownIt-Anchor" href="#26-其他"></a> 2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><p><strong>对类加载器的引用</strong></p><p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p><p><strong>类的主动使用和被动使用</strong></p><p>Java 程序对类的使用方式分为：主动使用和被动使用。</p><p>主动使用，又分为七种情况：</p><ul><li><p>创建类的实例</p></li><li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p></li><li><p>调用类的静态方法</p></li><li><p>反射（比如：Class.forName（“com.atguigu.Test”））</p></li><li><p>初始化一个类的子类</p></li><li><p>Java 虚拟机启动时被标明为启动类的类</p></li><li><p>JDK 7 开始提供的动态语言支持：</p><p>java.lang.invoke.MethodHandle 实例的解析结果</p><p>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</p></li></ul><p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都<mark>不会导致类的初始化</mark>。</p><hr><p><img src="../../../images/image-20221120230332074.png" alt="image-20221120230332074"></p><p><img src="../../../images/image-20221120230322953.png" alt="image-20221120230322953"></p><p><img src="../../../images/image-20221120230310840.png" alt="image-20221120230310840"></p><p><img src="../../../images/image-20221120230259551.png" alt="image-20221120230259551"></p><p><img src="../../../images/image-20221120230251515.png" alt="image-20221120230251515"></p><p><img src="../../../images/image-20221120230241584.png" alt="image-20221120230241584"></p><p><img src="../../../images/image-20221120230234436.png" alt="image-20221120230234436"></p><p><img src="../../../images/image-20221120230223130.png" alt="image-20221120230223130"></p><p><img src="../../../images/image-20221120230214513.png" alt="image-20221120230214513"></p><p><img src="../../../images/image-20221120230150104.png" alt="image-20221120230150104"></p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9. 执行引擎</title>
      <link href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9.%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/"/>
      <url>/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9.%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="9-执行引擎"><a class="markdownIt-Anchor" href="#9-执行引擎"></a> 9. 执行引擎</h1><h2 id="91-执行引擎概述"><a class="markdownIt-Anchor" href="#91-执行引擎概述"></a> 9.1. 执行引擎概述</h2><p>执行引擎属于 JVM 的下层，里面包括<mark>解释器、及时编译器、垃圾回收器</mark></p><p><img src="https://img-blog.csdnimg.cn/img_convert/9c0459b0f80a1c9bb534418b8e5a4ddd.png" alt="image-20200710080707873"></p><p>执行引擎是 Java 虚拟机核心的组成部分之一。</p><p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<mark>虚拟机的执行引擎则是由软件自行实现的</mark>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<mark>能够执行那些不被硬件直接支持的指令集格式</mark>。</p><p>JVM 的主要任务是负责<mark>装载字节码到其内部</mark>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b28ff1d82bc72999d1cbbae3f419673d.png" alt="image-20200710081118053"></p><p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是<mark>将字节码指令解释/编译为对应平台上的本地机器指令</mark>.才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H3dqdi5T-1620741818957)(<a href="https://gitee.com/vectorx/ImageCloud/raw/master/img/20210511090655.png">https://gitee.com/vectorx/ImageCloud/raw/master/img/20210511090655.png</a>)]</p><h3 id="911-执行引擎的工作流程"><a class="markdownIt-Anchor" href="#911-执行引擎的工作流程"></a> 9.1.1. 执行引擎的工作流程</h3><ol><li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li><li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li><li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/a03c1910e508456b690ec9088300de5f.png" alt="image-20200710081627217"></p><p>从外观上来看，所有的 Java 虚拟机的执行引擎输入，输出都是一致的：输入的是<strong>字节码二进制流</strong>，处理过程是字节码解析执行的等效过程，输出的是<strong>执行过程</strong>。</p><p><img src="../../../images/image-20221120193453610.png" alt="image-20221120193453610"></p><p>执行引擎就是负责将字节码指令，翻译成对应的机器指令，让程序能在操作系统中去执行，</p><h2 id="92-java-代码编译和执行过程"><a class="markdownIt-Anchor" href="#92-java-代码编译和执行过程"></a> 9.2. Java 代码编译和执行过程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/e2a8ec10bc97a061e4b77abf63936ba1.png" alt="image-20200710082141643"></p><p>（绿色代表解析过程，蓝色代表编译过程）</p><p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p><p><strong>Java 代码编译</strong>是由 Java 源码编译器（<mark>前端编译器</mark>）来完成，流程图如下所示：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/93e5f0b67767b7d783ace2471447f449.png" alt="image-20200710082433146"></p><p><strong>Java 字节码的执行</strong>是由 JVM 执行引擎（<mark>后端编译器</mark>）来完成，流程图 如下所示</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bf1139f9652e2a1ac0cab00df869e23e.png" alt="image-20200710083036258"></p><h3 id="921-什么是解释器interpreter什么是-jit-编译器"><a class="markdownIt-Anchor" href="#921-什么是解释器interpreter什么是-jit-编译器"></a> 9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？</h3><p><strong>解释器</strong>：当 Java 虚拟机启动时会根据预定义的规范<mark>对字节码采用逐行解释的方式执行</mark>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p><strong>JIT（Just In Time Compiler）编译器</strong>：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p><h3 id="922-为什么-java-是半编译半解释型语言"><a class="markdownIt-Anchor" href="#922-为什么-java-是半编译半解释型语言"></a> 9.2.2. 为什么 Java 是半编译半解释型语言？</h3><p>JDK1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p><p><strong>图示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f10a353479e6d2bca99abd4781fd9940.png" alt="image-20200710083656277"></p><h2 id="93-机器码-指令-汇编语言"><a class="markdownIt-Anchor" href="#93-机器码-指令-汇编语言"></a> 9.3. 机器码、指令、汇编语言</h2><h3 id="931-机器码"><a class="markdownIt-Anchor" href="#931-机器码"></a> 9.3.1. 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p><p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p><p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p><p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p><h3 id="932-指令"><a class="markdownIt-Anchor" href="#932-指令"></a> 9.3.2. 指令</h3><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p><p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好</p><p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p><h3 id="933-指令集"><a class="markdownIt-Anchor" href="#933-指令集"></a> 9.3.3. 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p><ul><li>x86 指令集，对应的是 x86 架构的平台</li><li>ARM 指令集，对应的是 ARM 架构的平台</li></ul><h3 id="934-汇编语言"><a class="markdownIt-Anchor" href="#934-汇编语言"></a> 9.3.4. 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p><p>在汇编语言中，<mark>用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark 地址符号（Symbol）或标号（Label）代替指令或操作数的地址</mark>。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p><p>由于计算机只认识指令码，所以用<mark>汇编语言编写的程序还必须翻译成机器指令码</mark>，计算机才能识别和执行。</p><h3 id="935-高级语言"><a class="markdownIt-Anchor" href="#935-高级语言"></a> 9.3.5. 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<mark>更接近人的语言</mark></p><p>当计算机执行高级语言编写的程序时，<mark>仍然需要把程序解释和编译成机器的指令码</mark>。完成这个过程的程序就叫做解释程序或编译程序。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c812403e1ebae81455d5276b884e5ca8.png" alt="image-20200710085323733"></p><p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的 C 和 C++</p><h4 id="c-c源程序执行过程"><a class="markdownIt-Anchor" href="#c-c源程序执行过程"></a> C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p><p><strong>编译过程</strong>：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p><p><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/71d4298a250e724d64d78a2d8ec67cdc.png" alt="image-20200710085553258"></p><h3 id="936-字节码"><a class="markdownIt-Anchor" href="#936-字节码"></a> 9.3.6. 字节码</h3><p>（字节码主要是为了实现跨平台性）</p><p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p><p>字节码主要为了实现特定软件运行和软件环境、<mark>与硬件环境无关</mark>。</p><p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p><p><img src="https://img-blog.csdnimg.cn/img_convert/cba8c417f20ae9f6671e64574d2e229a.png" alt="image-20210511092336091"></p><h2 id="94-解释器"><a class="markdownIt-Anchor" href="#94-解释器"></a> 9.4. 解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地为了<mark>满足 Java 程序实现跨平台特性</mark>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f1a9c57cf4b6b4197b85d6e2a48a045e.png" alt="image-20200710090203674"></p><p>为什么 Java 源文件不直接翻译成 JMV，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p><h3 id="941-解释器工作机制"><a class="markdownIt-Anchor" href="#941-解释器工作机制"></a> 9.4.1. 解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p><p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p><h3 id="942-解释器分类"><a class="markdownIt-Anchor" href="#942-解释器分类"></a> 9.4.2. 解释器分类</h3><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p><ul><li><strong>字节码解释器</strong>在执行时通过<mark>纯软件代码模拟字节码</mark>的执行，效率非常低下。</li><li>而<strong>模板解释器</strong>将<mark>每一条字节码和一个模板函数相关联</mark>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li></ul><p>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。</p><ul><li>Interpreter 模块：实现了解释器的核心功能</li><li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li></ul><h3 id="943-现状"><a class="markdownIt-Anchor" href="#943-现状"></a> 9.4.3. 现状</h3><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，<mark>基于解释器执行已经沦落为低效的代名词</mark>，并且时常被一些 C/C++程序员所调侃。</p><p>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<mark>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</mark>，这种方式可以使执行效率大幅度提升。</p><p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p><h2 id="95-jit-编译器"><a class="markdownIt-Anchor" href="#95-jit-编译器"></a> 9.5. JIT 编译器</h2><h3 id="951-java-代码的执行分类"><a class="markdownIt-Anchor" href="#951-java-代码的执行分类"></a> 9.5.1. Java 代码的执行分类</h3><ul><li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p></li><li><p>第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p></li></ul><p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用<mark>解释器与即时编译器并存的架构</mark>。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p><p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。</p><p><strong>问题来了</strong></p><p>有些开发人员会感觉到诧异，<mark>既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</mark>比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p><p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p><p>所以： 尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<mark>当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间</mark>。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p><p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p><h3 id="952-hotspot-jvm-执行方式"><a class="markdownIt-Anchor" href="#952-hotspot-jvm-执行方式"></a> 9.5.2. HotSpot JVM 执行方式</h3><p><font color="green"><strong>解析器和JIT编译器结合使用</strong></font></p><p>当虚拟机启动的时候，<mark>解释器可以首先发挥作用</mark>，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<mark>将有价值的字节码编译为本地机器指令</mark>，以换取更高的程序执行效率。</p><p><strong>案例来了</strong></p><p>注意解释执行与编译执行在线上环境微妙的辩证关系。<mark>机器在热机状态可以承受的负载要大于冷机状态</mark>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p><p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1/2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7f26fbc3a6ec701fe4f84eea99811540.png" alt="image-20200710095417462"></p><h3 id="953-概念解释"><a class="markdownIt-Anchor" href="#953-概念解释"></a> 9.5.3. 概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<mark>前端编译器</mark>（其实叫“编译器的前端”更准确一些）把.java 文件转变成.class 文件的过程；</p><p>也可能是指虚拟机的<mark>后端运行期编译器</mark>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p><p>还可能是指使用<mark>静态提前编译器</mark>（AOT 编译器，Ahead of Time Compiler）直接把.java 文件编译成本地机器代码的过程。</p><ul><li><p>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</p></li><li><p>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</p></li><li><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p></li></ul><h3 id="954-热点代码及探测技术"><a class="markdownIt-Anchor" href="#954-热点代码及探测技术"></a> 9.5.4. 热点代码及探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p><p><mark>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</mark>，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<mark>OSR（On Stack Replacement）编译</mark>。</p><p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<mark>热点探测功能</mark>。</p><p><mark>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测</mark>。</p><p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为<mark>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</mark>。</p><ul><li>方法调用计数器用于统计方法的调用次数</li><li>回边计数器则用于统计循环体执行的循环次数</li></ul><h4 id="方法调用计数器"><a class="markdownIt-Anchor" href="#方法调用计数器"></a> 方法调用计数器</h4><p><strong>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</strong></p><p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</p><p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断<mark>方法调用计数器与回边计数器值之和</mark>是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/26dc8459b4b31e3d9c40b3aec10b15cd.png" alt="image-20200710101829934"></p><h4 id="热点衰减"><a class="markdownIt-Anchor" href="#热点衰减"></a> 热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<mark>一段时间之内方法被调用的次数</mark>。当超过<mark>一定的时间限度</mark>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<mark>衰减（Counter Decay）</mark>，而这段时间就称为此方法统计的<mark>半衰周期（Counter Half Life Time）</mark></p><p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p><p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p><h4 id="回边计数器"><a class="markdownIt-Anchor" href="#回边计数器"></a> 回边计数器</h4><p>它的作用是统计一个<mark>方法中循环体代码执行的次数</mark>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4de983636a290fde3fea83a6cd60d6a5.png" alt="image-20200710103103869"></p><h3 id="955-hotspotvm-可以设置程序执行方法"><a class="markdownIt-Anchor" href="#955-hotspotvm-可以设置程序执行方法"></a> 9.5.5. HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，<strong>通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行</strong>。如下所示：</p><ul><li><code>-Xint</code>：完全采用解释器模式执行程序；</li><li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li><li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li></ul><p><img src="../../../images/image-20221120214349955.png" alt="image-20221120214349955"></p><p>例子：</p><p>通过设置三种不同的方式进行测试：</p><p><img src="../../../images/image-20221120214924904.png" alt="image-20221120214924904"></p><p>设置方式如下：</p><p><img src="../../../images/image-20221120214714985.png" alt="image-20221120214714985"></p><h3 id="956-hotspotvm-中-jit-分类"><a class="markdownIt-Anchor" href="#956-hotspotvm-中-jit-分类"></a> 9.5.6. HotSpotVM 中 JIT 分类</h3><p>JIT 的编译器还分为了两种，分别是 C1 和 C2，在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器 和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p><ul><li><code>-client</code>：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；C1 编译器会对字节码<mark>进行简单和可靠的优化，耗时短</mark>，以达到更快的编译速度。</li><li><code>-server</code>：指定 Java 虚拟机运行在 server 模式下，并使用 C2 编译器。C2<mark>进行耗时较长的优化，以及激进优化</mark>，但优化的代码执行效率更高。</li></ul><p><mark>分层编译（Tiered Compilation）策略</mark>：程序解释执行（ 不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p><p>不过在 Java7 版本之后，一旦开发人员在程序中显式指定命令“-server"时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p><h4 id="c1-和-c2-编译器不同的优化策略"><a class="markdownIt-Anchor" href="#c1-和-c2-编译器不同的优化策略"></a> C1 和 C2 编译器不同的优化策略</h4><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有<mark>方法内联、去虚拟化、冗余消除</mark>。</p><ul><li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li><li>去虚拟化：对唯一的实现类进行内联</li><li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li></ul><p>C2 的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p><ul><li><mark>标量替换</mark>：用标量值代替聚合对象的属性值</li><li><mark>栈上分配</mark>：对于未逃逸的对象分配对象在栈而不是堆</li><li><mark>同步消除</mark>：清除同步操作，通常指 synchronized</li></ul><p><img src="../../../images/image-20221120215856902.png" alt="image-20221120215856902"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>一般来讲，JIT 编译出来的机器码性能比解释器高。</p><p>C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</p><h3 id="写到最后-1"><a class="markdownIt-Anchor" href="#写到最后-1"></a> 写到最后 1</h3><ul><li>自 JDK10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li><li>编译效果短短几年时间就追评了 C2 编译器，未来可期</li><li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li></ul><h3 id="写到最后-2aot-编译器"><a class="markdownIt-Anchor" href="#写到最后-2aot-编译器"></a> 写到最后 2：AOT 编译器</h3><p>jdk9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p><p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p><p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，<mark>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码</mark>，并部署至托管环境中的过程。而<mark>AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</mark></p><p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p><p>缺点：</p><ul><li><mark>破坏了 java “ 一次编译，到处运行”的理念</mark>，必须为每个不同的硬件，OS 编译对应的发行包</li><li><mark>降低了 Java 链接过程的动态性</mark>，加载的代码在编译器就必须全部已知。</li><li>还需要继续优化中，最初只支持 Linux X64 java base</li></ul><h3 id="为什么不全部使用-aot-呢"><a class="markdownIt-Anchor" href="#为什么不全部使用-aot-呢"></a> 为什么不全部使用 AOT 呢？</h3><p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p><p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8. 对象实例化及直接内存</title>
      <link href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/"/>
      <url>/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="8-对象实例化及直接内存"><a class="markdownIt-Anchor" href="#8-对象实例化及直接内存"></a> 8. 对象实例化及直接内存</h1><h2 id="81-对象实例化"><a class="markdownIt-Anchor" href="#81-对象实例化"></a> 8.1. 对象实例化</h2><p><strong>面试题</strong></p><blockquote><p><mark>美团</mark>：</p><p>对象在 JVM 中是怎么存储的？</p><p>对象头信息里面有哪些东西？</p><p><mark>蚂蚁金服</mark>：</p><p>Java 对象头有什么？</p></blockquote><p><img src="../../../images/image-20221120122751656.png" alt="image-20221120122751656"></p><h3 id="811-创建对象的方式"><a class="markdownIt-Anchor" href="#811-创建对象的方式"></a> 8.1.1. 创建对象的方式</h3><ul><li>new：最常见的方式、Xxx 的静态方法，XxxBuilder/XxxFactory 的静态方法</li><li>Class 的 newInstance 方法：反射的方式，只能调用空参的构造器，权限必须是 public</li><li>Constructor 的 newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li><li>使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现 clone()</li><li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li><li>第三方库 Objenesis</li></ul><h3 id="812-创建对象的步骤"><a class="markdownIt-Anchor" href="#812-创建对象的步骤"></a> 8.1.2. 创建对象的步骤</h3><p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/504c93d37f3d51c88b1834d78c33eaa2.png" alt="image-20210510220743192"></p><h4 id="1-判断对象对应的类是否加载-链接-初始化即要加载创建的对象所属的类"><a class="markdownIt-Anchor" href="#1-判断对象对应的类是否加载-链接-初始化即要加载创建的对象所属的类"></a> 1. 判断对象对应的类是否加载、链接、初始化（即，要加载创建的对象所属的类）</h4><p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p><p>如果没有，那么在<strong>双亲委派</strong>模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件；</p><ul><li>如果没有找到文件，则抛出 ClassNotFoundException 异常</li><li>如果找到，则进行类加载，并生成对应的 Class 对象</li></ul><h4 id="2-为对象分配内存"><a class="markdownIt-Anchor" href="#2-为对象分配内存"></a> 2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小</p><p><strong>如果内存规整</strong>：虚拟机将采用的是<mark>指针碰撞法（Bump The Point）</mark>来为对象分配内存。</p><ul><li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</li></ul><p><strong>如果内存不规整</strong>：虚拟机需要维护一个<mark>空闲列表（Free List）</mark>来为对象分配内存。</p><ul><li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li></ul><p>选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><h4 id="3-处理并发问题"><a class="markdownIt-Anchor" href="#3-处理并发问题"></a> 3. 处理并发问题</h4><ul><li><p>采用 CAS 失败重试、区域加锁保证更新的原子性</p><ul><li>ps ： CAS（Compare-And-Swap）,它是一条CPU并发原语，用于判断内存中某个位置的值是否为<strong>预期值</strong>，如果是则更改为新的值，这个过程是<strong>原子</strong>的。</li></ul></li><li><p>每个线程预先分配一块 TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</p><ul><li>ps：TLAB是线程私有的，不会被其它线程共享使用，但是TLAB区域不大</li></ul></li></ul><h4 id="4-初始化分配到的内存"><a class="markdownIt-Anchor" href="#4-初始化分配到的内存"></a> 4. 初始化分配到的内存</h4><p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p><h4 id="5-设置对象的对象头"><a class="markdownIt-Anchor" href="#5-设置对象的对象头"></a> 5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p><h4 id="6-执行-init-方法进行初始化"><a class="markdownIt-Anchor" href="#6-执行-init-方法进行初始化"></a> 6. 执行 init 方法进行初始化</h4><p>在 Java 程序的视角看来，初始化才正式开始。<mark>初始化成员变量，执行实例化代码块，调用类的构造方法</mark>，并把堆内对象的首地址赋值给引用变量。</p><p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p><p><strong>给对象属性赋值的操作</strong></p><ul><li>属性的默认初始化</li><li>显式初始化</li><li>代码块中初始化</li><li>构造器中初始化</li></ul><p><strong>对象实例化的过程</strong></p><ol><li>加载类元信息</li><li>为对象分配内存</li><li>处理并发问题</li><li>属性的默认初始化（零值初始化）</li><li>设置对象头信息</li><li>属性的显示初始化、代码块中初始化、构造器中初始化</li></ol><h2 id="82-对象内存布局"><a class="markdownIt-Anchor" href="#82-对象内存布局"></a> 8.2. 对象内存布局</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f6e34140a6bd24a85d9f766652b57d98.png" alt="image-20200709151033237"></p><h3 id="821-对象头header"><a class="markdownIt-Anchor" href="#821-对象头header"></a> 8.2.1. 对象头（Header）</h3><p>对象头包含了两部分，分别是<mark>运行时元数据（Mark Word）</mark>和<mark>类型指针</mark>。如果是数组，还需要记录数组的长度</p><h4 id="运行时元数据"><a class="markdownIt-Anchor" href="#运行时元数据"></a> 运行时元数据</h4><ul><li>哈希值（HashCode）</li><li>GC 分代年龄</li><li>锁状态标志</li><li>线程持有的锁</li><li>偏向线程 ID</li><li>翩向时间戳</li></ul><h4 id="类型指针"><a class="markdownIt-Anchor" href="#类型指针"></a> 类型指针</h4><p>指向类元数据 InstanceKlass，确定该对象所属的类型。</p><h3 id="822-实例数据instance-data"><a class="markdownIt-Anchor" href="#822-实例数据instance-data"></a> 8.2.2. 实例数据（Instance Data）</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p><ul><li>相同宽度的字段总是被分配在一起</li><li>父类中定义的变量会出现在子类之前</li><li>如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙</li></ul><h3 id="823-对齐填充padding"><a class="markdownIt-Anchor" href="#823-对齐填充padding"></a> 8.2.3. 对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        name = <span class="string">"匿名客户"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> {</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerTest</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>{</span><br><span class="line">        Customer cust=<span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>图示</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/1bba0ee2a8a614b80d6cac9fecbb3f8a.png" alt="image-20200709152801713"></p><h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3be25c48b29d3cef51354f19cbe31d7d.png" alt="image-20210510225407119"></p><h2 id="83-对象的访问定位"><a class="markdownIt-Anchor" href="#83-对象的访问定位"></a> 8.3. 对象的访问定位</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/375b00ca9022291e7d2e214ce2d7cbfd.png" alt="image-20210510230045654"></p><p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p><p>定位，通过栈上reference访问</p><p><img src="https://img-blog.csdnimg.cn/img_convert/deab7773248ea150e5f7dee3901700cd.png" alt="image-20200709164149920"></p><h3 id="831-句柄访问"><a class="markdownIt-Anchor" href="#831-句柄访问"></a> 8.3.1. 句柄访问</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/59cc079fe02b7a5836ff7c2c7fffb635.png" alt="image-20210510230241991"></p><p>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改</p><h3 id="832-直接指针hotspot-采用"><a class="markdownIt-Anchor" href="#832-直接指针hotspot-采用"></a> 8.3.2. 直接指针（HotSpot 采用）</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/694601dcb023c6d10168a00fe000becc.png" alt="image-20210510230337956"></p><p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p><p>直接指针的reference是不稳定的，可能发生变化的，因为reference指向的对象，在垃圾回收时，需要移动，所以reference就会跟着修改</p><h2 id="84-直接内存direct-memory"><a class="markdownIt-Anchor" href="#84-直接内存direct-memory"></a> 8.4. 直接内存（Direct Memory）</h2><h3 id="841-直接内存概述"><a class="markdownIt-Anchor" href="#841-直接内存概述"></a> 8.4.1. 直接内存概述</h3><p>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。<mark>直接内存是在 Java 堆外的、直接向系统申请的内存区间</mark>。来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。通常，访问直接内存的速度会优于 Java 堆，即<mark>读写性能高</mark>。</p><ul><li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li><li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li></ul><h3 id="842-非直接缓存区"><a class="markdownIt-Anchor" href="#842-非直接缓存区"></a> 8.4.2. 非直接缓存区</h3><p>使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/c691d62d73e977fb942748a81313f5e6.png" alt="image-20210510231408607"></p><h3 id="843-直接缓存区"><a class="markdownIt-Anchor" href="#843-直接缓存区"></a> 8.4.3. 直接缓存区</h3><p>使用 NIO 时，操作系统划出的直接缓存区可以被 java 代码直接访问，只有一份。<strong>NIO</strong> 适合对大文件的读写操作。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d13b08447999ab32811a440496e4dac7.png" alt="image-20210510231456550"></p><p>也可能导致 OutOfMemoryError 异常</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">    at java.nio.Bits.reserveMemory(Bits.java:<span class="number">693</span>)</span><br><span class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">    at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure><p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p><ul><li>分配回收成本较高</li><li>不受 JVM 内存回收管理</li></ul><p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定，默认与堆的最大值-Xmx 参数值一致</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0ac6c50a98325c93b5652602137b9dea.png" alt="image-20200709230647277"></p><p>java总的进程空间 = java的堆空间 + 本地内存空间</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运行时数据区的总结以及常见大厂面试题</title>
      <link href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7-8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7-8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="运行时数据区的总结以及常见大厂面试题"><a class="markdownIt-Anchor" href="#运行时数据区的总结以及常见大厂面试题"></a> 运行时数据区的总结以及常见大厂面试题</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f73315a70302396e391a532dcf87ce26.png" alt="image-20200708220303243"></p><p>线程私有的：程序计数器、本地方法栈、虚拟机栈</p><p>虚拟机栈里的栈帧的结构：返回值、局部变量表、操作数栈、动态链接（装着指向运行时常量池的当前方法的引用，知道当前方法是引用运行时常量池中的哪个方法）</p><p><img src="../../../images/image-20221120105434202.png" alt="image-20221120105434202"></p><h2 id="常见面试题"><a class="markdownIt-Anchor" href="#常见面试题"></a> 常见面试题</h2><blockquote><p><mark>百度</mark>：</p><h3 id="说一下-jvm-内存模型吧有哪些区分别干什么的"><a class="markdownIt-Anchor" href="#说一下-jvm-内存模型吧有哪些区分别干什么的"></a> 说一下 JVM 内存模型吧，有哪些区？分别干什么的？</h3><p><strong>答：</strong></p><p>JVM内存区域主要包含：方法区 程序计数器 Java虚拟机栈 本地方法栈 Java堆</p><p><strong>1、方法区：</strong></p><p>方法区在JDK1.8之后把名字改成了“Metaspace"，可以翻译成"元数据空间"，这是一块<strong>线程共享</strong>的内存空间，主要用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p><p>Java虚拟机规范将方法区描述为堆的一个逻辑部分，但它有一个别名”Non-Heap 非堆“ 用于与Java堆区分。</p><p>很多人愿意把方法区成为”永久代“，本质上两者并不等价。HotSpot虚拟机 团队选择把GC分代收集扩展至方法区，或者说使用永久带实现方法区而已。</p><p>方法区存在的<strong>问题</strong>：</p><p>永久代容易遇到内存溢出问题（HotSpot永久代有-XX:MaxPermSize上限）当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常<strong>运行时常量池</strong>也是方法区的一个部分，主要用于存放编译器生成的各种字面量和符号引用。类加载后会进入方法区的运行时常量池</p><p>运行时常量池存在的<strong>问题：</strong></p><p>当常量池无法再申请到内存空间时会抛出OutOfMemoryError异常</p><p><strong>2、虚拟机栈</strong></p><p>虚拟机栈是<strong>线程私有</strong>的内存空间，其生命周期与线程相同，是用于<strong>Java方法执行的内存模型</strong>。方法执行时会创建栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等。</p><p>虚拟机栈存在的<strong>问题：</strong></p><p>线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常虚拟机栈动态扩展时无法申请到足够的内存，抛出OutOfMemoryError异常</p><p><strong>3、本地方法栈</strong></p><p>其发挥的作用和存在的问题与Java虚拟机栈类似，这里主要说一下其区别。其区别主要是虚拟机栈为虚拟机执行Java方法服务，而<font color="red">本地方法栈为虚拟机使用到Native方法服务。</font></p><p>**知识点：**Hotspot虚拟机中将本地方法栈与虚拟机栈合二为一。</p><p><strong>4、Java堆</strong></p><p>Java堆是虚拟机中占内存最大的一块内存空间，是所<strong>有线程共享</strong>的内存区域，当虚拟机启动的时候就会创建。它的作用主要是存放对象实例，几乎所有的对象实例都在这里分配内存。我们来看下Java虚拟机规范是怎么描述它的：</p><p>所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化</strong>技术将会导致一些微妙的变化发生，所有的对象都分配到堆上也渐渐变得不是那么”绝对“了。</p><p>这一块内存空间也是垃圾收集器管理的主要区域，所以有时候也被称为”GC堆“。</p><p>Java堆存在的<strong>问题：</strong></p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><p><strong>5、程序计数器</strong></p><p>程序计数器是<strong>线程私有</strong>的一块占用较小的内存空间，主要用于记录当前线程执行到哪里了。而且这也是<strong>唯一一个没有内存溢出</strong>的区域。</p><p><strong>6、直接内存</strong></p><p>除了以上几块内存空间外，还有一块内存空间就是直接内存，它不属于运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分频繁使用也可能导致OutOfMemoryError异常。NIO可以使用Native函数库直接分配堆外内存空间。</p><p><strong>文末小结</strong></p><p>关于jvm内存区域空间要重点关注<strong>方法区，程序计数器，Java虚拟机栈</strong>和<strong>Java堆</strong>这些内存区域的作用。只有在了解了虚拟机是怎么使用内存的之后，才能在出现内存溢出和泄漏时更快速的定位和排查解决问题。</p><p><mark>蚂蚁金服</mark>：</p><p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？</p><p>栈和堆的区别？</p><p>答：</p><ol><li><p>栈(stack)与堆(heap)都是Java用来在Ram(随机存储内存)中存放数据的地方。Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p></li><li><p>java内存的划分</p><p>（1）栈内存：基本类型的变量和对象的引用变量</p><pre><code>                   优势：存取速度比堆要快，仅次于直接位于CPU中的寄存器；  栈数据可以共享                   劣势：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性</code></pre><p>（2）堆内存：存放由new创建的对象和数组</p><pre><code>                   优势：动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据                   劣势：由于要在运行时动态分配内存，存取速度较慢</code></pre></li><li><p>内存的释放：</p><pre><code>（1）栈内存： 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 （2）堆内存：由Java虚拟机的自动垃圾回收器来管理。</code></pre></li></ol><p>一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？</p><p><strong>二面：Eden 和 survior 的比例分配</strong></p><p>答：8 : 1 : 1</p><p><mark>小米</mark>：</p><p>jvm 内存分区，为什么要有新生代和老年代</p><p>答：</p><p>其实不分代完全可以，分代的唯一理由就是<strong>优化 GC 性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p>答案一：</p><p>对于JVM而言，大部分对象都是属于一个朝生夕死的状态，这部分对象随着方法的调用而创建，方法的结束而消亡，只有少部分的对象会长久的留在JVM 内存中，所以根据这样的特性JVM 把内存分为了新生代 和老年代两个区，一般情况新创建的对象会放到新生代中，只有经过一定次数的GC后还没有被回收的对象，我们认为这部分对象在未来也会长时间存在，所以会把这部分的对象转移到老年代的区域中去。</p><p>答案二：</p><p>1）新生代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（from 和to）。<br>2）老年代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。</p></blockquote><blockquote><p><mark>字节跳动</mark>：</p><p>二面：Java 的内存分区</p><p>二面：讲讲 vm 运行时数据库区 什么时 候对象会进入老年代？</p><p>答：</p><ol><li><p><strong>长期存活的对象</strong>:虚拟机给每个对象定义了一个对象年龄(Age)计数器,如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1,。对象在Survivor区中每熬过一次Minor GC,年龄就增加1,当他的年龄增加到一定程度(默认是15岁), 就将会被晋升到老年代中。对象晋升到老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置。</p></li><li><p>当遇到<strong>超大对象</strong>时，发现新生代中的Eden区(即便进行了Minor GC)放不下，就会直接尝试放到老年代Tenured/OId，如果老年代也放不下，就触发Major GC 或 Full GC，之后老年代区能放得下就放，不能的话就报OOM。大对象对虚拟机的内存分配就是坏消息,尤其是一些朝生夕灭的短命大对象,写程序时应避免。</p></li><li><p><strong>动态对象年龄判定</strong>:为了能更好地适应不同程度的内存状况,虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代,如果在Survivor空间中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>, <strong>年龄大于或等于年龄的对象就可以直接进入老年代</strong>,无须等到MaxTenuringThreshold中要求的年龄。</p></li></ol><p><mark>京东</mark>：</p><p><strong>JVM 的内存结构，Eden 和 Survivor 比例。</strong> 8 ：1 ：1</p><p><strong>JVM 内存为什么要分成新生代，老年代，持久代。</strong></p><p><strong>新生代中为什么要分为 Eden 和 survivor。</strong></p><p>答：</p><ol><li><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多，大概是Minor GC的十倍以上, 如果Major GC触发次数多的话，就会降低性能，所以要尽可能避免或减少老年代触发Major GC。因此需要分为Eden和Survivor。</p></li><li><p>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p></li><li><p><strong>设置两个Survivor区最大的好处</strong>就是<font color="blue"><strong>解决了碎片化</strong></font>，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor spaceS1（这个过程非常重要，因为这种 <strong>复制算法 保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生</strong>）</p></li></ol><p><mark>天猫</mark>：</p><p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。</p><p>一面：JVM 的内存模型，Java8 做了什么改</p><p>答：</p><table><thead><tr><th style="text-align:left">JDK1.6 及之前</th><th style="text-align:left">有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td style="text-align:left"><strong>JDK1.7</strong></td><td style="text-align:left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td style="text-align:left"><strong>JDK1.8</strong></td><td style="text-align:left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td></tr></tbody></table><p>其中，String Table之所以要调整位置：</p><p>jdk7 中将 StringTable 放到了堆空间中。因为<strong>永久代的回收效率很低</strong>，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><p><mark>拼多多</mark>：</p><p>JVM 内存分哪几个区，每个区的作用是什么？</p><p><mark>美团</mark>：</p><p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？</p><p>一面：jvm 内存分区，为什么要有新生代和老年代？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
          <category> interview </category>
          
          <category> interview </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代理模式</title>
      <link href="/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="结构型模式"><a class="markdownIt-Anchor" href="#结构型模式"></a> 结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p><p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理模式</li><li>适配器模式</li><li>装饰者模式</li><li>桥接模式</li><li>外观模式</li><li>组合模式</li><li>享元模式</li></ul><h2 id="1-代理模式"><a class="markdownIt-Anchor" href="#1-代理模式"></a> 1 代理模式</h2><h3 id="1-概述"><a class="markdownIt-Anchor" href="#1-概述"></a> 1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p><p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p><h3 id="2-结构"><a class="markdownIt-Anchor" href="#2-结构"></a> 2 结构</h3><p>代理（Proxy）模式分为三种角色：</p><ul><li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li><li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li><li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li></ul><h3 id="3-静态代理"><a class="markdownIt-Anchor" href="#3-静态代理"></a> 3 静态代理</h3><p>我们通过案例来感受一下静态代理。</p><p>【例】火车站卖票</p><p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"火车站卖票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//代售点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyPoint</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"代理点收取一些服务费用"</span>);</span><br><span class="line">        station.sell();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ProxyPoint</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyPoint</span>();</span><br><span class="line">        pp.sell();</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221119220401804.png" alt="image-20221119220401804"></p><p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p><h3 id="4-jdk动态代理"><a class="markdownIt-Anchor" href="#4-jdk动态代理"></a> 4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//卖票接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"火车站卖票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂，用来创建代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//使用Proxy获取代理对象</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            newProxyInstance()方法参数说明：</span></span><br><span class="line"><span class="comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span></span><br><span class="line"><span class="comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span></span><br><span class="line"><span class="comment">                InvocationHandler h ： 代理对象的调用处理程序</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        InvocationHandler中invoke方法参数说明：</span></span><br><span class="line"><span class="comment">                            proxy ： 代理对象</span></span><br><span class="line"><span class="comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span></span><br><span class="line"><span class="comment">                            args ： 代理对象调用接口方法时传递的实际参数</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"代理点收取一些服务费用(JDK动态代理方式)"</span>);</span><br><span class="line">                        <span class="comment">//执行真实对象</span></span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p><font color="red">使用了动态代理，我们思考下面问题：</font></p><ul><li><p>ProxyFactory是代理类吗？</p><p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.UndeclaredThrowableException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) {</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.itheima.proxy.dynamic.jdk.SellTickets"</span>).getMethod(<span class="string">"sell"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException noSuchMethodException) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchMethodError</span>(noSuchMethodException.getMessage());</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException classNotFoundException) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoClassDefFoundError</span>(classNotFoundException.getMessage());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object object)</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m1, <span class="keyword">new</span> <span class="title class_">Object</span>[]{object});</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m2, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m0, <span class="literal">null</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Error | RuntimeException throwable) {</span><br><span class="line">            <span class="keyword">throw</span> throwable;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (Throwable throwable) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UndeclaredThrowableException</span>(throwable);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p>从上面的类中，我们可以看到以下几个信息：</p><ul><li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li><li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li></ul></li><li><p>动态代理的执行流程是什么样？</p><p>下面是摘取的重点代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//程序运行过程中动态生成的代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">$Proxy0</span> <span class="keyword">extends</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">SellTickets</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler invocationHandler) {</span><br><span class="line">        <span class="built_in">super</span>(invocationHandler);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        m3 = Class.forName(<span class="string">"com.itheima.proxy.dynamic.jdk.SellTickets"</span>).getMethod(<span class="string">"sell"</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[<span class="number">0</span>]);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.h.invoke(<span class="built_in">this</span>, m3, <span class="literal">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//Java提供的动态代理相关类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Proxy</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable {</span><br><span class="line">    <span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Proxy</span><span class="params">(InvocationHandler h)</span> {</span><br><span class="line">        <span class="built_in">this</span>.h = h;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">station</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SellTickets <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">sellTickets</span> <span class="operator">=</span> (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),</span><br><span class="line">                station.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>() {</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line"></span><br><span class="line">                        System.out.println(<span class="string">"代理点收取一些服务费用(JDK动态代理方式)"</span>);</span><br><span class="line">                        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(station, args);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">        <span class="keyword">return</span> sellTickets;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试访问类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="type">SellTickets</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure></li></ul><p>执行流程如下：</p><ol><li>在测试类中通过代理对象调用sell()方法</li><li>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</li><li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</li><li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li></ol><h3 id="515-cglib动态代理"><a class="markdownIt-Anchor" href="#515-cglib动态代理"></a> 5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p><p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p><p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p><p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span>Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//火车站</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrainStation</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sell</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"火车站卖票"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> <span class="keyword">implements</span> <span class="title class_">MethodInterceptor</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">TrainStation</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TrainStation</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">getProxyObject</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">//创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数</span></span><br><span class="line">        <span class="type">Enhancer</span> <span class="variable">enhancer</span> <span class="operator">=</span><span class="keyword">new</span> <span class="title class_">Enhancer</span>();</span><br><span class="line">        <span class="comment">//设置父类的字节码对象</span></span><br><span class="line">        enhancer.setSuperclass(target.getClass());</span><br><span class="line">        <span class="comment">//设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="built_in">this</span>);</span><br><span class="line">        <span class="comment">//创建代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">obj</span> <span class="operator">=</span> (TrainStation) enhancer.create();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        intercept方法参数说明：</span></span><br><span class="line"><span class="comment">            o ： 代理对象</span></span><br><span class="line"><span class="comment">            method ： 真实对象中的方法的Method实例</span></span><br><span class="line"><span class="comment">            args ： 实际参数</span></span><br><span class="line"><span class="comment">            methodProxy ：代理对象中的方法的method实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> TrainStation <span class="title function_">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        System.out.println(<span class="string">"代理点收取一些服务费用(CGLIB动态代理方式)"</span>);</span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">result</span> <span class="operator">=</span> (TrainStation) methodProxy.invokeSuper(o, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//创建代理工厂对象</span></span><br><span class="line">        <span class="type">ProxyFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>();</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        <span class="type">TrainStation</span> <span class="variable">proxyObject</span> <span class="operator">=</span> factory.getProxyObject();</span><br><span class="line"></span><br><span class="line">        proxyObject.sell();</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure><h3 id="516-三种代理的对比"><a class="markdownIt-Anchor" href="#516-三种代理的对比"></a> 5.1.6 三种代理的对比</h3><ul><li><p>jdk代理和CGLIB代理</p><p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p><p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p></li><li><p>动态代理和静态代理</p><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p><p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p></li></ul><h3 id="517-优缺点"><a class="markdownIt-Anchor" href="#517-优缺点"></a> 5.1.7 优缺点</h3><p><strong>优点：</strong></p><ul><li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li><li>代理对象可以扩展目标对象的功能；</li><li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li></ul><p><strong>缺点：</strong></p><ul><li>增加了系统的复杂度；</li></ul><h3 id="518-使用场景"><a class="markdownIt-Anchor" href="#518-使用场景"></a> 5.1.8 使用场景</h3><ul><li><p>远程（Remote）代理</p><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p></li><li><p>防火墙（Firewall）代理</p><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p></li><li><p>保护（Protect or Access）代理</p><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 结构型模式 </category>
          
          <category> 原型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 结构型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建者模式对比</title>
      <link href="/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/"/>
      <url>/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94/</url>
      
        <content type="html"><![CDATA[<h1 id="创建者模式对比"><a class="markdownIt-Anchor" href="#创建者模式对比"></a> <strong>创建者模式对比</strong></h1><h2 id="工厂方法模式vs建造者模式"><a class="markdownIt-Anchor" href="#工厂方法模式vs建造者模式"></a> <strong>工厂方法模式VS建造者模式</strong></h2><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p><p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p><h2 id="抽象工厂模式vs建造者模式"><a class="markdownIt-Anchor" href="#抽象工厂模式vs建造者模式"></a> <strong>抽象工厂模式VS建造者模式</strong></h2><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p><p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p><p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建者模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>黑马教程：</p><p><strong>1. 概述</strong></p><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p><p><strong>2. 结构</strong></p><p>原型模式包含如下角色：</p><p>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</p><p>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</p><p>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</p><p>接口类图如下</p><p><img src="../../../images/image-20221119212633976.png" alt="image-20221119212633976"></p><p><strong>3.实现</strong></p><p>原型模式的克隆分为浅克隆和深克隆。</p><p><strong>浅克隆</strong>：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p><p><strong>深克隆</strong>：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p><p>Java中的Object类中提供了 clone() 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽</p><p>象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。</p><p><img src="../../../images/image-20221119205017889.png" alt="image-20221119205017889"></p><p>clone()底层不是通过new一个对象来clone一个对象的，所以达到了克隆的效果</p><p><strong>4. 使用场景</strong></p><p>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</p><p>性能和安全要求比较高。</p><p><strong>5. 扩展（深克隆）</strong></p><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p><p><img src="../../../images/image-20221119212329160.png" alt="image-20221119212329160"></p><p><img src="../../../images/image-20221119212340510.png" alt="image-20221119212340510"></p><p><strong>说明：</strong></p><p>stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用<strong>对象流</strong>。代码如下：</p><p><img src="../../../images/image-20221119212418981.png" alt="image-20221119212418981"></p><p><strong>注意：</strong></p><p>Citation类和Student类必须实现<strong>Serializable</strong>接口，否则会抛</p><p>NotSerializableException异常。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建者模式 </category>
          
          <category> 原型模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7. 方法区</title>
      <link href="/2022/11/19/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7.%20%E6%96%B9%E6%B3%95%E5%8C%BA/"/>
      <url>/2022/11/19/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7.%20%E6%96%B9%E6%B3%95%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="7-方法区"><a class="markdownIt-Anchor" href="#7-方法区"></a> 7. 方法区</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/b802b35c3936900c290f8ad123e68b9b.png" alt="image-20210510141044840"></p><p>从线程共享与否的角度来看</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f356e103d9f75e3c0086079bba2b28a9.png" alt="image-20210510141131860"></p><p>程序计数器 ： 不会报异常，没有GC</p><p>虚拟机栈、方法栈：有异常，没有GC</p><p>堆、元空间：有异常、有GC</p><h2 id="71-栈-堆-方法区的交互关系"><a class="markdownIt-Anchor" href="#71-栈-堆-方法区的交互关系"></a> 7.1. 栈、堆、方法区的交互关系</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/b9f11764ee47b28d37f7764dfd9c9f55.png" alt="image-20200708094747667"></p><h2 id="72-方法区的理解"><a class="markdownIt-Anchor" href="#72-方法区的理解"></a> 7.2. 方法区的理解</h2><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4">Chapter 2. The Structure of the Java Virtual Machine (oracle.com)</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/ec22e5d6086dd6219195b2d886118d65.png" alt="image-20210510195446194"></p><h3 id="721-方法区在哪里"><a class="markdownIt-Anchor" href="#721-方法区在哪里"></a> 7.2.1. 方法区在哪里？</h3><p>《Java 虚拟机规范》中明确说明：“尽管所有的方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。”但对于 HotSpotJVM 而言，方法区还有一个别名叫做 Non-Heap（非堆），目的就是要和堆分开。</p><p>所以，<mark>方法区看作是一块独立于 Java 堆的内存空间</mark>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6a7f2350e0f4e0cde0ac246225e2acdd.png" alt="image-20200708095853544"></p><h3 id="722-方法区的基本理解"><a class="markdownIt-Anchor" href="#722-方法区的基本理解"></a> 7.2.2. 方法区的基本理解</h3><ul><li>方法区（Method Area）与 Java 堆一样，是各个线程共享的内存区域。</li><li>方法区在 JVM 启动的时候被创建，并且它的实际的物理内存空间中和 Java 堆区一样都可以是不连续的。</li><li>方法区的大小，跟堆空间一样，可以选择固定大小或者可扩展。</li><li>方法区的大小决定了系统可以保存多少个类，如果系统定义了太多的类，导致方法区溢出，虚拟机同样会抛出内存溢出错误：<code>java.lang.OutOfMemoryError: PermGen space</code> 或者<code>java.lang.OutOfMemoryError: Metaspace</code><ul><li>场景有：<mark>加载大量的第三方的 jar 包；Tomcat 部署的工程过多（30~50 个）；大量动态的生成反射类</mark></li></ul></li><li>关闭 JVM 就会释放这个区域的内存。</li></ul><p><img src="../../../images/image-20221119143002557.png" alt="image-20221119143002557"></p><p><img src="../../../images/image-20221119142804322.png" alt="image-20221119142804322"></p><h3 id="723-hotspot-中方法区的演进"><a class="markdownIt-Anchor" href="#723-hotspot-中方法区的演进"></a> 7.2.3. HotSpot 中方法区的演进</h3><p>在 jdk7 及以前，习惯上把方法区，称为永久代。jdk8 开始，使用元空间取代了永久代。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/fb71df89c52f89d3b711e0b648de244c.png" alt="image-20210510142516373"></p><p>本质上，方法区和永久代并不等价。仅是对 hotspot 而言的。《Java 虚拟机规范》对如何实现方法区，不做统一要求。例如：BEA JRockit / IBM J9 中不存在永久代的概念。</p><p>现在来看，当年使用永久代，不是好的 idea。导致 Java 程序更容易 OOM（超过<code>-XX:MaxPermsize</code>上限）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d0789c206d53bfb4b6004052236197a.png" alt="image-20210510142656677"></p><p>而到了 JDK8，终于完全废弃了永久代的概念，改用与 JRockit、J9 一样在本地内存中实现的元空间（Metaspace）来代替</p><p><img src="https://img-blog.csdnimg.cn/img_convert/1c229dc39ffc79e8e4f3abf765378d3b.png" alt="image-20200708103055914"></p><p>元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。不过元空间与永久代最大的区别在于：<mark><strong>元空间</strong>不在虚拟机设置的内存中，而是使用<strong>本地内存</strong></mark></p><p>永久代、元空间二者并不只是名字变了，内部结构也调整了</p><p>根据《Java 虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OOM 异常</p><h2 id="73-设置方法区大小与-oom"><a class="markdownIt-Anchor" href="#73-设置方法区大小与-oom"></a> 7.3. 设置方法区大小与 OOM</h2><h3 id="731-设置方法区内存的大小"><a class="markdownIt-Anchor" href="#731-设置方法区内存的大小"></a> 7.3.1. 设置方法区内存的大小</h3><p>方法区的大小不必是固定的，JVM 可以根据应用的需要<strong>动态调整</strong>。</p><p><strong>jdk7 及以前</strong></p><ul><li><mark>通过<code>-XX:Permsize</code>来设置永久代初始分配空间。默认值是 20.75M</mark></li><li><mark>通过<code>-XX:MaxPermsize</code>来设定永久代最大可分配空间。32 位机器默认是 64M，64 位机器模式是 82M</mark></li><li>当 JVM 加载的类信息容量超过了这个值，会报异常<code>OutOfMemoryError:PermGen space</code>。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/79ec6c83a9b6a4a7281c2ef5442f18ce.png" alt="image-20200708111756800"></p><p><strong>JDK8 以后</strong></p><ul><li>元数据区大小可以使用参数 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>指定</li><li>默认值依赖于平台。windows 下，<code>-XX:MetaspaceSize=21M -XX:MaxMetaspaceSize=-1 //即没有限制</code>。</li><li>与永久代不同，如果不指定大小，默认情况下，虚拟机会耗尽所有的可用系统内存。如果元数据区发生溢出，虚拟机一样会抛出异常<code>OutOfMemoryError:Metaspace</code></li><li><code>-XX:MetaspaceSize</code>：设置初始的元空间大小。对于一个 64 位的服务器端 JVM 来说，其默认的<code>-XX:MetaspaceSize</code>值为 21MB。这就是初始的高水位线，一旦触及这个水位线，Full GC 将会被触发并卸载没用的类（即这些类对应的类加载器不再存活），然后这个高水位线将会重置。新的高水位线的值取决于 GC 后释放了多少元空间。如果释放的空间不足，那么在不超过<code>MaxMetaspaceSize</code>时，适当提高该值。如果释放空间过多，则适当降低该值。</li><li>如果初始化的高水位线设置过低，上述高水位线调整情况会发生很多次。通过垃圾回收器的日志可以观察到 Full GC 多次调用。为了避免频繁地 GC，建议将<code>-XX:MetaspaceSize</code>设置为一个相对较高的值。</li></ul><p><img src="../../../images/image-20221119144559401.png" alt="image-20221119144559401"></p><p><strong>举例 1：《深入理解 Java 虚拟机》的例子</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6d1f5d0e7f035df53d16a16451781677.png" alt="image-20210510143959924"></p><p><strong>举例 2</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jdk8中：</span></span><br><span class="line"><span class="comment"> * -XX:MetaspaceSize=10m-XX:MaxMetaspaceSize=10m</span></span><br><span class="line"><span class="comment"> * jdk6中：</span></span><br><span class="line"><span class="comment"> * -XX:PermSize=10m-XX:MaxPermSize=10m</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="type">OOMTest</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OOMTest</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++){</span><br><span class="line">                <span class="comment">//创建Classwriter对象，用于生成类的二进制字节码</span></span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">classWriter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>);</span><br><span class="line">                <span class="comment">//指明版本号，public，类名，包名，父类，接口</span></span><br><span class="line">                classWriter.visit(Opcodes.V1_6, Opcodes.ACC_PUBLIC, <span class="string">"Class"</span> + i, nu1l, <span class="string">"java/lang/Object"</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = classWriter.toByteArray();</span><br><span class="line">                <span class="comment">//类的加载</span></span><br><span class="line">                test.defineClass(<span class="string">"Class"</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">//CLass对象</span></span><br><span class="line">                j++;</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">finally</span>{</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="732-如何解决这些-oom"><a class="markdownIt-Anchor" href="#732-如何解决这些-oom"></a> 7.3.2. 如何解决这些 OOM</h3><ol><li><p>要解决 OOM 异常或 heap space 的异常，一般的手段是首先通过内存映像分析工具（如 Eclipse Memory Analyzer）对 dump 出来的堆转储快照进行分析，重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）</p></li><li><p>如果是<strong>内存泄漏</strong>，可进一步通过工具查看泄漏对象到 GC Roots 的引用链。于是就能找到泄漏对象是通过怎样的路径与 GCRoots 相关联并导致垃圾收集器无法自动回收它们的。掌握了泄漏对象的类型信息，以及 GCRoots 引用链的信息，就可以比较准确地定位出泄漏代码的位置。</p></li><li><p>如果<strong>不存在内存泄漏</strong>，换句话说就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（<code>-Xmx</code>与<code>-Xms</code>），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p></li></ol><h2 id="74-方法区的内部结构"><a class="markdownIt-Anchor" href="#74-方法区的内部结构"></a> 7.4. 方法区的内部结构</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/8a5fcba10ccb773f185288ac22bde206.png" alt="image-20200708161728320"></p><h3 id="741-方法区method-area存储什么"><a class="markdownIt-Anchor" href="#741-方法区method-area存储什么"></a> 7.4.1. 方法区（Method Area）存储什么？</h3><p>《深入理解 Java 虚拟机》书中对方法区（Method Area）存储内容描述如下：</p><blockquote><p><strong>它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等。</strong></p></blockquote><p><img src="https://img-blog.csdnimg.cn/img_convert/fbe3915506e7979c7d591d17c216fbb1.png" alt="image-20200708161856504"></p><h3 id="742-方法区的内部结构"><a class="markdownIt-Anchor" href="#742-方法区的内部结构"></a> 7.4.2. 方法区的内部结构</h3><h4 id="类型信息"><a class="markdownIt-Anchor" href="#类型信息"></a> 类型信息</h4><p>对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储以下类型信息：</p><ol><li>这个类型的完整有效名称（全名=包名.类名）</li><li>这个类型直接父类的完整有效名（对于 interface 或是 java.lang.object，都没有父类）</li><li>这个类型的修饰符（public，abstract，final 的某个子集）</li><li>这个类型直接接口的一个有序列表</li></ol><h4 id="域field信息"><a class="markdownIt-Anchor" href="#域field信息"></a> 域（Field）信息</h4><p>JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序。</p><p>域的相关信息包括：域名称、域类型、域修饰符（public，private，protected，static，final，volatile，transient 的某个子集）</p><h4 id="方法method信息"><a class="markdownIt-Anchor" href="#方法method信息"></a> 方法（Method）信息</h4><p>JVM 必须保存所有方法的以下信息，同域信息一样包括声明顺序：</p><ol><li>方法名称</li><li>方法的返回类型（或 void）</li><li>方法参数的数量和类型（按顺序）</li><li>方法的修饰符（public，private，protected，static，final，synchronized，native，abstract 的一个子集）</li><li>方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）</li><li>异常表（abstract 和 native 方法除外）<ul><li>每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引</li></ul></li></ol><p><strong>ps :</strong></p><p>将class字节码文件进行反编译的信息，都会被类加载器加载到方法区当中（参与加载的类加载器也会被记录到方法区中），方法区会记录到class字节码文件是被哪个类加载器加载的，而类加载器也会记录到它加载了哪个字节码文件</p><h4 id="non-final-的类变量"><a class="markdownIt-Anchor" href="#non-final-的类变量"></a> non-final 的类变量</h4><ul><li>静态变量和类关联在一起，随着类的加载而加载，他们成为类数据在逻辑上的一部分</li><li><strong>类变量被类的所有实例共享，即使没有类实例时，你也可以访问它</strong></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">        order.hello();</span><br><span class="line">        System.out.println(order.count);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221119155721374.png" alt="image-20221119155721374"></p><h4 id="补充说明全局常量static-final"><a class="markdownIt-Anchor" href="#补充说明全局常量static-final"></a> 补充说明：全局常量（static final）</h4><p>被声明为 final 的类变量的处理方法则不同，每个全局常量在编译的时候就会被分配了。</p><p><img src="../../../images/image-20221119161339371.png" alt="image-20221119161339371"></p><h3 id="743-运行时常量池-vs-常量池"><a class="markdownIt-Anchor" href="#743-运行时常量池-vs-常量池"></a> 7.4.3. 运行时常量池 VS 常量池</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7ec9b450764c623c89e7de7e0d3c8d19.png" alt="image-20200708171151384"></p><p>Class File字节码文件当中的常量池（Constant pool）加载到方法区以后，对应的结构就叫做运行时常量池</p><ul><li>方法区，内部包含了运行时常量池</li><li>字节码文件，内部包含了常量池</li><li>要弄清楚方法区，需要理解清楚 ClassFile，因为加载类的信息都在方法区。</li><li>要弄清楚方法区的运行时常量池，需要理解清楚 ClassFile 中的常量池。</li></ul><p>官方文档：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html</a></p><p><img src="https://img-blog.csdnimg.cn/img_convert/be6d675673b353a266d48df43b0411f4.png" alt="image-20200708172357052"></p><p>一个有效的字节码文件中除了包含类的版本信息、字段、方法以及接口等描述符信息外，还包含一项信息就是常量池表（Constant Pool Table），包括各种字面量和对类型、域和方法的符号引用</p><p>ps（</p><p><strong>字面量：</strong></p><p>是指由字母，数字等构成的<a href="https://so.csdn.net/so/search?q=%E5%AD%97%E7%AC%A6%E4%B8%B2&amp;spm=1001.2101.3001.7020">字符串</a>或者数值，它只能作为右值出现，所谓右值是指等号右边的值，如：int a=123这里的a为左值，123为右值。</p><p><strong>常量：</strong></p><p>常量和变量都属于变量，只不过常量是赋过值后不能再改变的变量，而普通的变量可以再进行赋值操作</p><p>在java中，常量必须使用final修饰，表示不可修改，而且通常会把常量的名称全部大写，用以区别变量</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// a是变量，10是字面量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">A</span> <span class="operator">=</span> <span class="number">10</span>;<span class="comment">// A是常量，10是字面量，在java中，常量必须使用final修饰，表示不可修改，而且通常会把常量的名称全部大写，用以区别变量</span></span><br></pre></td></tr></tbody></table></figure><p>）</p><h4 id="为什么需要常量池"><a class="markdownIt-Anchor" href="#为什么需要常量池"></a> 为什么需要常量池？</h4><p>一个 java 源文件中的类、接口，编译后产生一个字节码文件。而 Java 中的字节码需要数据支持，通常这种数据会很大以至于不能直接存到字节码里，换另一种方式，可以存到常量池，这个字节码包含了指向常量池的引用。在动态链接的时候会用到运行时常量池，之前有介绍。</p><p>比如：如下的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleClass</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虽然只有 194 字节，但是里面却使用了 String、System、PrintStream 及 Object 等结构。这里的代码量其实很少了，如果代码多的话，引用的结构将会更多，这里就需要用到常量池了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/86cc8ce43ce5bcc9b2b167188b839a1b.png" alt="image-20210510145947122"></p><h4 id="常量池中有什么"><a class="markdownIt-Anchor" href="#常量池中有什么"></a> 常量池中有什么?</h4><p>击中常量池内存储的数据类型包括：</p><ul><li>数量值</li><li>字符串值</li><li>类引用</li><li>字段引用</li><li>方法引用</li></ul><p>例如下面这段代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaTest2</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>Object obj = new Object();</code>将会被翻译成如下字节码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: <span class="keyword">new</span> #<span class="number">2</span>  <span class="comment">// Class java/lang/Object</span></span><br><span class="line"><span class="number">1</span>: dup</span><br><span class="line"><span class="number">2</span>: invokespecial <span class="comment">// Method java/lang/Object "&lt;init&gt;"() V</span></span><br></pre></td></tr></tbody></table></figure><h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4><p>常量池、可以看做是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等类型</p><h3 id="744-运行时常量池"><a class="markdownIt-Anchor" href="#744-运行时常量池"></a> 7.4.4. 运行时常量池</h3><ul><li>运行时常量池（Runtime Constant Pool）是方法区的一部分。</li><li><mark>常量池表（Constant Pool Table）是 Class 文件的一部分，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。</mark></li><li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li><li>JVM 为每个已加载的类型（类或接口）都维护一个常量池。池中的数据项像数组项一样，是通过<mark>索引访问</mark>的。</li><li>运行时常量池中包含多种不同的常量，包括编译期就已经明确的数值字面量，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，这里换为<mark>真实地址</mark>。</li><li>运行时常量池，相对于 Class 文件常量池的另一重要特征是：具备<mark>动态性</mark>。</li><li>运行时常量池类似于传统编程语言中的符号表（symboltable），但是它所包含的数据却比符号表要更加丰富一些。</li><li>当创建类或接口的运行时常量池时，如果构造运行时常量池所需的内存空间超过了方法区所能提供的最大值，则 JVM 会抛 OutOfMemoryError 异常。</li></ul><h2 id="75-方法区使用举例"><a class="markdownIt-Anchor" href="#75-方法区使用举例"></a> 7.5. 方法区使用举例</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MethodAreaDemo</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        System.out.println(a+b);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/b5b9e7f8efd1cf8e889650cea5318b61.png" alt="image-20210510151436251"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/84396fa6be6164ffc54868e78c59dde6.png" alt="image-20210510151504259"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/2214af3dfe294eec73899c935589f569.png" alt="image-20210510151520952"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/64b6b95d37e97205b2f23a089addf321.png" alt="image-20210510151609566"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/692908400668791ac383561affed3520.png" alt="image-20210510151648231"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/885b0a628db8e5d96bd270b6c1073bc6.png" alt="image-20210510151712355"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/922d24be85f3ac3bf951e81bc1101e3d.png" alt="image-20210510151753579"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/67615b1384f553cab185a32460e607eb.png" alt="image-20210510151829404"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/4b80397e4e7a553cc7d7f0f9a8b38d1d.png" alt="image-20210510151918342"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bcc93f31b5dc95f4676dbd49ecc095d7.png" alt="image-20210510151951327"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/dfba814e0c1b198df7175fe93284c3e0.png" alt="image-20200708205708057"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/35be7c27bee2aa8c0930cffbefa07cd8.png" alt="image-20210510152102989"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/5f2935ec0858f5a74f512018e582f19c.png" alt="image-20210510152138492"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f584ed9e2b6d99499b2a451a63f12449.png" alt="image-20210510195824437"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b4428f7f351048601296fe211c40185e.png" alt="image-20210510195911639"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/bf50cc494594b4588794984df6448303.png" alt="image-20210510152243933"></p><h2 id="76-方法区的演进细节可能是面试热点"><a class="markdownIt-Anchor" href="#76-方法区的演进细节可能是面试热点"></a> 7.6. 方法区的演进细节（可能是面试热点）</h2><ol><li>首先明确：只有 Hotspot 才有永久代。BEA JRockit、IBMJ9 等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java 虚拟机规范》管束，并不要求统一</li><li>Hotspot 中方法区的变化：</li></ol><table><thead><tr><th style="text-align:left">JDK1.6 及之前</th><th style="text-align:left">有永久代（permanet），静态变量存储在永久代上</th></tr></thead><tbody><tr><td style="text-align:left"><strong>JDK1.7</strong></td><td style="text-align:left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td></tr><tr><td style="text-align:left"><strong>JDK1.8</strong></td><td style="text-align:left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td></tr></tbody></table><p><img src="https://img-blog.csdnimg.cn/img_convert/1a3aa55257c3150d78327542e5ca230e.png" alt="image-20200708211541300"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0f65fc4228d9b6573ae1b23d9a1558b.png" alt="image-20200708211609911"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/c3ed969b0d2bad704c22481208e5dd10.png" alt="image-20200708211637952"></p><h3 id="761-为什么永久代要被元空间替代"><a class="markdownIt-Anchor" href="#761-为什么永久代要被元空间替代"></a> 7.6.1. 为什么永久代要被元空间替代？</h3><p>官网地址：<a href="http://openjdk.java.net/jeps/122">JEP 122: Remove the Permanent Generation (java.net)</a></p><p><img src="../../../images/image-20221119175908561.png" alt="image-20221119175908561"></p><p>JRockit 是和 HotSpot 融合后的结果，因为 JRockit 没有永久代，所以他们不需要配置永久代</p><p>随着 Java8 的到来，HotSpot VM 中再也见不到永久代了。但是这并不意味着类的元数据信息也消失了。这些数据被移到了一个<mark>与堆不相连的<strong>本地内存</strong>区域，这个区域叫做元空间（Metaspace）</mark>。</p><p>由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。</p><p>这项改动是很有必要的，原因有：</p><ul><li><p><strong>为永久代设置空间大小是很难确定的</strong>。</p><ul><li>在某些场景下，如果动态加载类过多，容易产生 Perm 区的 oom。比如某个实际 Web 工 程中，因为功能点比较多，在运行过程中，要不断动态加载很多类，经常出现致命错误。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Exception in thread 'dubbo client x.x connector' java.lang.OutOfMemoryError:PermGen space"</span></span><br></pre></td></tr></tbody></table></figure><p>而元空间和永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。 因此，默认情况下，元空间的大小仅受本地内存限制。</p></li><li><p><strong>对永久代进行调优是很困难的。</strong></p></li></ul><p>有些人认为方法区（如 HotSpot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK 11 时期的 ZGC 收集器就不支持类卸载）。 一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻。但是这部分区域的回收有时又确实是必要的。以前 Sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏</p><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</p><h3 id="762-stringtable-为什么要调整位置"><a class="markdownIt-Anchor" href="#762-stringtable-为什么要调整位置"></a> 7.6.2. StringTable 为什么要调整位置？</h3><p>jdk7 中将 StringTable 放到了堆空间中。因为<strong>永久代的回收效率很低</strong>，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p><p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p><h3 id="763-静态变量存放在那里"><a class="markdownIt-Anchor" href="#763-静态变量存放在那里"></a> 7.6.3. 静态变量存放在那里？</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态引用对应的对象实体始终都存在堆空间</span></span><br><span class="line"><span class="comment"> * jdk7:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m -XX:PermSize=300m -XX:MaxPermSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> * jdk8:</span></span><br><span class="line"><span class="comment"> * -Xms200m -Xmx200m-XX:MetaspaceSize=300m -XX:MaxMetaspaceSize=300m -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFieldTest</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">100</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(StaticFieldTest.arr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** * staticobj、instanceobj、Localobj存放在哪里？ */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticobjTest</span> {   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> {        </span><br><span class="line">        <span class="keyword">static</span> <span class="type">ObjectHolder</span> <span class="variable">staticobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();       </span><br><span class="line">        <span class="type">ObjectHolder</span> <span class="variable">instanceobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();     </span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">()</span>{          </span><br><span class="line">            <span class="type">ObjectHolder</span> <span class="variable">localobj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectHolder</span>();     </span><br><span class="line">            System.out.println(<span class="string">"done"</span>);      </span><br><span class="line">        }      </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ObjectHolder</span>{      </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {  </span><br><span class="line">            <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StaticobjTest</span>.Test();     </span><br><span class="line">            test.foo();      </span><br><span class="line">        } </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 JHSDB 工具进行分析，这里细节略掉</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e8ced63603ee4a62c9eb7d4c48ae94dd.png" alt="image-20200708215218078"></p><p>staticobj 随着 Test 的类型信息存放在方法区，instanceobj 随着 Test 的对象实例存放在 Java 堆，localobject 则是存放在 foo()方法栈帧的局部变量表中。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e7c6b3dd5175466ee891da9e84577418.png" alt="image-20200708215025527"></p><p>测试发现：三个对象的数据在内存中的地址都落在 Eden 区范围内，所以结论：只要是对象实例必然会在 Java 堆中分配。</p><p>接着，找到了一个引用该 staticobj 对象的地方，是在一个 java.lang.Class 的实例里，并且给出了这个实例的地址，通过 Inspector 查看该对象实例，可以清楚看到这确实是一个 java.lang.Class 类型的对象实例，里面有一个名为 staticobj 的实例字段：</p><p>从《Java 虚拟机规范》所定义的概念模型来看，所有 Class 相关的信息都应该存放在方法区之中，但方法区该如何实现，《Java 虚拟机规范》并未做出规定，这就成了一件允许不同虚拟机自己灵活把握的事情。<strong>JDK7 及其以后版本的 HotSpot 虚拟机选择把静态变量与类型在 Java 语言一端的映射 Class 对象存放在一起，存储于 Java 堆之中，从我们的实验中也明确验证了这一点</strong></p><h2 id="77-方法区的垃圾回收"><a class="markdownIt-Anchor" href="#77-方法区的垃圾回收"></a> 7.7. 方法区的垃圾回收</h2><p>有些人认为方法区（如 Hotspot 虚拟机中的元空间或者永久代）是没有垃圾收集行为的，其实不然。<strong>《Java 虚拟机规范》对方法区的约束是非常宽松的，提到过可以不要求虚拟机在方法区中实现垃圾收集</strong>。事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如 JDK11 时期的 zGC 收集器就不支持类卸载）。</p><p>一般来说<mark>这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻</mark>。但是这部分区域的回收<mark>有时又确实是必要的</mark>。以前 sun 公司的 Bug 列表中，曾出现过的若干个严重的 Bug 就是由于低版本的 HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。</p><p><mark>方法区的垃圾收集主要回收两部分内容：<strong>常量池中废弃的常量</strong>和<strong>不再使用的类型</strong>。</mark></p><p>先来说说方法区内常量池之中主要存放的两大类常量：字面量和符号引用。字面量比较接近 Java 语言层次的常量概念，如文本字符串、被声明为 final 的常量值等。而符号引用则属于编译原理方面的概念，包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul><p>HotSpot 虚拟机对常量池的回收策略是很明确的，<mark>只要常量池中的常量没有被任何地方引用，就可以被回收</mark>。</p><p>回收废弃常量与回收 Java 堆中的对象非常类似。</p><p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p><ul><li><p><mark>该类所有的实例都已经被回收</mark>，也就是 Java 堆中不存在该类及其任何派生子类的实例。</p></li><li><p><mark>加载该类的类加载器已经被回收</mark>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP 的重加载等，否则通常是很难达成的。</p></li><li><p><mark>该类对应的 java.lang.Class 对象没有在任何地方被引用</mark>，无法在任何地方通过反射访问该类的方法。</p></li></ul><p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。关于是否要对类型进行回收，HotSpot 虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code> 以及 <code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息</p><p>在大量使用反射、动态代理、CGLib 等字节码框架，动态生成 JSP 以及 OSGi 这类频繁自定义类加载器的场景中，<u>通常都需要 Java 虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压力</u>。</p><h2 id="运行时数据区的总结以及常见大厂面试题"><a class="markdownIt-Anchor" href="#运行时数据区的总结以及常见大厂面试题"></a> 运行时数据区的总结以及常见大厂面试题</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f73315a70302396e391a532dcf87ce26.png" alt="image-20200708220303243"></p><p>线程私有的：程序计数器、本地方法栈、虚拟机栈</p><p>虚拟机栈里的栈帧的结构：返回值、局部变量表、操作数栈、动态链接（装着指向运行时常量池的当前方法的引用，知道当前方法是引用运行时常量池中的哪个方法）</p><p><img src="../../../images/image-20221120105434202.png" alt="image-20221120105434202"></p><h2 id="常见面试题"><a class="markdownIt-Anchor" href="#常见面试题"></a> 常见面试题</h2><blockquote><p><mark>百度</mark>：</p><p>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</p><p><mark>蚂蚁金服</mark>：</p><p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？</p><p>一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？</p><p>二面：Eden 和 survior 的比例分配</p><p><mark>小米</mark>：</p><p>jvm 内存分区，为什么要有新生代和老年代</p><p><mark>字节跳动</mark>：</p><p>二面：Java 的内存分区</p><p>二面：讲讲 vm 运行时数据库区 什么时候对象会进入老年代？</p><p><mark>京东</mark>：</p><p>JVM 的内存结构，Eden 和 Survivor 比例。</p><p>JVM 内存为什么要分成新生代，老年代，持久代。</p><p>新生代中为什么要分为 Eden 和 survivor。</p><p><mark>天猫</mark>：</p><p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。</p><p>一面：JVM 的内存模型，Java8 做了什么改</p><p><mark>拼多多</mark>：</p><p>JVM 内存分哪几个区，每个区的作用是什么？</p><p><mark>美团</mark>：</p><p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？</p><p>一面：jvm 内存分区，为什么要有新生代和老年代？</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(JVM)逃逸分析：代码优化</title>
      <link href="/2022/11/19/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/"/>
      <url>/2022/11/19/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%EF%BC%9A%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="堆是分配对象的唯一选择么"><a class="markdownIt-Anchor" href="#堆是分配对象的唯一选择么"></a> 堆是分配对象的唯一选择么？</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p><blockquote><p>随着 JIT 编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并<strong>没有逃逸出方法</strong>的话，那么就<strong>可能被优化成栈上分配</strong></mark>.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</p><p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p><h3 id="1-逃逸分析概述"><a class="markdownIt-Anchor" href="#1-逃逸分析概述"></a> 1. 逃逸分析概述</h3><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><strong>举例 1</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参数设置</strong></p><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>"显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>"查看逃逸分析的筛选结果</li></ul><p><strong>结论</strong>：<mark>开发中能使用局部变量的，就不要使用在方法外定义。</mark></p><h3 id="2-逃逸分析代码优化深入理解java虚拟机第3版的418页"><a class="markdownIt-Anchor" href="#2-逃逸分析代码优化深入理解java虚拟机第3版的418页"></a> 2. 逃逸分析：代码优化（深入理解Java虚拟机第3版的418页）</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、<mark>栈上分配</mark>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p><p>二、<mark>同步省略</mark>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>三、<mark>分离对象或标量替换</mark>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。（对于java语言来说的话，意思就是，对象可以不存储在堆空间中，而是存储在栈空间中（因为java虚拟机不是基于寄存器的，是基于栈结构的））</p><h4 id="栈上分配但其实由于复杂度等原因hotspot中目前暂时没有做这项优化"><a class="markdownIt-Anchor" href="#栈上分配但其实由于复杂度等原因hotspot中目前暂时没有做这项优化"></a> 栈上分配（但其实由于复杂度等原因，HotSpot中目前暂时没有做这项优化）</h4><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p><strong>常见的栈上分配的场景</strong></p><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p><p>例子：</p><p><img src="../../../images/image-20221119094751459.png" alt="image-20221119094751459"></p><p><strong>情况1</strong>：没开启<code>-XX:+DoEscapeAnalysis</code>"逃逸分析<img src="../../../images/image-20221119094927464.png" alt="image-20221119094927464"></p><p>运行结果：</p><p><img src="../../../images/image-20221119095001993.png" alt="image-20221119095001993"></p><p><img src="../../../images/image-20221119095114971.png" alt="image-20221119095114971"></p><p><strong>情况2</strong>：开启<code>-XX:+DoEscapeAnalysis</code>"逃逸分析<img src="../../../images/image-20221119095155465.png" alt="image-20221119095155465"></p><p>运行结果：会发现花费时间少很多</p><p><img src="../../../images/image-20221119095214464.png" alt="image-20221119095214464"></p><p><img src="../../../images/image-20221119095340404.png" alt="image-20221119095340404"></p><p><strong>情况3</strong>：把内存缩小，不开启逃逸分析<img src="../../../images/image-20221119095519089.png" alt="image-20221119095519089"></p><p>结果：</p><p><strong><img src="../../../images/image-20221119095612508.png" alt="image-20221119095612508"></strong></p><p><strong>情况4</strong>：开启逃逸分析<img src="../../../images/image-20221119095646626.png" alt="image-20221119095646626"></p><p>结果：时间少了很多，而且没有发生GC，因为优化到栈上分配后，栈不会进行GC的</p><p><img src="../../../images/image-20221119095719657.png" alt="image-20221119095719657"></p><p><strong>注意：</strong></p><p>​其实由于复杂度等原因，HotSpot中目前暂时没有做站上分配这项优化，上面例子之所以可以看到效果，是因为开启了逃逸分析，外加jdk7之后默认开启的标量替换，会将未逃逸的对象进行打散然后分配到栈上，所以上面例子可以看到效果</p><h4 id="同步省略"><a class="markdownIt-Anchor" href="#同步省略"></a> 同步省略</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT 编译器可以<mark><strong>借助逃逸分析</strong>来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<mark>锁消除</mark>。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) {</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="标量替换"><a class="markdownIt-Anchor" href="#标量替换"></a> 标量替换</h4><p><mark>标量（scalar）</mark>是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做<mark>聚合量（Aggregate）</mark>，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">    alloc();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为<strong>一旦不需要创建对象了，那么就不再需要分配堆内存了</strong>。 <strong>标量替换为栈上分配提供了很好的基础</strong>。</p><p><strong>标量替换参数设置</strong></p><p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（JDK7之后默认打开），允许将对象打散分配到<strong>栈</strong>上。</p><p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221119102333407.png" alt="image-20221119102333407"></p><p>这里设置参数如下：</p><ul><li>参数<code>-server</code>：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</li><li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li><li>参数<code>-Xmx10m</code>：指定了堆空间最大为 10MB</li><li>参数<code>-XX:+PrintGC</code>：将打印 Gc 日志</li><li>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="3-逃逸分析小结逃逸分析并不成熟"><a class="markdownIt-Anchor" href="#3-逃逸分析小结逃逸分析并不成熟"></a> 3. 逃逸分析小结：逃逸分析并不成熟</h3><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </mark></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也<mark>是即时编译器优化技术中一个十分重要的手段</mark>。</p><p>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，<strong>Oracle Hotspot JVM 中并未这么做</strong>，这一点在逃逸分析相关的文档里已经说明，所以可以明确<mark>所有的对象实例都是创建在堆上</mark>。</p><p>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
          <category> interview </category>
          
          <category> interview </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6. 堆</title>
      <link href="/2022/11/18/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/6.%E5%A0%86/"/>
      <url>/2022/11/18/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/6.%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="6-堆"><a class="markdownIt-Anchor" href="#6-堆"></a> 6. 堆</h1><h2 id="61-堆heap的核心概述"><a class="markdownIt-Anchor" href="#61-堆heap的核心概述"></a> 6.1. 堆（Heap）的核心概述</h2><p>堆针对一个 JVM 进程来说是<strong>唯一</strong>的，也就是一个进程只有一个 JVM，但是进程包含多个线程，他们是共享同一堆空间的。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/0be60cad417bedd46d651f710ae585ce.png" alt="image-20200706195127740"></p><p>一个 JVM 实例只存在一个堆内存，堆也是 Java 内存管理的核心区域。</p><p>Java 堆区在 JVM 启动的时候即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存空间。</p><ul><li>堆内存的大小是可以调节的。</li></ul><p>《Java 虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上它应该被视为连续的</strong>。</p><p>所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer，TLAB）。</p><p>《Java 虚拟机规范》中对 Java 堆的描述是：<strong>所有的对象实例以及数组都应当在运行时分配在堆上</strong>。（<code>The heap is the run-time data area from which memory for all class instances and arrays is allocated</code>）</p><p><font color="red">数组和对象可能永远不会存储在栈上，因为<strong>栈帧中保存引用</strong>，这个引用指向<strong>对象或者数组在堆中</strong>的位置.</font></p><p>在方法结束后，堆中的对象<strong>不会马上被移除</strong>，仅仅在垃圾收集的时候才会被移除。（方法结束后，栈中对应的变量就弹出栈，堆空间的对象不会立即跟着被移除，还是会继续留着，等到堆的空间不足了，要GC了，要垃圾回收时，发现那些堆中的对象没有指针指过来了，就移除回收。如果方法结束后，栈变量一移出堆空间对象就立马垃圾回收，这样的话，堆空间的GC频率就会很高，就会影响到用户线程区执行）</p><p><img src="../../../images/image-20221118100917171.png" alt="image-20221118100917171"></p><p>一执行 new 的时候，就会在堆中去创建对象并开辟堆空间，jvm 还会去初始化对象的实例变量</p><p>堆，是 GC（Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。（栈没有GC，只有OOM）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/3ae9948d069bd58ccfcda730cc12bf0f.png" alt="image-20200706201904057"></p><h3 id="611-堆内存细分"><a class="markdownIt-Anchor" href="#611-堆内存细分"></a> 6.1.1. 堆内存细分</h3><p>Java 7 及之前堆内存逻辑上分为三部分：新生区+养老区+<mark>永久区</mark></p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Permanent Space 永久区 Perm</li></ul><p>Java 8 及之后堆内存逻辑上分为三部分：新生区+养老区+<mark>元空间</mark></p><ul><li>Young Generation Space 新生区 Young/New 又被划分为 Eden 区和 Survivor 区</li><li>Tenure generation space 养老区 Old/Tenure</li><li>Meta Space 元空间 Meta</li></ul><p>约定：新生区（代）&lt;=&gt;年轻代 、 养老区&lt;=&gt;老年区（代）、 永久区&lt;=&gt;永久代</p><h3 id="612-堆空间内部结构jdk7"><a class="markdownIt-Anchor" href="#612-堆空间内部结构jdk7"></a> 6.1.2. 堆空间内部结构（JDK7）</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/deafdcce7cf88a496bc231820bb5b007.png" alt="image-20200706203419496"></p><h3 id="613-堆空间内部结构jdk8"><a class="markdownIt-Anchor" href="#613-堆空间内部结构jdk8"></a> 6.1.3. 堆空间内部结构（JDK8）</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/ee2836af2e1d5387b4ac58f5eacabbb6.png" alt="image-20200706203835403"></p><h2 id="62-设置堆内存大小与-oom"><a class="markdownIt-Anchor" href="#62-设置堆内存大小与-oom"></a> 6.2. 设置堆内存大小与 OOM</h2><h3 id="621-堆空间大小的设置"><a class="markdownIt-Anchor" href="#621-堆空间大小的设置"></a> 6.2.1. 堆空间大小的设置</h3><p>Java 堆区用于存储 Java 对象实例，那么堆的大小在 JVM 启动时就已经设定好了，大家可以通过选项"-Xmx"和"-Xms"来进行设置。</p><ul><li>“<strong>-Xms</strong>"用于表示堆区的起始内存，等价于<code>-XX:InitialHeapSize</code></li><li>“<strong>-Xmx</strong>"则用于表示堆区的最大内存，等价于<code>-XX:MaxHeapSize</code></li></ul><p>一旦堆区中的内存大小超过“-Xmx"所指定的最大内存时，将会抛出 OutOfMemoryError 异常。</p><p>通常会将-Xms 和-Xmx 两个参数配置相同的值，其目的是<mark>为了能够在 java 垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。</mark></p><p>-Xms 和-Xmx 为什么设置一样？</p><ul><li><pre><code>     我们设置一个初始值时，如果堆空间不够的话，会一直去扩容，最后达到上限最大堆内存，当然再空闲的时候也会把空间进行释放，</code></pre></li><li><pre><code>     那么不停的扩容和释放的过程会造成系统的压力。设置成大小一样的话，就可以避免GC之后去调整堆内存大小而造成系统额外的压力</code></pre></li><li><pre><code>     说白了就是不要一直区扩容和释放，降低性能消耗</code></pre></li></ul><p>默认情况下</p><ul><li>初始内存大小：物理电脑内存大小 / 64</li><li>最大内存大小：物理电脑内存大小 / 4</li></ul><p>例子：</p><p><img src="../../../images/image-20221118152706837.png" alt="image-20221118152706837"></p><h4 id="查看设置的参数"><a class="markdownIt-Anchor" href="#查看设置的参数"></a> 查看设置的参数：</h4><h5 id="方式一"><a class="markdownIt-Anchor" href="#方式一"></a> <strong>方式一：</strong></h5><p>jps ：能够查看当前程序运行的进程</p><p>jstat : 用来查看 JVM 在GC的时候的统计信息</p><p><img src="../../../images/image-20221118151354070.png" alt="image-20221118151354070"></p><p><img src="../../../images/image-20221118152449416.png" alt="image-20221118152449416"></p><p>要存对象的话，EC区能放，S0C 或 S1C 区能放（主要涉及到了垃圾回收 用到了复制算法），所以S0C区和S1C区只用到一个</p><h5 id="方式二"><a class="markdownIt-Anchor" href="#方式二"></a> <strong>方式二：</strong></h5><p>设置参数：    -XX:+PrintGCDetails(用于打印出GC过程中的细节信息)</p><p><img src="../../../images/image-20221118153741499.png" alt="image-20221118153741499"></p><p>查看参数打印出的GC信息</p><p><img src="../../../images/image-20221118153611462.png" alt="image-20221118153611462"></p><p>上面例子的代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 1. 设置堆空间大小的参数</span></span><br><span class="line"><span class="comment"> * - Xms 用来设置堆空间（年轻代 + 老年代）的初始内存大小</span></span><br><span class="line"><span class="comment"> *      - X 是jvm的运行参数</span></span><br><span class="line"><span class="comment"> *      ms 是 memory  start</span></span><br><span class="line"><span class="comment"> * - Xmx 用来设置堆空间（年轻代 + 老年代）的最大内存大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 2. 默认堆空间的大小</span></span><br><span class="line"><span class="comment"> *      初始内存大小：物理电脑内存大小 / 64</span></span><br><span class="line"><span class="comment"> *      最大内存大小：物理电脑内存大小 / 4</span></span><br><span class="line"><span class="comment"> * 3. 手动设置：-Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *      开发中建议将初始堆内存和最大的堆内存设置成相同的值，为什么呢？</span></span><br><span class="line"><span class="comment"> *        为什么呢？</span></span><br><span class="line"><span class="comment"> *          我们设置一个初始值时，如果堆空间不够的话，会一直去扩容，最后达到上限最大堆内存，当然再空闲的时候也会把空间进行释放，</span></span><br><span class="line"><span class="comment"> *          那么不停的扩容和释放的过程会造成系统的压力。设置成大小一样的话，就可以避免GC之后去调整堆内存大小而造成系统额外的压力</span></span><br><span class="line"><span class="comment"> *          说白了就是不要一直区扩容和释放，降低性能消耗</span></span><br><span class="line"><span class="comment"> * 4. 查看设置的参数：方式一： jps ---&gt; jstat -gc 进程id</span></span><br><span class="line"><span class="comment"> *                 方式二：-XX:+PrintGCDetails(用于打印出GC过程中的细节信息)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeadSpaceInitial</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 返回Java虚拟机中的堆内存总量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">initialMemory</span> <span class="operator">=</span> Runtime.getRuntime().totalMemory() / <span class="number">1024</span> / <span class="number">1024</span>;</span><br><span class="line">        <span class="comment">// 返回Java虚拟机试图使用的最大堆内存量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">maxMemory</span> <span class="operator">=</span> Runtime.getRuntime().maxMemory() / <span class="number">1024</span> /<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-Xms : "</span> + initialMemory + <span class="string">"M"</span> );</span><br><span class="line">        System.out.println(<span class="string">"-Xmx : "</span> + maxMemory + <span class="string">"M"</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//        System.out.println("系统内存大小为：" + initialMemory * 64.0 / 1024 + "G");</span></span><br><span class="line"><span class="comment">//        System.out.println("系统最大内存大小为：" + maxMemory * 4 / 1024 + "G");</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//        try {</span></span><br><span class="line"><span class="comment">//            Thread.sleep(10000000 );</span></span><br><span class="line"><span class="comment">//        } catch (InterruptedException e) {</span></span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line"><span class="comment">//        }</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="622-outofmemory-举例"><a class="markdownIt-Anchor" href="#622-outofmemory-举例"></a> 6.2.2. OutOfMemory 举例</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OOMTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[]args)</span>{</span><br><span class="line">        ArrayList&lt;Picture&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>){</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (InterruptedException e){</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">Picture</span>(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1024</span>*<span class="number">1024</span>)));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutofMemoryError: Java heap space</span><br><span class="line">    at com.atguigu. java.Picture.&lt;init&gt;(OOMTest. java:<span class="number">25</span>)</span><br><span class="line">    at com.atguigu.java.O0MTest.main(OOMTest.java:<span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="63-年轻代与老年代"><a class="markdownIt-Anchor" href="#63-年轻代与老年代"></a> 6.3. 年轻代与老年代</h2><p>存储在 JVM 中的 Java 对象可以被划分为两类：</p><ul><li>一类是生<strong>命周期较短</strong>的瞬时对象，这类对象的创建和消亡都非常迅速</li><li>另外一类对象的<strong>生命周期却非常长</strong>，在某些极端的情况下还能够与 JVM 的生命周期保持一致</li></ul><p>Java 堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（oldGen）</p><p>其中年轻代又可以划分为 Eden 空间、Survivor0 空间和 Survivor1 空间（有时也叫做 from 区、to 区）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f3ee86daaf5076fe22265ffcaa831175.png" alt="image-20200707075847954"></p><p>下面这参数开发中一般不会调：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7d9c2d1f9ef9f315f01b3441c6e81660.png" alt="image-20200707080154039"></p><p>配置新生代与老年代在堆结构的占比。</p><ul><li>默认<code>-XX:NewRatio=2</code>，表示新生代占 1，老年代占 2，新生代占整个堆的 1/3</li><li>可以修改<code>-XX:NewRatio=4</code>，表示新生代占 1，老年代占 4，新生代占整个堆的 1/5</li></ul><p>在 HotSpot 中，Eden 空间和另外两个 survivor 空间缺省所占的比例是 <strong>8：1：1</strong></p><p>当然开发人员可以通过选项“<code>-xx:SurvivorRatio</code>”调整这个空间比例。比如<code>-xx:SurvivorRatio=8</code></p><p><mark>几乎所有的 Java 对象都是在 Eden 区被 new 出来的。</mark>绝大部分的 Java 对象的销毁都在新生代进行了。</p><ul><li>IBM 公司的专门研究表明，新生代中 80%的对象都是“朝生夕死”的。</li></ul><p>可以使用选项"<code>-Xmn</code>"设置新生代最大内存大小，这个参数一般使用默认值就可以了。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31fd90d99565ec8ce0682a4468076f94.png" alt="image-20210510105849497"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/18</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -Xms600m -Xmx600m</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * -NewRatio : 设置新生代与老年代的比例。默认值是2（新生代 : 老年代 = 1 : 2）</span></span><br><span class="line"><span class="comment"> * -XX:SurvivorRatio : 设置新新生代中的Eden区与Survivor区的比例。默认值是8（但测试的时候是6，要它是8，需要加上这个参数的设置）</span></span><br><span class="line"><span class="comment"> * -XX:-UseAdaptiveSizePolicy  :  Use前面加-表示关闭自适应的内存分配策略，加+表示用（暂时用不到）</span></span><br><span class="line"><span class="comment"> * -Xmn: 设置新生代的空间的大小 （一般不设置）（当和-NewRatio一同设置有矛盾时，以-Xmn为准）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EdenSurvivorTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"我只是来打酱油~"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="64-图解对象分配过程"><a class="markdownIt-Anchor" href="#64-图解对象分配过程"></a> 6.4. 图解对象分配过程</h2><p>为新对象分配内存是一件非常严谨和复杂的任务，JVM 的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑 GC 执行完内存回收后是否会在内存空间中产生内存碎片。</p><p>(新生代分为：Eden（伊甸园区）、SO（幸存者0区）、S1（幸存者1区）；老年代：Tenured/OId)</p><ol><li><p>new 的对象先放伊甸园区。此区有大小限制。</p></li><li><p>当伊甸园（Eden）的空间填满时，程序又需要创建对象，JVM 的垃圾回收器将对伊甸园区进行垃圾回收（MinorGC），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园区</p></li><li><p>然后将伊甸园中的剩余对象移动到幸存者 0 区，age = 1。</p></li><li><p>如果再次触发垃圾回收，此时上次幸存下来的放到幸存者 0 区的，如果没有回收，就会放到幸存者 1 区，此时age = 2(后面依次递增)。</p></li><li><p>如果再次经历垃圾回收，此时会重新放回幸存者 0 区，接着再去幸存者 1 区。</p></li><li><p>啥时候能去养老区呢？可以设置次数。默认是 15 次（当age 到达15之后，再触发GC时，就会通过Promotion晋升进入Tenured/OId老年代区，进行养老）。</p><ul><li><mark>可以设置参数：<code>-Xx:MaxTenuringThreshold= N</code>进行设置</mark></li></ul></li><li><p>在养老区，相对悠闲。当养老区内存不足时，再次触发 GC：Major GC，进行养老区的内存清理</p></li><li><p>若养老区执行了 Major GC 之后，发现依然无法进行对象的保存，就会产生 OOM 异常。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutofMemoryError: Java heap space</span><br></pre></td></tr></tbody></table></figure></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/9d588ca1c3495a21ada5b7fce89c6633.png" alt="第08章_新生代对象分配与回收过程"></p><p><strong>流程图</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/23b91eb543fc0072cb628365267f0089.png" alt="image-20200707091058346"></p><p><strong>总结</strong></p><ul><li><mark>针对幸存者 s0，s1 区的总结：复制之后有交换，谁空谁是 to</mark></li><li><mark>关于垃圾回收：频繁在新生区收集，很少在老年代收集，几乎不在永久代和元空间进行收集</mark></li><li>Eden区满时才会触发YGC，S0和S1满不会触发YGC。当Eden触发YGC也会让SO、S1进行YGC</li><li>当遇到超大对象时，发现新生代中的Eden区(即便进行了YGC)放不下，就会直接尝试放到老年代Tenured/OId，如果老年代也放不下，就触发FGC，之后OId能放得下就放，不能的话就报OOM</li></ul><p>通过<strong>VisualVM</strong>工具来查看，如下：</p><p>Eden Space每次到达顶峰（满了），就会触发一次GC( 看GC Time 的触发时间点刚好对应上）,触发GC后，就会将Eden中的一些还需要继续用的放到Survivor区中，如果Survivor区也装不下，就会放到Old Gen区（其他进入该区的情况：幸存者区有对象达到了阈值了；Eden中遇到超大对象）</p><p>最后Old Gen满了后，触发FGC也还是内存不足，就会导致OOM</p><p><img src="../../../images/image-20221118173112878.png" alt="image-20221118173112878"></p><p><strong>常用调优工具（在 JVM 下篇：性能监控与调优篇会详细介绍）</strong></p><ul><li>JDK 命令行</li><li>Eclipse:Memory Analyzer Tool</li><li>Jconsole</li><li>VisualVM</li><li>Jprofiler</li><li>Java Flight Recorder</li><li>GCViewer</li><li>GC Easy</li></ul><h2 id="65-minor-gcmajorgc-full-gc"><a class="markdownIt-Anchor" href="#65-minor-gcmajorgc-full-gc"></a> 6.5. Minor GC，MajorGC、Full GC</h2><p>MajorGC、Full GC在垃圾回收的时候产生的暂停时间，是Minor GC的十倍以上，所以我们重点是针对MajorGC、Full GC这两个GC调优，尽量避免它们出现GC.</p><p>JVM 在进行 GC 时，并非每次都对上面三个内存（新生代、老年代；方法区）区域一起回收的，大部分时候回收的都是指新生代。</p><p>针对 Hotspot VM 的实现，它里面的 GC 按照回收区域又分为两大种类型：一种是部分收集（Partial GC），一种是整堆收集（FullGC）</p><ul><li>**部分收集：**不是完整收集整个 Java 堆的垃圾收集。其中又分为：<ul><li>新生代收集（<strong>Minor GC / Young GC</strong>）：只是新生代（Eden、S0、S1）的垃圾收集</li><li>老年代收集（<strong>Major GC / Old GC</strong>）：只是老年代的圾收集。<ul><li>目前，只有 CMSGC 会有单独收集老年代的行为。</li><li><mark>注意，很多时候 Major GC 会和 Full GC 混淆使用，需要具体分辨是老年代回收还是整堆回收。</mark></li></ul></li><li>混合收集（<strong>MixedGC</strong>）：收集整个新生代以及部分老年代的垃圾收集。<ul><li>目前，只有 G1 GC 会有这种行为</li></ul></li></ul></li><li><strong>整堆收集</strong>（<strong>Full GC</strong>）：收集整个 java 堆和方法区的垃圾收集。</li></ul><h3 id="651-最简单的分代式-gc-策略的触发条件"><a class="markdownIt-Anchor" href="#651-最简单的分代式-gc-策略的触发条件"></a> 6.5.1. 最简单的分代式 GC 策略的触发条件</h3><h3 id="年轻代-gcminor-gc触发机制"><a class="markdownIt-Anchor" href="#年轻代-gcminor-gc触发机制"></a> 年轻代 GC（Minor GC）触发机制</h3><ul><li><p>当年轻代空间不足时，就会触发 MinorGC，这里的年轻代满指的是 Eden 代满，Survivor 满不会引发 GC。（每次 Minor GC 会清理年轻代的内存。）</p></li><li><p>因为<mark>Java 对象大多都具备朝生夕灭的特性</mark>.，所以 Minor GC 非常频繁，一般回收速度也比较快。这一定义既清晰又易于理解。</p></li><li><p>Minor GC 会引发 STW，暂停其它用户的线程，等垃圾回收结束，用户线程才恢复运行</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/29146da9c1f3a3241d52201641899020.png" alt="image-20200707095606813"></p><h3 id="老年代-gcmajor-gc-full-gc触发机制"><a class="markdownIt-Anchor" href="#老年代-gcmajor-gc-full-gc触发机制"></a> 老年代 GC（Major GC / Full GC）触发机制</h3><ul><li><p>指发生在老年代的 GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了</p></li><li><p>出现了 Major Gc，经常会伴随至少一次的 Minor GC（但非绝对的，在 Paralle1 Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）</p><ul><li>也就是在老年代空间不足时，会先尝试触发 Minor GC。如果之后空间还不足，则触发 Major GC</li></ul></li><li><p>Major GC 的速度一般会比 Minor GC 慢 10 倍以上，STW 的时间更长</p></li><li><p>如果 Major GC 后，内存还不足，就报 OOM 了</p></li></ul><h3 id="full-gc-触发机制后面细讲"><a class="markdownIt-Anchor" href="#full-gc-触发机制后面细讲"></a> Full GC 触发机制（后面细讲）：</h3><p>触发 Full GC 执行的情况有如下五种：</p><ol><li>调用 System.gc()时，系统建议执行 Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过 Minor GC 后进入老年代的平均大小大于老年代的可用内存</li><li>由 Eden 区、survivor space0（From Space）区向 survivor space1（To Space）区复制时，对象大小大于 To Space 可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ol><p><mark>说明：Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些</mark></p><h2 id="66-堆空间分代思想"><a class="markdownIt-Anchor" href="#66-堆空间分代思想"></a> 6.6. 堆空间分代思想</h2><p>为什么要把 Java 堆分代？不分代就不能正常工作了吗？</p><p>经研究，不同对象的生命周期不同。70%-99%的对象是临时对象。</p><ul><li>新生代：有 Eden、两块大小相同的 survivor（又称为 from/to，s0/s1）构成，to 总为空。</li><li>老年代：存放新生代中经历多次 GC 仍然存活的对象。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/d776de4eb3a801b6e271b3f870317aa1.png" alt="image-20200707101511025"></p><p>其实不分代完全可以，分代的唯一理由就是<strong>优化 GC 性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/9b5ad9b0a881973d2955e61f7ebed160.png" alt="image-20200707101543871"></p><h2 id="67-内存分配策略"><a class="markdownIt-Anchor" href="#67-内存分配策略"></a> 6.7. 内存分配策略</h2><p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然存活，并且能被 Survivor 容纳的话，将被移动到 survivor 空间中，并将对象年龄设为 1。对象在 survivor 区中每熬过一次 MinorGC，年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁，其实每个 JVM、每个 GC 都有所不同）时，就会被晋升到老年代</p><p>对象晋升老年代的年龄阀值，可以通过选项<code>-XX:MaxTenuringThreshold</code>来设置</p><p>针对不同年龄段的对象分配原则如下所示：</p><ul><li><p>优先分配到 Eden</p></li><li><p>大对象直接分配到老年代</p><ul><li>（尽量避免程序中出现过多的大对象，特别是朝生夕死的）</li></ul></li><li><p>长期存活的对象分配到老年代</p></li><li><p>动态对象年龄判断：如果 survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代，无须等到<code>MaxTenuringThreshold</code>中要求的年龄。</p></li><li><p>空间分配担保： <code>-XX:HandlePromotionFailure</code></p></li><li><p><img src="../../../images/image-20221118221547758.png" alt="image-20221118221547758"></p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试：大对象直接进入老年代</span></span><br><span class="line"><span class="comment"> * -Xms60m -Xmx60m -XX:NewRatio=2 -XX:SurvivorRatio=8 -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">YoungOldAreaTest</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// 20m</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">20</span>];</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="68-为对象分配内存tlab"><a class="markdownIt-Anchor" href="#68-为对象分配内存tlab"></a> 6.8. 为对象分配内存：TLAB</h2><h3 id="681-为什么有-tlabthread-local-allocation-buffer"><a class="markdownIt-Anchor" href="#681-为什么有-tlabthread-local-allocation-buffer"></a> 6.8.1. 为什么有 TLAB（Thread Local Allocation Buffer）？</h3><ul><li><p><strong>堆区是线程共享区域</strong>，任何线程都可以访问到堆区中的共享数据</p></li><li><p>由于对象实例的创建在 JVM 中非常频繁，因此在<strong>并发环境下从堆区中划分内存空间是线程不安全的</strong></p></li><li><p>为避免多个线程操作同一地址，需要使用加锁等机制，进而影响分配速度。</p></li></ul><h3 id="682-什么是-tlab"><a class="markdownIt-Anchor" href="#682-什么是-tlab"></a> 6.8.2. 什么是 TLAB？</h3><ul><li><p>从内存模型而不是垃圾收集的角度，对 Eden 区域继续进行划分，JVM 为<mark>每个线程分配了一个私有缓存区域</mark>，它包含在 Eden 空间内。</p></li><li><p>多线程同时分配内存时，使用 TLAB 可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们可以将这种内存分配方式称之为<mark>快速分配策略</mark>。</p></li><li><p>据我所知所有 OpenJDK 衍生出来的 JVM 都提供了 TLAB 的设计。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/90162691ef6b0f4dc96be1c1ab02dc8b.png" alt="image-20210510114110526"></p><h3 id="683-tlab-的再说明"><a class="markdownIt-Anchor" href="#683-tlab-的再说明"></a> 6.8.3. TLAB 的再说明</h3><ul><li><p>尽管不是所有的对象实例都能够在 TLAB 中成功分配内存，但<mark>JVM 确实是将 TLAB 作为内存分配的首选</mark>。</p></li><li><p>在程序中，开发人员可以通过选项“<code>-XX:UseTLAB</code>”设置是否开启 TLAB 空间。</p></li><li><p>默认情况下，TLAB 空间的内存非常小，<mark>仅占有整个 Eden 空间的 1%</mark>，当然我们可以通过选项 “<code>-XX:TLABWasteTargetPercent</code>” 设置 TLAB 空间所占用 Eden 空间的百分比大小。</p></li><li><p>一旦对象在 TLAB 空间分配内存失败时，JVM 就会尝试着通过使用加锁机制确保数据操作的原子性，从而直接在 Eden 空间中分配内存。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/011ab4c65cfe41f64208447bf6c9d6d7.png" alt="image-20200707104253530"></p><p><a href="https://blog.csdn.net/weixin_38410177/article/details/123704443">(2条消息) jvm 堆一定是共享的吗？_Y仟仟的博客-CSDN博客</a></p><h2 id="69-小结堆空间的参数设置"><a class="markdownIt-Anchor" href="#69-小结堆空间的参数设置"></a> 6.9. 小结：堆空间的参数设置</h2><p>官网地址：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html">https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html</a></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 详细的参数内容会在JVM下篇：性能监控与调优篇中进行详细介绍，这里先熟悉下</span></span><br><span class="line">-XX:+PrintFlagsInitial  <span class="comment">//查看所有的参数的默认初始值</span></span><br><span class="line">-XX:+PrintFlagsFinal  <span class="comment">//查看所有的参数的最终值（可能会存在修改，不再是初始值）</span></span><br><span class="line">-Xms  <span class="comment">//初始堆空间内存（默认为物理内存的1/64）</span></span><br><span class="line">-Xmx  <span class="comment">//最大堆空间内存（默认为物理内存的1/4）</span></span><br><span class="line">-Xmn  <span class="comment">//设置新生代的大小。（初始值及最大值）</span></span><br><span class="line">-XX:NewRatio  <span class="comment">//配置新生代与老年代在堆结构的占比</span></span><br><span class="line">-XX:SurvivorRatio  <span class="comment">//设置新生代中Eden和S0/S1空间的比例</span></span><br><span class="line">-XX:MaxTenuringThreshold  <span class="comment">//设置新生代垃圾的最大年龄</span></span><br><span class="line">-XX:+PrintGCDetails <span class="comment">//输出详细的GC处理日志</span></span><br><span class="line"><span class="comment">//打印gc简要信息：①-Xx：+PrintGC ② - verbose:gc</span></span><br><span class="line">-XX:HandlePromotionFalilure：<span class="comment">//是否设置空间分配担保</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">具体查看某个参数的指令：</span><br><span class="line">jps : 查看当前运行中的进程</span><br><span class="line">jinfo -flag SurvivorRatio 进程id</span><br></pre></td></tr></tbody></table></figure><p>在发生 Minor GC 之前，虚拟机会<mark>检查老年代最大可用的连续空间是否大于新生代所有对象的总空间</mark>。</p><ul><li>如果大于，则此次 Minor GC 是安全的</li><li>如果小于，则虚拟机会查看<code>-XX:HandlePromotionFailure</code>设置值是否允担保失败。<ul><li>如果<code>HandlePromotionFailure=true</code>，那么会继续检查老年代最大可用连续空间是否大于历次晋升到老年代的对象的平均大小。<ul><li>如果大于，则尝试进行一次 Minor GC，但这次 Minor GC 依然是有风险的；</li><li>如果小于，则改为进行一次 Full GC。</li></ul></li><li>如果<code>HandlePromotionFailure=false</code>，则改为进行一次 Full Gc。</li></ul></li></ul><p>在 JDK6 Update24 之后，HandlePromotionFailure 参数不会再影响到虚拟机的空间分配担保策略，观察 openJDK 中的源码变化，虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它。JDK6 Update 24 之后的规则变为**<mark>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC</mark>，否则将进行 FullGC。**</p><p>( 所以Minor GC触发的条件不完全是当Eden放不下的时候了? )</p><h2 id="6x-堆是分配对象的唯一选择么"><a class="markdownIt-Anchor" href="#6x-堆是分配对象的唯一选择么"></a> 6.X. 堆是分配对象的唯一选择么？</h2><p>在《深入理解 Java 虚拟机》中关于 Java 堆内存有这样一段描述：</p><blockquote><p>随着 JIT 编译期的发展与<mark>逃逸分析技术</mark>逐渐成熟，<mark>栈上分配</mark>、<mark>标量替换优化技术</mark>将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>在 Java 虚拟机中，对象是在 Java 堆中分配内存的，这是一个普遍的常识。但是，有一种特殊情况，那就是<mark>如果经过逃逸分析（Escape Analysis）后发现，一个对象并<strong>没有逃逸出方法</strong>的话，那么就<strong>可能被优化成栈上分配</strong></mark>.。这样就无需在堆上分配内存，也无须进行垃圾回收了。这也是最常见的<strong>堆外存储技术</strong>。</p><p>此外，前面提到的基于 OpenJDK 深度定制的 TaoBaoVM，其中创新的 GCIH（GC invisible heap）技术实现 off-heap，将生命周期较长的 Java 对象从 heap 中移至 heap 外，并且 GC 不能管理 GCIH 内部的 Java 对象，以此达到降低 GC 的回收频率和提升 GC 的回收效率的目的。</p><h3 id="6x1-逃逸分析概述"><a class="markdownIt-Anchor" href="#6x1-逃逸分析概述"></a> 6.X.1. 逃逸分析概述</h3><p>如何将堆上的对象分配到栈，需要使用逃逸分析手段。</p><p>这是一种可以有效减少 Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p><p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。</p><p>逃逸分析的基本行为就是分析对象动态作用域：</p><ul><li>当一个对象在方法中被定义后，对象只在方法内部使用，则认为没有发生逃逸。</li><li>当一个对象在方法中被定义后，它被外部方法所引用，则认为发生逃逸。例如作为调用参数传递到其他地方中。</li></ul><p><strong>举例 1</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">my_method</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">V</span>();</span><br><span class="line">    <span class="comment">// use v</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    v = <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>没有发生逃逸的对象，则可以分配到栈上，随着方法执行的结束，栈空间就被移除，每个栈里面包含了很多栈帧</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述方法如果想要<code>StringBuffer sb</code>不发生逃逸，可以这样写</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">createStringBuffer</span><span class="params">(String s1, String s2)</span> {</span><br><span class="line">    <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EscapeAnalysis</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回EscapeAnalysis对象，发生逃逸</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> EscapeAnalysis <span class="title function_">getInstance</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>() : obj;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为成员属性赋值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.obj = <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象的作用于仅在当前方法中有效，没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EscapeAnalysis</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用成员变量的值，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">useEscapeAnalysis2</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">EscapeAnalysis</span> <span class="variable">e</span> <span class="operator">=</span> getInstance();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>参数设置</strong></p><p>在 JDK 6u23 版本之后，HotSpot 中默认就已经开启了逃逸分析</p><p>如果使用的是较早的版本，开发人员则可以通过：</p><ul><li>选项“<code>-XX:+DoEscapeAnalysis</code>"显式开启逃逸分析</li><li>通过选项“<code>-XX:+PrintEscapeAnalysis</code>"查看逃逸分析的筛选结果</li></ul><p><strong>结论</strong>：<mark>开发中能使用局部变量的，就不要使用在方法外定义。</mark></p><h3 id="6x2-逃逸分析代码优化深入理解java虚拟机第3版的418页"><a class="markdownIt-Anchor" href="#6x2-逃逸分析代码优化深入理解java虚拟机第3版的418页"></a> 6.X.2. 逃逸分析：代码优化（深入理解Java虚拟机第3版的418页）</h3><p>使用逃逸分析，编译器可以对代码做如下优化：</p><p>一、<mark>栈上分配</mark>：将堆分配转化为栈分配。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会发生逃逸，对象可能是栈上分配的候选，而不是堆上分配</p><p>二、<mark>同步省略</mark>：如果一个对象被发现只有一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p><p>三、<mark>分离对象或标量替换</mark>：有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在 CPU 寄存器中。（对于java语言来说的话，意思就是，对象可以不存储在堆空间中，而是存储在栈空间中（因为java虚拟机不是基于寄存器的，是基于栈结构的））</p><h4 id="栈上分配但其实由于复杂度等原因hotspot中目前暂时没有做这项优化"><a class="markdownIt-Anchor" href="#栈上分配但其实由于复杂度等原因hotspot中目前暂时没有做这项优化"></a> 栈上分配（但其实由于复杂度等原因，HotSpot中目前暂时没有做这项优化）</h4><p>JIT 编译器在编译期间根据逃逸分析的结果，发现如果一个对象并没有逃逸出方法的话，就可能被优化成栈上分配。分配完成后，继续在调用栈内执行，最后线程结束，栈空间被回收，局部变量对象也被回收。这样就无须进行垃圾回收了。</p><p><strong>常见的栈上分配的场景</strong></p><p>在逃逸分析中，已经说明了。分别是给成员变量赋值、方法返回值、实例引用传递。</p><p>例子：</p><p><img src="../../../images/image-20221119094751459.png" alt="image-20221119094751459"></p><p><strong>情况1</strong>：没开启<code>-XX:+DoEscapeAnalysis</code>"逃逸分析<img src="../../../images/image-20221119094927464.png" alt="image-20221119094927464"></p><p>运行结果：</p><p><img src="../../../images/image-20221119095001993.png" alt="image-20221119095001993"></p><p><img src="../../../images/image-20221119095114971.png" alt="image-20221119095114971"></p><p><strong>情况2</strong>：开启<code>-XX:+DoEscapeAnalysis</code>"逃逸分析<img src="../../../images/image-20221119095155465.png" alt="image-20221119095155465"></p><p>运行结果：会发现花费时间少很多</p><p><img src="../../../images/image-20221119095214464.png" alt="image-20221119095214464"></p><p><img src="../../../images/image-20221119095340404.png" alt="image-20221119095340404"></p><p><strong>情况3</strong>：把内存缩小，不开启逃逸分析<img src="../../../images/image-20221119095519089.png" alt="image-20221119095519089"></p><p>结果：</p><p><strong><img src="../../../images/image-20221119095612508.png" alt="image-20221119095612508"></strong></p><p><strong>情况4</strong>：开启逃逸分析<img src="../../../images/image-20221119095646626.png" alt="image-20221119095646626"></p><p>结果：时间少了很多，而且没有发生GC，因为优化到栈上分配后，栈不会进行GC的</p><p><img src="../../../images/image-20221119095719657.png" alt="image-20221119095719657"></p><p><strong>注意：</strong></p><p>​其实由于复杂度等原因，HotSpot中目前暂时没有做站上分配这项优化，上面例子之所以可以看到效果，是因为开启了逃逸分析，外加jdk7之后默认开启的标量替换，会将未逃逸的对象进行打散然后分配到栈上，所以上面例子可以看到效果</p><h4 id="同步省略"><a class="markdownIt-Anchor" href="#同步省略"></a> 同步省略</h4><p>线程同步的代价是相当高的，同步的后果是降低并发性和性能。</p><p>在动态编译同步块的时候，JIT 编译器可以<mark><strong>借助逃逸分析</strong>来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程</mark>。如果没有，那么 JIT 编译器在编译这个同步块的时候就会取消对这部分代码的同步。这样就能大大提高并发性和性能。这个取消同步的过程就叫同步省略，也叫<mark>锁消除</mark>。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">synchronized</span>(hellis) {</span><br><span class="line">        System.out.println(hellis);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>代码中对 hellis 这个对象加锁，但是 hellis 对象的生命周期只在 f()方法中，并不会被其他线程所访问到，所以在 JIT 编译阶段就会被优化掉，优化成：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Object</span> <span class="variable">hellis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">System.out.println(hellis);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="标量替换"><a class="markdownIt-Anchor" href="#标量替换"></a> 标量替换</h4><p><mark>标量（scalar）</mark>是指一个无法再分解成更小的数据的数据。Java 中的原始数据类型就是标量。</p><p>相对的，那些还可以分解的数据叫做<mark>聚合量（Aggregate）</mark>，Java 中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</p><p>在 JIT 阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过 JIT 优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。</p><p><strong>举例</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String args[])</span> {</span><br><span class="line">    alloc();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">Point</span> <span class="variable">point</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    System.out.println(<span class="string">"point.x"</span> + point.x + <span class="string">";point.y"</span> + point.y);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> y;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>以上代码，经过标量替换后，就会变成</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">alloc</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"point.x = "</span> + x + <span class="string">"; point.y="</span> + y);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，Point 这个聚合量经过逃逸分析后，发现他并没有逃逸，就被替换成两个标量了。那么标量替换有什么好处呢？就是可以大大减少堆内存的占用。因为<strong>一旦不需要创建对象了，那么就不再需要分配堆内存了</strong>。 <strong>标量替换为栈上分配提供了很好的基础</strong>。</p><p><strong>标量替换参数设置</strong></p><p>参数<code>-XX:EliminateAllocations</code>：开启了标量替换（JDK7之后默认打开），允许将对象打散分配到<strong>栈</strong>上。</p><p>上述代码在主函数中进行了 1 亿次 alloc。调用进行对象创建，由于 User 对象实例需要占据约 16 字节的空间，因此累计分配空间达到将近 1.5GB。如果堆空间小于这个值，就必然会发生 GC。使用如下参数运行上述代码：</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-server -Xmx100m -Xms100m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221119102333407.png" alt="image-20221119102333407"></p><p>这里设置参数如下：</p><ul><li>参数<code>-server</code>：启动 Server 模式，因为在 server 模式下，才可以启用逃逸分析。</li><li>参数<code>-XX:+DoEscapeAnalysis</code>：启用逃逸分析</li><li>参数<code>-Xmx10m</code>：指定了堆空间最大为 10MB</li><li>参数<code>-XX:+PrintGC</code>：将打印 Gc 日志</li><li>参数<code>-XX:+EliminateAllocations</code>：开启了标量替换（默认打开），允许将对象打散分配在栈上，比如对象拥有 id 和 name 两个字段，那么这两个字段将会被视为两个独立的局部变量进行分配</li></ul><h3 id="6x3-逃逸分析小结逃逸分析并不成熟"><a class="markdownIt-Anchor" href="#6x3-逃逸分析小结逃逸分析并不成熟"></a> 6.X.3. 逃逸分析小结：逃逸分析并不成熟</h3><p>关于逃逸分析的论文在 1999 年就已经发表了，但直到 JDK1.6 才有实现，而且这项技术到如今也并不是十分成熟。</p><p>其根本原因就是<mark>无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过<strong>逃逸分析</strong>可以做<strong>标量替换、栈上分配、和锁消除</strong>。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。 </mark></p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是它也<mark>是即时编译器优化技术中一个十分重要的手段</mark>。</p><p>注意到有一些观点，认为通过逃逸分析，JVM 会在栈上分配那些不会逃逸的对象，这在理论上是可行的，但是取决于 JVM 设计者的选择。据我所知，<strong>Oracle Hotspot JVM 中并未这么做</strong>，这一点在逃逸分析相关的文档里已经说明，所以可以明确<mark>所有的对象实例都是创建在堆上</mark>。</p><p>目前很多书籍还是基于 JDK7 以前的版本，JDK 已经发生了很大变化，intern 字符串的缓存和静态变量曾经都被分配在永久代上，而永久代已经被元数据区取代。但是，intern 字符串缓存和静态变量并不是被转移到元数据区，而是直接在堆上分配，所以这一点同样符合前面一点的结论：<strong>对象实例都是分配在堆上</strong>。</p><h2 id="本章小结"><a class="markdownIt-Anchor" href="#本章小结"></a> 本章小结</h2><p>年轻代是对象的诞生、成长、消亡的区域，一个对象在这里产生、应用，最后被垃圾回收器收集、结束生命。</p><p>老年代放置长生命周期的对象，通常都是从 survivor 区域筛选拷贝过来的 Java 对象。当然，也有特殊情况，我们知道普通的对象会被分配在 TLAB 上；如果对象较大，JVM 会试图直接分配在 Eden 其他位置上；如果对象太大，完全无法在新生代找到足够长的连续空闲空间，JVM 就会直接分配到老年代。当 GC 只发生在年轻代中，回收年轻代对象的行为被称为 MinorGc。</p><p>当 GC 发生在老年代时则被称为 MajorGc 或者 FullGC。一般的，MinorGc 的发生频率要比 MajorGC 高很多，即老年代中垃圾回收发生的频率将大大低于年轻代。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5. 本地方法接口和本地方法栈</title>
      <link href="/2022/11/18/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5.%20%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/"/>
      <url>/2022/11/18/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/5.%20%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="5-本地方法接口和本地方法栈"><a class="markdownIt-Anchor" href="#5-本地方法接口和本地方法栈"></a> 5. 本地方法接口和本地方法栈</h1><h2 id="51-什么是本地方法"><a class="markdownIt-Anchor" href="#51-什么是本地方法"></a> 5.1. 什么是本地方法？</h2><p>简单地讲，<mark>一个 Native Method 是一个 Java 调用非 Java 代码的接囗</mark>。一个 Native Method 是这样一个 Java 方法：该方法的实现由<strong>非 Java 语言</strong>实现，比如 C。这个特征并非 Java 所特有，很多其它的编程语言都有这一机制，比如在 C<ins>中，你可以用 extern “c” 告知 c</ins>编译器去调用一个 c 的函数。</p><blockquote><p>A native method is a Java method whose implementation is provided by non-java code.</p></blockquote><p>在定义一个 <strong>native</strong> method 时，并不提供实现体（有些像定义一个 Java interface），因为其实现体是由非 java 语言在外面实现的。</p><p>本地接口的作用是融合不同的编程语言为 Java 所用，它的初衷是融合 C/C++程序。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/7b36a8321e4c955f06220775c9c2cf4c.png" alt="image-20200706164139252"></p><p>举例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IHaveNatives</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative1</span><span class="params">(<span class="type">int</span> x)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">methodNative2</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">synchronized</span> <span class="type">float</span> <span class="title function_">methodNative3</span><span class="params">(Object o)</span>;</span><br><span class="line">    <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">methodNative4</span><span class="params">(<span class="type">int</span>[] ary)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>标识符 <strong>native</strong> 可以与其它 java 标识符连用，但是 abstract 除外</p><h2 id="52-为什么使用-native-method"><a class="markdownIt-Anchor" href="#52-为什么使用-native-method"></a> 5.2. 为什么使用 Native Method？</h2><p>Java 使用起来非常方便，然而<strong>有些层次的任务用 Java 实现起来不容易</strong>，或者我们对程序的<strong>效率很在意</strong>时，问题就来了。</p><p><strong>与 Java 环境的交互</strong></p><p><mark><strong>有时 Java 应用需要与 Java 外面的环境交互</strong>，这是本地方法存在的主要原因。</mark>你可以想想 Java 需要与一些底层系统，如<strong>操作系统或某些硬件交换信息时</strong>的情况。本地方法正是这样一种<strong>交流机制</strong>：它为我们提供了一个非常简洁的接口，而且我们无需去了解 Java 应用之外的繁琐的细节。</p><p><strong>与操作系统的交互</strong></p><p>JVM 支持着 Java 语言本身和运行时库，它是 Java 程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一底层系统的支持。这些底层系统常常是强大的操作系统。<mark>通过使用本地方法，我们得以用 Java 实现了 jre 的与底层系统的交互，甚至 JVM 的一些部分就是用 c 写的。</mark>还有，如果我们要使<strong>用一些 Java 语言本身没有提供封装的操作系统的特性</strong>时，我们也需要使用本地方法。</p><p><strong>Sun’s Java</strong></p><p><mark>Sun 的解释器是用 C 实现的，这使得它能像一些普通的 C 一样与外部交互。</mark>jre 大部分是用 Java 实现的，它也通过一些本地方法与外界交互。例如：类 java.lang.Thread 的 setPriority()方法是用 Java 实现的，但是它实现调用的是该类里的本地方法 setPriority()。这个本地方法是用 C 实现的，并被植入 JVM 内部，在 Windows 95 的平台上，这个本地方法最终将调用 Win32 setPriority() ApI。这是一个本地方法的具体实现由 JVM 直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被 JVw 调用。</p><p><strong>现状</strong></p><p><mark>目前该方法使用的越来越少了，除非是与硬件有关的应用</mark>，比如通过 Java 程序驱动打印机或者 Java 系统管理生产设备，在企业级应用中已经比较少见。因为现在的异构领域间的通信很发达，比如可以使用 Socket 通信，也可以使用 Web Service 等等，不多做介绍。</p><h2 id="52-本地方法栈"><a class="markdownIt-Anchor" href="#52-本地方法栈"></a> 5.2. 本地方法栈</h2><p><mark>Java 虚拟机栈于管理 Java 方法的调用，而本地方法栈用于管理本地方法的调用。</mark></p><p>本地方法栈，也是线程私有的。</p><p>允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）</p><ul><li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java 虚拟机将会抛出一个 StackOverflowError 异常。</li><li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么 Java 虚拟机将会抛出一个 OutOfMemoryError 异常。</li></ul><p>本地方法是使用 C 语言实现的。</p><p>它的具体做法是 Native Method Stack 中登记 native 方法，在 Execution Engine 执行时加载本地方法库。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b4aea15cec874411f749e336c8b5d8fd.png" alt="image-20200706174708418"></p><p><mark>当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。</mark></p><ul><li>本地方法可以通过本地方法接口来<mark>访问虚拟机内部的运行时数据区</mark>。</li><li>它甚至可以直接使用本地处理器中的寄存器</li><li>直接从本地内存的堆中分配任意数量的内存。</li></ul><p><mark>并不是所有的 JVM 都支持本地方法。因为 Java 虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。</mark>如果 JVM 产品不打算支持 native 方法，也可以无需实现本地方法栈。</p><p>在 Hotspot JVM 中，直接将本地方法栈和虚拟机栈合二为一。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h1><p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p><mark><strong>意图：</strong></mark>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p><p><mark><strong>主要解决：</strong></mark>主要解决在软件系统中，有时候面临着"一个复杂对象"的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。</p><p><mark><strong>何时使用：</strong></mark>一些基本部件不会变，而其组合经常变化的时候。</p><p>**如何解决：**将变与不变分离开。</p><p>**关键代码：**建造者：创建和提供实例，导演：管理建造出来的实例的依赖关系。</p><p><strong>应用实例：</strong> 1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的"套餐"。 2、JAVA 中的 StringBuilder。</p><p><strong>优点：</strong> 1、建造者独立，易扩展。 2、便于控制细节风险。</p><p><strong>缺点：</strong> 1、产品必须有共同点，范围有限制。 2、如内部变化复杂，会有很多的建造类。</p><p><strong>使用场景：</strong> 1、需要生成的对象具有复杂的内部结构。 2、需要生成的对象内部属性本身相互依赖。</p><p>**注意事项：**与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>我们假设一个快餐店的商业案例，其中，一个典型的套餐可以是一个汉堡（Burger）和一杯冷饮（Cold drink）。汉堡（Burger）可以是素食汉堡（Veg Burger）或鸡肉汉堡（Chicken Burger），它们是包在纸盒中。冷饮（Cold drink）可以是可口可乐（coke）或百事可乐（pepsi），它们是装在瓶子中。</p><p>我们将创建一个表示食物条目（比如汉堡和冷饮）的 <em>Item</em> 接口和实现 <em>Item</em> 接口的实体类，以及一个表示食物包装的 <em>Packing</em> 接口和实现 <em>Packing</em> 接口的实体类，汉堡是包在纸盒中，冷饮是装在瓶子中。</p><p>然后我们创建一个 <em>Meal</em> 类，带有 <em>Item</em> 的 <em>ArrayList</em> 和一个通过结合 <em>Item</em> 来创建不同类型的 <em>Meal</em> 对象的 <em>MealBuilder</em>。<em>BuilderPatternDemo</em> 类使用 <em>MealBuilder</em> 来创建一个 <em>Meal</em>。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/20210315-builder-pattern.svg" alt="建造者模式的 UML 图"></p><p>运行结果：</p><p><img src="../../../images/image-20221117230502768.png" alt="image-20221117230502768"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建者模式 </category>
          
          <category> 建造者模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h1><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>**意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p><p>**主要解决：**主要解决接口选择的问题。</p><p>**何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。</p><p>**如何解决：**在一个产品族里面，定义多个产品。</p><p>**关键代码：**在一个工厂里聚合多个同类产品。</p><p>**应用实例：**工作了，为了参加一些聚会，肯定有两套或多套衣服吧，比如说有商务装（成套，一系列具体产品）、时尚装（成套，一系列具体产品），甚至对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，这些也都是成套的，即一系列具体产品。假设一种情况（现实中是不存在的，要不然，没法进入共产主义了，但有利于说明抽象工厂模式），在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OOP 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p><p>**优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p><p>**缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。</p><p><strong>使用场景：</strong> 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。</p><p>**注意事项：**产品族难扩展，产品等级易扩展。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>我们将创建 <em>Shape</em> 和 <em>Color</em> 接口和实现这些接口的实体类。下一步是创建抽象工厂类 <em>AbstractFactory</em>。接着定义工厂类 <em>ShapeFactory</em> 和 <em>ColorFactory</em>，这两个工厂类都是扩展了 <em>AbstractFactory</em>。然后创建一个工厂创造器/生成器类 <em>FactoryProducer</em>。</p><p><em>AbstractFactoryPatternDemo</em> 类使用 <em>FactoryProducer</em> 来获取 <em>AbstractFactory</em> 对象。它将向 <em>AbstractFactory</em> 传递形状信息 <em>Shape</em>（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。同时它还向 <em>AbstractFactory</em> 传递颜色信息 <em>Color</em>（<em>RED / GREEN / BLUE</em>），以便获取它所需对象的类型。</p><p><a href="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg"><img src="https://www.runoob.com/wp-content/uploads/2014/08/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg" alt="抽象工厂模式的 UML 图"></a></p><h3 id="步骤-1"><a class="markdownIt-Anchor" href="#步骤-1"></a> 步骤 1</h3><p>为形状创建一个接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤1；为形状创建一个接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤 2</h3><p>创建实现接口的实体类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建实现接口的实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建实现接口的实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Rectangle::draw() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建实现接口的实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-3"><a class="markdownIt-Anchor" href="#步骤-3"></a> 步骤 3</h3><p>为颜色创建一个接口。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 为颜色创建一个接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Color</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤4"><a class="markdownIt-Anchor" href="#步骤4"></a> 步骤4</h3><p>创建实现接口的实体类。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Blue</span> <span class="keyword">implements</span> <span class="title class_">Color</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Blue::fill() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Green</span> <span class="keyword">implements</span> <span class="title class_">Color</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Green::fill() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Red</span> <span class="keyword">implements</span> <span class="title class_">Color</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Red::fill() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-5"><a class="markdownIt-Anchor" href="#步骤-5"></a> 步骤 5</h3><p>为 Color 和 Shape 对象创建抽象类来获取工厂。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Shape <span class="title function_">getShape</span><span class="params">(String shape)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-6"><a class="markdownIt-Anchor" href="#步骤-6"></a> 步骤 6</h3><p>创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ColorFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span> {</span><br><span class="line">        <span class="keyword">if</span>(color == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"RED"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Red</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"GREEN"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Green</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(color.equalsIgnoreCase(<span class="string">"BLUE"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Blue</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractFactory</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> {</span><br><span class="line">        <span class="keyword">if</span>(shapeType == <span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Color <span class="title function_">getColor</span><span class="params">(String color)</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-7"><a class="markdownIt-Anchor" href="#步骤-7"></a> 步骤 7</h3><p>创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryProducer</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> AbstractFactory <span class="title function_">getFactory</span><span class="params">(String choice)</span> {</span><br><span class="line">        <span class="keyword">if</span> (choice.equalsIgnoreCase(<span class="string">"SHAPE"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (choice.equalsIgnoreCase(<span class="string">"COLOR"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ColorFactory</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-8"><a class="markdownIt-Anchor" href="#步骤-8"></a> 步骤 8</h3><p>使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AbstractFactoryPatternDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状工厂</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> FactoryProducer.getFactory(<span class="string">"SHAPE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Circle 的对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Rectangle 的对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取形状为 Square 的对象</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色工厂</span></span><br><span class="line">        <span class="type">AbstractFactory</span> <span class="variable">colorFactory</span> <span class="operator">=</span> FactoryProducer.getFactory(<span class="string">"COLOR"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Red 的对象</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color1</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">"RED"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Red 的 fill 方法</span></span><br><span class="line">        color1.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Green 的对象</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color2</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">"GREEN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Green 的 fill 方法</span></span><br><span class="line">        color2.fill();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取颜色为 Blue 的对象</span></span><br><span class="line">        <span class="type">Color</span> <span class="variable">color3</span> <span class="operator">=</span> colorFactory.getColor(<span class="string">"BLUE"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用 Blue 的 fill 方法</span></span><br><span class="line">        color3.fill();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br><span class="line">Inside Red::fill() method.</span><br><span class="line">Inside Green::fill() method.</span><br><span class="line">Inside Blue::fill() method.</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建者模式 </category>
          
          <category> 抽象工厂模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4. 虚拟机栈</title>
      <link href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
      <url>/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="4-虚拟机栈"><a class="markdownIt-Anchor" href="#4-虚拟机栈"></a> 4. 虚拟机栈</h1><h2 id="41-虚拟机栈概述"><a class="markdownIt-Anchor" href="#41-虚拟机栈概述"></a> 4.1. 虚拟机栈概述</h2><h3 id="411-虚拟机栈出现的背景"><a class="markdownIt-Anchor" href="#411-虚拟机栈出现的背景"></a> 4.1.1. 虚拟机栈出现的背景</h3><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。</p><h3 id="412-初步印象"><a class="markdownIt-Anchor" href="#412-初步印象"></a> 4.1.2. 初步印象</h3><p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p><h3 id="413-内存中的栈与堆"><a class="markdownIt-Anchor" href="#413-内存中的栈与堆"></a> 4.1.3. 内存中的栈与堆</h3><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p><ul><li><strong>栈</strong>解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li><li><strong>堆</strong>解决的是数据存储的问题，即数据怎么放，放哪里</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/2d195f3aafd8b1f426efad75f0a52478.png" alt="image-20200705163928652"></p><h3 id="414-虚拟机栈基本内容"><a class="markdownIt-Anchor" href="#414-虚拟机栈基本内容"></a> 4.1.4. 虚拟机栈基本内容</h3><h4 id="java-虚拟机栈是什么"><a class="markdownIt-Anchor" href="#java-虚拟机栈是什么"></a> Java 虚拟机栈是什么？</h4><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。<strong>每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），<font color="red">对应着一次次的 Java 方法调用</font>，是线程私有的</strong>。</p><h4 id="生命周期"><a class="markdownIt-Anchor" href="#生命周期"></a> 生命周期</h4><p>生命周期和线程一致</p><h4 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h4><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p><h4 id="栈的特点-优点"><a class="markdownIt-Anchor" href="#栈的特点-优点"></a> 栈的特点 ( 优点 )</h4><p>栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。</p><p>JVM 直接对 Java 栈的操作只有两个：</p><ul><li>每个方法执行，伴随着进栈（入栈、压栈）</li><li>执行结束后的出栈工作</li></ul><p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d4e4445f4faee685dc98d54129344bb3.png" alt="image-20200705165025382"></p><h4 id=""><a class="markdownIt-Anchor" href="#"></a> </h4><p><img src="../../../images/image-20221116180408869.png" alt="image-20221116180408869"></p><h4 id="面试题开发中遇到哪些异常"><a class="markdownIt-Anchor" href="#面试题开发中遇到哪些异常"></a> 面试题：开发中遇到哪些异常？</h4><p><strong>栈中可能出现的异常</strong></p><p>Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。</p><ul><li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。</p></li><li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    test();</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    test();</span><br><span class="line">}</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread"main"java.lang.StackoverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></tbody></table></figure><p><strong>设置栈内存大小</strong></p><p>我们可以使用参数 <strong>-Xss</strong> 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p><p><img src="../../../images/image-20221116184119213.png" alt="image-20221116184119213"></p><h2 id="42-栈的存储单位"><a class="markdownIt-Anchor" href="#42-栈的存储单位"></a> 4.2. 栈的存储单位</h2><h3 id="421-栈中存储什么"><a class="markdownIt-Anchor" href="#421-栈中存储什么"></a> 4.2.1. 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。</p><p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p><p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p><h3 id="422-栈运行原理"><a class="markdownIt-Anchor" href="#422-栈运行原理"></a> 4.2.2. 栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”/“后进先出”原则</mark>。</p><p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。</p><p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p><p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/893126a7a33507917e11377fd3e4b639.png" alt="image-20200705203142545"></p><p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p><p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p><p>Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</mark>。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentFrameTest</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>{</span><br><span class="line">        system.out.println（<span class="string">"当前栈帧对应的方法-&gt;methodA"</span>);</span><br><span class="line">        methodB();</span><br><span class="line">        system.out.println（<span class="string">"当前栈帧对应的方法-&gt;methodA"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>{</span><br><span class="line">        System.out.println（<span class="string">"当前栈帧对应的方法-&gt;methodB"</span>);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="423-栈帧的内部结构"><a class="markdownIt-Anchor" href="#423-栈帧的内部结构"></a> 4.2.3. 栈帧的内部结构</h3><p>每个栈帧中存储着：</p><ul><li><mark>局部变量表（Local Variables）</mark></li><li><mark>操作数栈（operand Stack）（或表达式栈）</mark></li><li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li><li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li><li>一些附加信息</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0ed2029b435d547547f32540077bb082.png" alt="image-20200705204836977"></p><p>虚拟机栈中的栈帧的数量取决于栈帧的大小，栈帧的大小主要取决于局部变量表和操作数栈的大小。</p><p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p><p><img src="https://img-blog.csdnimg.cn/img_convert/2451fa6f061c426179e3674bb6813e46.png" alt="image-20200705205443993"></p><h2 id="43-局部变量表local-variables"><a class="markdownIt-Anchor" href="#43-局部变量表local-variables"></a> 4.3. 局部变量表(Local Variables)</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p><ul><li><p><mark>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</p></li><li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<mark>不存在数据安全问题</mark></p></li><li><p><mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p></li><li><p><mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p></li><li><p><mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p></li></ul><h3 id="431-关于-slot-的理解"><a class="markdownIt-Anchor" href="#431-关于-slot-的理解"></a> 4.3.1. 关于 Slot 的理解</h3><ul><li><p>局部变量表，最基本的存储单元是 Slot（变量槽）</p></li><li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束。</p></li><li><p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</p></li><li><p>在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</p></li><li><p>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</p></li><li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p></li><li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot 上</p></li><li><p><mark>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</mark>。（比如：访问 long 或 doub1e 类型变量）</p></li><li><p>如果当前帧是由构造方法或者实例方法创建的，那么<mark>该对象引用 this 将会存放在 index 为 0 的 slot 处</mark>，其余的参数按照参数表顺序继续排列。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/866e014106701648c63c0b232066fced.png" alt="image-20200705212454445"></p><h3 id="432-slot-的重复利用"><a class="markdownIt-Anchor" href="#432-slot-的重复利用"></a> 4.3.2. Slot 的重复利用</h3><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlotTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarl</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVar2</span><span class="params">()</span> {</span><br><span class="line">        {</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//此时的就会复用a的槽位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="433-静态变量与局部变量的对比"><a class="markdownIt-Anchor" href="#433-静态变量与局部变量的对比"></a> 4.3.3. 静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p><p>我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。</p><p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    System. out. println(i);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样的代码是错误的，没有赋值不能够使用。</p><h3 id="434-补充说明"><a class="markdownIt-Anchor" href="#434-补充说明"></a> 4.3.4. 补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p><p><mark>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。</p><h2 id="44-操作数栈operand-stack"><a class="markdownIt-Anchor" href="#44-操作数栈operand-stack"></a> 4.4. 操作数栈（Operand Stack）</h2><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 <mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark></p><p><mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark></p><ul><li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li><li>比如：执行复制、交换、求和等操作</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/7f911f276f834d820fa09f31dd63a74b.png" alt="image-20200706090618332"></p><p>代码举例</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>字节码指令信息</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation();</span><br><span class="line">    Code:</span><br><span class="line">    0: bipush 15</span><br><span class="line">    2: istore_1</span><br><span class="line">    3: bipush 8</span><br><span class="line">    5: istore_2</span><br><span class="line">    6:iload_1</span><br><span class="line">    7:iload_2</span><br><span class="line">    8:iadd</span><br><span class="line">    9:istore_3</span><br><span class="line">    10:return</span><br></pre></td></tr></tbody></table></figure><p>操作数栈，<mark>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</mark>。</p><p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。</p><p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max_stack 的值。</p><p>栈中的任何一个元素都是可以任意的 Java 数据类型</p><ul><li>32bit 的类型占用一个栈单位深度</li><li>64bit 的类型占用两个栈单位深度</li></ul><p>操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p><p><mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。</p><p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p><p>另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。</p><h2 id="45-代码追踪"><a class="markdownIt-Anchor" href="#45-代码追踪"></a> 4.5. 代码追踪</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation() {</span><br><span class="line">    byte i = 15;</span><br><span class="line">    int j = 8;</span><br><span class="line">    int k = i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>使用 javap 命令反编译 class 文件：<code> javap -v 类名.class</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddoperation</span><span class="params">()</span>; Code:<span class="number">0</span>: bipush <span class="number">15</span> <span class="number">2</span>: istore_1 <span class="number">3</span>: bipush <span class="number">8</span><span class="number">5</span>: istore_2<span class="number">6</span>: iload_1<span class="number">7</span>: iload_2<span class="number">8</span>: iadd<span class="number">9</span>: istore_3    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/da41b01ad08238a2c8065552aaa7d676.png" alt="image-20200706093131621"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6867c7a53a4faff29318783b46aef097.png" alt="image-20200706093251302"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2d6c5d906914ebdca0a472fee33e047.png" alt="image-20200706093646406"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6ef9c2eb8ac3395133950caf8ef80da3.png" alt="image-20200706093751711"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/28113c3dc724bbffe677ea61b49e7c56.png" alt="image-20200706093859191"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/f960c074fb4a6b1f35e862568ed23d04.png" alt="image-20200706093921573"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/73a07a0e10bef2537b6da97a5348fee2.png" alt="image-20200706094046782"></p><p><img src="https://img-blog.csdnimg.cn/img_convert/17309b8150015a8b359f2cb2ef78cb60.png" alt="image-20200706094109629"></p><p><init>就是我们的构造器，任何类方法都会有<init><img src="../../../images/image-20221116214709319.png" alt="image-20221116214709319"></init></init></p><p>就是我们定义的方法：<img src="../../../images/image-20221116214722349.png" alt="image-20221116214722349"></p><p><img src="../../../images/image-20221116220618255.png" alt="image-20221116220618255"></p><p>相当于8在byte范围内，一个字节能存，push之后，再istore，就是以int类型存储了</p><p><img src="../../../images/image-20221116220949208.png" alt="image-20221116220949208"></p><p>程序员面试过程中，常见的 i<ins>和</ins>i 的区别，放到字节码篇章时再介绍。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序员面试过程中，常见的 i++ 和 ++i 的区别，放到字节码篇章时再介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 第1类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i1 ++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    ++i2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> i3++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i6</span> <span class="operator">=</span> ++i5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i7</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i7 = i7 ++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i8</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i8 = ++i8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i10</span> <span class="operator">=</span> i9++ + ++i9;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="46-栈顶缓存技术top-of-stack-cashing技术"><a class="markdownIt-Anchor" href="#46-栈顶缓存技术top-of-stack-cashing技术"></a> 4.6. 栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。</p><p>由于<strong>操作数是存储在内存中</strong>的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<mark>将<strong>栈顶元素</strong>全部<strong>缓存</strong>在<strong>物理 CPU 的寄存器</strong>中，以此<strong>降低对内存的读/写次数</strong>，提升执行引擎的执行效率</mark>。</p><h2 id="47-动态链接dynamic-linking"><a class="markdownIt-Anchor" href="#47-动态链接dynamic-linking"></a> 4.7. 动态链接（Dynamic Linking）</h2><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p><p>每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p><p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的<strong>常量池</strong>（Constant pool）里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark><strong>动态链接的作用</strong>就是为了将这些符号引用转换为调用方法的直接引用</mark>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/31f48e82748240d7694e542374e9d723.png" alt="image-20200706101251847"></p><p><strong>为什么需要运行时常量池呢？</strong></p><p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p><p>比如：编译一个java代码时，所有的结构其实都需要我们加载到内存当中，但我们不能在字节码文件里面直接把这些结构都全部写出来，不然会导致字节码文件会很大。我们可以通过符号引用的方式去引用相关的结构就可以了，因此字节码文件就可以比较小，要使用时，直接用指针来指向即可</p><h2 id="48-方法的调用解析与分配"><a class="markdownIt-Anchor" href="#48-方法的调用解析与分配"></a> 4.8. 方法的调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p><h3 id="481-静态链接"><a class="markdownIt-Anchor" href="#481-静态链接"></a> 4.8.1. 静态链接</h3><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p><h3 id="482-动态链接"><a class="markdownIt-Anchor" href="#482-动态链接"></a> 4.8.2. 动态链接</h3><p>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p><p><mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark></p><hr><p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark></p><h3 id="483-早期绑定"><a class="markdownIt-Anchor" href="#483-早期绑定"></a> 4.8.3. 早期绑定</h3><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p><h3 id="484-晚期绑定"><a class="markdownIt-Anchor" href="#484-晚期绑定"></a> 4.8.4. 晚期绑定</h3><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p><hr><p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark></p><p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C<ins>语言中的虚函数（C</ins>中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p><hr><h3 id="485-虚方法和非虚方法"><a class="markdownIt-Anchor" href="#485-虚方法和非虚方法"></a> 4.8.5. 虚方法和非虚方法</h3><p>**非虚方法：**如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p><p>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。</p><p>**虚方法：**在编译期间没法确定下来的。除了上面的非虚方法包含的，其他方法称为虚方法。</p><p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>{   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>{ </span><br><span class="line">        System. out. println(<span class="string">"father "</span>+str);</span><br><span class="line">    }    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span>{      </span><br><span class="line">        System. out. println(<span class="string">"father"</span>+str);  </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>{  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualMethodTest</span>{   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>{   </span><br><span class="line">            Son.print(<span class="string">"coder"</span>);      </span><br><span class="line">            <span class="comment">//Father fa=new Father();      </span></span><br><span class="line">            <span class="comment">//fa.show("atguigu.com");      </span></span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>虚拟机中提供了以下几条方法调用指令：</p><h4 id="普通调用指令"><a class="markdownIt-Anchor" href="#普通调用指令"></a> 普通调用指令：</h4><ul><li><mark>invokestatic：调用静态方法，解析阶段确定唯一方法版本</mark></li><li><mark>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</mark></li><li>invokevirtual：调用所有虚方法</li><li>invokeinterface：调用接口方法</li></ul><h4 id="动态调用指令"><a class="markdownIt-Anchor" href="#动态调用指令"></a> 动态调用指令：</h4><ul><li>invokedynamic：动态解析出需要调用的方法，然后执行</li></ul><p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。<mark>其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</mark></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 解析调用中非虚方法、虚方法的测试</span><br><span class="line"> * 其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/17</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Father {</span><br><span class="line">    public Father() {</span><br><span class="line">        System.out.println( "father 的构造器" );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void showStatic(String str) {</span><br><span class="line">        System.out.println("father" + str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public final void showFinal() {</span><br><span class="line">        System.out.println("father show final");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void showCommon() {</span><br><span class="line">        System.out.println("father 普通方法");</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public class Son extends Father {</span><br><span class="line">    public Son() {</span><br><span class="line">        // invokespecial #1 &lt;jvm/chapter04/Father.&lt;init&gt; : ()V&gt;</span><br><span class="line">        super();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public Son(int age) {</span><br><span class="line">        // invokespecial #3 &lt;jvm/chapter04/Son.&lt;init&gt; : ()V&gt;</span><br><span class="line">        this();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不是重写的静态方法，因为静态方法不能被重写</span><br><span class="line">     */</span><br><span class="line">    public static void showStatic(String str) {</span><br><span class="line">        System.out.println("son " + str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void showPrivate(String str) {</span><br><span class="line">        System.out.println("son private " +str);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void show() {</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            非虚方法：</span><br><span class="line">         */</span><br><span class="line">        // 这showStatic 和 Father.showStatic("good") 两个都是调用的静态方法，所有都是非虚方法</span><br><span class="line">        // invokestatic #13 &lt;jvm/chapter04/Son.showStatic : (Ljava/lang/String;)V&gt;</span><br><span class="line">        showStatic("qrly.com");</span><br><span class="line">        //  invokestatic #15 &lt;jvm/chapter04/Father.showStatic : (Ljava/lang/String;)V&gt;</span><br><span class="line">        Father.showStatic("good");</span><br><span class="line">        // invokespecial #17 &lt;jvm/chapter04/Son.showPrivate : (Ljava/lang/String;)V&gt;</span><br><span class="line">        showPrivate("hello");</span><br><span class="line">        // invokespecial #18 &lt;jvm/chapter04/Father.showCommon : ()V&gt;</span><br><span class="line">        super.showCommon();</span><br><span class="line"></span><br><span class="line">        // invokevirtual #19 &lt;jvm/chapter04/Son.showFinal : ()V&gt;</span><br><span class="line">        // 因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法</span><br><span class="line">        // 虚方法是编译期间没法确定下里的才是虚方法</span><br><span class="line">        showFinal();</span><br><span class="line">        // invokespecial #20 &lt;jvm/chapter04/Father.showFinal : ()V&gt;</span><br><span class="line">        super.showFinal();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">          虚方法如下：</span><br><span class="line">         */</span><br><span class="line">        // invokevirtual #20 &lt;jvm/chapter04/Son.showCommon : ()V&gt;</span><br><span class="line">        // 由于没有加 super.来调用，且有可能这个方法会在子类里面重写，所以在编译期间是没法确定的，所以这个是虚方法</span><br><span class="line">        showCommon();</span><br><span class="line">        // invokevirtual #21 &lt;jvm/chapter04/Son.info : ()V&gt;</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = null;</span><br><span class="line">        // invokeinterface #22 &lt;jvm/chapter04/MethodInterface.methodA : ()V&gt; count 1</span><br><span class="line">        // 要调用接口中的方法，在执行的时候肯定要被实现类里实现的</span><br><span class="line">        in.methodA();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void info() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public void display(Father f) {</span><br><span class="line">        f.showCommon();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        Son so = new Son();</span><br><span class="line">        so.show();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">interface MethodInterface {</span><br><span class="line">    void methodA();</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><img src="../../../images/image-20221117111404877.png" alt="image-20221117111404877"></p><p><img src="../../../images/image-20221117112919097.png" alt="image-20221117112919097"></p><p><strong>关于 invokednamic 指令</strong></p><ul><li><p>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark></p></li><li><p>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。<mark>直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</mark></p></li><li><p>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p></li></ul><h4 id="动态类型语言和静态类型语言"><a class="markdownIt-Anchor" href="#动态类型语言和静态类型语言"></a> 动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p><p>说的再直白一点就是，<mark>静态类型语言是判断<strong>变量</strong>自身的类型信息；动态类型语言是判断<strong>变量值</strong>的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。</p><p>java主要的还是静态类型语言的特点，而Python 和 JS 是动态类型语言</p><h3 id="486-方法重写的本质"><a class="markdownIt-Anchor" href="#486-方法重写的本质"></a> 4.8.6. 方法重写的本质</h3><p><strong>Java 语言中方法重写的本质：</strong></p><ol><li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li><li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li><li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出 java.1ang.AbstractMethodsrror 异常。</li></ol><p><strong>IllegalAccessError 介绍</strong></p><p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p><h3 id="487-方法的调用虚方法表"><a class="markdownIt-Anchor" href="#487-方法的调用虚方法表"></a> 4.8.7. 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark></p><p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p><p>虚方法表是什么时候被创建的呢？</p><p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p><p>举例 1：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/79470fa420092e07a411e4e849f743b8.png" alt="image-20200706144954070"></p><p>举例 2：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Friendly</span>{   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span>; </span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>{   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>{   </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tostring</span><span class="params">()</span>{     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Dog"</span>;   </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span> {   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> {  </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> { </span><br><span class="line">    }     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> {   </span><br><span class="line">    }    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> {   </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CockerSpaniel</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span>{  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> {      </span><br><span class="line">        <span class="built_in">super</span>.sayHello();  </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> { </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/img_convert/2264627eaca3c5385a75101478565f5b.png" alt="image-20210509203351535"></p><h2 id="49-方法返回地址return-address"><a class="markdownIt-Anchor" href="#49-方法返回地址return-address"></a> 4.9. 方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p><ul><li>正常执行完成</li><li>出现未处理的异常，非正常退出</li></ul><p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p><p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p><ol><li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；<ul><li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li><li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li></ul></li><li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。</li></ol><p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">from to   target type</span><br><span class="line">4 16  19   any</span><br><span class="line">19 21  19   any</span><br></pre></td></tr></tbody></table></figure><p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p><p><mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark></p><h2 id="410-一些附加信息"><a class="markdownIt-Anchor" href="#410-一些附加信息"></a> 4.10. 一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p><h2 id="411-栈的相关面试题"><a class="markdownIt-Anchor" href="#411-栈的相关面试题"></a> 4.11. 栈的相关面试题</h2><ul><li><p>举例栈溢出的情况？（StackOverflowError）</p><ul><li>当栈空间不足的时候，就会导致栈溢出的情况，会报StackOverflowError</li><li>通过 -Xss 设置栈的大小</li></ul></li><li><p>调整栈大小，就能保证不出现溢出么？</p><ul><li>不能保证不溢出</li></ul></li><li><p>分配的栈内存越大越好么？</p><ul><li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li></ul></li><li><p>垃圾回收是否涉及到虚拟机栈？</p><ul><li>不会</li></ul></li><li><p>方法中定义的局部变量是否线程安全？</p><ul><li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li></ul></li></ul><table><thead><tr><th style="text-align:left">运行时数据区</th><th style="text-align:left">是否存在 Error</th><th style="text-align:left">是否存在 GC</th></tr></thead><tbody><tr><td style="text-align:left">程序计数器</td><td style="text-align:left">否</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">虚拟机栈</td><td style="text-align:left">是（SOE）</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">本地方法栈</td><td style="text-align:left">是</td><td style="text-align:left">否</td></tr><tr><td style="text-align:left">方法区</td><td style="text-align:left">是（OOM）</td><td style="text-align:left">是</td></tr><tr><td style="text-align:left">堆</td><td style="text-align:left">是</td><td style="text-align:left">是</td></tr></tbody></table><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P62_StringBuilderTest</span> {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的声明方式是线程安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> {</span><br><span class="line">        <span class="comment">// StringBuider:线程不安全的</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sBuider的操作过程：是线程不安全的，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuider)</span> {</span><br><span class="line">        sBuider.append(<span class="string">"a"</span>);</span><br><span class="line">        sBuider.append(<span class="string">"b"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的操作：是线程不安全的</span></span><br><span class="line"><span class="comment">     * 因为StringBuilder被返回，发生逃逸，返回的话就可能会被其它线程拿去用，导致不安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的操作：是线程安全的</span></span><br><span class="line"><span class="comment">     * 因为s1在方法内部生命周期就结束了。没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">"a"</span>);</span><br><span class="line">        s1.append(<span class="string">"b"</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            s.append(<span class="string">"a"</span>);</span><br><span class="line">            s.append(<span class="string">"b"</span>);</span><br><span class="line">        }).run();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3. 运行时数据区及程序计数器</title>
      <link href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
      <url>/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<blockquote></blockquote><p>[toc]</p><h1 id="3-运行时数据区-及-程序计数器"><a class="markdownIt-Anchor" href="#3-运行时数据区-及-程序计数器"></a> 3. 运行时数据区 及 程序计数器</h1><h2 id="31-运行时数据区"><a class="markdownIt-Anchor" href="#31-运行时数据区"></a> 3.1. 运行时数据区</h2><h3 id="311-概述"><a class="markdownIt-Anchor" href="#311-概述"></a> 3.1.1. 概述</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p><p><img src="https://img-blog.csdnimg.cn/img_convert/b5d91ce04cfef9a681bbed216732511a.png" alt="image-20200705111640511"></p><p>当我们通过前面的：<strong>类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化</strong> 这几个阶段完成后，就会用到<strong>执行引擎</strong>对我们的类进行使用，同时执行引擎将会使用到我们<strong>运行时数据区</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/b3cd82be688254afd263db9094e004a7.png" alt="image-20200705111843003"></p><p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/d6f0aac226ebab0c435b8fe79995eddc.png" alt="image-20210509174724223"></p><p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bbf59f2544890b06cdb69b2d7719c060.png" alt="image-20210509174543026"></p><p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说<strong>内存充当了 CPU 和磁盘之间的桥梁</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/d9139f792f2d10eb03fb827da25b3b28.png" alt="image-20200705112416101"></p><p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p><p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p><ul><li>每个线程：独立包括程序计数器、栈、本地栈。</li><li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/0f0cce71a35c12ef13e6482d0663dc21.png" alt="image-20200705112601211"></p><p>每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/efc4643bdd550c6ecacb9d764e71890e.png" alt="image-20210509173410373"></p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><hr><h3 id="312-线程"><a class="markdownIt-Anchor" href="#312-线程"></a> 3.1.2. 线程</h3><p><strong>线程是一个程序里的运行单元</strong>。JVM 允许一个应用有多个线程并行的执行。 <strong>在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射</strong>。</p><p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p><p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p><p><img src="http://img10.360buyimg.com/n7/s523x355_jfs/t6595/305/70607884/742714/c76b7170/59390c8aNf12b52ac.bmp" alt="image"></p><p>JVM 是否要终止还要取决于当前线程是不是最后一个非守护线程（线程分为 守护线程、非守护线程）。如果们内存中都只剩下守护线程的话，JVM就可以退出了。</p><p>守护进程就是服务进程(例如GC进程,他们的存在不是必须的),当所有非守护进程执行结束了,守护就没有存在的意义了,自然jvm的运行就可以停止了</p><h3 id="313-jvm-系统线程"><a class="markdownIt-Anchor" href="#313-jvm-系统线程"></a> 3.1.3. JVM 系统线程</h3><p>如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p><p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p><ul><li><mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括"stop-the-world"的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li><li><mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于<strong>周期性操作的调度执行</strong>。</li><li><mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的<strong>垃圾收集</strong>行为提供了支持。</li><li><mark>编译线程</mark>：这种线程在<strong>运行时会将字节码编译成到本地代码</strong>。</li><li><mark>信号调度线程</mark>：这种线程接<strong>收信号并发送给 JVM</strong>，在它内部通过调用适当的方法进行处理。</li></ul><h2 id="32-程序计数器pc-寄存器"><a class="markdownIt-Anchor" href="#32-程序计数器pc-寄存器"></a> 3.2. 程序计数器(PC 寄存器)</h2><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e6785d89d74d694f7cfe22ba74a164d9.png" alt="image-20200705155551919"></p><p><strong>作用</strong></p><p><strong>PC 寄存器</strong>用来<strong>存储指向下一条指令的地址，也即将要执行的指令代码</strong>。由<strong>执行引擎</strong>读取下一条指令。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/998d864c026e5d6b565d1cfaecda2bb0.png" alt="image-20200705155728557"></p><p>它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。</p><p>在 JVM 规范中，<mark><strong>每个线程都有它自己的程序计数器</strong>，是线程<strong>私有</strong>的，生命周期与线程的生命周期保持一致</mark>。</p><p><mark>任何时间一个线程都只有一个方法在执行，也就是所谓的<strong>当前方法</strong></mark>。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。</p><p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p><p><strong>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</strong></p><p><strong>Stack Area、Native Method Stack</strong> 都没有GC垃圾回收，但是有可能发生OOM内存溢出</p><p><strong>Method Area 和 Head Area</strong>都有GC垃圾回收，也会发生OOM内存溢出</p><p>PC寄存器既没有GC，也没有OOM (OutOfMemoryError )</p><p><strong>举例说明</strong></p><p><img src="../../../images/image-20221116095436397.png" alt="image-20221116095436397"></p><p>字节码文件分析：</p><p><img src="../../../images/image-20221116095326530.png" alt="image-20221116095326530"></p><h1 id="pc寄存器面试问题"><a class="markdownIt-Anchor" href="#pc寄存器面试问题"></a> PC寄存器面试问题</h1><p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p><p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p><p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68aa12d47725e4559e6b71489d91122e.png" alt="image-20200705161409533"></p><p><strong>PC 寄存器为什么被设定为私有的？</strong></p><p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p><p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p><p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p><p><strong>CPU 时间片</strong></p><p><strong>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</strong></p><p>在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p><p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bbab7cdab74c493af70b423f06e6ff86.png" alt="image-20200705161849557"></p><p>了解一下</p><p>并行、串行</p><p>并行、并发</p><p>的概念和区别</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式</title>
      <link href="/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="工厂模式"><a class="markdownIt-Anchor" href="#工厂模式"></a> 工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p><p>在工厂模式中，<strong>我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>**意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p><p>**主要解决：**主要解决接口选择的问题。</p><p>**何时使用：**我们明确地计划不同条件下创建不同实例时。</p><p>**如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。</p><p>**关键代码：**创建过程在其子类执行。</p><p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p><p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p><p>**缺点：**每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p><p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，“POP3”、“IMAP”、“HTTP”，可以把这三个作为产品类，共同实现一个接口。</p><p>**注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p><h2 id="实现"><a class="markdownIt-Anchor" href="#实现"></a> 实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p><p><em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE / RECTANGLE / SQUARE</em>），以便获取它所需对象的类型。</p><p><img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图"></p><h3 id="步骤-1"><a class="markdownIt-Anchor" href="#步骤-1"></a> 步骤 1</h3><p>创建一个接口:</p><h2 id="shapejava"><a class="markdownIt-Anchor" href="#shapejava"></a> Shape.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤1：创建一个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-2"><a class="markdownIt-Anchor" href="#步骤-2"></a> 步骤 2</h3><p>创建实现接口的实体类。</p><h2 id="rectanglejava"><a class="markdownIt-Anchor" href="#rectanglejava"></a> Rectangle.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>{</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        System.out.println( <span class="string">"Inside Rectangle :: draw() method."</span> );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="squarejava"><a class="markdownIt-Anchor" href="#squarejava"></a> Square.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Square::draw() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="circlejava"><a class="markdownIt-Anchor" href="#circlejava"></a> Circle.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"Inside Circle::draw() method."</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-3"><a class="markdownIt-Anchor" href="#步骤-3"></a> 步骤 3</h3><p>创建一个工厂，生成基于给定信息的实体类的对象。</p><h2 id="shapefactoryjava"><a class="markdownIt-Anchor" href="#shapefactoryjava"></a> ShapeFactory.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤3：创建一个工厂，生成基于给定信息的实体类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 getShape 方法获取类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> {</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-4"><a class="markdownIt-Anchor" href="#步骤-4"></a> 步骤 4</h3><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p><h2 id="factorypatterndemojava"><a class="markdownIt-Anchor" href="#factorypatterndemojava"></a> FactoryPatternDemo.java</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤4：使用该工厂，通过传递类型信息来获取实体类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatterDemo</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line">        <span class="comment">// 调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="步骤-5"><a class="markdownIt-Anchor" href="#步骤-5"></a> 步骤 5</h3><p>执行程序，输出结果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></tbody></table></figure><p>截图分析</p><p><img src="../../../images/image-20221115223614920.png" alt="image-20221115223614920"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
          <category> 创建者模式 </category>
          
          <category> 工厂模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 创建者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(JVM)双亲委派机制</title>
      <link href="/2022/11/15/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/11/15/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="双亲委派机制"><a class="markdownIt-Anchor" href="#双亲委派机制"></a> 双亲委派机制</h1><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> <strong>工作原理</strong></h2><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）<strong>如果父类加载器可以完成类加载任务，就成功返回</strong>（就不会由子类加载器去加载了），倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p><p>举例：</p><ol><li></li></ol><p><img src="../../../images/image-20221115204949307.png" alt="image-20221115204949307"></p><p>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。一看你是java开头的，引导类加载就说了。这是归我管我来加载String（核心API里的String）。因此有父类来加载后，就不会再向下委托了，所以我们new 的这个String对象就是核心API里面的String类对象，而不是我们自定义的String，因此就没有打印出自定义String里的static静态资源里的语句</p><ol start="2"><li></li></ol><p><img src="../../../images/image-20221115205956137.png" alt="image-20221115205956137"></p><p>委托到引导类加载器，它发现你这个包是jvm开头的，不归引导类加载管，就向下委托，也不归扩展类加载器管，所以最后回到系统类加载器来加载，因此最后输出结果就是系统类加载来进行的加载</p><ol start="3"><li></li></ol><p><img src="../../../images/image-20221115210219781.png" alt="image-20221115210219781"></p><p>一直往上委托，就交给到了引导类加载器，它加载了String类以后，然后就想去执行main方法，但是核心API的String里面是没有main方法的，所以就报了 <mark>错误: 在类 java.lang.String 中找不到 main 方法</mark>. 可知，根本就没有试着想去加载我们自定义的String类，完全忽略掉你了</p><ol start="4"><li></li></ol><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p><h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> <strong>优势</strong></h2><ul><li><strong>避免类的重复加载</strong></li><li><strong>保护程序安全，防止核心 API 被随意篡改</strong><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><img src="../../../images/image-20221115212723174.png" alt="image-20221115212723174"></p><p>引导类加载器看到是 java.lang开头的，就表示这是归它管，于是就要去加载这个ShkStart类了，但直接直接给它报错了，相当于，要加载java.lang这个包，要想访问是要有权限的，现在报错就是阻止我们去直接用这个java.lang包来自定义这个ShkStart类。其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个类，加载成功的话，就会导致对引导类加载器本身造成影响，所以这里是直接把引导类加载器给整挂了。所以我们也禁止去用java.lang这样的包名去命名</p><p>其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个种自定义的类，加载成功的话，但里面可能会有一些<strong>恶意代码</strong>，就可能会会对现有的项目和程序进行破坏</p><h2 id="弊端"><a class="markdownIt-Anchor" href="#弊端"></a> 弊端</h2><p>​检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p><p>​通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<font color="red">应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题</font>。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p><h2 id="14-代码支持"><a class="markdownIt-Anchor" href="#14-代码支持"></a> 1.4 代码支持</h2><p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p><p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p><p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p><p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p><p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p><p>双亲委派的模型就隐藏在这第2和第3步中。</p><h2 id="15-举例"><a class="markdownIt-Anchor" href="#15-举例"></a> 1.5 举例</h2><p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p><h2 id="16-思考"><a class="markdownIt-Anchor" href="#16-思考"></a> 1.6 思考</h2><p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p><p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p><h2 id="18-结论"><a class="markdownIt-Anchor" href="#18-结论"></a> 1.8 结论</h2><p>由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p><h2 id="沙箱安全机制"><a class="markdownIt-Anchor" href="#沙箱安全机制"></a> <strong>沙箱安全机制</strong></h2><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
          <category> interview </category>
          
          <category> interview </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2022/11/14/interview/redis/Redis/"/>
      <url>/2022/11/14/interview/redis/Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="1-说说你对redis的了解"><a class="markdownIt-Anchor" href="#1-说说你对redis的了解"></a> 1. 说说你对Redis的了解</h2><p>**得分点 : **Redis概念，Redis优点及用途</p><p><strong>标准回答</strong> ：</p><p>Redis是一款基于键值对的NoSQL数据库,与其他键值对数据库不同的是,<strong>Redis中拥有string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构,这给Redis带来了满足多种应用场景的能力</strong>,而且,Redis将所有数据放到内存中的做法让它的读写性能十分惊人。不仅如此,Redis的<strong>持久化机制</strong>保证了在发生类似断电,机械故障等情况时,内存中的数据不会丢失。此外Redis还提供了<strong>键过期、发布订阅、事务、流水线、Lua脚本等多个附加功能</strong>。总之,在合适的情况下使用Redis会大大增强系统的性能,减少开发人员工作量。</p><p><strong>加分回答</strong></p><p>适合Redis使用的场景：</p><ul><li>热点数据的缓存：redis访问速度快、支持的数据类型丰富,很适合用来存储热点数据。</li><li>限时业务：redis中可以使用expire命令设置一个键的生存时间,到时间后redis会删除它。因此,Redis在限时业务中的表现很亮眼。</li><li>计数器：incrby命令可以实现原子性的递增,所以可以运用于高并发的秒杀活动、分布式序列号的生成。</li><li>排行榜：关系型数据库在排行榜方面查询速度普遍偏慢,所以可以借助redis的SortedSet进行热点数据的排序。</li><li>分布式锁：这个主要利用redis的setnx命令进行,在后面的如何用Redis实现一个分布式锁中会进行详解。</li><li>延时操作：redis自2.8.0之后版本提供Keyspace Notifications功能,允许客户订阅Pub/Sub频道,以便以某种方式接收影响Redis数据集的事件。</li><li>分页查询、模糊查询：Redis的set集合中提供了一个zrangebylex方法,通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询,其中- +表示获取全部数据；rangebylex key min max 这个就可以返回字典区间的数据可以利用这个特性可以进行模糊查询功能。</li><li>点赞,好友等相互关系的存储：Redis set对外提供的功能与list类似是一个列表的功能,特殊之处在于set是可以自动排重的,我们可以通过这一点实现类似共同好友等功能。</li><li>队列：由于redis有list push和list pop这样的命令,所以能够很方便的执行队列操作。</li></ul><p>简介版回答：</p><p>Redis是一款基于键值对的NoSQL数据库，Redis中拥有string(字符串)，hash(哈希)、list(列表)、set（集合）等多种数据结构，redis将数据写进内存的性能很快，不仅如此，如遇到系统崩溃，内存中的数据不会丢失；redis访问速度快、支持的数据类型丰富，很适合用来储存热点数据、 而且适用业务广，如可以运用expire命令来做限时业务，设置一个键的生存时间，到时间后redis会自动删除它，如排行榜可以借住redis的SortedSet进行热点数据的排序，还有分页查询，模糊查询，点赞好友等</p><h2 id="2-详细的说说redis的数据类型"><a class="markdownIt-Anchor" href="#2-详细的说说redis的数据类型"></a> 2. 详细的说说Redis的数据类型</h2><p><strong>得分点</strong></p><p>Redis5种数据结构</p><p><strong>标准回答</strong></p><p>Redis主要提供了5种数据结构：<strong>字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)</strong>。Redis还提供了<strong>Bitmap、HyperLogLog、Geo</strong>类型,但这些类型都是基于上述核心数据类型实现的(Bitmap基于redis的字符串实现)。5.0版本中,Redis新增加了<strong>Streams</strong>数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。</p><p><mark>string</mark>可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。</p><p><mark>list</mark>保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素.</p><p><mark>hash</mark>的值本身也是一个键值对结构,最多能存储2^32-1个元素.</p><p><mark>set</mark>是无序不可重复的,它支持多个set求交集、并集、差集, 适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素.</p><p><mark>zset</mark>是<strong>有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据</strong>,一个zset最多可以存储2^32-1个元素。</p><p>Bitmap:  原本的含义是用一个比特位来映射某个元素的状态。由于一个比特位只能表示 0 和 1 两种状态，所以 BitMap 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间 <a href="https://www.cnblogs.com/54chensongxia/p/13794391.html">Redis 中 BitMap 的使用场景 - 程序员自由之路 - 博客园 (cnblogs.com)</a></p><p>HyperLogLog: 用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 <a href="https://www.runoob.com/redis/redis-hyperloglog.html">Redis HyperLogLog | 菜鸟教程 (runoob.com)</a></p><p>Geo: 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。[Redis GEO | 菜鸟教程 (<a href="http://runoob.com">runoob.com</a>)](<a href="https://www.runoob.com/redis/redis-geo.html#:~:text=Redis">https://www.runoob.com/redis/redis-geo.html#:~:text=Redis</a> GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2,版本新增。 geoadd：添加地理位置的坐标。 geopos：获取地理位置的坐标。 geodist：计算两个位置之间的距离。 georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。)</p><p><strong>加分回答</strong></p><p>每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构： string：编码分为int、raw、embstr；int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。 hash：编码分为ziplist、hashtable两种,其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。 set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。</p><hr><p>主要：字符串（String），哈希（hash），列表（list），集合（set），有序集合（zset）</p><hr><h2 id="3-说说redis的持久化策略"><a class="markdownIt-Anchor" href="#3-说说redis的持久化策略"></a> 3. 说说Redis的持久化策略</h2><p><strong>得分点</strong> RDB、AOF</p><p>标准回答</p><p>Redis4.0之后,Redis有<strong>RDB持久化（默认）、AOF持久化、RDB-AOF混合持久化</strong>这三种持久化方式。</p><p><mark>RDB持久化</mark>是将当前进程数据以生成快照的方式保存到硬盘的过程,也是Redis<strong>默认</strong>的持久化机制。RDB会创建一个经过压缩的二进制文件,这个文件以’<strong>.rdb</strong>‘结尾,内部存储了各个数据库的键值对等信息。RDB持久化过程有<strong>手动触发</strong>和<strong>自动触发</strong>两种方式。手动触发是指通过SAVE或BGSAVE命令触发RDB持久化操作,创建“.rdb”文件；<strong>自动触发是指通过配置选项,让服务器在满足指定条件时自动执行BGSAVE命令</strong>。RDB持久化的<strong>优点</strong>是其生成的紧凑压缩的二进制文件体积小,使用该文件恢复数据的速度非常快；<strong>缺点</strong>则是BGSAVE每次运行都要执行fork操作创建子进程,这属于重量级操作,不宜频繁执行,因此,RBD没法做到实时的持久化;RDB执行时间长，两次RDB之间写入数据有丢失的风险</p><p><img src="../../../images/image-20230216113518076.png" alt="image-20230216113518076"></p><p><mark>AOF</mark>（Append Only File）以独立日志的方式记录了每次写入的命令,重启时再重新执行AOF文件中的命令来恢复数据。AOF持久化的<strong>优点</strong>是与RDB持久化可能丢失大量的数据相比,AOF持久化的安全性要高很多。通过使用<strong>everysec</strong>（每秒刷盘）选项,用户可以将数据丢失的时间窗口限制在1秒之内。其<strong>缺点</strong>则是,AOF文件存储的是协议文本,它的体积要比二进制格式的”.rdb”文件大很多。AOF需要通过执行AOF文件中的命令来恢复数据库,其恢复速度比RDB慢很多。AOF在进行重写时也需要创建子进程,在数据库体积较大时将占用大量资源,会导致服务器的短暂阻塞。AOF解决了数据持久化的实时性,是目前Redis主流的持久化方式。</p><p><mark>RDB-AOF混合持久化模式</mark>是Redis4.0开始引入的,这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时,会像执行BGSAVE命令一样,根据数据库当前的状态生成相应的RDB数据,并将其写入AOF文件中；对于重写之后执行的Redis命令,则以协议文本的方式追加到AOF文件的末尾,即RDB数据之后。 通过使用RDB-AOF混合持久化,用户可以同时获得RDB持久化和AOF持久化的优点,服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作,又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内</p><p><strong>加分回答</strong><br>RDB手动触发分别对应save和bgsave命令： - save 命令会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。 - bgsave命令会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。 除了执行命令手动触发之外,Redis内部还存在自动触发RDB的持久化机制,例如以下场景： 1. 使用save相关配置,如“save m n”。表示m秒内数据集存在n次修改 时,自动触发bgsave。 2. 如果从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件并发送给从节点。 3. 执行debug reload命令重新加载Redis时,也会自动触发save操作。 4. 默认情况下执行shutdown命令时,如果没有开启AOF持久化功能则 自动执行bgsave。 AOF默认不开启,需要修改配置项来启用它： appendonly yes # 启用AOF appendfilename “appendonly.aof” # 设置文件名 AOF以文本协议格式写入命令,如： *3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n 文本协议格式具有如下的优点： 1. 文本协议具有很好的兼容性； 2. 直接采用文本协议格式,可以避免二次处理的开销； 3. 文本协议具有可读性,方便直接修改和处理。 AOF持久化的文件同步机制： 为了提高程序的写入性能,现代操作系统会把针对硬盘的多次写操作优化为一次写操作。 1. 当程序调用write对文件写入时,系统不会直接把书记写入硬盘,而是先将数据写入内存的缓冲区中； 2. 当达到特定的时间周期或缓冲区写满时,系统才会执行flush操作,将缓冲区中的数据冲洗至硬盘中； 这种优化机制虽然提高了性能,但也给程序的写入操作带来了不确定性。 1. 对于AOF这样的持久化功能来说,冲洗机制将直接影响AOF持久化的安全性； 2. 为了消除上述机制的不确定性,Redis向用户提供了appendfsync选项,来控制系统冲洗AOF的频率； 3. Linux的glibc提供了fsync函数,可以将指定文件强制从缓冲区刷到硬盘,上述选项正是基于此函数。</p><h2 id="4-如何利用redis实现一个分布式锁"><a class="markdownIt-Anchor" href="#4-如何利用redis实现一个分布式锁"></a> 4. 如何利用Redis实现一个分布式锁？</h2><p>得分点： 为什么要实现分布式锁、实现分布式锁的方式</p><p><strong>标准回答</strong></p><p><strong>在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境, 而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁</strong>。</p><p>采用Redis实现分布式锁,我们可以在Redis中存一份代表锁的数据,数据格式通常使用字符串即可。 首先加锁的逻辑可以通过<code>setnx key value</code>来实现,但如果客户端忘记解锁,那么这种情况就很有可能造成死锁,但如果直接给锁增加过期时间即新增<code>expire key seconds</code>又会发生其他问题,即这两个命令并不是原子性的,那么如果第二步失败,依然无法避免死锁问题。考虑到如上问题,我们最终可以通过<code>set...nx...</code>命令,将加锁、过期命令编排到一起,把他们变成原子操作,这样就可以避免死锁。写法为<code>set key value nx ex seconds</code> 。 解锁就是将代表锁的那份数据删除,但不能用简单的<code>del key</code>,因为会出现一些问题。比如此时有进程A,如果进程A在任务没有执行完毕时,锁被到期释放了。这种情况下进程A在任务完成后依然会尝试释放锁,因为它的代码逻辑规定它在任务结束后释放锁,但是它的锁早已经被释放过了,那这种情况它释放的就可能是其他线程的锁。为解决这种情况,我们可以在加锁时为key赋一个随机值,来充当进程的标识,进程要记住这个标识。当进程解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。另外判断,释放这两步需要保持原子性,否则如果第二步失败,就会造成死锁。而获取和删除命令不是原子的,这就需要采用Lua脚本,通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的。综上所述,优化后的实现分布式锁命令如下： # 加锁 set key random-value nx ex seconds # 解锁 if redis.call(“get”,KEYS[1]) == ARGV[1] then return redis.call(“del”,KEYS[1]) else return 0 end 加分回答 上述的分布式锁实现方式是建立在单节点之上的,它可能存在一些问题,比如有一种情况,进程A在主节点加锁成功,但主节点宕机了,那么从节点就会晋升为主节点。那如果此时另一个进程B在新的主节点上加锁成功而原主节点重启了,成为了从节点,系统中就会出现两把锁,这违背了锁的唯一性原则。 总之,就是在单个主节点的架构上实现分布式锁,是无法保证高可用的。若要保证分布式锁的高可用,则可以采用多个节点的实现方案。这种方案有很多,而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点,它的基本逻辑如下： - 这些节点相互独立,不存在主从复制或者集群协调机制； - 加锁：以相同的KEY向N个实例加锁,只要超过一半节点成功,则认定加锁成功； - 解锁：向所有的实例发送DEL命令,进行解锁； 我们可以自己实现该算法,也可以直接使用Redisson框架。</p><h2 id="5-说说缓存穿透-击穿-雪崩的区别"><a class="markdownIt-Anchor" href="#5-说说缓存穿透-击穿-雪崩的区别"></a> 5. 说说缓存穿透、击穿、雪崩的区别</h2><p>得分点： 三种问题的发生原因以及解决方式</p><p><strong>标准回答</strong></p><p><mark>缓存穿透</mark>：<strong>是指客户端查询了根本<font color="red">不存在的数据</font>,使得这个请求直达存储层,导致其负载过大甚至造成宕机</strong>。这种情况可能是由于业务层误将缓存和库中的数据删除造成的,当然也不排除有人恶意攻击,专门访问库中不存在的数据导致缓存穿透。 我们可以通过缓存空对象的方式和布隆过滤器两种方式来解决这一问题。<strong>缓存空对象</strong>是指当存储层未命中后,仍然将空值存入缓存层 ,当客户端再次访问数据时,缓存层直接返回空值。还可以将数据存入<strong>布隆过滤器</strong>,访问缓存之前以过滤器拦截,若请求的数据不存在则直接返回空值。</p><p><mark>缓存击穿</mark>：<strong>当一份访问量非常大的<font color="red">热点数据缓存失效的瞬间</font>,大量的请求直达存储层,导致服务崩溃</strong>。 缓存击穿可以通过<strong>热点数据不设置过期时间</strong>来解决,这样就不会出现上述的问题,这是“物理”上的永不过期。或者为每个数据<strong>设置逻辑过期时间</strong>,当发现该数据逻辑过期时,使用单独的线程重建缓存。除了永不过期的方式,我们也可以通过<strong>加互斥锁</strong>的方式来解决缓存击穿,即对数据的访问加互斥锁,当一个线程访问该数据时,其他线程只能等待。这个线程访问过后,缓存中的数据将被重建,届时其他线程就可以直接从缓存中取值。</p><p><mark>缓存雪崩</mark>：<strong>是指当某一时刻<font color="red">缓存层无法继续提供服务</font>,导致所有的请求直达存储层,造成数据库宕机</strong>。可能是缓存中有大量数据同时过期,也可能是Redis节点发生故障,导致大量请求无法得到处理。 缓存雪崩的解决方式有三种；<strong>第一种</strong>是在设置过期时间时,附加一个随机数,避免大量的key同时过期。<strong>第二种</strong>是启用降级和熔断措施,即发生雪崩时,若应用访问的不是核心数据,则直接返回预定义信息/空值/错误信息。或者在发生雪崩时,对于访问缓存接口的请求,客户端并不会把请求发给Redis,而是直接返回。<strong>第三种</strong>是构建高可用的Redis服务,也就是采用哨兵或集群模式,部署多个Redis实例,这样即使个别节点宕机,依然可以保持服务的整体可用。</p><h2 id="6-redis如何与数据库保持双写一致性"><a class="markdownIt-Anchor" href="#6-redis如何与数据库保持双写一致性"></a> 6. Redis如何与数据库保持双写一致性</h2><p>得分点: 四种同步策略及其可能出现的问题,重试机制</p><p><strong>标准回答 :</strong></p><p>保证缓存和数据库的双写一致性,共有四种同步策略,即<strong>先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再删除缓存</strong>。 <strong>先更新缓存的优点</strong>是每次数据变化时都能及时地更新缓存,这样不容易出现查询未命中的情况,但这种操作的消耗很大,如果数据需要经过复杂的计算再写入缓存的话,频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景,可能会导致频繁的更新缓存却没有业务来读取该数据。 <strong>删除缓存的优点</strong>是操作简单,无论更新的操作复杂与否,都是直接删除缓存中的数据。这种做法的缺点则是,当删除了缓存之后,下一次查询容易出现未命中的情况,那么这时就需要再次读取数据库。 那么对比而言,<strong>删除缓存无疑是更好的选择</strong>。 那么我们再来看一下先操作数据库和后操作数据库的区别；先删除缓存再操作数据库的话,如果第二步骤失败可能导致缓存和数据库得到相同的旧数据。先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致。出现上述问题的时候,我们一般采用重试机制解决,而为了避免重试机制影响主要业务的执行,一般建议重试机制采用异步的方式执行。当我们采用重试机制之后由于存在并发,先删除缓存依然可能存在缓存中存储了旧的数据,而数据库中存储了新的数据,二者数据不一致的情况。 所以我们得到结论：<strong>先更新数据库、再删除缓存是影响更小的方案</strong>。如果第二步出现失败的情况,则可以采用重试机制解决问题。</p><h2 id="7-请你说说redis数据类型中的zset它和set有什么区别底层是怎么实现的"><a class="markdownIt-Anchor" href="#7-请你说说redis数据类型中的zset它和set有什么区别底层是怎么实现的"></a> 7. 请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？</h2><p>得分点: 有序无序、底层结构</p><p><strong>标准回答</strong></p><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数, Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数 ( score ) 却可以重复。</p><p>集合是通过哈希表实现的,所以添加,删除,查找的复杂度都是 O(1)。集合中最大的成员数为 232 – 1 ( 4294967295 ) , 每个集合可存储 40 多亿个成员。</p><p>zset底层的存储结构包括ziplist或skiplist,在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist,其他时候使用skiplist。 当ziplist作为zset的底层存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值。 当skiplist作为zset的底层存储结构的时候,使用skiplist按序保存元素及分值,使用dict来保存元素和分值的映射关系。</p><p><strong>加分回答</strong></p><p>实际上单独使用Hashmap或skiplist也可以实现有序集合,Redis使用两种数据结构组合的原因是如果我们单独使用Hashmap,虽然能以O</p><p>(1) 的时间复杂度查找成员的分值,但是因为Hashmap是以无序的方式来保存集合元素,所以每次进行范围操作的时候都要进行排序；而如果单独使用skiplist,虽然能执行范围操作,但查找操作的复杂度却由 O(1)变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。</p><h2 id="8-说说redis的单线程架构"><a class="markdownIt-Anchor" href="#8-说说redis的单线程架构"></a> 8. 说说Redis的单线程架构</h2><p>得分点:  单线程的前提,单线程的优劣,简单的io模型</p><p><strong>标准回答</strong></p><p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行。单线程可以简化数据结构和算法的实现,并且可以避免线程切换和竞争造成的消耗。但要注意如果某个命令执行时间过长,会造成其他命令的阻塞。Redis采用了io多路复用机制,这带给了Redis并发处理大量客户端请求的能力。</p><p>Redis单线程实现为什么这么快呢？因为对服务端程序来说,线程切换和锁通常是性能杀手,而单线程避免了线程切换和竞争所产生的消耗。另外Redis的大部分操作是在内存上完成的,这是它实现高性能的一个重要原因；Redis还采用了IO多路复用机制,使其在网络IO操作中能并发处理大量的客户端请求,实现高吞吐率。</p><p><strong>加分回答</strong></p><p>Redis的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能,如持久化、异步删除、集群数据同步等,则是依赖其他线程来执行的。所以,说Redis是单线程的只是一种习惯的说法,事实上它的底层不是单线程的。</p><h2 id="9-如何实现redis高可用"><a class="markdownIt-Anchor" href="#9-如何实现redis高可用"></a> 9. 如何实现Redis高可用</h2><p>得分点： 哨兵模式、集群模式</p><p><strong>标准回答</strong></p><p>主要有哨兵和集群两种方式可以实现Redis高可用。</p><p><strong>哨兵</strong>： 哨兵模式是Redis的高可用的解决方案,它由一个或多个Sentinel实例组成Sentinel系统,可以监视任意多个主服务器以及这些主服务器属下的所有从服务器。当哨兵节点发现有节点不可达时,会对该节点做下线标识。如果是主节点下线,它还会和其他Sentinel节点进行“协商”,当大多数Sentinel节点都认为主节点不可达时,它们会选举出一个Sentinel节点来完成自动故障转移的工作,同时会将这个变化实时通知给Redis应用方。 哨兵节点包含如下的特征：</p><ol><li><p>哨兵节点会定期监控数据节点,其他哨兵节点是否可达；</p></li><li><p>哨兵节点会将故障转移的结果通知给应用方；</p></li><li><p>哨兵节点可以将从节点晋升为主节点,并维护后续正确的主从关系；</p></li><li><p>哨兵模式下,客户端连接的是哨兵节点集合,从中获取主节点信息；</p></li><li><p>节点的故障判断是由多个哨兵节点共同完成的,可有效地防止误判；</p></li><li><p>哨兵节点集合是由多个哨兵节点组成的,即使个别哨兵节点不可用,整个集合依然是健壮的；</p></li><li><p>哨兵节点也是独立的Redis节点,是特殊的Redis节点,它们不存储数据,只支持部分命令。</p></li></ol><p><strong>集群：</strong> Redis集群采用虚拟槽分区来实现数据分片,它把所有的键根据哈希函数映射到<code>0-16383</code>整数槽内,计算公式为<code>slot=CRC16(key)&amp;16383</code>,每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：。</p><ol><li><p>解耦数据和节点之间的关系,简化了节点扩容和收缩的难度；</p></li><li><p>节点自身维护槽的映射关系,不需要客户端或者代理服务维护槽分区元数据；</p></li><li><p>支持节点、槽、键之间的映射查询,用于数据路由,在线伸缩等场景。</p></li></ol><h3 id="哨兵的作用和原理"><a class="markdownIt-Anchor" href="#哨兵的作用和原理"></a> 哨兵的作用和原理</h3><p><img src="https://img-blog.csdnimg.cn/2b52c12b7a1b4d368a2b605873b82930.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/d06a5ac4f10e4b1496d454ebc1f57250.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b76d7ce8f8314194a996d3d6f680cc6e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b42e0e3f92ad46efb231bcb628532d55.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/adbee544452f4d6badc1b7790bb4b2ae.png" alt="img"></p><h2 id="10-说说redis的主从同步机制"><a class="markdownIt-Anchor" href="#10-说说redis的主从同步机制"></a> 10. 说说Redis的主从同步机制</h2><p>得分点 ： psync,全量复制、部分复制</p><p><strong>标准回答</strong></p><p><strong>Redis主从同步</strong>是指任意数量的从节点（slave node）都可以从主节点上（master node）同步数据。而除了多个 slave 可以连接到同一个 master 之外,slave 还可以接受其他 slave 的连接,这就形成一个树形结构,使得Redis可执行单层树复制。 从2.8版本开始,当启动一个 slave node 的时候,它会发送一个 <code>PSYNC</code> 命令给 master node。如果slave node 是第一次连接到 master node,那么会触发一次<strong>全量复制</strong>。此时 master 会启动一个后台线程,开始生成一份 <code>RDB</code> 快照文件,同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后, master 会将这个 <code>RDB</code> 发送给 slave,slave 会先写入本地磁盘,然后再从本地磁盘加载到内存中,接着 master 会将内存中缓存的写命令发送到 slave,slave 也会同步这些数据。slave node 如果跟 master node 有网络故障,断开了连接,会自动重连,连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><p><strong>开启主从关系</strong><br>要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。有临时和永久两种模式：</p><ul><li><p>修改配置文件（永久生效）</p><ul><li>在redis.conf中添加一行配置：<strong>slaveof <masterip> <masterport></masterport></masterip></strong></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><ul><li><strong>slaveof <masterip> <masterport></masterport></masterip></strong></li></ul></li></ul><p><img src="../../../images/image-20230216211538641.png" alt="image-20230216211538641"></p><h3 id="数据同步原理"><a class="markdownIt-Anchor" href="#数据同步原理"></a> 数据同步原理</h3><p><img src="https://img-blog.csdnimg.cn/566d2c905de44bd3a908d3ef2a221eb3.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e07861738258498a80882dd99d5f65e6.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c519a72fdc2140268b2b18c3e82df57e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/32c36304a2ce450eaa3ecee4e3203ccd.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/5cb9aa1893bb409c8a65259d8dd094da.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/435c034f44794a3fbc0d6f15efe1e77c.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/1d1d8ba89683446eb5d4053a7f3c0eca.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/4e540323ef0443eb915595fe8d975817.png" alt="img"></p><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126649510?spm=1001.2014.3001.5501">(9条消息) （分布式缓存）Redis主从_其然乐衣的博客-CSDN博客</a></p><h2 id="11-说说redis的缓存淘汰策略redis的回收策略"><a class="markdownIt-Anchor" href="#11-说说redis的缓存淘汰策略redis的回收策略"></a> 11. 说说Redis的缓存淘汰策略(Redis的回收策略)</h2><p>得分点 : 惰性删除、定期删除,maxmemory-policy</p><p><strong>标准回答</strong></p><p>Redis有如下两种过期策略：</p><p>**惰性删除：**客户端访问一个key的时候,Redis会先检查它的过期时间,如果发现过期就立刻删除这个key。</p><p>**定期删除：**Redis会将设置了过期时间的key放到一个独立的字典中,并对该字典进行每秒10次的过期扫描, 过期扫描不会遍历字典中所有的key,而是采用了一种简单的贪心策略。该策略的删除逻辑如下： 1. 从过期字典中随机选择20个key； 2. 删除这20个key中已过期的key； 3. 如果已过期key的比例超过25%,则重复步骤1。 当写入数据将导致超出maxmemory限制时,Redis会采用maxmemory-policy所指定的策略进行数据淘汰,该策略一共包含8种选项,其中除了noeviction直接返回错误之外,筛选键的方式分为volatile和allkeys两种,volatile前缀代表从设置了过期时间的键中淘汰数据,allkeys前缀代表从所有的键中淘汰数据关于后缀,ttl代表选择过期时间最小的键,random代表随机选择键,需要我们额外关注的是lru和lfu后缀,它们分别代表采用lru算法和lfu算法来淘汰数据。因为allkeys是筛选所有的键,所以不存在ttl,余下三个后缀二者都有,lfu算法是再Redis4版本才提出来的。</p><p><strong>加分回答</strong></p><p><strong>LRU</strong>（Least Recently Used）是按照最近最少使用原则来筛选数据,即最不常用的数据会被筛选出来 - 标准LRU：把所有的数据组成一个链表,表头和表尾分别表示MRU和LRU端,即最常使用端和最少使用端。刚被访问的数据会被移动到MRU端,而新增的数据也是刚被访问的数据,也会被移动到MRU端。当链表的空间被占满时,它会删除LRU端的数据。 - 近似LRU：Redis会记录每个数据的最近一次访问的时间戳（LRU）。Redis执行写入操作时,若发现内存超出maxmemory,就会执行一次近似LRU淘汰算法。近似LRU会随机采样N个key,然后淘汰掉最旧的key,若淘汰后内存依然超出限制,则继续采样淘汰。可以通过maxmemory_samples配置项,设置近似LRU每次采样的数据个数,该配置项的默认值为5。 LRU算法的不足之处在于,若一个key很少被访问,只是刚刚偶尔被访问了一次,则它就被认为是热点数据,短时间内不会被淘汰。 <strong>LFU</strong>算法正式用于解决上述问题,LFU（Least Frequently Used）是Redis4新增的淘汰策略,它根据key的最近访问频率进行淘汰。LFU在LRU的基础上,为每个数据增加了一个计数器,来统计这个数据的访问次数。当使用LFU策略淘汰数据时,首先会根据数据的访问次数进行筛选,把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同,LFU再比较这两个数据的访问时间,把访问时间更早的数据淘汰出内存。</p><h3 id="redis的回收策略"><a class="markdownIt-Anchor" href="#redis的回收策略"></a> <strong>Redis的回收策略</strong></h3><blockquote><p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据<br>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br>使用策略规则：<br>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru<br>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p></blockquote><h2 id="12-使用redis有哪些好处"><a class="markdownIt-Anchor" href="#12-使用redis有哪些好处"></a> 12. 使用Redis有哪些好处？</h2><p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>(2) 支持丰富数据类型，支持string，list，set，zset，hash<br>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p><h2 id="13-redis的缺点"><a class="markdownIt-Anchor" href="#13-redis的缺点"></a> 13. Redis的缺点</h2><ol><li>不保证数据的可靠性,数据有可能在宕机情况会丢失少部分数据.不能保持数据库和缓存的一致性,如果需要保持一致性,需要付出一定性能代价(加锁串行)</li><li>单线程操作，无法利用多核CPU的优势</li><li>如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本以后，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的从库。</li></ol><h2 id="14-redis相比memcached有哪些优势"><a class="markdownIt-Anchor" href="#14-redis相比memcached有哪些优势"></a> 14. Redis相比memcached有哪些优势？</h2><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据<br>(4) redis支持数据的备份，即master-slave模式的数据备份。<br>(5) 使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>(6）value大小：redis最大可以达到1GB，而memcache只有1MB</p>]]></content>
      
      
      <categories>
          
          <category> 面试题 </category>
          
          <category> 中间件 </category>
          
          <category> Redis </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试题 </tag>
            
            <tag> Redis </tag>
            
            <tag> 中间件 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/14/interview/waitingSee/"/>
      <url>/2022/11/14/interview/waitingSee/</url>
      
        <content type="html"><![CDATA[<p>八股文</p><p>netty</p><p>io</p><p>设计模式</p><table><thead><tr><th>ID</th><th>标题</th><th>地址</th></tr></thead><tbody><tr><td>1</td><td>设计模式面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125721772039">juejin.cn/post/684490…</a></td></tr><tr><td>2</td><td>Java基础知识面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738631">juejin.cn/post/684490…</a></td></tr><tr><td>3</td><td>Java集合面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125939843079">juejin.cn/post/684490…</a></td></tr><tr><td>4</td><td>JavaIO、BIO、NIO、AIO、Netty面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125700784136">juejin.cn/post/684490…</a></td></tr><tr><td>5</td><td>Java并发编程面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125755293710">juejin.cn/post/684490…</a></td></tr><tr><td>6</td><td>Java异常面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904128959741965">juejin.cn/post/684490…</a></td></tr><tr><td>7</td><td>Java虚拟机（JVM）面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125696573448">juejin.cn/post/684490…</a></td></tr><tr><td>8</td><td>Spring面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127051513864">juejin.cn/post/684490…</a></td></tr><tr><td>9</td><td>Spring MVC面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722253">juejin.cn/post/684490…</a></td></tr><tr><td>10</td><td>Spring Boot面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125709156359">juejin.cn/post/684490…</a></td></tr><tr><td>11</td><td>Spring Cloud面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125717544973">juejin.cn/post/684490…</a></td></tr><tr><td>12</td><td>Redis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127055527950">juejin.cn/post/684490…</a></td></tr><tr><td>13</td><td>MyBatis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935648776">juejin.cn/post/684490…</a></td></tr><tr><td>14</td><td>MySQL面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127047139335">juejin.cn/post/684490…</a></td></tr><tr><td>15</td><td>TCP、UDP、Socket、HTTP面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125692379143">juejin.cn/post/684490…</a></td></tr><tr><td>16</td><td>Nginx面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125784653837">juejin.cn/post/684490…</a></td></tr><tr><td>17</td><td>ElasticSearch面试题</td><td></td></tr><tr><td>18</td><td>kafka面试题</td><td></td></tr><tr><td>19</td><td>RabbitMQ面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935665160">juejin.cn/post/684490…</a></td></tr><tr><td>20</td><td>Dubbo面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499463">juejin.cn/post/684490…</a></td></tr><tr><td>21</td><td>ZooKeeper面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499464">juejin.cn/post/684490…</a></td></tr><tr><td>22</td><td>Netty面试题（总结最全面的面试题）</td><td></td></tr><tr><td>23</td><td>Tomcat面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722247">juejin.cn/post/684490…</a></td></tr><tr><td>24</td><td>Linux面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738637">juejin.cn/post/684490…</a></td></tr><tr><td>25</td><td>互联网相关面试题（总结最全面的面试题）</td><td></td></tr><tr><td>26</td><td>互联网安全面试题（总结最全面的面试题）</td><td></td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1. 零碎笔记</title>
      <link href="/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210028078.png" alt="image-20221112210028078"></p><p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210242978.png" alt="image-20221112210242978"></p><p><img src="/.com//D:%5CTypora%5CRunningYuBlog%5Csource%5Cimages%5Cimage-20221112210338812.png" alt="image-20221112210338812"></p><p><img src="../../../images/image-20221112212347371.png" alt="image-20221112212347371"></p><p>Java虚拟机不只是适用于java语言，也适用于其它语言，只要其它语言通过编译器生成的字节码文件遵循java虚拟机的规则，java虚拟机就可以运行</p><p><img src="../../../images/image-20221112212742280.png" alt="image-20221112212742280"></p><h2 id="15-虚拟机与-java-虚拟机"><a class="markdownIt-Anchor" href="#15-虚拟机与-java-虚拟机"></a> 1.5. 虚拟机与 Java 虚拟机</h2><p><strong>虚拟机</strong></p><p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为系统虚拟机和程序虚拟机。</p><ul><li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。</li><li>程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li></ul><p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p><p><strong>Java 虚拟机</strong></p><ul><li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</li><li>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li><li><mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li></ul><p>作用</p><ul><li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释/编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li></ul><p>特点</p><ul><li>一次编译，到处运行</li><li>自动内存管理</li><li>自动垃圾回收功能</li></ul><p><strong>JVM 的位置</strong></p><p><img src="https://img-blog.csdnimg.cn/img_convert/6b5c24b8d634d5a741ef5d8a90db1123.png" alt="image-20200704183048061"></p><p>JVM 是运行在操作系统之上的，它与硬件没有直接的交互<br><img src="https://img-blog.csdnimg.cn/img_convert/cd8b795cf080b8ba40f6915b6242c8af.png" alt="image-20210507104030823"></p><h2 id="16-jvm-的整体结构"><a class="markdownIt-Anchor" href="#16-jvm-的整体结构"></a> 1.6. JVM 的整体结构</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/1bf0b96d082d684a818bc36a8f864a89.png" alt="image-20200704183436495"></p><ul><li>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。</li><li>它采用<strong>解释器与即时编译器</strong>并存的架构。</li><li>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++程序一较高下的地步。</li></ul><h2 id="17-java-代码执行流程"><a class="markdownIt-Anchor" href="#17-java-代码执行流程"></a> 1.7. Java 代码执行流程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/4ce09e21efc2533d2b80f45f97b35a48.png" alt="image-20200704210429535"></p><p>操作系统并不能识别字节码指令，只能识别机器指令</p><h2 id="18-jvm-的架构模型"><a class="markdownIt-Anchor" href="#18-jvm-的架构模型"></a> 1.8. JVM 的架构模型</h2><p>Java 编译器输入的指令流基本上是一种基于<mark>栈的指令集架构</mark>，另外一种指令集架构则是基于<mark>寄存器的指令集架构</mark>。</p><p>具体来说：这两种架构之间的区别：</p><p><strong>基于栈式架构的特点</strong></p><ul><li>设计和实现更简单，适用于资源受限的系统</li><li>避开了寄存器的分配难题：使用零地址指令方式分配</li><li>指令流中的指令大部分是零地址指令，其执行过程依赖于操作栈。指令集更小，编译器容易实现</li><li>不需要硬件支持，可移植性更好，更好实现跨平台</li></ul><p><strong>基于寄存器架构的特点</strong></p><ul><li>典型的应用是 x86 的二进制指令集：比如传统的 PC 以及 Android 的 Davlik 虚拟机</li><li>指令集架构则完全依赖硬件，可移植性差</li><li>性能优秀和执行更高效</li><li>花费更少的指令去完成一项操作</li><li>在大部分情况下，基于寄存器架构的指令集往往都以一地址指令、二地址指令和三地址指令为主，而基于栈式架构的指令集却是以零地址指令为主</li></ul><p><strong>举例 1</strong></p><p>同样执行 2+3 这种逻辑操作，其指令分别如下：</p><p>基于栈的计算流程（以 Java 虚拟机为例）：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iconst_2 <span class="comment">//常量2入栈</span></span><br><span class="line">istore_1</span><br><span class="line">iconst_3 <span class="comment">// 常量3入栈</span></span><br><span class="line">istore_2</span><br><span class="line">iload_1</span><br><span class="line">iload_2</span><br><span class="line">iadd <span class="comment">//常量2/3出栈，执行相加</span></span><br><span class="line">istore_0 <span class="comment">// 结果5入栈</span></span><br></pre></td></tr></tbody></table></figure><p>而基于寄存器的计算流程</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov eax,<span class="number">2</span> <span class="comment">//将eax寄存器的值设为1</span></span><br><span class="line">add eax,<span class="number">3</span> <span class="comment">//使eax寄存器的值加3</span></span><br></pre></td></tr></tbody></table></figure><p><strong>举例 2</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">int</span> a=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b=<span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> c=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; javap -c Test.class</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calc</span><span class="params">()</span>;</span><br><span class="line">    Code:</span><br><span class="line">    Stack=<span class="number">2</span>,Locals=<span class="number">4</span>,Args_size=<span class="number">1</span></span><br><span class="line">       <span class="number">0</span>: bipush        <span class="number">100</span></span><br><span class="line">       <span class="number">2</span>: istore_1</span><br><span class="line">       <span class="number">3</span>: sipush        <span class="number">200</span></span><br><span class="line">       <span class="number">6</span>: istore_2</span><br><span class="line">       <span class="number">7</span>: sipush        <span class="number">300</span></span><br><span class="line">      <span class="number">10</span>: istore_3</span><br><span class="line">      <span class="number">11</span>: iload_1</span><br><span class="line">      <span class="number">12</span>: iload_2</span><br><span class="line">      <span class="number">13</span>: iadd</span><br><span class="line">      <span class="number">14</span>: iload_3</span><br><span class="line">      <span class="number">15</span>: imul</span><br><span class="line">      <span class="number">16</span>: ireturn</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>总结</strong></p><p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令。</p><p>时至今日，尽管嵌入式平台已经不是 Java 程序的主流运行平台了（准确来说应该是 HotSpotVM 的宿主环境已经不局限于嵌入式平台了），那么为什么不将架构更换为基于寄存器的架构呢？</p><hr><p><strong>编译器前端</strong>（将源文件编译生成字节码文件），<strong>编译器后端</strong>（将字节码指令编译成机器指令）</p><p>因为机器指令是反复执行的<strong>热点代码</strong>，所以缓存起来，下次可以直接调用</p><hr><p><img src="../../../images/image-20221112225810473.png" alt="image-20221112225810473"></p><p>栈式架构采用的是8位作为一个基本单位的，所以栈的指令集更小，但是指令数多</p><p>寄存器架构采用的是16位的双字节的进行设计的，所以指令集大，但指令数更少</p><p>比如：</p><p><img src="../../../images/image-20221112225721970.png" alt="image-20221112225721970"></p><p><strong>总结</strong></p><p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p><p>优点：是跨平台，指令集小，编译器容易实现。</p><p>缺点：是性能下降，实现同样的功能需要更多的指令。</p><p>栈：</p><p>跨平台、指令集小、指令多，执行性能比寄存器差</p><hr><h1 id="虚拟机的生命周期"><a class="markdownIt-Anchor" href="#虚拟机的生命周期"></a> 虚拟机的生命周期</h1><h2 id="虚拟机的启动"><a class="markdownIt-Anchor" href="#虚拟机的启动"></a> <strong>虚拟机的启动</strong></h2><p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p><p><img src="../../../images/image-20221113093105220.png" alt="image-20221113093105220"></p><p>像上面我们自定义的类，是由系统类加载器来加载的</p><p>但（如果）没有明确指定的父类，它的父类就是Object，Object作为核心api，由引导类加载器（bootstrap class loader）加载的</p><p>我们要启动一个类，而父类是要早于子类先加载的，但是父类还没加载而它的子类要用，所以我们就需要先启动Java虚拟机</p><h2 id="虚拟机的执行"><a class="markdownIt-Anchor" href="#虚拟机的执行"></a> <strong>虚拟机的执行</strong></h2><ul><li><p>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</p></li><li><p>程序开始执行时他才运行，程序结束时他就停止。</p></li><li><p><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></p></li></ul><h2 id="虚拟机的退出"><a class="markdownIt-Anchor" href="#虚拟机的退出"></a> <strong>虚拟机的退出</strong></h2><p>有如下的几种情况：</p><ul><li>程序正常执行结束</li><li>程序在执行过程中遇到了异常或错误而异常终止</li><li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li><li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li><li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li></ul><hr><p><img src="../../../images/image-20221113101445106.png" alt="image-20221113101445106"></p><p><img src="../../../images/image-20221113101718312.png" alt="image-20221113101718312"></p><p><strong>编译器前端</strong>（将源文件编译生成字节码文件），<strong>编译器后端</strong>（将字节码指令编译成机器指令）</p><p>因为机器指令是反复执行的<strong>热点代码</strong>，所以缓存起来，下次可以直接调用</p><hr><h3 id="hotspot-vm"><a class="markdownIt-Anchor" href="#hotspot-vm"></a> HotSpot VM</h3><ul><li>HotSpot 历史<ul><li>最初由一家名为“Longview Technologies”的小公司设计</li><li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li><li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li></ul></li><li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark><ul><li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li><li>Sun / Oracle JDK 和 OpenJDK 的默认虚拟机</li><li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li></ul></li><li>从服务器、桌面到移动端、嵌入式都有应用。</li><li>名称中的 HotSpot 指的就是它的<strong>热点代码探测技术</strong>。<ul><li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li><li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li></ul></li></ul><h3 id="jrockit"><a class="markdownIt-Anchor" href="#jrockit"></a> JRockit</h3><ul><li><p><mark>专注于服务器端应用</mark></p><ul><li><strong>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</strong></li></ul></li><li><p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p><ul><li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li></ul></li><li><p>优势：全面的 Java 运行时解决方案组合</p><ul><li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li><li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li></ul></li><li><p>2008 年，JRockit 被 oracle 收购。</p></li><li><p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p></li><li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p></li></ul><h3 id=""><a class="markdownIt-Anchor" href="#"></a> </h3><h3 id="ibm-的-j9"><a class="markdownIt-Anchor" href="#ibm-的-j9"></a> IBM 的 J9</h3><ul><li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</li><li>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</li><li>广泛用于 IBM 的各种 Java 产品（一般用于自己的产品）。</li><li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机（但J9只是在自己的产品上使用时比较快，而通用性的话，还是JRockit好点）。</li><li>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</li></ul><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> …</h3><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>​具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p><hr><h1 id="2-类加载子系统"><a class="markdownIt-Anchor" href="#2-类加载子系统"></a> 2. 类加载子系统</h1><p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p><ul><li>类加载器</li><li>执行引擎</li></ul><p>**类加载器子系统：**获取字节码文件的信息（常量信息，变量信息，方法，指令等），然后有组织地分配到内存当中（<strong>运行时数据区</strong>）</p><p><strong>执行引擎:</strong>  需要去解释这些指令</p><hr><p>如果不是一个合法的字节码文件，就会在加载的过程中抛出异常。如果有些恶意攻击的话，就会对这个字节码文件进行修改，就不合法了</p><h3 id="初始化阶段"><a class="markdownIt-Anchor" href="#初始化阶段"></a> 初始化阶段</h3><ul><li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li><li>此方法不需定义，是 javac 编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。</li><li>构造器方法中指令按语句在源文件中出现的顺序执行。</li><li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li><li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li><li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li></ul><p><img src="../../../images/image-20221114203139057.png" alt="image-20221114203139057"></p><p>当要只能main方法时，先把这个ClinitTest1类加载到内存当中（当然在加载这个类之前先把它的父类加载），加载完后，调用main静态方法，里面要加载Son这个类，要把Son这个类加载进来，但在加载Son类之前要先加载Son的父类Father，加载完父类后，在加载Son的时候，在初始化这个环节，把A的值赋过来，这时A已经等于2，所以main中打印出来的结果就是2</p><p><strong>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</strong></p><p>线程2进来了，但是线程2出不来，它还在初始化这个DeadThread类，线程1也进不去，因为线程正在处于一个加锁的状态</p><p><img src="../../../images/image-20221114213537778.png" alt="image-20221114213537778"></p><p><img src="../../../images/image-20221114210548293.png" alt="image-20221114210548293"></p><p><strong>static代码块只执行一次原因：</strong></p><p>​static代码块只在类加载时执行，类是用类加载器来读取的，<strong>类加载器是带有一个缓存区的</strong>，它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p><hr><h1 id="231-虚拟机自带的加载器"><a class="markdownIt-Anchor" href="#231-虚拟机自带的加载器"></a> 2.3.1. 虚拟机自带的加载器</h1><p><strong>启动类加载器（引导类加载器，Boostrap ClassLoader）</strong>,我们获取不到，它是由C/C++语言编写的</p><p>**扩展类加载器（Extension ClassLoader）**和 **应用程序类加载器（系统类加载器，AppClassLoader）**都是由java语言编写的</p><p>还要记住什么样的类加载器加载什么样的类文件</p><hr><h4 id="为什么要自定义类加载器"><a class="markdownIt-Anchor" href="#为什么要自定义类加载器"></a> <strong>为什么要自定义类加载器？</strong></h4><ul><li><strong>隔离加载类 (避免类的冲突)</strong><ul><li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</li></ul></li><li><strong>修改类加载的方式 （可以实现动态的加载）</strong><ul><li>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行<strong>动态加载</strong>。</li></ul></li><li><strong>扩展加载源</strong><ul><li>比如从数据库、网络、甚至是电视机机顶盒进行加载。</li></ul></li><li><strong>防止源码泄漏</strong><ul><li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</li></ul></li></ul><hr><p><strong>获取 ClassLoader 的途径</strong></p><ul><li><p>方式一：获取当前 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式二：获取当前线程上下文的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式三：获取系统的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></tbody></table></figure></li><li><p>方式四：获取调用者的 ClassLoader</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> </h2><h1 id="25-双亲委派机制"><a class="markdownIt-Anchor" href="#25-双亲委派机制"></a> 2.5. 双亲委派机制</h1><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p><h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> <strong>工作原理</strong></h2><ul><li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li><li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li><li>3）<strong>如果父类加载器可以完成类加载任务，就成功返回</strong>（就不会由子类加载器去加载了），倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p><p>举例：</p><ol><li></li></ol><p><img src="../../../images/image-20221115204949307.png" alt="image-20221115204949307"></p><p>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。一看你是java开头的，引导类加载就说了。这是归我管我来加载String（核心API里的String）。因此有父类来加载后，就不会再向下委托了，所以我们new 的这个String对象就是核心API里面的String类对象，而不是我们自定义的String，因此就没有打印出自定义String里的static静态资源里的语句</p><ol start="2"><li></li></ol><p><img src="../../../images/image-20221115205956137.png" alt="image-20221115205956137"></p><p>委托到引导类加载器，它发现你这个包是jvm开头的，不归引导类加载管，就向下委托，也不归扩展类加载器管，所以最后回到系统类加载器来加载，因此最后输出结果就是系统类加载来进行的加载</p><ol start="3"><li></li></ol><p><img src="../../../images/image-20221115210219781.png" alt="image-20221115210219781"></p><p>一直往上委托，就交给到了引导类加载器，它加载了String类以后，然后就想去执行main方法，但是核心API的String里面是没有main方法的，所以就报了 <mark>错误: 在类 java.lang.String 中找不到 main 方法</mark>. 可知，根本就没有试着想去加载我们自定义的String类，完全忽略掉你了</p><ol start="4"><li></li></ol><p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p><p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p><h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> <strong>优势</strong></h2><ul><li><strong>避免类的重复加载</strong></li><li><strong>保护程序安全，防止核心 API 被随意篡改</strong><ul><li>自定义类：java.lang.String</li><li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li></ul></li></ul><p><img src="../../../images/image-20221115212723174.png" alt="image-20221115212723174"></p><p>引导类加载器看到是 java.lang开头的，就表示这是归它管，于是就要去加载这个ShkStart类了，但直接直接给它报错了，相当于，要加载java.lang这个包，要想访问是要有权限的，现在报错就是阻止我们去直接用这个java.lang包来自定义这个ShkStart类。其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个类，加载成功的话，就会导致对引导类加载器本身造成影响，所以这里是直接把引导类加载器给整挂了。所以我们也禁止去用java.lang这样的包名去命名</p><p>其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个种自定义的类，加载成功的话，但里面可能会有一些<strong>恶意代码</strong>，就可能会会对现有的项目和程序进行破坏</p><h2 id="沙箱安全机制"><a class="markdownIt-Anchor" href="#沙箱安全机制"></a> <strong>沙箱安全机制</strong></h2><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p><hr><h2 id="26-其他"><a class="markdownIt-Anchor" href="#26-其他"></a> 2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p><p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p><ul><li>类的完整类名必须一致，包括包名。</li><li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li></ul><p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
          <category> 内存与垃圾回收篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 内存与垃圾回收篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义UserDetailsServiceImpl</title>
      <link href="/2022/11/12/SpringSecurity/UserDetailsServiceImpl/"/>
      <url>/2022/11/12/SpringSecurity/UserDetailsServiceImpl/</url>
      
        <content type="html"><![CDATA[<p>当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。</p><p>如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p><h3 id="userdetailsserviceimpl"><a class="markdownIt-Anchor" href="#userdetailsserviceimpl"></a> UserDetailsServiceImpl</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.aclservice.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.service.PermissionService;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.SecurityUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以</span></span><br><span class="line"><span class="comment"> * 我们要通过自定义逻辑控制认证逻辑。</span></span><br><span class="line"><span class="comment"> * 如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermissionService permissionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        <span class="comment">// 根据用户名查询数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.selectByUsername(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 抛出用户名没有发现异常，系统就知道用户名没有查询到</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">"用户不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        com.atguigu.security.entity.<span class="type">User</span> <span class="variable">curUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.atguigu.security.entity.User();</span><br><span class="line">        BeanUtils.copyProperties(user, curUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户查询用户权限列表</span></span><br><span class="line">        List&lt;String&gt; permissionValueList = permissionService.selectPermissionValueByUserId(user.getId());</span><br><span class="line">        <span class="type">SecurityUser</span> <span class="variable">securityUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityUser</span>();</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityUser</span>();</span><br><span class="line">        securityUser.setPermissionValueList(permissionValueList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityUser;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="securityuser"><a class="markdownIt-Anchor" href="#securityuser"></a> SecurityUser</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> {</span><br><span class="line">    <span class="comment">//当前登录用户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> User currentUserInfo;</span><br><span class="line">    <span class="comment">//当前权限</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissionValueList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">(User user)</span> {</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.currentUserInfo = user;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() {</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String permissionValue : permissionValueList) {</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(permissionValue)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">SimpleGrantedAuthority</span> <span class="variable">authority</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">SimpleGrantedAuthority</span>(permissionValue);</span><br><span class="line">            authorities.add(authority);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getPassword();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getUsername();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>User</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = "用户实体类")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ApiModelProperty</span>用于swapper测试的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "微信openid")</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "密码")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "昵称")</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "用户头像")</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "用户签名")</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/12/SpringSecurity/%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/"/>
      <url>/2022/11/12/SpringSecurity/%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RequestInterceptor  implements WebMvcConfigurer {</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; patterns = new ArrayList&lt;String&gt;();  //不用过滤的url</span><br><span class="line"></span><br><span class="line">    public void addInterceptor(InterceptorRegistry registry){</span><br><span class="line"></span><br><span class="line">        //写一个拦截器</span><br><span class="line">        registry.addInterceptor(new HandlerInterceptor() {</span><br><span class="line">            @Override</span><br><span class="line">            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //从请求头中获取token</span><br><span class="line">                String token = request.getHeader("Authorization");</span><br><span class="line">//                                      从redis中获取token</span><br><span class="line">                if(token != null &amp;&amp; redisTemplate.opsForValue().get(token) != null){</span><br><span class="line">                    //每次认证后就充值为30天                      时间单位：天</span><br><span class="line">                    redisTemplate.expire(token,30, TimeUnit.DAYS);</span><br><span class="line">                    return true;   //取到就返回true</span><br><span class="line">                }</span><br><span class="line"></span><br><span class="line">                //设置响应状态为401</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">                return false;</span><br><span class="line">            }</span><br><span class="line">        }).excludePathPatterns(patterns);  //不用过滤的url</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JWT 生成Token、解析Token的简单工具类</title>
      <link href="/2022/11/12/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/JWT%20%E7%94%9F%E6%88%90Token%E3%80%81%E8%A7%A3%E6%9E%90Token%E7%9A%84%E7%AE%80%E5%8D%95%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2022/11/12/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/JWT%20%E7%94%9F%E6%88%90Token%E3%80%81%E8%A7%A3%E6%9E%90Token%E7%9A%84%E7%AE%80%E5%8D%95%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="pomxml导入依赖"><a class="markdownIt-Anchor" href="#pomxml导入依赖"></a> pom.xml导入依赖：</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">0.9</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><h1 id="jwttokenmanager工具类"><a class="markdownIt-Anchor" href="#jwttokenmanager工具类"></a> JwtTokenManager工具类</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.User;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.CompressionCodecs;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenManager</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于签名的私钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">"516Letitbe"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签发者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ISSUER</span> <span class="operator">=</span> <span class="string">"Letitbe"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间 1 小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_ONE_HOUR</span> <span class="operator">=</span> <span class="number">3600L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间 1 天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_ONE_DAY</span> <span class="operator">=</span> <span class="number">3600</span> * <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user         token存储的 实体类 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime   token的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(User user, <span class="type">long</span> expireTime)</span> {</span><br><span class="line">        <span class="comment">// 过期时间</span></span><br><span class="line">        <span class="keyword">if</span> ( expireTime == <span class="number">0</span> ) {</span><br><span class="line">            <span class="comment">// 如果是0，就设置默认 1天 的过期时间</span></span><br><span class="line">            expireTime = EXPIRATION_ONE_DAY;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义有效载荷部分, 将User实体类用户名和密码存储</span></span><br><span class="line">        claims.put(<span class="string">"id"</span>, user.getId());</span><br><span class="line">        claims.put(<span class="string">"username"</span>, user.getUsername());</span><br><span class="line">        claims.put(<span class="string">"password"</span>, user.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 发证人</span></span><br><span class="line">                .setIssuer(ISSUER)</span><br><span class="line">                <span class="comment">// 有效载荷</span></span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                <span class="comment">// 设定签发时间</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                <span class="comment">// 设置有效时长</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expireTime))</span><br><span class="line">                <span class="comment">// 使用HS512算法签名，PRIVATE_KEY为签名密钥</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, PRIVATE_KEY)</span><br><span class="line">                <span class="comment">// compressWith() 压缩方法，当载荷过长时可对其进行压缩</span></span><br><span class="line">                <span class="comment">// 可采用jjwt实现的两种压缩方法CompressionCodecs.GZIP和CompressionCodecs.DEFLATE</span></span><br><span class="line">                .compressWith(CompressionCodecs.GZIP)</span><br><span class="line">                <span class="comment">// 生成JWT</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的User实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserFromToken</span><span class="params">(String token)</span> {</span><br><span class="line">        <span class="comment">// 获取有效载荷</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        <span class="comment">// 解析token后，从有效载荷取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (String) claims.get(<span class="string">"id"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">"username"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) claims.get(<span class="string">"password"</span>);</span><br><span class="line">        <span class="comment">// 封装成User实体类</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId( id );</span><br><span class="line">        user.setUsername( username );</span><br><span class="line">        user.setPassword( password );</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取有效载荷</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">getClaimsFromToken</span><span class="params">(String token)</span>{</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    <span class="comment">//设定解密私钥</span></span><br><span class="line">                    .setSigningKey(PRIVATE_KEY)</span><br><span class="line">                    <span class="comment">//传入Token</span></span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    <span class="comment">//获取载荷类</span></span><br><span class="line">                    .getBody();</span><br><span class="line">        }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试：</h1><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">czyTokenTest</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="string">"1arg232t3tg231235"</span>);</span><br><span class="line">        user.setUsername(<span class="string">"其然乐衣"</span>);</span><br><span class="line">        user.setPassword(<span class="string">"2000516"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtTokenManager.createToken(user, <span class="number">0L</span>);</span><br><span class="line">        System.out.println(<span class="string">"生成的token: "</span>);</span><br><span class="line">        System.out.println(token);</span><br><span class="line">        <span class="type">User</span> <span class="variable">userFromToken</span> <span class="operator">=</span> jwtTokenManager.getUserFromToken(token);</span><br><span class="line">        System.out.println(<span class="string">"userFromToken:"</span>);</span><br><span class="line">        System.out.println(userFromToken);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20221112165845740.png" alt="image-20221112165845740"></p>]]></content>
      
      
      <categories>
          
          <category> token </category>
          
          <category> JWT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> token </tag>
            
            <tag> JWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test测试注意事项</title>
      <link href="/2022/11/12/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/test%E6%B5%8B%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2022/11/12/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/test%E6%B5%8B%E8%AF%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<p>非void返回类型的test是不能独立自己进行运行的，否则会报下面的错误“No tests were found”</p><p><img src="../../images/image-20221112151022771.png" alt="image-20221112151022771"></p><p>但可以通过其它的测试类来调用运行，比如：</p><p><img src="../../images/image-20221112151331621.png" alt="image-20221112151331621"></p>]]></content>
      
      
      <categories>
          
          <category> 零碎知识&amp;笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎知识&amp;笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Security-安全管理框架</title>
      <link href="/2022/11/12/SpringSecurity/%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/"/>
      <url>/2022/11/12/SpringSecurity/%E7%BD%91%E4%B8%8A%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/349962352">Spring Security-安全管理框架 - 知乎 (zhihu.com)</a></p><p><img src="https://picd.zhimg.com/v2-9ab1736c4be73705dc1010ed438c33c2_720w.jpg?source=172ae18b" alt="Spring Security-安全管理框架"></p><h1 id="spring-security-安全管理框架"><a class="markdownIt-Anchor" href="#spring-security-安全管理框架"></a> Spring Security-安全管理框架</h1><h2 id="主要内容"><a class="markdownIt-Anchor" href="#主要内容"></a> 主要内容</h2><ol><li>Spring Security 简介</li><li>第一个Spring Security项目</li><li>UserDetailsService详解</li><li>PasswordEncoder密码解析器详解</li><li>自定义登录逻辑</li><li>自定义登录逻辑（数据库访问方式）</li><li>自定义登录页面</li><li>认证过程其他常用配置</li><li>完整认证流程</li></ol><p><a href="https://link.zhihu.com/?target=https%3A//www.bilibili.com/video/BV1R54y1a7Cv">【尚学堂】SpringSecurity安全管理框架_spring security框架从入门到实战_Spring Security源码解析_哔哩哔哩 (゜-゜)つロ 干杯~-bilibiliwww.bilibili.com/video/BV1R54y1a7Cv<img src="https://pic2.zhimg.com/v2-036d5c8d19c234d755e706304d5f0669_180x120.jpg" alt="img"></a></p><h2 id="一-spring-security简介"><a class="markdownIt-Anchor" href="#一-spring-security简介"></a> <strong>一、Spring Security简介</strong></h2><h3 id="1-概括"><a class="markdownIt-Anchor" href="#1-概括"></a> <strong>1、概括</strong></h3><p>Spring Security是一个高度自定义的<strong>安全框架</strong>。利用Spring IoC/DI和AOP功能，为系统提供了声明式安全访问控制功能，减少了为系统安全而编写大量重复代码的工作。</p><p>使用Spring Secruity的原因有很多，但大部分都是发现了javaEE的Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景。同时认识到他们在WAR或EAR级别无法移植。因此如果你更换服务器环境，还有大量工作去重新配置你的应用程序。使用Spring Security 解决了这些问题，也为你提供许多其他有用的、可定制的安全功能。</p><p>正如你可能知道的关于安全方面的两个主要区域是“<strong>认证</strong>”和“<strong>授权</strong>”（或者访问控制）。这两点也是Spring Security重要核心功能。“认证”，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户是否能登录。“授权”指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户是否有权限去做某些事情。</p><h3 id="2-历史"><a class="markdownIt-Anchor" href="#2-历史"></a> <strong>2、历史</strong></h3><p>Spring Security 以“The Acegi Secutity System for Spring” 的名字始于2003年年底。其前身为acegi项目。起因是Spring开发者邮件列表中一个问题，有人提问是否考虑提供一个基于Spring的安全实现。限制于时间问题，开发出了一个简单的安全实现，但是并没有深入研究。几周后，Spring社区中其他成员同样询问了安全问题，代码提供给了这些人。2004年1月份已经有20人左右使用这个项目。随着更多人的加入，在2004年3月左右在sourceforge中建立了一个项目。在最开始并没有认证模块，所有的认证功能都是依赖容器完成的，而acegi则注重授权。但是随着更多人的使用，基于容器的认证就显现出了不足。acegi中也加入了认证功能。大约1年后acegi成为Spring子项目。</p><p>在2006年5月发布了acegi 1.0.0版本。2007年底acegi更名为Spring Security。</p><h2 id="二-第一个spring-security项目"><a class="markdownIt-Anchor" href="#二-第一个spring-security项目"></a> <strong>二、第一个Spring Security项目</strong></h2><h3 id="1-导入依赖"><a class="markdownIt-Anchor" href="#1-导入依赖"></a> <strong>1、导入依赖</strong></h3><p>Spring Security已经被Spring boot进行集成，使用时直接引入启动器即可。</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-访问页面"><a class="markdownIt-Anchor" href="#2-访问页面"></a> <strong>2、访问页面</strong></h3><p>导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p><p>在项目中新建login.html页面后</p><p>在浏览器输入：<a href="http://localhost:8080/login.html%E5%90%8E%E4%BC%9A%E6%98%BE%E7%A4%BA%E4%B8%8B%E9%9D%A2%E9%A1%B5%E9%9D%A2">http://localhost:8080/login.html后会显示下面页面</a></p><p><img src="https://pic2.zhimg.com/80/v2-847d78177f8801e560ee32a230a6afe1_720w.webp" alt="img"></p><p>默认的username为user，password打印在控制台中。当然了，同学们显示的肯定和我的不一样。</p><p><img src="https://pic2.zhimg.com/80/v2-4f0034b67ac60d95822b80529bee6519_720w.webp" alt="img"></p><p>在浏览器中输入账号和密码后会显示login.html页面内容。</p><h3 id="3-应用场景"><a class="markdownIt-Anchor" href="#3-应用场景"></a> <strong>3、应用场景</strong></h3><h3 id="31-对已有项目添加认证功能"><a class="markdownIt-Anchor" href="#31-对已有项目添加认证功能"></a> <strong>3.1</strong> <strong>对已有项目添加认证功能</strong></h3><p>在很多技术中都可能有web访问控制页面。例如：solr就有web管理页面。不需要进行登录，只要知道ip和端口任何人都可以进行访问的。可能导致solr中数据不安全问题。为了保证数据安全性，可以想办法添加Spring Security。（实际上无法添加的，非maven项目）后面还会学很多其他技术，也可以按照这个思想进行操作。</p><h3 id="32-对常规项目"><a class="markdownIt-Anchor" href="#32-对常规项目"></a> <strong>3.2</strong> <strong>对常规项目</strong></h3><p>需要有权限控制的项目都可以使用Spring Security。</p><h3 id="4-可以自定义用户名和密码"><a class="markdownIt-Anchor" href="#4-可以自定义用户名和密码"></a> <strong>4、可以自定义用户名和密码</strong></h3><p>通过修改application.properties(application.yml)</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.security.user.name</span>=<span class="string">smallming</span></span><br><span class="line"><span class="attr">spring.security.user.password</span>=<span class="string">smallming</span></span><br></pre></td></tr></tbody></table></figure><h2 id="三-userdetailsservice详解"><a class="markdownIt-Anchor" href="#三-userdetailsservice详解"></a> <strong>三、UserDetailsService详解</strong></h2><p>当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。</p><p>如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p><p><img src="https://pic4.zhimg.com/80/v2-556e2bb8516b8936856afb664d76fa53_720w.webp" alt="img"></p><h3 id="1-返回值"><a class="markdownIt-Anchor" href="#1-返回值"></a> <strong>1、返回值</strong></h3><p>返回值UserDetails是一个接口，定义如下</p><p><img src="https://pic3.zhimg.com/80/v2-e9fc4046430b279a5185ead48ff9c176_720w.webp" alt="img"></p><p>要想返回UserDetails的实例就只能返回接口的实现类。Spring Security中提供了如下的实例。对于我们只需要使用里面的User类即可。注意User的全限定路径是：</p><p>org.springframework.security.core.userdetails.User</p><p>此处经常和系统中自己开发的User类弄混。</p><p><img src="https://pic4.zhimg.com/80/v2-094f90966c29fe05fff8fb9fd8cfe4a3_720w.webp" alt="img"></p><p>在User类中提供了很多方法和属性。</p><p><img src="https://pic3.zhimg.com/80/v2-86b04d726853d18a02b90f7a7be32f52_720w.webp" alt="img"></p><p>其中构造方法有两个，调用其中任何一个都可以实例化UserDetails实现类User类的实例。而三个参数的构造方法实际上也是调用7个参数的构造方法。</p><ul><li>username：用户名</li><li>password：密码</li><li>authorities：用户具有的权限。此处不允许为null</li></ul><p><img src="https://pic3.zhimg.com/80/v2-1ec3c42314ea72b5bfdcf35293277742_720w.webp" alt="img"></p><p>此处的用户名应该是客户端传递过来的用户名。而密码应该是从数据库中查询出来的密码。Spring Security会根据User中的password和客户端传递过来的password进行比较。如果相同则表示认证通过，如果不相同表示认证失败。</p><p>authorities里面的权限对于后面学习授权是很有必要的，包含的所有内容为此用户具有的权限，如有里面没有包含某个权限，而在做某个事情时必须包含某个权限则会出现403。通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”)来创建authorities集合对象的。参数时一个字符串，多个权限使用逗号分隔。</p><h3 id="2-方法参数"><a class="markdownIt-Anchor" href="#2-方法参数"></a> <strong>2、方法参数</strong></h3><p>方法参数表示用户名。此值是客户端表单传递过来的数据。默认情况下必须叫username，否则无法接收。</p><h3 id="3-异常"><a class="markdownIt-Anchor" href="#3-异常"></a> <strong>3、异常</strong></h3><p>UsernameNotFoundException 用户名没有发现异常。在loadUserByUsername中是需要通过自己的逻辑从数据库中取值的。如果通过用户名没有查询到对应的数据，应该抛出UsernameNotFoundException，系统就知道用户名没有查询到。</p><h2 id="四-passwordencoder密码解析器详解"><a class="markdownIt-Anchor" href="#四-passwordencoder密码解析器详解"></a> <strong>四、PasswordEncoder密码解析器详解</strong></h2><p>Spring Security要求容器中<strong>必须有PasswordEncoder实例（客户端密码和数据库密码是否匹配是由Spring Security 去完成的，Security中还没有默认密码解析器）</strong>。所以当自定义登录逻辑时要求必须给容器注入PaswordEncoder的bean对象</p><h3 id="1-接口介绍"><a class="markdownIt-Anchor" href="#1-接口介绍"></a> <strong>1、接口介绍</strong></h3><p>encode():把参数按照特定的解析规则进行解析。</p><p>matches()验证从存储中获取的编码密码与编码后提交的原始密码是否匹配。如果密码匹配，则返回true；如果不匹配，则返回false。第一个参数表示需要被解析的密码。第二个参数表示存储的密码。</p><p>upgradeEncoding()：如果解析的密码能够再次进行解析且达到更安全的结果则返回true，否则返回false。默认返回false。</p><p><img src="https://pic2.zhimg.com/80/v2-de4a264a945136131d46211735eabbd9_720w.webp" alt="img"></p><h3 id="2-内置解析器介绍"><a class="markdownIt-Anchor" href="#2-内置解析器介绍"></a> <strong>2、内置解析器介绍</strong></h3><p>在Spring Security中内置了很多解析器。</p><p><img src="https://pic2.zhimg.com/80/v2-5b97b758e16b305cb0182f19b1477cb9_1440w.webp" alt="img"></p><h3 id="3-bcryptpasswordencoder简介"><a class="markdownIt-Anchor" href="#3-bcryptpasswordencoder简介"></a> <strong>3、BCryptPasswordEncoder简介</strong></h3><p>BCryptPasswordEncoder是Spring Security官方推荐的密码解析器，平时多使用这个解析器。</p><p>BCryptPasswordEncoder是对bcrypt强散列方法的具体实现。是基于Hash算法实现的单向加密。可以通过strength控制加密强度，默认10.</p><h3 id="4-代码演示"><a class="markdownIt-Anchor" href="#4-代码演示"></a> <strong>4、代码演示</strong></h3><p>在项目src/test/java下新建com.bjsxt.MyTest测试BCryptPasswordEncoder用法。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTest</span> {</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>{</span><br><span class="line">        <span class="comment">//创建解析器</span></span><br><span class="line">        <span class="type">PasswordEncoder</span> <span class="variable">encoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对密码进行加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> encoder.encode(<span class="string">"123"</span>);</span><br><span class="line">        System.out.println(<span class="string">"------------"</span>+password);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断原字符加密后和内容是否匹配</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> encoder.matches(<span class="string">"123"</span>,password);</span><br><span class="line">        System.out.println(<span class="string">"============="</span>+result);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="五-自定义登录逻辑"><a class="markdownIt-Anchor" href="#五-自定义登录逻辑"></a> <strong>五、自定义登录逻辑</strong></h2><p>当进行自定义登录逻辑时需要用到之前讲解的UserDetailsService和PasswordEncoder。但是Spring Security要求：当进行自定义登录逻辑时容器内必须有PasswordEncoder实例。所以不能直接new对象。</p><h3 id="1-编写配置类"><a class="markdownIt-Anchor" href="#1-编写配置类"></a> <strong>1、编写配置类</strong></h3><p>新建类com.bjsxt.config.SecurityConfig 编写下面内容</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">getPwdEncoder</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-自定义逻辑"><a class="markdownIt-Anchor" href="#2-自定义逻辑"></a> <strong>2、自定义逻辑</strong></h3><p>在Spring Security中实现UserDetailService就表示为用户详情服务。在这个类中编写用户认证逻辑。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PasswordEncoder encoder;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        <span class="comment">//1. 查询数据库判断用户名是否存在，如果不存在抛出UsernameNotFoundException</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!username.equals(<span class="string">"admin"</span>)){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">"用户名不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//把查询出来的密码进行解析,或直接把password放到构造方法中。</span></span><br><span class="line">        <span class="comment">//理解:password就是数据库中查询出来的密码，查询出来的内容不是123</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> encoder.encode(<span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,password, AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-查看效果"><a class="markdownIt-Anchor" href="#3-查看效果"></a> <strong>3、查看效果</strong></h3><p>重启项目后，在浏览器中输入账号：admin，密码：123。后可以正确进入到login.html页面。</p><h2 id="六-自定义登录逻辑数据库访问方式"><a class="markdownIt-Anchor" href="#六-自定义登录逻辑数据库访问方式"></a> <strong>六、自定义登录逻辑（数据库访问方式）</strong></h2><h3 id="1-新建数据库表结构"><a class="markdownIt-Anchor" href="#1-新建数据库表结构"></a> <strong>1、新建数据库表结构</strong></h3><p>根据RBAC设计思想完成数据库原型设计。</p><p>因为Spring Security中UserDetails的实现类是User，所以我们尽量不要叫做User</p><p><img src="https://pic2.zhimg.com/80/v2-d12b3310b956d178984199ee30e6dfb1_1440w.webp" alt="img"></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users(</span><br><span class="line">        id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">username <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">password <span class="type">varchar</span>(<span class="number">100</span>)</span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 密码zs</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'张三'</span>,<span class="string">'$2a$10$dwi9Xv9cFDC1r8zQDp9wzupxoULvlzjtAMoes1zExZuDdLqtxT.rG'</span>);</span><br><span class="line"><span class="comment">-- 密码ls</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'李四'</span>,<span class="string">'$2a$10$Tomc5i8yHA.dUROgqX0eVO.Aa9qOAnvbNkUJhZ1znemqhRWdGGSle'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'管理员'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'普通用户'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role_user(</span><br><span class="line">uid <span class="type">bigint</span>,</span><br><span class="line">rid <span class="type">bigint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_user <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_user <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> menu(</span><br><span class="line">id <span class="type">bigint</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">url <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">parentid <span class="type">bigint</span>,</span><br><span class="line">permission <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> menu <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">'系统管理'</span>,<span class="string">''</span>,<span class="number">0</span>,<span class="string">'menu:sys'</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">'用户管理'</span>,<span class="string">''</span>,<span class="number">0</span>,<span class="string">'menu:user'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> role_menu(</span><br><span class="line">mid <span class="type">bigint</span>,</span><br><span class="line">rid <span class="type">bigint</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> role_menu <span class="keyword">values</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="2-在项目中添加依赖"><a class="markdownIt-Anchor" href="#2-在项目中添加依赖"></a> <strong>2、在项目中添加依赖</strong></h3><p>添加MyBatis相关依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.48<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-编写配置文件"><a class="markdownIt-Anchor" href="#3-编写配置文件"></a> <strong>3、编写配置文件</strong></h3><p>新建application.yml</p><p>在配置文件中添加Mybatis配置</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring</span>:<span class="string"></span></span><br><span class="line">  <span class="attr">datasource</span>:<span class="string"></span></span><br><span class="line">    <span class="attr">driver-class-name</span>: <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url</span>: <span class="string">jdbc:mysql://localhost:3306/distributed</span></span><br><span class="line">    <span class="attr">username</span>: <span class="string">root</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">smallming</span></span><br></pre></td></tr></tbody></table></figure><h3 id="4-新建实体类"><a class="markdownIt-Anchor" href="#4-新建实体类"></a> <strong>4、新建实体类</strong></h3><p>新建com.bjsxt.pojo.Users</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Users</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-新建配置类"><a class="markdownIt-Anchor" href="#5-新建配置类"></a> <strong>5、新建配置类</strong></h3><p>新建com.bjsxt.config.SecurityConfig</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-新建mapper"><a class="markdownIt-Anchor" href="#6-新建mapper"></a> <strong>6、新建Mapper</strong></h3><p>新建com.bjsxt.mapper.UsersMapper</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UsersMapper</span> {</span><br><span class="line">    <span class="meta">@Select("select * from users where username=#{username}")</span></span><br><span class="line">    Users <span class="title function_">selectByUsername</span><span class="params">(String username)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="7-修改自定义service逻辑"><a class="markdownIt-Anchor" href="#7-修改自定义service逻辑"></a> <strong>7、修改自定义service逻辑</strong></h3><p>修改com.bjsxt.service.UsersServiceImpl</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsersServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UsersMapper usersMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        <span class="type">Users</span> <span class="variable">users</span> <span class="operator">=</span> usersMapper.selectByUsername(username);</span><br><span class="line">        <span class="keyword">if</span>(users==<span class="literal">null</span>){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">"用户名不存在"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(username,users.getPassword(), AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"admin"</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="8-新建启动器"><a class="markdownIt-Anchor" href="#8-新建启动器"></a> <strong>8、新建启动器</strong></h3><p>新建com.bjsxt.SecurityApplication</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityApplication</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        SpringApplication.run(SecurityApplication.class,args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="七-自定义登录页面"><a class="markdownIt-Anchor" href="#七-自定义登录页面"></a> <strong>七、自定义登录页面</strong></h2><p>虽然Spring Security给我们提供了登录页面，但是对于实际项目中，大多喜欢使用自己的登录页面。所以Spring Security中不仅仅提供了登录页面，还支持用户自定义登录页面。实现过程也比较简单，只需要修改配置类即可。</p><p>说明：在上面代码基础上进行修改</p><h3 id="1-修改pom"><a class="markdownIt-Anchor" href="#1-修改pom"></a> <strong>1、修改pom</strong></h3><p>添加thymeleaf的依赖</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-编写登录页面"><a class="markdownIt-Anchor" href="#2-编写登录页面"></a> <strong>2、编写登录页面</strong></h3><p>在resources下新建templates文件夹。其中fail.html和success.html都只有一句话，分别是：“登录失败”和“登录成功”</p><p><img src="https://pic1.zhimg.com/80/v2-31b628344debad9559ce0591596cf5e0_1440w.webp" alt="img"></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="3-修改配置类"><a class="markdownIt-Anchor" href="#3-修改配置类"></a> <strong>3、修改配置类</strong></h3><p>修改配置类中主要是设置哪个页面是登录页面。配置类需要继承WebSecurityConfigurerAdapter，并重写configure方法。</p><ul><li>successForwardUrl()：登录成功后跳转地址</li><li>loginPage()：登录页面</li><li>loginProcessingUrl：登录页面表单提交地址，此地址可以不真实存在。</li><li>antMatchers()：匹配内容</li><li>permitAll()：允许</li></ul><p>**注意：**configure方法中除了FailureForwardUrl()以外其他配置都是必须写的配置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="comment">// 配置认证</span></span><br><span class="line">        http.formLogin()</span><br><span class="line">                <span class="comment">// 哪个URL为登录页面</span></span><br><span class="line">                .loginPage(<span class="string">"/"</span>)</span><br><span class="line">                <span class="comment">// 当发现什么URL时执行登录逻辑</span></span><br><span class="line">                .loginProcessingUrl(<span class="string">"/login"</span>)</span><br><span class="line">                <span class="comment">// 成功后跳转到哪里</span></span><br><span class="line">                .successForwardUrl(<span class="string">"/success"</span>)</span><br><span class="line">                <span class="comment">// 失败后跳转到哪里</span></span><br><span class="line">                .failureForwardUrl(<span class="string">"/fail"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置URL的授权问题</span></span><br><span class="line">        <span class="comment">// 多个条件取交集</span></span><br><span class="line">        http.authorizeRequests()</span><br><span class="line">                <span class="comment">// 匹配 / 控制器  permitAll() 不需要被认证就可以访问</span></span><br><span class="line">                .antMatchers(<span class="string">"/"</span>).permitAll()</span><br><span class="line">                <span class="comment">// anyRequest() 所有请求   authenticated() 必须被认证</span></span><br><span class="line">                .anyRequest().authenticated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 关闭csrf</span></span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-编写控制器"><a class="markdownIt-Anchor" href="#4-编写控制器"></a> <strong>4、编写控制器</strong></h3><p>新建com.bjsxt.controller.UserController。</p><p>三个方法都是只有显示页面的功能。因为Thymeleaf页面必须通过控制器显示。如果示例代码是拿纯HTMl静态页面演示，是不需要写这些控制器。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> {</span><br><span class="line">    <span class="meta">@RequestMapping("/")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">showLogin</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"login"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@RequestMapping("/success")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">success</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@RequestMapping("/fail")</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">fail</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"fail"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="1-测试效果"><a class="markdownIt-Anchor" href="#1-测试效果"></a> <strong>1</strong> <strong>测试效果</strong></h3><p>在浏览器输入：http://localhost:8080显示登录页面。输入：账号：张三，密码：zs后会显示“登录成功”</p><p><img src="https://pic1.zhimg.com/80/v2-f1f249f104bd5b9de236fdbce38f16ac_1440w.webp" alt="img"></p><h2 id="八-认证过程其他常用配置"><a class="markdownIt-Anchor" href="#八-认证过程其他常用配置"></a> <strong>八、认证过程其他常用配置</strong></h2><h3 id="1-设置请求账户和密码的参数名"><a class="markdownIt-Anchor" href="#1-设置请求账户和密码的参数名"></a> <strong>1、设置请求账户和密码的参数名</strong></h3><h3 id="11-源码简介"><a class="markdownIt-Anchor" href="#11-源码简介"></a> <strong>1.1</strong> <strong>源码简介</strong></h3><p>当进行登录时会执行UsernamePasswordAuthenticationFilter过滤器。</p><ul><li>usernamePasrameter：账户参数名</li><li>passwordParameter：密码参数名</li><li>postOnly=true：默认情况下只允许POST请求。</li></ul><p><img src="https://pic1.zhimg.com/80/v2-6de3d6eac29731b4c7bf21bd1f9ec458_1440w.webp" alt="img"></p><p><strong>1.2</strong> <strong>修改配置</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单认证</span></span><br><span class="line">http.formLogin()</span><br><span class="line">        .loginProcessingUrl(<span class="string">"/login"</span>)   <span class="comment">//当发现/login时认为是登录，需要执行UserDetailsServiceImpl</span></span><br><span class="line">        .successForwardUrl(<span class="string">"/toMain"</span>)   <span class="comment">//此处是post请求</span></span><br><span class="line">        .failureForwardUrl(<span class="string">"/fail"</span>)     <span class="comment">//登录失败跳转地址</span></span><br><span class="line">        .loginPage(<span class="string">"/login.html"</span>)</span><br><span class="line">        .usernameParameter(<span class="string">"myusername"</span>)</span><br><span class="line">        .passwordParameter(<span class="string">"mypassword"</span>);</span><br></pre></td></tr></tbody></table></figure><p><strong>1.3</strong> <strong>修改页面</strong></p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span> = <span class="string">"/login"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"myusername"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    密码:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">"mypassword"</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="2-登录成功三种配置方式"><a class="markdownIt-Anchor" href="#2-登录成功三种配置方式"></a> <strong>2、登录成功三种配置方式</strong></h3><h3 id="21-转发源码分析"><a class="markdownIt-Anchor" href="#21-转发源码分析"></a> <strong>2.1</strong> <strong>转发源码分析</strong></h3><p>使用successForwardUrl()时表示成功后转发请求到地址。内部是通过successHandler（）方法进行控制成功后交给哪个类进行处理。</p><p><img src="https://pic4.zhimg.com/80/v2-69291e34e97142b7edbd35f1f060f603_1440w.webp" alt="img"></p><p>orwardAuthenticationSuccessHandler内部就是最简单的请求转发。由于是请求转发，当遇到需要跳转到站外或在前后端分离的项目中就无法使用了。</p><p><img src="https://pic2.zhimg.com/80/v2-6c68c64aca24f7e38c5387e13b67bbcd_1440w.webp" alt="img"></p><p>当需要控制登录成功后去做一些事情时，可以进行自定义认证成功控制器。</p><h3 id="12-自定义成功逻辑"><a class="markdownIt-Anchor" href="#12-自定义成功逻辑"></a> <strong>1.2</strong> <strong>自定义成功逻辑</strong></h3><p>在配置类使用.successHandler自定义成功逻辑。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.successHandler(<span class="keyword">new</span> <span class="title class_">AuthenticationSuccessHandler</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationSuccess</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        httpServletResponse.sendRedirect(<span class="string">"http://www.bjsxt.com"</span>);</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><h3 id="23-重定向方法支持"><a class="markdownIt-Anchor" href="#23-重定向方法支持"></a> <strong>2.3</strong> <strong>重定向方法支持</strong></h3><p>可以直接使用defaultSuccessUrl(); 可以进行重定向到特定页面.</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.defaultSuccessUrl(<span class="string">"/success123"</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="3-登录失败时三种配置方式"><a class="markdownIt-Anchor" href="#3-登录失败时三种配置方式"></a> <strong>3、登录失败时三种配置方式</strong></h3><h3 id="31-转发源码分析"><a class="markdownIt-Anchor" href="#31-转发源码分析"></a> <strong>3.1</strong> <strong>转发源码分析</strong></h3><p>failureForwardUrl()内部调用的是failureHandler()方法</p><p><img src="https://pic4.zhimg.com/80/v2-eef20f382ba974a7b07031a032a3dbdb_1440w.webp" alt="img"></p><p>ForwardAuthenticationFailureHandler中也是一个请求转发，并在request作用域中设置SPRING_SECURITY_LAST_EXCEPTION的key，内容为异常对象。</p><p><img src="https://pic3.zhimg.com/80/v2-c9825b9e86fe7dae9985d5dda3046122_1440w.webp" alt="img"></p><h3 id="32-自定义登录失败逻辑"><a class="markdownIt-Anchor" href="#32-自定义登录失败逻辑"></a> <strong>3.2</strong> <strong>自定义登录失败逻辑</strong></h3><p>在配置类中使用.failureHandler设置</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.failureHandler(<span class="keyword">new</span> <span class="title class_">AuthenticationFailureHandler</span>() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onAuthenticationFailure</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, AuthenticationException e)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        httpServletResponse.sendRedirect(<span class="string">"http://www.smallming.com"</span>);</span><br><span class="line">    }</span><br><span class="line">})</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3</strong> <strong>登录失败后重定向到指定地址</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.failureUrl(<span class="string">"http://www.smallming.com"</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="完整认证流程包含自定义页面和自定义登录逻辑"><a class="markdownIt-Anchor" href="#完整认证流程包含自定义页面和自定义登录逻辑"></a> <strong>完整认证流程（包含自定义页面和自定义登录逻辑）</strong></h2><p><img src="https://pic4.zhimg.com/v2-bc1813a0ad7fc3979810a7452c0450b3_r.jpg" alt="img"></p><ol><li>用户在浏览器中随意输入一个URL</li><li>Spring Security 会判断当前是否已经被认证（登录）如果已经认证，正常访问URL。如果没有被认证跳转到loginPage()对应的URL中，显示登录页面。</li><li>用户输入用户名和密码点击登录按钮后，发送登录url</li><li>如果url和loginProcessingUrl()一样才执行登录流程。否则需要重新认证。</li><li>执行登录流程时首先被UsernamePasswordAuthenticationFilter进行过滤，取出用户名和密码，放入到容器中。根据usernameParameter和passwordParameter进行取用户名和密码，如果没有配置这两个方法，默认为请求参数名username和password</li><li>执行自定义登录逻辑UserDetailsService的实现类。判断用户名是否存在和数据库中,如果不存在，直接抛出UsernameNotFoundException。如果用户名存在，把从数据库中查询出来的密码通过org.springframework.security.core.userdetails.User传递给Spring Security。Spring Security根据容器中配置的Password encoder示例把客户端传递过来的密码和数据库传递过来的密码进行匹配。如果匹配成功表示认证成功。</li><li>如果登录成功，跳转到successForwardUrl（转发）/successHandler（自己控制跳转方式）/defaultSuccessUrl(重定向)配置的URL</li><li>如果登录失败，跳转到failureForwardUrl/failureHandler/failureUrl</li></ol>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity 请求间共享认证信息（源码剖析）</title>
      <link href="/2022/11/11/SpringSecurity/SpringSecurity%20%E8%AF%B7%E6%B1%82%E9%97%B4%E5%85%B1%E4%BA%AB%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/"/>
      <url>/2022/11/11/SpringSecurity/SpringSecurity%20%E8%AF%B7%E6%B1%82%E9%97%B4%E5%85%B1%E4%BA%AB%E8%AE%A4%E8%AF%81%E4%BF%A1%E6%81%AF%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="springsecurity-请求间共享认证信息"><a class="markdownIt-Anchor" href="#springsecurity-请求间共享认证信息"></a> <strong>SpringSecurity 请求间共享认证信息</strong></h1><p>对应教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP?p=39&amp;vd_source=746b9336d739b80b11820809545b6604">39-尚硅谷-SpringSecurity-源码剖析-认证信息共享详解_哔哩哔哩_bilibili</a></p><p>一般认证成功后的用户信息是通过 Session 在多个请求之间共享，那么 <strong>Spring</strong> <strong>Security</strong> 中是如何实现将已认证的用户信息对象 Authentication 与 Session 绑定的进行具体分析</p><p><img src="../../images/image-20221111211841097.png" alt="image-20221111211841097"></p><p>⚫ 在前面讲解认证成功的处理方法 successfulAuthentication() 时，有以下代码：</p><p><img src="../../images/image-20221111211945405.png" alt="image-20221111211945405"></p><p>⚫ 查 看 SecurityContext 接 口 及 其 实 现 类 SecurityContextImpl ， 该 类 其 实 就 是 对Authentication 的封装：</p><p>⚫ 查 看 SecurityContextHolder 类 ， 该 类 其 实 是 对 ThreadLocal 的 封 装 ， 存 储SecurityContext 对象：</p><p><img src="../../images/image-20221111212010159.png" alt="image-20221111212010159"></p><p><img src="../../images/image-20221111212020024.png" alt="image-20221111212020024"></p><p><img src="../../images/image-20221111212029106.png" alt="image-20221111212029106"></p><p><img src="../../images/image-20221111212041020.png" alt="image-20221111212041020"></p><h1 id="securitycontextpersistencefilter-过滤器"><a class="markdownIt-Anchor" href="#securitycontextpersistencefilter-过滤器"></a> SecurityContextPersistenceFilter 过滤器</h1><p>前面提到过，在 <strong>UsernamePasswordAuthenticationFilter</strong> 过滤器认证成功之后，会在认证成功的处理方法中将已认证的用户信息对象 Authentication 封装进</p><p>SecurityContext，并存入 SecurityContextHolder。之后，响应会通过 <strong>SecurityContextPersistenceFilter</strong> 过滤器，该过滤器的位置在所有过滤器的最前面，请求到来先进它，响应返回最后一个通过它，所以在该过滤器中处理已认证的用户信息对象 Authentication 与 Session 绑定。</p><p>认证成功的响应通过 <strong>SecurityContextPersistenceFilter</strong> 过滤器时，会从SecurityContextHolder 中取出封装了已认证用户信息对象 Authentication 的SecurityContext，放进 Session 中。当请求再次到来时，请求首先经过该过滤器，该过滤器会判断当前请求的 Session 是否存有 SecurityContext 对象，如果有则将该对象取出再次放入 SecurityContextHolder 中，之后该请求所在的线程获得认证用户信息，后续的资源访问不需要进行身份认证；当响应再次返回时，该过滤器同样从 SecurityContextHolder 取出SecurityContext 对象，放入 Session 中。具体源码如下：</p><p><img src="../../images/image-20221111212148379.png" alt="image-20221111212148379"></p><p><img src="../../images/image-20221111212156838.png" alt="image-20221111212156838"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity权限访问流程（源码剖析）</title>
      <link href="/2022/11/11/SpringSecurity/SpringSecurity%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/"/>
      <url>/2022/11/11/SpringSecurity/SpringSecurity%E6%9D%83%E9%99%90%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="exceptiontranslationfilter-过滤器"><a class="markdownIt-Anchor" href="#exceptiontranslationfilter-过滤器"></a> <strong>ExceptionTranslationFilter 过滤器</strong></h2><p>该过滤器是用于处理异常的，不需要我们配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（例如：权限访问限制）。具体源码如下：</p><p><img src="../../images/image-20221111205806671.png" alt="image-20221111205806671"></p><h1 id="filtersecurityinterceptor-过滤器"><a class="markdownIt-Anchor" href="#filtersecurityinterceptor-过滤器"></a> <strong>FilterSecurityInterceptor</strong> <strong>过滤器</strong></h1><p><strong>FilterSecurityInterceptor</strong> 是过滤器链的最后一个过滤器，该过滤器是过滤器链的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，最终所抛出的异常会由前一个过滤器<strong>ExceptionTranslationFilter</strong> 进行捕获和处理。具体源码如下：</p><p><img src="../../images/image-20221111210309165.png" alt="image-20221111210309165"></p><p>需要注意，<strong>Spring Security</strong> 的过滤器链是配置在 SpringMVC 的核心组件DispatcherServlet 运行之前。也就是说，请求通过 <strong>Spring Security</strong> 的所有过滤器，不意味着能够正常访问资源，该请求还需要通过 SpringMVC 的拦截器链。</p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity 认证流程（源码剖析）</title>
      <link href="/2022/11/11/SpringSecurity/SpringSecurity%20%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/"/>
      <url>/2022/11/11/SpringSecurity/SpringSecurity%20%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B%EF%BC%88%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>ps:硅谷老师的笔记(代码背景白色)</strong></p><h1 id="springsecurity-基本流程"><a class="markdownIt-Anchor" href="#springsecurity-基本流程"></a> <strong>SpringSecurity 基本流程</strong></h1><p><strong>上：对应教程视频：</strong><a href="https://www.bilibili.com/video/BV15a411A7kP?p=36&amp;vd_source=746b9336d739b80b11820809545b6604">36-尚硅谷-SpringSecurity-源码剖析-认证流程详解上_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221111185833955.png" alt="image-20221111185833955"></p><p>绿色部分是认证过滤器，需要我们自己配置，可以配置多个认证过滤器。认证过滤器可以使用 <strong>Spring Security</strong> 提供的认证过滤器，也可以自定义过滤器（例如：短信验证）。认证过滤器要在 **configure(HttpSecurity http)**方法中配置，没有配置不生效。下面会重点介绍以下三个过滤器：</p><p><strong>UsernamePasswordAuthenticationFilter</strong> 过滤器：该过滤器会拦截前端提交的 POST 方式的登录表单请求，并进行身份认证。</p><p><strong>ExceptionTranslationFilter</strong> 过滤器：该过滤器不需要我们配置，对于前端提交的请求会直接放行，捕获后续抛出的异常并进行处理（例如：权限访问限制）。</p><p><strong>FilterSecurityInterceptor</strong> 过滤器：该过滤器是过滤器链的最后一个过滤器，根据资源权限配置来判断当前请求是否有权限访问对应的资源。如果访问受限会抛出相关异常，并由 <strong>ExceptionTranslationFilter</strong> 过滤器进行捕获和处理。</p><h1 id="springsecurity-认证流程源码剖析"><a class="markdownIt-Anchor" href="#springsecurity-认证流程源码剖析"></a> <strong>SpringSecurity 认证流程</strong>（源码剖析）</h1><p><img src="../../images/image-20221111185759068.png" alt="image-20221111185759068"></p><p>前端的post请求都会被<strong>UsernamePasswordAuthenticationFilter</strong>这个过滤器给拦截，并进行身份的认证</p><p>（1) 到父类<strong>AbstractAuthenticationProcessingFilter</strong></p><p>​第一步：过滤的方法<strong>doFilter</strong>，判断提交方式是否post提交</p><p><img src="../../images/image-20221111175238982.png" alt="image-20221111175238982"></p><p>​第二步：调用子类<strong>UsernamePasswordAuthenticationFilter</strong>的<strong>attemptAuthentication</strong>方法进行身份认证，认证成功之后，把认证信息封装到<strong>Authentication</strong>对象里面</p><p>​<strong>Authentication</strong>用于封装认证信息的类对象</p><p>​在post提交表单之后，得到表单提交过来的数据，然后这里调用子类里的<strong>attemptAuthentication</strong>方法去查数据库和进行验证，认证之后，那认证通过后的信息用<strong>Authentication</strong>进行封装</p><p><img src="../../images/image-20221111175602673.png" alt="image-20221111175602673"></p><p>第三步：session策略处理</p><p><img src="../../images/image-20221111180301213.png" alt="image-20221111180301213"></p><p>第四步：</p><p>1、认证失败抛出异常，执行认证失败的方法</p><p>认证成功后会进行封装，但认证失败会，会在catch里面调用<strong>unsuccessfulAuthentication</strong>方法，做认证失败处理，比如提示用户你没有权限</p><p><img src="../../images/image-20221111180616578.png" alt="image-20221111180616578"></p><p>ps:网友的笔记(代码背景白色)</p><p><img src="../../images/image-20221111185611776.png" alt="image-20221111185611776"></p><p>2、认证成功后，调用认证成功后的方法</p><p><img src="../../images/image-20221111181109625.png" alt="image-20221111181109625"></p><p><strong>ps:<strong>上面第二步：调用子类</strong>UsernamePasswordAuthenticationFilter</strong>的<strong>attemptAuthentication</strong>方法去查数据库和进行验证的源码剖析：</p><p><strong>attemptAuthentication中的</strong></p><p>第一步：判断前端是否是post提交</p><p>第二步：获取前端表单提交数据</p><p><img src="../../images/image-20221111182257781.png" alt="image-20221111182257781"></p><p><img src="../../images/image-20221111185415885.png" alt="image-20221111185415885"></p><p><img src="../../images/image-20221111185333746.png" alt="image-20221111185333746"></p><p>第三步：</p><p>使用获取数据，构造成对象(<strong>UsernamePasswordAuthenticationToken</strong>)，标记为未认证的状态</p><p>把请求一些属性信息设置到该对象里面（ this.setDetails(request, authRequest); ）</p><p>调用authenticate方法进行身份认证（调用我们自己编写的<strong>userDetailsService</strong>里面的方法进行查数据过程或认证过程）</p><p><img src="../../images/image-20221111182712378.png" alt="image-20221111182712378"></p><p><img src="../../images/image-20221111190458033.png" alt="image-20221111190458033"></p><p>（3）查看 <strong>UsernamePasswordAuthenticationToken</strong> 的构建过程</p><p><img src="../../images/image-20221111185138507.png" alt="image-20221111185138507"></p><p><strong>下：对应教程视频：</strong><a href="https://www.bilibili.com/video/BV15a411A7kP?p=37&amp;vd_source=746b9336d739b80b11820809545b6604">37-尚硅谷-SpringSecurity-源码剖析-认证流程详解下_哔哩哔哩_bilibili</a></p><p>（4）查看ProviderManager源码，认证实现</p><p>上述过程中，<strong>UsernamePasswordAuthenticationFilter</strong> 过滤器的<strong>attemptAuthentication</strong>() 方法的<strong>身份认证过程</strong>将未认证的 <strong>Authentication</strong> 对象传入<strong>ProviderManager</strong> 类的 <strong>authenticate</strong>() 方法进行身份认证。</p><p>ProviderManager 是 AuthenticationManager 接口的实现类，该接口是认证相关的核心接口，也是认证的入口。在实际开发中，我们可能有多种不同的认证方式，例如：用户名+密码、邮箱+密码、手机号+验证码等，而这些认证方式的入口始终只有一个，那就是AuthenticationManager。在该接口的常用实现类 ProviderManager 内部会维护一个**List<authenticationprovider>**列表，存放多种认证方式，实际上这是委托者模式（Delegate）的应用。每种认证方式对应着一个 AuthenticationProvider，AuthenticationManager 根据认证方式的不同（根据传入的 Authentication 类型判断）委托对应的 AuthenticationProvider 进行用户认证。</authenticationprovider></p><p><img src="../../images/image-20221111203614625.png" alt="image-20221111203614625"></p><p><img src="../../images/image-20221111203630089.png" alt="image-20221111203630089"></p><p><img src="../../images/image-20221111203653228.png" alt="image-20221111203653228"></p><p><img src="../../images/image-20221111203710806.png" alt="image-20221111203710806"></p><p><strong>上述认证成功之后的（<strong>6</strong>）过程，调用</strong> <strong>CredentialsContainer</strong> <strong>接口定义的eraseCredentials</strong>() <strong>方法去除敏感信息。查看</strong></p><p><strong>UsernamePasswordAuthenticationToken</strong> <strong>实现的</strong> <strong>eraseCredentials()</strong> <strong>方法，该方</strong>法实现在其父类中：</p><p><img src="../../images/image-20221111203846591.png" alt="image-20221111203846591"></p><p>上述过程就是认证流程的最核心部分，接下来重新回到</p><p><strong>UsernamePasswordAuthenticationFilter</strong> 过滤器的 doFilter() 方法，查看认证成功/失败的处理：</p><p><img src="../../images/image-20221111203923720.png" alt="image-20221111203923720"></p><h4 id="查看successfulauthentication-和-unsuccessfulauthentication-方法源码"><a class="markdownIt-Anchor" href="#查看successfulauthentication-和-unsuccessfulauthentication-方法源码"></a> 查看successfulAuthentication() 和 unsuccessfulAuthentication() 方法源码：</h4><p><img src="../../images/image-20221111204011293.png" alt="image-20221111204011293"></p><p><img src="../../images/image-20221111204101980.png" alt="image-20221111204101980"></p><p>———————————————————————————————————————————————————————————————————————</p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
          <category> 源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关注解的使用</title>
      <link href="/2022/11/11/springboot/%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/11/11/springboot/%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-autowired"><a class="markdownIt-Anchor" href="#1-autowired"></a> 1. @Autowired</h1><p><a href="https://www.cnblogs.com/x-jingxin/p/12918974.html">@Autowired 写在构造方法上 - x_jingxin - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
          <category> 注解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>活跃性-定位死锁 （如何查看、定位死锁）</title>
      <link href="/2022/11/10/juc/%E6%B4%BB%E8%B7%83%E6%80%A7-%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%20%EF%BC%88%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E3%80%81%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%EF%BC%89/"/>
      <url>/2022/11/10/juc/%E6%B4%BB%E8%B7%83%E6%80%A7-%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%20%EF%BC%88%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E3%80%81%E5%AE%9A%E4%BD%8D%E6%AD%BB%E9%94%81%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考视频教程：<a href="https://www.bilibili.com/video/BV16J411h7Rd?p=116&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">04.067-活跃性-定位死锁_哔哩哔哩_bilibili</a></p></blockquote><p><strong>方式1 ：jstack工具</strong></p><p>通过终端命令：jstack 进程号 （图上面写错了，不是进程的端口号，是进程号）</p><p><img src="https://img-blog.csdnimg.cn/98cd05b7a9ac4db1a434dd16cedf747f.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑通过上面的运行后可以看到下面的 线程信息：</p><p><img src="https://img-blog.csdnimg.cn/188b8741f76d4b68b02383249c0f5612.png" alt="img"></p><p>方式1的jstack工具可以查看死锁的位置（哪一行），然后让我们去修改相应的代码</p><p><strong>方式2：jconsole工具</strong></p><p><img src="https://img-blog.csdnimg.cn/8730559d36184371ab7b0e704935b94f.png" alt="img"><img src="https://img-blog.csdnimg.cn/717a771fd58048c4b3e0d67c2a382bd7.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/193622a6730f4390b3cd5dddde10fdc4.png" alt="img"></p><p>点击之后<img src="https://img-blog.csdnimg.cn/bb94babc5de941d6932699155cc5f2a1.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 死锁 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（rabbitmq的高级特性）MQ集群</title>
      <link href="/2022/11/10/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89MQ%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/11/10/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89MQ%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<p>对应的教程视频：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=161&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day5-04-MQ集群_哔哩哔哩_bilibili</a></p></blockquote><p>1.集群分类</p><p><img src="https://img-blog.csdnimg.cn/a9ebe4585fd54ed8b699e315a6141c1b.png" alt="img"></p><p>因为比较推荐使用仲裁队列，所以 普通集群和镜像集群就不做笔记的记录了</p><h1 id="2普通集群"><a class="markdownIt-Anchor" href="#2普通集群"></a> 2.普通集群</h1><h1 id="3镜像集群"><a class="markdownIt-Anchor" href="#3镜像集群"></a> 3.镜像集群</h1><h1 id="3仲裁队列"><a class="markdownIt-Anchor" href="#3仲裁队列"></a> 3.仲裁队列</h1><p>仲裁队列：仲裁队列是3.8版本以后才有的新功能，用来替代镜像队列，具备下列特征：</p><p>•与镜像队列一样，都是主从模式，支持主从数据同步</p><p>•使用非常简单，没有复杂的配置</p><p>•主从同步基于Raft协议，强一致</p><h3 id="搭建非常简单不需要任何配置直接在控制台添加一个队列就行"><a class="markdownIt-Anchor" href="#搭建非常简单不需要任何配置直接在控制台添加一个队列就行"></a> 搭建（非常简单，不需要任何配置，直接在控制台添加一个队列就行）：</h3><p>在任意控制台添加一个队列，一定要选择队列类型为Quorum类型</p><p><img src="https://img-blog.csdnimg.cn/b9b16bfc723f4178b04c1d8b1e857991.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/59c23da4cec14f29b409ba7141f30431.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ad2ce48988004e1f889af46c0b63ba20.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c55881b2175f4ace9b41b616877e7a38.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（rabbitmq的高级特性）惰性队列</title>
      <link href="/2022/11/10/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97/"/>
      <url>/2022/11/10/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89%E6%83%B0%E6%80%A7%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=160&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day5-03-消息堆积及惰性队列_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1消息堆积问题"><a class="markdownIt-Anchor" href="#1消息堆积问题"></a> 1.消息堆积问题</h1><p><img src="https://img-blog.csdnimg.cn/b99d3d1549204d588c14889ef1d9c246.png" alt="img"></p><p>当出现高并发的时候，一如说有一百万条，这些消息都扔到内存当中，显然是不合适的，所以需要学习 队形队列</p><h1 id="2惰性队列"><a class="markdownIt-Anchor" href="#2惰性队列"></a> 2.惰性队列</h1><p><img src="https://img-blog.csdnimg.cn/1245c0f36dd548db84d5c5d494c2d331.png" alt="img"></p><p>使用第一种Bean方式方式显然方便些</p><p><img src="https://img-blog.csdnimg.cn/69f85d1fbdcb4501a3804dabefea0ce2.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9876735c7b4845b3b333773526244587.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(rabbitmq的高级特性)死信交换机</title>
      <link href="/2022/11/10/MQ/(rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA/"/>
      <url>/2022/11/10/MQ/(rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7)%E6%AD%BB%E4%BF%A1%E4%BA%A4%E6%8D%A2%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>对应的教程视频：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=159&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day5-02-死信交换机_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1初始死信交换机"><a class="markdownIt-Anchor" href="#1初始死信交换机"></a> 1.初始死信交换机</h1><p><img src="https://img-blog.csdnimg.cn/2689f1bfc1eb42778182145abfcf6675.png" alt="img"></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h2><p>什么样的消息会成为死信？</p><p>•消息被消费者reject或者返回nack</p><p>•消息超时未消费</p><p>•队列满了</p><p>如何给队列绑定死信交换机？</p><p>•给队列设置dead-letter-exchange属性，指定一个交换机</p><p>•给队列设置dead-letter-routing-key属性，设置死信交换机与死信队列的RoutingKey</p><h1 id="2ttl"><a class="markdownIt-Anchor" href="#2ttl"></a> 2.TTL</h1><p><img src="https://img-blog.csdnimg.cn/e68465dd5a8b49dd8ccb078c78f1ef94.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ab0c69d04e4546f481d0f07ed98eb68a.png" alt="img"><img src="https://img-blog.csdnimg.cn/d7bc1af04dae44f9b6a644135646c125.png" alt="img"></p><h2 id="img-总结"><a class="markdownIt-Anchor" href="#img-总结"></a> <img src="https://img-blog.csdnimg.cn/af49a4d919f84acdb4de208beb3f50f4.png" alt="img"> <strong>总结：</strong></h2><p>消息超时的两种方式是？</p><p>•给队列设置ttl属性，进入队列后超过ttl时间的消息变为死信</p><p>•给消息设置ttl属性，队列接收到消息超过ttl时间后变为死信</p><p>•两者共存时，以时间短的ttl为准</p><p>如何实现发送一个消息20秒后消费者才收到消息？</p><p>•给消息的目标队列指定死信交换机</p><p>•消费者监听与死信交换机绑定的队列</p><p>•发送消息时给消息设置ttl为20秒</p><h1 id="3延迟队列"><a class="markdownIt-Anchor" href="#3延迟队列"></a> 3.延迟队列</h1><p><img src="https://img-blog.csdnimg.cn/7e4045074e8645398aee01a86bd72b6d.png" alt="img"></p><p><strong>延迟队列插件</strong></p><p>因为延迟队列的需求非常多，所以RabbitMQ的官方也推出了一个插件，原生支持延迟队列效果。</p><p>详细安装过程略~~~（我也没装，只是做下笔记，具体怎么装看教程视频吧或是自行查询资料）</p><p><img src="https://img-blog.csdnimg.cn/4f7be72a86ca4d52bace861262cf91b0.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/662b16adf47048b5b82200fe32c3d4b2.png" alt="img"><img src="https://img-blog.csdnimg.cn/8400f734ba474b95b9177715cb17f499.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/6281fbc64d7048149430bca5ba0d4641.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/8df2a4654802484e9d257c28c0f4eb48.png" alt="img"></p><h2 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结：</h2><p>延迟队列插件的使用步骤包括哪些？</p><p>•声明一个交换机，添加<mark>delayed</mark>属性为true</p><p>•发送消息时，添加<mark>x-delay头</mark>，值为超时时间</p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>rabbitmq的高级特性</title>
      <link href="/2022/11/10/MQ/rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2022/11/10/MQ/rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="mq的一些常见问题"><a class="markdownIt-Anchor" href="#mq的一些常见问题"></a> MQ的一些常见问题</h1><ul><li>**消息可靠性问题：**如何确保发送的消息至少被消费一次</li><li>**延迟消息问题：**如何实现消息的延迟投递</li><li>**消息堆积问题：**如何解决数百万消息堆积，无法及时消费的问题</li><li>**高可用问题：**如何避免单点的MQ故障而导致的不可用问题</li></ul><p>一、消息可靠性</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126685420?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126685420%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(78条消息) （rabbitmq的高级特性）消息可靠性_其然乐衣的博客-CSDN博客</a></p></blockquote><p>二、死信交换机</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126711760?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126711760%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(18条消息) (rabbitmq的高级特性)死信交换机_其然乐衣的博客-CSDN博客</a></p></blockquote><p>三、惰性队列</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126712044?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126712044%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(19条消息) （rabbitmq的高级特性）惰性队列_其然乐衣的博客-CSDN博客</a></p></blockquote><p>四、MQ集群</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126713121?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126713121%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(19条消息) （rabbitmq的高级特性）MQ集群_其然乐衣的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（多级缓存）缓存同步</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89%E7%BC%93%E5%AD%98%E5%90%8C%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=157&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day4-04-缓存同步_哔哩哔哩_bilibili</a></p></blockquote><h1 id="一-数据同步策略"><a class="markdownIt-Anchor" href="#一-数据同步策略"></a> 一、数据同步策略</h1><p>缓存数据同步的常见方式有三种：</p><p>•<strong>设置有效期</strong>：给缓存设置有效期，到期后自动删除。再次查询时更新</p><p>•优势：简单、方便</p><p>•缺点：时效性差，缓存过期之前可能不一致</p><p>•场景：更新频率较低，时效性要求低的业务</p><p>•<strong>同步双写</strong>：在修改数据库的同时，直接修改缓存</p><p>•优势：时效性强，缓存与数据库强一致</p><p>•缺点：有代码侵入，耦合度高；</p><p>•场景：对一致性、时效性要求较高的缓存数据</p><p>•**异步通知：**修改数据库时发送事件通知，相关服务监听到通知后修改缓存数据</p><p>•优势：低耦合，可以同时通知多个缓存服务</p><p>•缺点：时效性一般，可能存在中间不一致状态</p><p>•场景：时效性要求一般，有多个服务需要同步</p><p><img src="https://img-blog.csdnimg.cn/bda8a839d8e3410aac0f850fcb0e4217.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2a9abda92ecf43fbbe6d8bf07a0feedb.png" alt="img"></p><h1 id="二-安装和配置canal"><a class="markdownIt-Anchor" href="#二-安装和配置canal"></a> 二、安装和配置Canal</h1><p><img src="https://img-blog.csdnimg.cn/e5131fff2fce4439be9a99a20f4dc213.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/25de1e7f4dc44d5db4105d32df986638.png" alt="img"></p><p>下面我们就开启mysql的主从同步机制，让Canal来模拟salve</p><h1 id="1开启mysql主从"><a class="markdownIt-Anchor" href="#1开启mysql主从"></a> 1.开启MySQL主从</h1><p>Canal是基于MySQL的主从同步功能，因此必须先开启MySQL的主从功能才可以。</p><p>这里以之前用Docker运行的mysql为例：</p><h2 id="11开启binlog"><a class="markdownIt-Anchor" href="#11开启binlog"></a> 1.1.开启binlog</h2><p>打开mysql容器挂载的日志文件，我的在<code>/tmp/mysql/conf</code>目录:</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7I8WMYyf-1662205186188)(assets/image-20210813153241537.png)]</p><p>修改文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /tmp/mysql/conf/my.cnf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>添加内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">binlog-do-db=heima</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>配置解读：</p><ul><li><code>log-bin=/var/lib/mysql/mysql-bin</code>：设置binary log文件的存放地址和文件名，叫做mysql-bin</li><li><code>binlog-do-db=heima</code>：指定对哪个database记录binary log events，这里记录heima这个库</li></ul><p>最终效果：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">skip-name-resolve</span><br><span class="line">character_set_server=utf8</span><br><span class="line">datadir=/var/lib/mysql</span><br><span class="line">server-id=1000</span><br><span class="line">log-bin=/var/lib/mysql/mysql-bin</span><br><span class="line">binlog-do-db=heima</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="12设置用户权限"><a class="markdownIt-Anchor" href="#12设置用户权限"></a> 1.2.设置用户权限</h2><p>接下来添加一个仅用于数据同步的账户，出于安全考虑，这里仅提供对heima这个库的操作权限。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user canal@'%' IDENTIFIED by 'canal';</span><br><span class="line">GRANT SELECT, REPLICATION SLAVE, REPLICATION CLIENT,SUPER ON *.* TO 'canal'@'%' identified by 'canal';</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>重启mysql容器即可</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart mysql</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>测试设置是否成功：在mysql控制台，或者Navicat中，输入命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show master status;</span><br></pre></td></tr></tbody></table></figure><h1 id="2安装canal"><a class="markdownIt-Anchor" href="#2安装canal"></a> 2.安装Canal</h1><h2 id="21创建网络"><a class="markdownIt-Anchor" href="#21创建网络"></a> 2.1.创建网络</h2><p>我们需要创建一个网络，将MySQL、Canal、MQ放到同一个Docker网络中：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create heima</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>让mysql加入这个网络：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network connect heima mysql</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="23安装canal"><a class="markdownIt-Anchor" href="#23安装canal"></a> 2.3.安装Canal</h2><p>课前资料中提供了canal的镜像压缩包:</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-FvuASqcG-1662205186198)(assets/image-20210813161804292.png)]</p><p>大家可以上传到虚拟机，然后通过命令导入：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker load -i canal.tar</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后运行命令创建Canal容器：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 11111:11111 --name canal \</span><br><span class="line">-e canal.destinations=heima \</span><br><span class="line">-e canal.instance.master.address=mysql:3306  \</span><br><span class="line">-e canal.instance.dbUsername=canal  \</span><br><span class="line">-e canal.instance.dbPassword=canal  \</span><br><span class="line">-e canal.instance.connectionCharset=UTF-8 \</span><br><span class="line">-e canal.instance.tsdb.enable=true \</span><br><span class="line">-e canal.instance.gtidon=false  \</span><br><span class="line">-e canal.instance.filter.regex=heima\\..* \</span><br><span class="line">--network heima \</span><br><span class="line">-d canal/canal-server:v1.1.5</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>说明:</p><ul><li><code>-p 11111:11111</code>：这是canal的默认监听端口</li><li><code>-e canal.instance.master.address=mysql:3306</code>：数据库地址和端口，如果不知道mysql容器地址，可以通过<code>docker inspect 容器id</code>来查看</li><li><code>-e canal.instance.dbUsername=canal</code>：数据库用户名</li><li><code>-e canal.instance.dbPassword=canal</code> ：数据库密码</li><li><code>-e canal.instance.filter.regex=</code>：要监听的表名称</li></ul><p>表名称监听支持的语法：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql 数据解析关注的表，Perl正则表达式.</span><br><span class="line">多个正则之间以逗号(,)分隔，转义符需要双斜杠(\\) </span><br><span class="line">常见例子：</span><br><span class="line">1.  所有表：.*   or  .*\\..*</span><br><span class="line">2.  canal schema下所有表： canal\\..*</span><br><span class="line">3.  canal下的以canal打头的表：canal\\.canal.*</span><br><span class="line">4.  canal schema下的一张表：canal.test1</span><br><span class="line">5.  多个规则组合使用然后以逗号隔开：canal\\..*,mysql.test1,mysql.test2 </span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="三-监听canal"><a class="markdownIt-Anchor" href="#三-监听canal"></a> 三、监听Canal</h1><p><img src="https://img-blog.csdnimg.cn/4f4e40a3a2e4469ca7836693c3db991d.png" alt="img"></p><p>Canal提供了各种语言的客户端，当Canal监听到binlog变化时，会通知Canal的客户端。不过这里我们会使用GitHub上的第三方开源的canal-starter。地址：<a href="https://github.com/NormanGyllenhaal/canal-client">GitHub - NormanGyllenhaal/canal-client: spring boot canal starter 易用的canal 客户端 canal client</a></p><p><img src="https://img-blog.csdnimg.cn/b1b64382430e47e5b2be08b569e2cefa.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/1869924653994a95a7660b76b7823fa7.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/8f6d29940fc84098a92e02339632ff66.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（多级缓存）多级缓存</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<blockquote><h1 id="对应的教程视频-高级篇day4-03-多级缓存_哔哩哔哩_bilibili"><a class="markdownIt-Anchor" href="#对应的教程视频-高级篇day4-03-多级缓存_哔哩哔哩_bilibili"></a> 对应的教程视频：  <a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=156&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day4-03-多级缓存_哔哩哔哩_bilibili</a></h1></blockquote><h1 id="一-安装openresty"><a class="markdownIt-Anchor" href="#一-安装openresty"></a> 一、安装OpenResty</h1><p>OpenResty® 是一个基于 Nginx的高性能 Web 平台，用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。具备下列特点：</p><p>•具备Nginx的完整功能</p><p>•基于Lua语言进行扩展，集成了大量精良的 Lua 库、第三方模块</p><p>•允许使用Lua自定义业务逻辑、自定义库</p><p>官方网站： <a href="https://openresty.org/cn/">OpenResty® - 中文官方站</a></p><p><img src="https://img-blog.csdnimg.cn/f9416bd0de8341369c0b577d3df4b841.png" alt="img"></p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126669241?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126669241%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(74条消息) 安装OpenResty_其然乐衣的博客-CSDN博客</a></p></blockquote><p>二、OpenResty快速入门</p><p><img src="https://img-blog.csdnimg.cn/1177aa67f71b4cb681a56b665ee70f38.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/6d1a045a3e5244919257fec0d8c9d379.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2adaa7fe0fc7467db3348e60c5274671.png" alt="img"></p><p>三、请求参数处理</p><p><img src="https://img-blog.csdnimg.cn/34ffb6ee962644a4ac3c71dee0165970.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c204b371b5904ab4bc7bfee4232a859a.png" alt="img"></p><p>四、查询Tomcat</p><p><img src="https://img-blog.csdnimg.cn/9b8419f000b945048c5b528b1931a899.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/238474e6212f4a29a48245a579718bf6.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/444f4c49f7bf42319b3f6c24b8554ceb.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2a2ed265a3774d5581b4a7a957d64151.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/a53b27c055cf4e8fa3b156b7f0fa8547.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9c6cfac399744d52b367861934a0a62e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/7d853f9f2b124bdb849f1829c94c5f34.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/6c84d9c5a634422894f205f2ccc03480.png" alt="img"></p><p>五、Redis缓存预热</p><p><img src="https://img-blog.csdnimg.cn/8f5fd7be4ed54c3f8f086bbe0bba17ca.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b511678b54b541e1a75184e7ef236faa.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ea58bc28593c4103994a8b585eaad613.png" alt="img"></p><p>六、查询Redis缓存</p><p><img src="https://img-blog.csdnimg.cn/1ecd62b73616428b89912bbe9cf51e37.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/dec61d13f74542cab29209d0391c786e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/2b864644e92445c78c389d88989abb01.png" alt="img"></p><p>七、Nginx本地缓存</p><p><img src="https://img-blog.csdnimg.cn/6f672ee617a44863858ce5c6f2e82077.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/19fd546b225d4f89bf8a75f1f26f0263.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/1f24570d8c124c0ea3aa6bd0449580ec.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/43069c308a474c639503022aae4f2122.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装OpenResty</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%AE%89%E8%A3%85OpenResty/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%AE%89%E8%A3%85OpenResty/</url>
      
        <content type="html"><![CDATA[<h1 id="安装openresty"><a class="markdownIt-Anchor" href="#安装openresty"></a> 安装OpenResty</h1><h1 id="1安装"><a class="markdownIt-Anchor" href="#1安装"></a> 1.安装</h1><p>首先你的Linux虚拟机必须联网</p><h2 id="1安装开发库"><a class="markdownIt-Anchor" href="#1安装开发库"></a> <strong>1）安装开发库</strong></h2><p>首先要安装OpenResty的依赖开发库，执行命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre-devel openssl-devel gcc --skip-broken</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="2安装openresty仓库"><a class="markdownIt-Anchor" href="#2安装openresty仓库"></a> <strong>2）安装OpenResty仓库</strong></h2><p>你可以在你的 CentOS 系统中添加 <code>openresty</code> 仓库，这样就可以便于未来安装或更新我们的软件包（通过 <code>yum check-update</code> 命令）。运行下面的命令就可以添加我们的仓库：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum-config-manager --add-repo https://openresty.org/package/centos/openresty.repo</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果提示说命令不存在，则运行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils </span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后再重复上面的命令</p><h2 id="3安装openresty"><a class="markdownIt-Anchor" href="#3安装openresty"></a> <strong>3）安装OpenResty</strong></h2><p>然后就可以像下面这样安装软件包，比如 <code>openresty</code>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4安装opm工具"><a class="markdownIt-Anchor" href="#4安装opm工具"></a> <strong>4）安装opm工具</strong></h2><p>opm是OpenResty的一个管理工具，可以帮助我们安装一个第三方的Lua模块。</p><p>如果你想安装命令行工具 <code>opm</code>，那么可以像下面这样安装 <code>openresty-opm</code> 包：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openresty-opm</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5目录结构"><a class="markdownIt-Anchor" href="#5目录结构"></a> <strong>5）目录结构</strong></h2><p>默认情况下，OpenResty安装的目录是：/usr/local/openresty</p><p><img src="https://img-blog.csdnimg.cn/40823c6fcead429c8f59070c7a9ed20f.png" alt="在这里插入图片描述"></p><p>看到里面的nginx目录了吗，OpenResty就是在Nginx基础上集成了一些Lua模块。</p><h2 id="6配置nginx的环境变量"><a class="markdownIt-Anchor" href="#6配置nginx的环境变量"></a> <strong>6）配置nginx的环境变量</strong></h2><p>打开配置文件：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在最下面加入两行：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export NGINX_HOME=/usr/local/openresty/nginx</span><br><span class="line">export PATH=${NGINX_HOME}/sbin:$PATH</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>NGINX_HOME：后面是OpenResty安装目录下的nginx的目录</p><p>然后让配置生效：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="2启动和运行"><a class="markdownIt-Anchor" href="#2启动和运行"></a> 2.启动和运行</h1><p>OpenResty底层是基于Nginx的，查看OpenResty目录的nginx目录，结构与windows中安装的nginx基本一致：<br><img src="https://img-blog.csdnimg.cn/7469d035c7044b60b9ca2306cea81596.png" alt="在这里插入图片描述"></p><p>所以运行方式与nginx基本一致：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 启动nginx</span><br><span class="line">nginx</span><br><span class="line"># 重新加载配置</span><br><span class="line">nginx -s reload</span><br><span class="line"># 停止</span><br><span class="line">nginx -s stop</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>nginx的默认配置文件注释太多，影响后续我们的编辑，这里将nginx.conf中的注释部分删除，保留有效部分。</p><p>修改<code>/usr/local/openresty/nginx/conf/nginx.conf</code>文件，内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#user  nobody;</span><br><span class="line">worker_processes  1;</span><br><span class="line">error_log  logs/error.log;</span><br><span class="line"></span><br><span class="line">events {</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">http {</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line"></span><br><span class="line">    server {</span><br><span class="line">        listen       8081;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / {</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        }</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html {</span><br><span class="line">            root   html;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在Linux的控制台输入命令以启动nginx：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nginx</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后访问页面：<a href="http://192.168.150.101:8081">http://192.168.150.101:8081</a>，注意ip地址替换为你自己的虚拟机IP：</p><h1 id="3备注"><a class="markdownIt-Anchor" href="#3备注"></a> 3.备注</h1><p>加载OpenResty的lua模块：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#lua 模块</span><br><span class="line">lua_package_path "/usr/local/openresty/lualib/?.lua;;";</span><br><span class="line">#c模块     </span><br><span class="line">lua_package_cpath "/usr/local/openresty/lualib/?.so;;";  </span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>common.lua</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-- 封装函数，发送http请求，并解析响应</span><br><span class="line">local function read_http(path, params)</span><br><span class="line">    local resp = ngx.location.capture(path,{</span><br><span class="line">        method = ngx.HTTP_GET,</span><br><span class="line">        args = params,</span><br><span class="line">    })</span><br><span class="line">    if not resp then</span><br><span class="line">        -- 记录错误信息，返回404</span><br><span class="line">        ngx.log(ngx.ERR, "http not found, path: ", path , ", args: ", args)</span><br><span class="line">        ngx.exit(404)</span><br><span class="line">    end</span><br><span class="line">    return resp.body</span><br><span class="line">end</span><br><span class="line">-- 将方法导出</span><br><span class="line">local _M = {  </span><br><span class="line">    read_http = read_http</span><br><span class="line">}  </span><br><span class="line">return _M</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>释放Redis连接API：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-- 关闭redis连接的工具方法，其实是放入连接池</span><br><span class="line">local function close_redis(red)</span><br><span class="line">    local pool_max_idle_time = 10000 -- 连接的空闲时间，单位是毫秒</span><br><span class="line">    local pool_size = 100 --连接池大小</span><br><span class="line">    local ok, err = red:set_keepalive(pool_max_idle_time, pool_size)</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.log(ngx.ERR, "放入redis连接池失败: ", err)</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>读取Redis数据的API：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 查询redis的方法 ip和port是redis地址，key是查询的key</span><br><span class="line">local function read_redis(ip, port, key)</span><br><span class="line">    -- 获取一个连接</span><br><span class="line">    local ok, err = red:connect(ip, port)</span><br><span class="line">    if not ok then</span><br><span class="line">        ngx.log(ngx.ERR, "连接redis失败 : ", err)</span><br><span class="line">        return nil</span><br><span class="line">    end</span><br><span class="line">    -- 查询redis</span><br><span class="line">    local resp, err = red:get(key)</span><br><span class="line">    -- 查询失败处理</span><br><span class="line">    if not resp then</span><br><span class="line">        ngx.log(ngx.ERR, "查询Redis失败: ", err, ", key = " , key)</span><br><span class="line">    end</span><br><span class="line">    --得到的数据为空处理</span><br><span class="line">    if resp == ngx.null then</span><br><span class="line">        resp = nil</span><br><span class="line">        ngx.log(ngx.ERR, "查询Redis数据为空, key = ", key)</span><br><span class="line">    end</span><br><span class="line">    close_redis(red)</span><br><span class="line">    return resp</span><br><span class="line">end</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>开启共享词典：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 共享字典，也就是本地缓存，名称叫做：item_cache，大小150m</span><br><span class="line">lua_shared_dict item_cache 150m; </span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（多级缓存）Lua语法入门</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89Lua%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89Lua%E8%AF%AD%E6%B3%95%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=155&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day4-02-Lua语法_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1-初识lua"><a class="markdownIt-Anchor" href="#1-初识lua"></a> 1、初识Lua</h1><h3 id="lua-是一种轻量小巧的脚本语言用标准c语言编写并以源代码形式开放-其设计目的是为了嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能-官网the-programming-language-lua"><a class="markdownIt-Anchor" href="#lua-是一种轻量小巧的脚本语言用标准c语言编写并以源代码形式开放-其设计目的是为了嵌入应用程序中从而为应用程序提供灵活的扩展和定制功能-官网the-programming-language-lua"></a> <strong>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。官网：*<em><a href="https://www.lua.org/">The Programming Language Lua</a>*</em></strong></h3><p><img src="https://img-blog.csdnimg.cn/5e7cb6070b6e4341b1e6c428398130cd.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ecc800b20d8840b7af73bceda62655ac.png" alt="img"></p><h1 id="2-变量和循环"><a class="markdownIt-Anchor" href="#2-变量和循环"></a> 2、变量和循环</h1><p><img src="https://img-blog.csdnimg.cn/a2ab6fa43ad341a9b59b1777b5a11695.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/3a4448e4766d46d3b5f859e7fc0065b9.jpeg" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e2442f0938cb4c638efa043ac2a24169.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/76bfeb726de4434980c94e5bede5327c.jpeg" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/68d14568d9dc4ec384fa5499f073ce48.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/a2ac6877cdb0496a88610d9127bcc7aa.jpeg" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/cdcc9691729e40d49a7cb69c24dc9389.jpeg" alt="img"></p><h1 id="3-条件控制-函数"><a class="markdownIt-Anchor" href="#3-条件控制-函数"></a> 3、条件控制、函数</h1><p><strong>3.1.函数</strong></p><p><img src="https://img-blog.csdnimg.cn/1e70b07d746a4cb5ad168f4aead7be78.png" alt="img"></p><p>定义一个函数，如 :<img src="https://img-blog.csdnimg.cn/132d1aac109545e9804533f29c3aa89e.png" alt="img"></p><p>定义好函数后，就可以调用了，如：<img src="https://img-blog.csdnimg.cn/dc221991f67546308bbec91952bb58f0.png" alt="img"></p><p><strong>3.2.条件控制</strong></p><p><img src="https://img-blog.csdnimg.cn/d2a24292a1ac49c9840f1ecc0d34c1d1.png" alt="img"></p><p><strong>3.3.案例</strong></p><p><img src="https://img-blog.csdnimg.cn/3f88ecc1627f4c979ecd23800503b285.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/61b92797ee994c55869771b00b676eac.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（多级缓存）JVM进程缓存</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%89JVM%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频 ：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=154&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day4-01-多级缓存意义及JVM进程缓存_哔哩哔哩_bilibili</a></p></blockquote><h1 id="1初识caffeineimg"><a class="markdownIt-Anchor" href="#1初识caffeineimg"></a> 1.初识Caffeine<img src="https://img-blog.csdnimg.cn/97fc0d8a62a24516ae8465c345947821.png" alt="img"></h1><p>Caffeine是一个基于Java8开发的，提供了近乎最佳命中率的高性能的本地缓存库。目前Spring内部的缓存使用的就是Caffeine。GitHub地址：<a href="https://github.com/ben-manes/caffeine">GitHub - ben-manes/caffeine: A high performance caching library for Java</a></p><p><img src="https://img-blog.csdnimg.cn/8ca1bb60f7834609b3c35e0d2b25a88c.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/cb86859c9d00473a87f2d5c71e2ce5c3.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/648576613bd749d2862362aeb02c10a3.png" alt="img"></p><h1 id="2实现进程缓存"><a class="markdownIt-Anchor" href="#2实现进程缓存"></a> 2.实现进程缓存</h1><p><img src="https://img-blog.csdnimg.cn/f922d46b6fb7423cb6a08b1adc6c63a4.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/94a0a2d0715d4cdd92e6c96ede34901e.png" alt="img"></p><p>定义好缓存：</p><p><img src="https://img-blog.csdnimg.cn/a54253303948433f8e225e1df20b0933.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/0370e1da16314f0db27924f579e6f991.png" alt="img"></p><p>修改查询业务（实现 优先查缓存，不中标再查数据库）</p><p><img src="https://img-blog.csdnimg.cn/b0e5f85f12524027893ded107c0d2850.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/28c7922e4a43430483acecde229ef06a.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级缓存 （亿级流量的缓存方案）</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%20%EF%BC%88%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%9A%84%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%EF%BC%89/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%20%EF%BC%88%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%9A%84%E7%BC%93%E5%AD%98%E6%96%B9%E6%A1%88%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/238fc4c7fdeb4ebfb2311a793102d10b.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/fdc04f7711214c149e0d042b6838a8f9.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ccd59cfc2d0b4d22bbeead792258ac8f.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/a434cc59226d4cedbe29c97956653ddd.png" alt="img"></p><h2 id="1-jvm进程缓存"><a class="markdownIt-Anchor" href="#1-jvm进程缓存"></a> 1、JVM进程缓存</h2><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126665519?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126665519%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(73条消息) （多级缓存）JVM进程缓存_其然乐衣的博客-CSDN博客</a></p></blockquote><h2 id="2-lua语法入门"><a class="markdownIt-Anchor" href="#2-lua语法入门"></a> 2、Lua语法入门</h2><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126666384?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126666384%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(74条消息) （多级缓存）Lua语法入门_其然乐衣的博客-CSDN博客</a></p></blockquote><h2 id="3-多级缓存"><a class="markdownIt-Anchor" href="#3-多级缓存"></a> 3、多级缓存</h2><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126669262?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126669262%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(75条消息) （多级缓存）多级缓存_其然乐衣的博客-CSDN博客</a></p></blockquote><h2 id="4-缓存同步策略"><a class="markdownIt-Anchor" href="#4-缓存同步策略"></a> 4、缓存同步策略</h2><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126681566?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126681566%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(75条消息) （多级缓存）缓存同步_其然乐衣的博客-CSDN博客</a></p></blockquote><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h1><p><img src="https://img-blog.csdnimg.cn/a8894e7f55f64bc5933762875d23a252.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
          <category> 多级缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(分布式缓存)Redis分片集群</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/(%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98)Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/(%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98)Redis%E5%88%86%E7%89%87%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频:</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=153&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day3-04-Redis分片集群_哔哩哔哩_bilibili</a></p></blockquote><h1 id="一搭建分片集群"><a class="markdownIt-Anchor" href="#一搭建分片集群"></a> <strong>一.搭建分片集群</strong></h1><h2 id="1集群结构"><a class="markdownIt-Anchor" href="#1集群结构"></a> 1.集群结构</h2><p>分片集群需要的节点数量较多，这里我们搭建一个最小的分片集群，包含3个master节点，每个master包含一个slave节点，结构如下：</p><p><img src="https://img-blog.csdnimg.cn/40dc06a7246f4a4bb906d2a1a89880af.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-If9nMNjR-1662083428136)(assets/image-20210702164116027.png)]"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里我们会在同一台虚拟机中开启6个redis实例，模拟分片集群，信息如下：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>192.168.150.101</td><td>7001</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7002</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7003</td><td>master</td></tr><tr><td>192.168.150.101</td><td>8001</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>8002</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>8003</td><td>slave</td></tr></tbody></table><h2 id="2准备实例和配置"><a class="markdownIt-Anchor" href="#2准备实例和配置"></a> 2.准备实例和配置</h2><p>删除之前的7001、7002、7003这几个目录，重新创建出7001、7002、7003、8001、8002、8003目录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 删除旧的，避免配置干扰</span><br><span class="line">rm -rf 7001 7002 7003</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir 7001 7002 7003 8001 8002 8003</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在/tmp下准备一个新的redis.conf文件，内容如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">port 6379</span><br><span class="line"># 开启集群功能</span><br><span class="line">cluster-enabled yes</span><br><span class="line"># 集群的配置文件名称，不需要我们创建，由redis自己维护</span><br><span class="line">cluster-config-file /tmp/6379/nodes.conf</span><br><span class="line"># 节点心跳失败的超时时间</span><br><span class="line">cluster-node-timeout 5000</span><br><span class="line"># 持久化文件存放目录</span><br><span class="line">dir /tmp/6379</span><br><span class="line"># 绑定地址</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 让redis后台运行</span><br><span class="line">daemonize yes</span><br><span class="line"># 注册的实例ip</span><br><span class="line">replica-announce-ip 192.168.150.101</span><br><span class="line"># 保护模式</span><br><span class="line">protected-mode no</span><br><span class="line"># 数据库数量</span><br><span class="line">databases 1</span><br><span class="line"># 日志</span><br><span class="line">logfile /tmp/6379/run.log</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>将这个文件拷贝到每个目录下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 执行拷贝</span><br><span class="line">echo 7001 7002 7003 8001 8002 8003 | xargs -t -n 1 cp redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>修改每个目录下的redis.conf，将其中的6379修改为与所在目录一致：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 修改配置文件</span><br><span class="line">printf '%s\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t sed -i 's/6379/{}/g' {}/redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3启动"><a class="markdownIt-Anchor" href="#3启动"></a> 3.启动</h2><p>因为已经配置了后台启动模式，所以可以直接启动服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 一键启动所有服务</span><br><span class="line">printf '%s\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-server {}/redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>通过ps查看状态：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>发现服务都已经正常启动：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-ZSycAyBD-1662083428139)(assets/image-20210702174255799.png)]</p><p>如果要关闭所有进程，可以执行命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis | awk '{print $2}' | xargs kill</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>或者（推荐这种方式）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%s\n' 7001 7002 7003 8001 8002 8003 | xargs -I{} -t redis-cli -p {} shutdown</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4创建集群"><a class="markdownIt-Anchor" href="#4创建集群"></a> 4.创建集群</h2><p>虽然服务启动了，但是目前每个服务之间都是独立的，没有任何关联。</p><p>我们需要执行命令来创建集群，在Redis5.0之前创建集群比较麻烦，5.0之后集群管理命令都集成到了redis-cli中。</p><p>1）Redis5.0之前</p><p>Redis5.0之前集群命令都是用redis安装包下的src/redis-trib.rb来实现的。因为redis-trib.rb是有ruby语言编写的所以需要安装ruby环境。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 安装依赖</span><br><span class="line">yum -y install zlib ruby rubygems</span><br><span class="line">gem install redis</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后通过命令来管理集群：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入redis的src目录</span><br><span class="line">cd /tmp/redis-6.2.4/src</span><br><span class="line"># 创建集群</span><br><span class="line">./redis-trib.rb create --replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2）Redis5.0以后</p><p>我们使用的是Redis6.2.4版本，集群管理以及集成到了redis-cli中，格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create --cluster-replicas 1 192.168.150.101:7001 192.168.150.101:7002 192.168.150.101:7003 192.168.150.101:8001 192.168.150.101:8002 192.168.150.101:8003</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>命令说明：</p><ul><li><code>redis-cli --cluster</code>或者<code>./redis-trib.rb</code>：代表集群操作命令</li><li><code>create</code>：代表是创建集群</li><li><code>--replicas 1</code>或者<code>--cluster-replicas 1</code> ：指定集群中每个master的副本个数为1，此时<code>节点总数 ÷ (replicas + 1)</code> 得到的就是master的数量。因此节点列表中的前n个就是master，其它节点都是slave节点，随机分配到不同master</li></ul><p>运行后的样子：</p><p><img src="https://img-blog.csdnimg.cn/3996838a0a8d4aafa2ea27d77698a752.png" alt="在这里插入图片描述"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这里输入yes，则集群开始创建：</p><p><img src="https://img-blog.csdnimg.cn/0cafdb419d7f4d9bbf88cb1c8b6c9932.png" alt="在这里插入图片描述"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>通过命令可以查看集群状态：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p 7001 cluster nodes</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/f148a5f1708d4df3abd3e1653c5b0720.png" alt="在这里插入图片描述"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5测试"><a class="markdownIt-Anchor" href="#5测试"></a> 5.测试</h2><p>尝试连接7001节点，存储一个数据：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 连接</span><br><span class="line">redis-cli -p 7001</span><br><span class="line"># 存储数据</span><br><span class="line">set num 123</span><br><span class="line"># 读取数据</span><br><span class="line">get num</span><br><span class="line"># 再次存储</span><br><span class="line">set a 1</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>结果悲剧了</p><p>集群操作时，需要给<code>redis-cli</code>加上**<code>-c</code>**参数才可以：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 7001</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/a5aa8344a1794085a9e75c0ac4c48606.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>这次可以了</p><h1 id="二散列插槽"><a class="markdownIt-Anchor" href="#二散列插槽"></a> 二.散列插槽</h1><p><img src="https://img-blog.csdnimg.cn/d503adec7799441393c540a612fdbef5.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> <strong>总结:</strong></h2><p>Redis如何判断某个key应该在哪个实例？</p><p>•将16384个插槽分配到不同的实例</p><p>•根据 key 的有效部分计算哈希值，对16384取余</p><p>•余数作为插槽，寻找插槽所在实例即可</p><p>如何将同一类数据固定的保存在同一个Redis实例？</p><p>•这一类数据使用相同的有效部分，例如key都以{typeId}为前缀. 如:</p><p><img src="https://img-blog.csdnimg.cn/738e30bb8e714accbef06e39f2bf613a.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><h1 id="三集群伸缩"><a class="markdownIt-Anchor" href="#三集群伸缩"></a> 三.集群伸缩</h1><p><img src="https://img-blog.csdnimg.cn/8f145bf6f2a6461f867b2c8315cba342.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/df3fb8a272a4440b932f010e61538637.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/332c72d8d02346628cafc7371fab76f7.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="四故障转移"><a class="markdownIt-Anchor" href="#四故障转移"></a> 四.故障转移</h1><p><img src="https://img-blog.csdnimg.cn/bd0e6e29a53443da94cafe455398d9bd.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/4e7f4e57eaac4a6e81d9aab993567722.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/7556d8dd6e6e4d66a3b239b2919e4430.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="五redistemplate访问分片集群"><a class="markdownIt-Anchor" href="#五redistemplate访问分片集群"></a> 五.RedisTemplate访问分片集群</h1><p><img src="https://img-blog.csdnimg.cn/eca3551a35d94234913ee0f3d59fce93.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>上面的第1和第3步和哨兵模式的1和3是一样的,主要差别是第2步</strong><img src="https://img-blog.csdnimg.cn/a77acca140d34f6b85e4aa3d10dde209.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（分布式缓存）Redis哨兵</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E5%93%A8%E5%85%B5/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E5%93%A8%E5%85%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=152&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day3-03-Redis哨兵_哔哩哔哩_bilibili</a></p></blockquote><h1 id="目录"><a class="markdownIt-Anchor" href="#目录"></a> 目录：</h1><ul><li>哨兵的作用和原理</li><li>搭建哨兵集群</li><li>RedisTemplate的哨兵模式</li></ul><h1 id="一-哨兵的作用和原理"><a class="markdownIt-Anchor" href="#一-哨兵的作用和原理"></a> 一、哨兵的作用和原理</h1><p><img src="https://img-blog.csdnimg.cn/2b52c12b7a1b4d368a2b605873b82930.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/d06a5ac4f10e4b1496d454ebc1f57250.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b76d7ce8f8314194a996d3d6f680cc6e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b42e0e3f92ad46efb231bcb628532d55.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/adbee544452f4d6badc1b7790bb4b2ae.png" alt="img"></p><h1 id="二-搭建哨兵集群"><a class="markdownIt-Anchor" href="#二-搭建哨兵集群"></a> 二、搭建哨兵集群</h1><h2 id="1集群结构"><a class="markdownIt-Anchor" href="#1集群结构"></a> 1.集群结构</h2><p>这里我们搭建一个三节点形成的Sentinel集群，来监管之前的Redis主从集群。如图：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MOzScJfs-1662037549415)(assets/image-20210701215227018.png)]</p><p>三个sentinel实例信息如下：</p><table><thead><tr><th>节点</th><th>IP</th><th>PORT</th></tr></thead><tbody><tr><td>s1</td><td>192.168.150.101</td><td>27001</td></tr><tr><td>s2</td><td>192.168.150.101</td><td>27002</td></tr><tr><td>s3</td><td>192.168.150.101</td><td>27003</td></tr></tbody></table><h2 id="2准备实例和配置"><a class="markdownIt-Anchor" href="#2准备实例和配置"></a> 2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>我们创建三个文件夹，名字分别叫s1、s2、s3：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir s1 s2 s3</span><br></pre></td></tr></tbody></table></figure><p>如图：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-smeM4g2V-1662037549418)(assets/image-20210701215534714.png)]</p><p>然后我们在s1目录创建一个sentinel.conf文件，添加下面的内容：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 27001</span><br><span class="line">sentinel announce-ip 192.168.150.101</span><br><span class="line">sentinel monitor mymaster 192.168.150.101 7001 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 5000</span><br><span class="line">sentinel failover-timeout mymaster 60000</span><br><span class="line">dir "/tmp/s1"</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>解读：</p><ul><li><p><code>port 27001</code>：是当前sentinel实例的端口</p></li><li><pre class="highlight"><code class="">sentinel monitor mymaster 192.168.150.101 7001 2<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：指定主节点信息 </span><br><span class="line"></span><br><span class="line">  - `mymaster`：主节点名称，自定义，任意写</span><br><span class="line">  - `192.168.150.101 7001`：主节点的ip和端口</span><br><span class="line">  - `2`：选举master时的quorum值</span><br><span class="line"></span><br><span class="line">然后将s1/sentinel.conf文件拷贝到s2、s3两个目录中（在/tmp目录执行下列命令）：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul><h1 id="方式一逐个拷贝"><a class="markdownIt-Anchor" href="#方式一逐个拷贝"></a> 方式一：逐个拷贝</h1><p>cp s1/sentinel.conf s2<br>cp s1/sentinel.conf s3</p><h1 id="方式二管道组合命令一键拷贝"><a class="markdownIt-Anchor" href="#方式二管道组合命令一键拷贝"></a> 方式二：管道组合命令，一键拷贝</h1><p>echo s2 s3 | xargs -t -n 1 cp s1/sentinel.conf</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)</span><br><span class="line"></span><br><span class="line">修改s2、s3两个文件夹内的配置文件，将端口分别修改为27002、27003：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>sed -i -e ‘s/27001/27002/g’ -e ‘s/s1/s2/g’ s2/sentinel.conf<br>sed -i -e ‘s/27001/27003/g’ -e ‘s/s1/s3/g’ s3/sentinel.conf</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)</span><br><span class="line"></span><br><span class="line">## 3.启动</span><br><span class="line"></span><br><span class="line">为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h1 id="第1个"><a class="markdownIt-Anchor" href="#第1个"></a> 第1个</h1><p>redis-sentinel s1/sentinel.conf</p><h1 id="第2个"><a class="markdownIt-Anchor" href="#第2个"></a> 第2个</h1><p>redis-sentinel s2/sentinel.conf</p><h1 id="第3个"><a class="markdownIt-Anchor" href="#第3个"></a> 第3个</h1><p>redis-sentinel s3/sentinel.conf</p><pre class="highlight"><code class="">![点击并拖拽以移动](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==)启动后：## 4.测试尝试让master节点7001宕机，查看sentinel日志：查看7003的日志：查看7002的日志：# 三、RedisTemplate的哨兵模式在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。首先，我们引入课前资料提供的Demo工程：![img](https://img-blog.csdnimg.cn/9560625acea141d798bfcb128ea95031.png) ![img](https://img-blog.csdnimg.cn/44d017488b6b4ef094613c07de195732.png)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（分布式缓存）Redis主从</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E4%B8%BB%E4%BB%8E/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E4%B8%BB%E4%BB%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的视频教程"><a class="markdownIt-Anchor" href="#对应的视频教程"></a> 对应的视频教程</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=151&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day3-02-Redis主从_哔哩哔哩_bilibili</a></p></blockquote><h1 id="一-搭建redis主从集群"><a class="markdownIt-Anchor" href="#一-搭建redis主从集群"></a> 一、搭建Redis主从集群</h1><h2 id="1集群结构"><a class="markdownIt-Anchor" href="#1集群结构"></a> 1.集群结构</h2><p>我们搭建的主从集群结构如图：</p><p><img src="https://img-blog.csdnimg.cn/760dffe18def4d9dbb5499bcc3cc2a4f.png" alt="img"></p><p>共包含三个节点，一个主节点，两个从节点。</p><p>这里我们会在同一台虚拟机中开启3个redis实例，模拟主从集群，信息如下：</p><table><thead><tr><th>IP</th><th>PORT</th><th>角色</th></tr></thead><tbody><tr><td>192.168.150.101</td><td>7001</td><td>master</td></tr><tr><td>192.168.150.101</td><td>7002</td><td>slave</td></tr><tr><td>192.168.150.101</td><td>7003</td><td>slave</td></tr></tbody></table><h2 id="2准备实例和配置"><a class="markdownIt-Anchor" href="#2准备实例和配置"></a> 2.准备实例和配置</h2><p>要在同一台虚拟机开启3个实例，必须准备三份不同的配置文件和目录，配置文件所在目录也就是工作目录。</p><p>1）创建目录</p><p>我们创建三个文件夹，名字分别叫7001、7002、7003：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 进入/tmp目录</span><br><span class="line">cd /tmp</span><br><span class="line"># 创建目录</span><br><span class="line">mkdir 7001 7002 7003</span><br></pre></td></tr></tbody></table></figure><p>如图：</p><p><img src="https://img-blog.csdnimg.cn/4cf724d39ef5484a9eab3d9b064fe44f.png" alt="img"></p><p>2）恢复原始配置</p><p>修改redis-6.2.4/redis.conf文件，将其中的持久化模式改为默认的RDB模式，AOF保持关闭状态。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 开启RDB</span><br><span class="line"># save ""</span><br><span class="line">save 3600 1</span><br><span class="line">save 300 100</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"># 关闭AOF</span><br><span class="line">appendonly no</span><br></pre></td></tr></tbody></table></figure><p>3）拷贝配置文件到每个实例目录</p><p>然后将redis-6.2.4/redis.conf文件拷贝到三个目录中（在/tmp目录执行下列命令）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：逐个拷贝</span><br><span class="line">cp redis-6.2.4/redis.conf 7001</span><br><span class="line">cp redis-6.2.4/redis.conf 7002</span><br><span class="line">cp redis-6.2.4/redis.conf 7003</span><br><span class="line"># 方式二：管道组合命令，一键拷贝</span><br><span class="line">echo 7001 7002 7003 | xargs -t -n 1 cp redis-6.2.4/redis.conf</span><br></pre></td></tr></tbody></table></figure><p>4）修改每个实例的端口、工作目录</p><p>修改每个文件夹内的配置文件，将端口分别修改为7001、7002、7003，将rdb文件保存位置都修改为自己所在目录（在/tmp目录执行下列命令）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sed -i -e 's/6379/7001/g' -e 's/dir .\//dir \/tmp\/7001\//g' 7001/redis.conf</span><br><span class="line">sed -i -e 's/6379/7002/g' -e 's/dir .\//dir \/tmp\/7002\//g' 7002/redis.conf</span><br><span class="line">sed -i -e 's/6379/7003/g' -e 's/dir .\//dir \/tmp\/7003\//g' 7003/redis.conf</span><br></pre></td></tr></tbody></table></figure><p>5）修改每个实例的声明IP</p><p>虚拟机本身有多个IP，为了避免将来混乱，我们需要在redis.conf文件中指定每一个实例的绑定ip信息，格式如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># redis实例的声明 IP</span><br><span class="line">replica-announce-ip 192.168.150.101</span><br></pre></td></tr></tbody></table></figure><p>每个目录都要改，我们一键完成修改（在/tmp目录执行下列命令）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 逐一执行</span><br><span class="line">sed -i '1a replica-announce-ip 192.168.150.101' 7001/redis.conf</span><br><span class="line">sed -i '1a replica-announce-ip 192.168.150.101' 7002/redis.conf</span><br><span class="line">sed -i '1a replica-announce-ip 192.168.150.101' 7003/redis.conf</span><br><span class="line"></span><br><span class="line"># 或者一键修改</span><br><span class="line">printf '%s\n' 7001 7002 7003 | xargs -I{} -t sed -i '1a replica-announce-ip 192.168.150.101' {}/redis.conf</span><br></pre></td></tr></tbody></table></figure><h2 id="3启动"><a class="markdownIt-Anchor" href="#3启动"></a> 3.启动</h2><p>为了方便查看日志，我们打开3个ssh窗口，分别启动3个redis实例，启动命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第1个</span><br><span class="line">redis-server 7001/redis.conf</span><br><span class="line"># 第2个</span><br><span class="line">redis-server 7002/redis.conf</span><br><span class="line"># 第3个</span><br><span class="line">redis-server 7003/redis.conf</span><br></pre></td></tr></tbody></table></figure><p>启动后：</p><p><img src="https://img-blog.csdnimg.cn/a59daa70d87f4f9d949860dae391942c.png" alt="img"></p><p>如果要一键停止，可以运行下面命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf '%s\n' 7001 7002 7003 | xargs -I{} -t redis-cli -p {} shutdown</span><br></pre></td></tr></tbody></table></figure><h2 id="4开启主从关系"><a class="markdownIt-Anchor" href="#4开启主从关系"></a> 4.开启主从关系</h2><p>现在三个实例还没有任何关系，要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。</p><p>有临时和永久两种模式：</p><ul><li><p>修改配置文件（<mark>永久生效</mark>）</p><ul><li>在redis.conf中添加一行配置：<font color="blue"><code>slaveof &lt;masterip&gt; &lt;masterport&gt;</code></font></li></ul></li><li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></tbody></table></figure></li></ul><p><strong>注意</strong>：在5.0以后新增命令replicaof，与salveof效果一致。</p><p>这里我们为了演示方便，使用方式二。</p><p>通过redis-cli命令连接7002，执行下面命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 连接 7002</span><br><span class="line">redis-cli -p 7002</span><br><span class="line"># 执行slaveof</span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></tbody></table></figure><p>通过redis-cli命令连接7003，执行下面命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 连接 7003</span><br><span class="line">redis-cli -p 7003</span><br><span class="line"># 执行slaveof</span><br><span class="line">slaveof 192.168.150.101 7001</span><br></pre></td></tr></tbody></table></figure><p><img src="https://img-blog.csdnimg.cn/8ba1e82306a74338b0b8e7b64087e790.png" alt="img"></p><p>然后连接 7001节点，查看集群状态：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 连接 7001</span><br><span class="line">redis-cli -p 7001</span><br><span class="line"># 查看状态</span><br><span class="line">info replication</span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="https://img-blog.csdnimg.cn/9fe619ef341e48e9a7d11a46b6f1e943.png" alt="img"></p><h2 id="5测试"><a class="markdownIt-Anchor" href="#5测试"></a> 5.测试</h2><p>执行下列操作以测试：</p><ul><li>利用redis-cli连接7001，执行<code>set num 123</code></li><li>利用redis-cli连接7002，执行<code>get num</code>，再执行<code>set num 666</code></li><li>利用redis-cli连接7003，执行<code>get num</code>，再执行<code>set num 888</code></li></ul><p>可以发现，只有在7001这个master节点上可以执行写操作，7002和7003这两个slave节点只能执行读操作。</p><p><img src="https://img-blog.csdnimg.cn/8b72b006934c477b9aaf1806542007a1.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e9985b1fcb7046b2849d2b260e4183a4.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/00e23fce5f8040b7bdcdd8daf059785d.png" alt="img"></p><h1 id="二-数据同步原理"><a class="markdownIt-Anchor" href="#二-数据同步原理"></a> 二、数据同步原理</h1><p><img src="https://img-blog.csdnimg.cn/566d2c905de44bd3a908d3ef2a221eb3.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e07861738258498a80882dd99d5f65e6.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c89f161adfcf4eb9a16367bb72919139.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/c519a72fdc2140268b2b18c3e82df57e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/32c36304a2ce450eaa3ecee4e3203ccd.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/5cb9aa1893bb409c8a65259d8dd094da.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/435c034f44794a3fbc0d6f15efe1e77c.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/1d1d8ba89683446eb5d4053a7f3c0eca.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/4e540323ef0443eb915595fe8d975817.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（分布式缓存）Redis持久化</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%EF%BC%89Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的视频教程"><a class="markdownIt-Anchor" href="#对应的视频教程"></a> 对应的视频教程</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=150&amp;vd_source=746b9336d739b80b11820809545b6604">高级篇Day3-01-Redis持久化_哔哩哔哩_bilibili</a></p></blockquote><h1 id="一-rdb持久化"><a class="markdownIt-Anchor" href="#一-rdb持久化"></a> 一、RDB持久化</h1><p><img src="https://img-blog.csdnimg.cn/20407d008453450da1df4a8dd664043f.png" alt="img"></p><p>首先需要在Linux系统中安装一个Redis，如果尚未安装的同学，可以参考下面链接教程安装先：</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126645589?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126645589%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(73条消息) 单机安装Redis_其然乐衣的博客-CSDN博客</a></p></blockquote><p><img src="https://img-blog.csdnimg.cn/63326861407a45378d6710545e246731.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/9470faad3b884165be8bffe4bc24733b.jpeg" alt="img"><img src="https://img-blog.csdnimg.cn/66ec88a142d44244942caffa0627aaf2.jpeg" alt="img"></p><p><strong>修改配置文件</strong></p><p><img src="https://img-blog.csdnimg.cn/94fb67f940b5431d852b80399a9fbd25.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/5aa1265753014ccfa15d794e4a5005ef.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/98d8fab9ec7c45958f264cdab7f02e6d.png" alt="img"></p><p>创建一个数据</p><p><img src="https://img-blog.csdnimg.cn/55154d5296954502886f3cf4669830c6.png" alt="img"></p><p>因为设置了只要5秒内有一次修改就会触发一次备份数据，所以就得到了备份数据</p><p><img src="https://img-blog.csdnimg.cn/2bc8917421d449f0bd6bd26c37bb088f.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/5a74275f5dc64deea5433084e5de160f.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e88a8f0875164ea68019ad0d005ef092.png" alt="img"></p><p>RDB是有可能会发生数据丢失的，因为两次备份的时间间隔会比较长。因此我们需要AOF持久化，它可以大大地提高数据的安全性，来弥补RDB缺点</p><h1 id="二-aof持久化"><a class="markdownIt-Anchor" href="#二-aof持久化"></a> 二、AOF持久化</h1><p><img src="https://img-blog.csdnimg.cn/308e771be0c645ac8ed9c31b3e4de652.png" alt="img"></p><h2 id="1-修改配置文件redisconf"><a class="markdownIt-Anchor" href="#1-修改配置文件redisconf"></a> 1、修改配置文件redis.conf</h2><p><img src="https://img-blog.csdnimg.cn/a5ca06b74fe74c12a70cd73046176b03.png" alt="img"></p><h3 id="11先禁用rdb因为要演示aof"><a class="markdownIt-Anchor" href="#11先禁用rdb因为要演示aof"></a> <strong>1.1.先禁用RDB，因为要演示AOF</strong></h3><p><img src="https://img-blog.csdnimg.cn/a08acd2bca2542bb887b7eafdd2d0d20.png" alt="img"></p><h3 id="12开启aof功能默认的是no"><a class="markdownIt-Anchor" href="#12开启aof功能默认的是no"></a> <strong>1.2.开启AOF功能（默认的是no）</strong></h3><p><img src="https://img-blog.csdnimg.cn/8d1ec653dcdd40ffb0cc04046dee3c88.png" alt="img"></p><h3 id="13aof文件的名称文件后缀是aof文件名可任意这里我们不做修改没用默认的就行"><a class="markdownIt-Anchor" href="#13aof文件的名称文件后缀是aof文件名可任意这里我们不做修改没用默认的就行"></a> <strong>1.3.AOF文件的名称，文件后缀是.aof，文件名可任意，这里我们不做修改没用默认的就行</strong></h3><p><img src="https://img-blog.csdnimg.cn/ebfe881314fb4bcd82749f7600386c4f.png" alt="img"></p><h3 id="14img"><a class="markdownIt-Anchor" href="#14img"></a> <strong>1.4.</strong><img src="https://img-blog.csdnimg.cn/acfa0e8bdcfb456581c29e7c7fd87ff4.png" alt="img"></h3><p>到这配置文件的修改就完成了</p><h2 id="2删掉rdb文件"><a class="markdownIt-Anchor" href="#2删掉rdb文件"></a> 2.删掉rdb文件</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf *.rdb</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/ef2cdc7bcf6244adac4e1cc0a1ada807.png" alt="img"></p><h2 id="3重启redis"><a class="markdownIt-Anchor" href="#3重启redis"></a> 3.重启redis</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="4检查数据发现证明之前的数据都清空了"><a class="markdownIt-Anchor" href="#4检查数据发现证明之前的数据都清空了"></a> 4.检查数据，发现证明之前的数据都清空了</h2><p><img src="https://img-blog.csdnimg.cn/d68adeda51db40d09591bbc38373f6d7.png" alt="img"></p><h2 id="5写新数据"><a class="markdownIt-Anchor" href="#5写新数据"></a> 5.写新数据</h2><p><img src="https://img-blog.csdnimg.cn/8fe389f98ece4d72b13350164f874966.png" alt="img"></p><h2 id="6刷新一下aof文件就生成了也就是备份了数据"><a class="markdownIt-Anchor" href="#6刷新一下aof文件就生成了也就是备份了数据"></a> 6.刷新一下，aof文件就生成了，也就是备份了数据</h2><p><img src="https://img-blog.csdnimg.cn/84403c504fbb4148b789c0a113784c17.png" alt="img"></p><h2 id="7查看aof文件"><a class="markdownIt-Anchor" href="#7查看aof文件"></a> 7.查看aof文件</h2><p><img src="https://img-blog.csdnimg.cn/4718952955844c8c9f4a86bfc94eb5cf.png" alt="img"></p><h3 id="如果继续添加命令写数据"><a class="markdownIt-Anchor" href="#如果继续添加命令写数据"></a> 如果继续添加命令写数据</h3><p><img src="https://img-blog.csdnimg.cn/2d3bc4e053c14b7590661e50153537d5.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/11fa9cfaeaab4a4b9754a782c7216522.png" alt="img"></p><h2 id="8停止redis和重启redis"><a class="markdownIt-Anchor" href="#8停止redis和重启redis"></a> 8.停止redis和重启redis</h2><p><img src="https://img-blog.csdnimg.cn/b5e51a9c90bd48a2a7970eee3e190b97.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/f881f1c01cba44b588cf3d2d64a82a17.png" alt="img"></p><h3 id="停止重启后依然有以前的数据"><a class="markdownIt-Anchor" href="#停止重启后依然有以前的数据"></a> 停止重启后，依然有以前的数据</h3><p><img src="https://img-blog.csdnimg.cn/4a4c063d1cfe4dbbb6c80303d2e168e7.png" alt="img"></p><p><strong>【 这就证明了，我们确实已经实现了数据的持久化和 故障的维护】</strong></p><h2 id="9"><a class="markdownIt-Anchor" href="#9"></a> <strong>9.</strong></h2><h2 id="但是存在的缺陷是aof会记录对同一个key的多次写操作但只有最有一次写操作才意义然而这增大了文件的大小比rdb的文件大很多"><a class="markdownIt-Anchor" href="#但是存在的缺陷是aof会记录对同一个key的多次写操作但只有最有一次写操作才意义然而这增大了文件的大小比rdb的文件大很多"></a> 但是存在的缺陷是，aof会记录对同一个key的多次写操作，但只有最有一次写操作才意义，然而这增大了文件的大小，比RDB的文件大很多</h2><h3 id="通过执行-font-colorredbgrewriteaoffont-命令可以让aof文件执行重写功能用最少的命令达到相同的效果-img91-执行bgrewriteaof-命令img"><a class="markdownIt-Anchor" href="#通过执行-font-colorredbgrewriteaoffont-命令可以让aof文件执行重写功能用最少的命令达到相同的效果-img91-执行bgrewriteaof-命令img"></a> <strong>通过执行</strong> <font color="red"><strong>bgrewriteaof</strong></font> <strong>命令，可以让AOF文件执行重写功能，用最少的命令达到相同的效果</strong> <img src="https://img-blog.csdnimg.cn/5506c4caef1b48418c78689524c8c579.png" alt="img">9.1 执行<strong>bgrewriteaof</strong> 命令<img src="https://img-blog.csdnimg.cn/29559d3d58e34b048ed677137ea0b640.png" alt="img"></h3><h3 id="92-通过cat命令查询aof文件"><a class="markdownIt-Anchor" href="#92-通过cat命令查询aof文件"></a> 9.2. 通过cat命令查询aof文件</h3><p><img src="https://img-blog.csdnimg.cn/5df8a1ec2f7243dc985d2b6a9b58f528.png" alt="img"></p><h3 id="93-通过vi查看aof文件"><a class="markdownIt-Anchor" href="#93-通过vi查看aof文件"></a> 9.3. 通过vi查看aof文件</h3><p>会发现命令被压缩了</p><p>虽然比之前的难看些了， 但还可以看懂一些，比如num name这些</p><p><img src="https://img-blog.csdnimg.cn/0025be1aa1bb486cb1e03032c1fba34a.png" alt="img"></p><h2 id="10如果我们不自己手动执行-bgrewriteaof-命令redis也会在触发阈值时自动去重写aof文件-阈值也可以在redisconf中配置"><a class="markdownIt-Anchor" href="#10如果我们不自己手动执行-bgrewriteaof-命令redis也会在触发阈值时自动去重写aof文件-阈值也可以在redisconf中配置"></a> 10.如果我们不自己手动<strong>执行</strong> <strong>bgrewriteaof</strong> **命令，**Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</h2><blockquote><h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2><h2 id="aof文件比上次文件-增长超过多少百分比则触发重写-auto-aof-rewrite-percentage-100"><a class="markdownIt-Anchor" href="#aof文件比上次文件-增长超过多少百分比则触发重写-auto-aof-rewrite-percentage-100"></a> <strong># AOF文件比上次文件 增长超过多少百分比则触发重写</strong>  auto-aof-rewrite-percentage 100</h2><h2 id="aof文件体积最小多大以上才触发重写-auto-aof-rewrite-min-size-64mb"><a class="markdownIt-Anchor" href="#aof文件体积最小多大以上才触发重写-auto-aof-rewrite-min-size-64mb"></a> <strong># AOF文件体积最小多大以上才触发重写</strong>  auto-aof-rewrite-min-size 64mb</h2></blockquote><h1 id="三-rdb和aof两种持久化的对比"><a class="markdownIt-Anchor" href="#三-rdb和aof两种持久化的对比"></a> 三、RDB和AOF两种持久化的对比</h1><p><img src="https://img-blog.csdnimg.cn/b12fc64d10514094a26c7ba72a6f3b33.png" alt="img"></p><h3 id="注意"><a class="markdownIt-Anchor" href="#注意"></a> 注意：</h3><h3 id="我们在实际使用中往往会两者结合使用数据回复优先级aof优先于rdb"><a class="markdownIt-Anchor" href="#我们在实际使用中往往会两者结合使用数据回复优先级aof优先于rdb"></a> 我们在实际使用中，往往会两者结合使用（数据回复优先级AOF优先于RDB）</h3><p><strong>RDB主要充一个数据备份的作用</strong>，我们可以将备份的RDB文件拷贝到别的机房，异地的容灾。当机房这个机房毁了，AOF也就毁了，但被拷贝到别的机房的RDB文件还在，那么我们的数据还是可以恢复的。所以RDB就是主要起到这么一个备份数据的作用</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2022/11/10/redis/Untitled/"/>
      <url>/2022/11/10/redis/Untitled/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>单机安装Redis</title>
      <link href="/2022/11/10/redis/%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85Redis/"/>
      <url>/2022/11/10/redis/%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="单机安装redis"><a class="markdownIt-Anchor" href="#单机安装redis"></a> 单机安装Redis</h1><p>首先需要安装Redis所需要的依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc tcl</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>然后将课前资料提供的Redis安装包上传到虚拟机的任意目录：</p><p>例如，我放到了/tmp目录：</p><p>解压缩：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf redis-6.2.4.tar.gz</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>解压后：</p><p>进入redis目录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd redis-6.2.4</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>运行编译命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>如果没有出错，应该就安装成功了。</p><p>然后修改redis.conf文件中的一些配置：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 绑定地址，默认是127.0.0.1，会导致只能在本地访问。修改为0.0.0.0则可以在任意IP访问</span><br><span class="line">bind 0.0.0.0</span><br><span class="line"># 数据库数量，设置为1</span><br><span class="line">databases 1</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>启动Redis：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server redis.conf</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>停止redis服务：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli shutdown</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式缓存 Redis</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%20Redis/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E7%BC%93%E5%AD%98/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%20Redis/</url>
      
        <content type="html"><![CDATA[<p><strong>单点Redis的问题</strong></p><ul><li>**数据丢失问题：**Redis是内存存储，服务重启可能会丢失数据</li><li>**并发能力问题：**单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景</li><li><strong>故障恢复问题</strong>：如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段</li><li>**存储能力问题：**Redis基于内存，单节点能存储的数据量难以满足海量数据需求</li><li><img src="https://img-blog.csdnimg.cn/2de8a33a144b4c56b6356b88d9c01dd5.png" alt="img"></li></ul><p><img src="https://img-blog.csdnimg.cn/b007d4c74b0b4a0fa96272eeb389bfff.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/0c3be77c63b34ad0a2e03c6b1f624c6f.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/7908c6fa767f42b98ab8fd055c488a87.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>解决问题</strong></p><p><img src="https://img-blog.csdnimg.cn/374954ff3bb44b2dab45ed463955b4c6.png" alt="img"></p><p>一、Redis持久化</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126640334?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126640334%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(73条消息) （分布式缓存）Redis持久化_其然乐衣的博客-CSDN博客</a></p></blockquote><p>二、Redis主从</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126649510?spm=1001.2014.3001.5501">(73条消息) （分布式缓存）Redis主从_其然乐衣的博客-CSDN博客</a></p></blockquote><p>三、Redis哨兵</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126651375?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126651375%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(73条消息) （分布式缓存）Redis哨兵_其然乐衣的博客-CSDN博客</a></p></blockquote><p>四、Redis分片集群</p><blockquote><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/126656765?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22126656765%22%2C%22source%22%3A%22QRLYLETITBE%22%7D">(74条消息) (分布式缓存)Redis分片集群_其然乐衣的博客-CSDN博客</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> redis </tag>
            
            <tag> 缓存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【多余的@autowired】springboot异常：Consider defining a bean of type ‘java.lang.String‘</title>
      <link href="/2022/11/10/debug/%E3%80%90%E5%A4%9A%E4%BD%99%E7%9A%84@autowired%E3%80%91springboot%E5%BC%82%E5%B8%B8%EF%BC%9AConsider%20defining%20a%20bean%20of%20type%20%E2%80%98java.lang.String%E2%80%98%20/"/>
      <url>/2022/11/10/debug/%E3%80%90%E5%A4%9A%E4%BD%99%E7%9A%84@autowired%E3%80%91springboot%E5%BC%82%E5%B8%B8%EF%BC%9AConsider%20defining%20a%20bean%20of%20type%20%E2%80%98java.lang.String%E2%80%98%20/</url>
      
        <content type="html"><![CDATA[<p>**报错：**Consider defining a bean of type ‘java.lang.String’ in your configuration</p><p>总结了网上的几种解决方案：</p><p>1、多余的@autowired</p><p>如：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0886820a87b94873902e51a903ffc582~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>2、<strong>待实例化的类里必须有默认的构造方法（即没有参数的那种）</strong></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-微服务整合sentinel</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B4%E5%90%88sentinel/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%95%B4%E5%90%88sentinel/</url>
      
        <content type="html"><![CDATA[<p>1.引入sentinel依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入sentinel依赖--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>配置控制台地址（让微服务与控制台建立联系）：</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5149d3958b294d3e8f8bb82d4d1d5089~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    sentinel:</span><br><span class="line">      transport:</span><br><span class="line">        dashboard: localhost:8080    # sentinel控制台地址</span><br></pre></td></tr></tbody></table></figure><p>（如果是在云服务器上安装的sentinel，localhost改为服务器的ip地址）</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【分布式事务】XA模式、AT模式、TCC模式、SAGA模式</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%89XA%E6%A8%A1%E5%BC%8F%E3%80%81AT%E6%A8%A1%E5%BC%8F%E3%80%81TCC%E6%A8%A1%E5%BC%8F%E3%80%81SAGA%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%EF%BC%88%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%89XA%E6%A8%A1%E5%BC%8F%E3%80%81AT%E6%A8%A1%E5%BC%8F%E3%80%81TCC%E6%A8%A1%E5%BC%8F%E3%80%81SAGA%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>参考B站黑马教程视频：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=149&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604" title="高级篇Day2-03-动手实践_哔哩哔哩_bilibili">高级篇Day2-03-动手实践_哔哩哔哩_bilibili</a></p></blockquote><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/745beeae3ca642c78aff91d85fe6628b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="一-xa模式"><a class="markdownIt-Anchor" href="#一-xa模式"></a> 一、XA模式</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c9130e3bdc64f0eb5852ca6c122a425~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bdcf55f4a9848f091776d531d062fda~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/470683757d404e9688dbaf17dde1edf0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/669714ab671d437985d27de4021fdfc0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a124dc1f7c8045d3bea64739f2191865~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="二-at模式"><a class="markdownIt-Anchor" href="#二-at模式"></a> 二、 AT模式</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/67a70e46700c4c9ab2bbc3cf614250eb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8f3cc8ef1f0d4ee3b6b215befd90ac01~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a15c92cce5547ba8e95cb162ec43bf7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d01d8f3820f24936bbd2b090f1ce2b55~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c36cdaa74c8a475c8c5b60e173b9f8e4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7824bc6efe3144aaad603f8dcc802cf6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1281ce856033497cb5d651d63b7c2f19~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94f0eedf792e47bb9839bfbef207fb54~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0339c27aa63c4370ab5b1513e108aa33~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="三-tcc模式"><a class="markdownIt-Anchor" href="#三-tcc模式"></a> 三、TCC模式</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42b3538f29434d20b6954899bda76fd7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/010912f002144482880661a46e39f59f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/858e90ef0cd9406da4779a8abaf33349~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f0eb18dced54dff9f788ebd88b96b17~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b0f398e2c9224bc3892c8489d3883fa9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/05af9a60f4c34db79768a15dc95f5f5c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae608053977d442fbdd556e033fcda7e~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b6fb7648df8b41db845dc0f146824dbb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4722208a42c0470983ca00f035de1504~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="四-saga模式"><a class="markdownIt-Anchor" href="#四-saga模式"></a> 四、Saga模式</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/662bf331e424447dbefac8d90dbe8580~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/927441e650854e68a75aba60a260036d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="四-四种模式的对比"><a class="markdownIt-Anchor" href="#四-四种模式的对比"></a> 四、四种模式的对比</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acb1137e27d84003a2cccf18458e2a05~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 分布式事务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式事务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-Feign整合Sentinel</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Feign%E6%95%B4%E5%90%88Sentinel/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Feign%E6%95%B4%E5%90%88Sentinel/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1368428c32d14d989f2fff60d3d0873f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>步骤一</strong>：在feing-api项目中定义类，实现FallbackFactory：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a9bbbbe20240416aaf9b469c521948e1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import cn.itcast.feign.clients.UserClient;</span><br><span class="line">import cn.itcast.feign.pojo.User;</span><br><span class="line">import feign.hystrix.FallbackFactory;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line"></span><br><span class="line">@Slf4j   //记录日志</span><br><span class="line">public class UserClientFallbackFactory implements FallbackFactory&lt;UserClient&gt; {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public UserClient create(Throwable throwable) {</span><br><span class="line">        return new UserClient() {</span><br><span class="line">            /*</span><br><span class="line">                在这个方法中编写降级的业务逻辑</span><br><span class="line">                    返回 友好提示、一个默认值...，都可以在这个方法里面写</span><br><span class="line">             */</span><br><span class="line">            @Override</span><br><span class="line">            public User findById(Long id) {  //在这个方法中编写降级的逻辑</span><br><span class="line">                log.error("查询用户异常",throwable);</span><br><span class="line">                return new User();</span><br><span class="line">            }</span><br><span class="line">        };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤二：</strong> 在feing-api项目中的DefaultFeignConfiguration类中将UserClientFallbackFactory注册为一个Bean：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fce1948b5d9b41c5b5f84446d65dccab~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//将UserClientFallbackFactory注册到bean</span><br><span class="line">    @Bean</span><br><span class="line">    public UserClientFallbackFactory userClientFallbackFactory(){</span><br><span class="line">        return new UserClientFallbackFactory();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>步骤三：</strong> 在feing-api项目中的UserClient接口中使用UserClientFallbackFactory：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c3138f6a45941ceb565802cbb3c0e45~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import cn.itcast.feign.clients.fallback.UserClientFallbackFactory;</span><br><span class="line">import cn.itcast.feign.pojo.User;</span><br><span class="line">import org.springframework.cloud.openfeign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"></span><br><span class="line">@FeignClient(value = "userservice", fallbackFactory = UserClientFallbackFactory.class)</span><br><span class="line">public interface UserClient {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/user/{id}")</span><br><span class="line">    User findById(@PathVariable("id") Long id);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java后端数据返回通用类</title>
      <link href="/2022/11/10/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/Java%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E9%80%9A%E7%94%A8%E7%B1%BB/"/>
      <url>/2022/11/10/%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/Java%E5%90%8E%E7%AB%AF%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E9%80%9A%E7%94%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="第一种简单定义"><a class="markdownIt-Anchor" href="#第一种简单定义"></a> 第一种（简单定义）</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">import lombok.Data;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 结果数据返回通用类</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/7/20</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@Data</span><br><span class="line">public class JsonResult&lt;T&gt; {</span><br><span class="line">    /**</span><br><span class="line">     *  编码：200成功，500和其它数字为失败或其他异常情况</span><br><span class="line">     **/</span><br><span class="line">    private Integer code;</span><br><span class="line">    /**</span><br><span class="line">     * 返回描述信息</span><br><span class="line">     **/</span><br><span class="line">    private String msg;</span><br><span class="line">    /**</span><br><span class="line">     * 信息返回数据</span><br><span class="line">     **/</span><br><span class="line">    private T data;</span><br><span class="line">    /**</span><br><span class="line">     *  动态数据</span><br><span class="line">     **/</span><br><span class="line"></span><br><span class="line">    private Map map = new HashMap();</span><br><span class="line"></span><br><span class="line">    public JsonResult() {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code) {</span><br><span class="line">        this.code = code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code, String msg) {</span><br><span class="line">        this.code = code;</span><br><span class="line">        this.msg = msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(String msg, T object) {</span><br><span class="line">        JsonResult&lt;T&gt; result = new JsonResult&lt;T&gt;();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.data = object;</span><br><span class="line">        result.code = 200;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(String msg, Integer code) {</span><br><span class="line">        JsonResult result = new JsonResult();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.code = code;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success( Integer code) {</span><br><span class="line">        JsonResult result = new JsonResult();</span><br><span class="line">        result.code = code;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(String msg) {</span><br><span class="line">        JsonResult&lt;T&gt; result = new JsonResult&lt;T&gt;();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.code = 200;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success() {</span><br><span class="line">        JsonResult&lt;T&gt; result = new JsonResult&lt;T&gt;();</span><br><span class="line">        result.code = 200;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error(String msg, Integer code) {</span><br><span class="line">        JsonResult result = new JsonResult();</span><br><span class="line">        result.msg = msg;</span><br><span class="line">        result.code = code;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error(Integer code) {</span><br><span class="line">        JsonResult result = new JsonResult();</span><br><span class="line">        result.code = code;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error() {</span><br><span class="line">        JsonResult result = new JsonResult();</span><br><span class="line">        result.code = 500;</span><br><span class="line">        return result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult&lt;T&gt; add(String key, Object value) {</span><br><span class="line">        this.map.put(key, value);</span><br><span class="line">        return this;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="第二种"><a class="markdownIt-Anchor" href="#第二种"></a> 第二种</h1><p>导入依赖</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.5.13&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>编写结果数据通用类</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">import com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line">import io.swagger.annotations.ApiModel;</span><br><span class="line">import io.swagger.annotations.ApiModelProperty;</span><br><span class="line">import lombok.Data;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * todo JsonInclude 注解忽略 null值 看业务需求添加</span><br><span class="line"> */</span><br><span class="line">@ApiModel("分页响应参数")</span><br><span class="line">@JsonInclude(value = JsonInclude.Include.NON_EMPTY)</span><br><span class="line">@Data</span><br><span class="line">public class JsonResult&lt;T&gt; implements Serializable {</span><br><span class="line">    private static final long serialVersionUID = 1L;</span><br><span class="line"></span><br><span class="line">    @ApiModelProperty(value = "结果状态", example = "200")</span><br><span class="line">    private Integer code = 200;</span><br><span class="line">    @ApiModelProperty(value = "结果数据")</span><br><span class="line">    private T data;</span><br><span class="line">    @ApiModelProperty(value = "结果描述", example = "成功")</span><br><span class="line">    private String message = "ok";</span><br><span class="line"></span><br><span class="line">    public JsonResult() {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code) {</span><br><span class="line">        this();</span><br><span class="line">        this.code = code;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code, T data) {</span><br><span class="line">        this(code);</span><br><span class="line">        this.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code, String message) {</span><br><span class="line">        this(code);</span><br><span class="line">        this.message = message;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public JsonResult(Integer code, String message, T data) {</span><br><span class="line">        this(code, message);</span><br><span class="line">        this.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success() {</span><br><span class="line">        return new JsonResult(200);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(T data) {</span><br><span class="line">        return new JsonResult(200, data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(String message, T data) {</span><br><span class="line">        return new JsonResult(200, message, data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; success(Integer code, String message, T data) {</span><br><span class="line">        return new JsonResult(code, message, data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static JsonResult&lt;String&gt; error() {</span><br><span class="line">        return new JsonResult(500);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error(String message) {</span><br><span class="line">        return new JsonResult(500, message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error(Integer code, String message) {</span><br><span class="line">        return new JsonResult(code, message);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public static &lt;T&gt; JsonResult&lt;T&gt; error(Integer code, String message, T data) {</span><br><span class="line">        return new JsonResult(code, message, data);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据封装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据封装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-授权规则及规则持久化</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99%E5%8F%8A%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E6%8E%88%E6%9D%83%E8%A7%84%E5%88%99%E5%8F%8A%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="一-授权规则"><a class="markdownIt-Anchor" href="#一-授权规则"></a> 一、授权规则</h1><p><strong>第1步：添加判断来源逻辑</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b5b579c658f74e349cf4a46b3c6dc291~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.RequestOriginParser;</span><br><span class="line">import org.apache.commons.lang.StringUtils;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class HeaderOriginParser implements RequestOriginParser {</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String parseOrigin(HttpServletRequest request) {</span><br><span class="line"></span><br><span class="line">        //1.获取请求头</span><br><span class="line">        String origin = request.getHeader( "origin" );</span><br><span class="line">        //2.非空判断</span><br><span class="line">        if ( StringUtils.isEmpty( origin ) ) {</span><br><span class="line">            origin = "blank";   //如果是空的就返回一个默认值</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        return origin;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第2步：编写过滤器–&gt;给网关添加origin头</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9540b33304404f328b31c9161b8ef9a1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>第3步：</strong> 重新启动，访问一个接口</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4a5e2e9dc8a4639b95a7c0b97da66c4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>第4步：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/851bce58ceb2456db41b0144dcda074b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80eb3929081f4aefba30e4206ede04a8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>第5步：重新范访问上面的接口</p><p>8088是直接范文oder服务的，也就是绕过了网关，但是现在我们已经设置了授权规则，所以直接访问是不行的，你报错如下</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/482f2a45e56343aca62c0b82d30f2881~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p>现在我们通过网关来访问，网关的端口设置的是10010，用10010来访问</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d18b1f049f0417ab4ef1c2734f607b7~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p>因为网关做了权限的校验，所以需要把权限加上</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2f737346485e41babc766c33ce4a48f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><strong>因此，通过上面的授权规则设置后，通过网关来访问的就可以，而通过浏览器直接访问的就不行</strong></p><p>下面是黑马PPT的笔记</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b351bf12a5fe43b6b588b532968e1d7e~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/850f51aaa13d41c1b19cb3c7b87b9c9e~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4eab592a0aed4910971e3c9ba636c0d9~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><h1 id="二-自定义异常结果"><a class="markdownIt-Anchor" href="#二-自定义异常结果"></a> 二、自定义异常结果</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b44de8fe5e834c19a60748e8662f26dd~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><strong>第1步：</strong> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4e133292990e4c6fb15e1210d175886f~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.order.sentinel;</span><br><span class="line"></span><br><span class="line">import com.alibaba.csp.sentinel.adapter.spring.webmvc.callback.BlockExceptionHandler;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.BlockException;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.authority.AuthorityException;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.degrade.DegradeException;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.FlowException;</span><br><span class="line">import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class SentinelExceptionHandler implements BlockExceptionHandler {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {</span><br><span class="line">        String msg = "未知异常";</span><br><span class="line">        int status = 429;</span><br><span class="line"></span><br><span class="line">        if ( e instanceof FlowException ) {</span><br><span class="line">            msg = "请求被限流了";</span><br><span class="line">        } else if ( e instanceof ParamFlowException ) {</span><br><span class="line">            msg = "请求被热点参数限流";</span><br><span class="line">        } else if ( e instanceof DegradeException ) {</span><br><span class="line">            msg = "请求被降级了";</span><br><span class="line">        } else if ( e instanceof AuthorityException ) {</span><br><span class="line">            msg = "没有权限访问";</span><br><span class="line">            status = 401;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        response.setContentType( "application/json;charset=utf-8" );</span><br><span class="line">        response.setStatus( status );</span><br><span class="line">        response.getWriter().println( "{"msg": " + msg +", "status": " + status + "}" );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>第2步：</strong> 重启微服务，然后浏览器访问接口</p><p><strong>第3步：</strong> 在sentinel中给端口设置响应的规则进行测试</p><p>（1）新增授权规则</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/240faee0e7694cf7947401b226d8c933~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p>（2）新增流控规则</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef7c802314174e49a213ef23bdb29528~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p>下面是黑马PPT笔记</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/76ca017f596d4f24be8956443191ce4a~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/099ca98c8d5b4bbfa6773e99791b1357~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a2dc2084784278b7327691475f6347~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3de8bab8500d4a97b2490d67c276d691~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><h1 id="三-规则持久化"><a class="markdownIt-Anchor" href="#三-规则持久化"></a> 三、规则持久化</h1><p>这一节知识就没有详细的操作笔记，需要观看黑马教程视频如下链接：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=146&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604" title="高级篇Day1-04-授权规则及规则持久化_哔哩哔哩_bilibili">高级篇Day1-04-授权规则及规则持久化_哔哩哔哩_bilibili</a></p></blockquote><p><strong>前言：</strong></p><p><strong>当我们服务重启，我们所配的所有规则就会丢失，因为sentinel会默认把这些规则保存在内存里，重启就自然丢失了。而在生产的环境下 肯定是不能容忍这样的问题的。所以我们就需要学习怎么将****sentinel的规则持久化。</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9fee22491fb24e4790646e3160c4450b~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21f7ae7d47244927a44627937b075cb6~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/456e266b724743aa8a2ed42b70c57bf7~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5144409040ff4be2af188f8c376082bb~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e50c75a61c044a8b4f0c51ba43a1bdd~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/763c66ee38ef4265bfaef1619a950931~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1794f451b3e247ceba1104df2869efe6~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93b5c98c80e245b6b31ece62385982b6~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7f5cb43090984314a238cd2ad2507edf~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a936beac99946e6a3afb2669ff052d9~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37820802305143d5b38febbda0ff5aa1~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7762b122a81e4381a4be27d88581eda0~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/525f945958194209835152ba1c4f188e~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf6c39ffdf904508ad6e409a5d8b85b1~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5f5b1ce4ac9840ccac06ec19e94f2e02~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-认识和(本地)安装sentinel</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E8%AE%A4%E8%AF%86%E5%92%8C(%E6%9C%AC%E5%9C%B0)%E5%AE%89%E8%A3%85sentinel/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/%E8%AE%A4%E8%AF%86%E5%92%8C(%E6%9C%AC%E5%9C%B0)%E5%AE%89%E8%A3%85sentinel/</url>
      
        <content type="html"><![CDATA[<h3 id="首先先了解一下雪崩问题"><a class="markdownIt-Anchor" href="#首先先了解一下雪崩问题"></a> 首先先了解一下雪崩问题：</h3><p><img src="https://img-blog.csdnimg.cn/1139e40162ce4a62bcadc2a186bcb714.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/886685dbe38a4d42b6057d9cf4887350.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/88671edda4e64363919a6273c6805780.png" alt="img"></p><p>如何避免因服务故障引起的雪崩问题？</p><ul><li><p>超时处理：</p><ul><li>我们会给业务设置超时时间，如果一个业务执行时超过了这个时间还是没有给出响应，我们就立即释放资源，返回异常信息，从而避免无休止的等待导致资源耗尽，避免雪崩</li></ul></li><li><p>线程隔离：</p><ul><li>将每一个服务隔离开，设置单独一个线程池，这样呢，一旦一个业务出现了故障，它也只是把这一个线程池里的资源耗尽，而不会导致整个tomcat资源耗尽</li></ul></li><li><p>降级熔断：</p><ul><li>我们会去统计一个业务的正常请求和异常请求的比例，如果异常请求的比例过高，我们会认为，这个请求或业务会比较危险，我们就可以阻止这个业务的请求，快速失败，释放资源，从而避免雪崩问题发生。在这个业务恢复正常以后，我才会放心访问这个业务的请求</li></ul></li></ul><h3 id="服务保护技术对比"><a class="markdownIt-Anchor" href="#服务保护技术对比"></a> 服务保护技术对比</h3><p><img src="https://img-blog.csdnimg.cn/cf6b35737bc24c509745f945d9fe8772.png" alt="img"></p><p>Sentinel是阿里巴巴开源的一款微服务流量控制组件。官网地址：<a href="https://sentinelguard.io/zh-cn/index.html" title="https://sentinelguard.io/zh-cn/index.html">https://sentinelguard.io/zh-cn/index.html</a></p><p>Sentinel 具有以下特征:</p><p>•<strong>丰富的应用场景</strong>：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</p><p>•<strong>完备的实时监控</strong>：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</p><p>•<strong>广泛的开源生态</strong>：Sentinel 提供<strong>开箱即用</strong>的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</p><p>•<strong>完善的</strong> <strong>SPI</strong> <strong>扩展点</strong>：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20237b6177d541998fa970b5b2fb9ba1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae2fa1d0ac60466a92186098af87f490~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2083e797b72e41a69fbc5e52b3077951~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/676c94cd816c4b2d95f99b8a3572d2ac~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sentinel-流控效果</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E6%B5%81%E6%8E%A7%E6%95%88%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>流控效果</strong>是指请求达到流控阈值时应该采取的措施，包括三种：</p><p>• 快速失败：达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。</p><p>• warm up：预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化,从一个较小值逐渐增加到最大阈值。</p><p>• 排队等待：让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf2acabbe42c4d59ba57ac1746efbe72~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="流控效果-warm-up"><a class="markdownIt-Anchor" href="#流控效果-warm-up"></a> 流控效果-<strong>warm up</strong></h1><p>warm up也叫<strong>预热</strong>模式，是应对服务冷启动的一种方案。请求阈值初始值是 threshold / coldFactor，持续指定时长后，逐渐提高到threshold值。而coldFactor的默认值是3.</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7cb643747de42fbbf07e67f66382752~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>添加规则：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2b2b9033602f45ac80923d9c44f32ec2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efa48b598b3b40febf2cf3b23e062901~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>借助JMeter测试：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b936da7ff482473bbf59c37958f964dc~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>启动后，通过的会随着预热过程而逐渐变多，拒绝逐渐变少</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97ec69f1667246329b926dcebb2f1b09~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d3f8c537aff846ee9ac14d8f6d72fdea~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebe8e5b42e8e4420b84bb1d71852b5f8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>实时监控显示：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac3aa62e175b4712875072a5b42607fb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="流控效果-排队等待"><a class="markdownIt-Anchor" href="#流控效果-排队等待"></a> 流控效果-排队等待</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2161a4aaf7084c7c94e1d76f620307a0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22c88521614944c7bb83341b85a84793~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/238bc1dae1384083b0a05f9b14304147~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d1d18095a7446a8924b68bc99f118a0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7d27a74a69d34b1b9f866058691107cf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10c1f225aef84934abcc8aa2751928cd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ba02ec011c24ec7a4c5c5c608f20e36~tplv-k3u1fbpfcp-zoom-1.image" alt=""> 排队等待的有点：</p><pre><code>   （1） 发出的QPS是15，但大多数是通过的（10）而其它有的都是放到队列里面去了，小部分是拒绝的。   （2）而且不管你发出QPS的波动有多么剧烈，我放出的永远是均衡的，同过的都是10。这样对于微服务来说，波动的肯定不比均衡的好，所以这样的作用也是起到了流量整形的作用</code></pre>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Sentinel </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Sentinel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestTemplate远程调用</title>
      <link href="/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/RestTemplate%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2022/11/10/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/RestTemplate%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b15ec093f4414539b6d4c1d5b0b0c3cf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/363d9e0f524245e8937672f4f6609239~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>步骤 1：注册RestTemplate</p><p>在order-service的OrderApplication中注册RestTemplate</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afb47de2b56a46dd8bc2621feac8c81e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SquareApplication {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(SquareApplication.class,args);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 创建RestTemplate 并注入Spring容器</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Bean</span><br><span class="line">    public RestTemplate restTemplate(){</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf012adbd3b9440d9d15dd2bbc763050~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> 远程调用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> 远程调用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用Git上传项目gitLab（简单笔记）</title>
      <link href="/2022/11/10/GIt/%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AEgitLab%EF%BC%88%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%89/"/>
      <url>/2022/11/10/GIt/%E7%94%A8Git%E4%B8%8A%E4%BC%A0%E9%A1%B9%E7%9B%AEgitLab%EF%BC%88%E7%AE%80%E5%8D%95%E7%AC%94%E8%AE%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb61fd3a0a2f4d70920108045b60da5b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5427111cce7342eab886c0563819500b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eaf04def88974008bdb8277f58e49fec~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>如果出错了，看下面：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebe9ad0d2ed7451b9bd50f3134e5256a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 提交代码 到 gitee仓库指定文件夹中</title>
      <link href="/2022/11/10/GIt/git%20%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%20%E5%88%B0%20gitee%E4%BB%93%E5%BA%93%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD/"/>
      <url>/2022/11/10/GIt/git%20%E6%8F%90%E4%BA%A4%E4%BB%A3%E7%A0%81%20%E5%88%B0%20gitee%E4%BB%93%E5%BA%93%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="一-创建一个空文件夹"><a class="markdownIt-Anchor" href="#一-创建一个空文件夹"></a> <strong>一、创建一个空文件夹</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9fc3c90c93a4adc8e3dc78322e30129~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="二-将gitee仓库地址复制下来"><a class="markdownIt-Anchor" href="#二-将gitee仓库地址复制下来"></a> <strong>二、将gitee仓库地址复制下来</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2464b99947454e96bfe6a00054780a41~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="三-在刚刚新建的空文件夹真打开-git-bash-here"><a class="markdownIt-Anchor" href="#三-在刚刚新建的空文件夹真打开-git-bash-here"></a> <strong>三、在刚刚新建的空文件夹真打开 Git Bash Here</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/99969c86e67544a7b9d216bd9a52270e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="四-克隆-gitee-仓库"><a class="markdownIt-Anchor" href="#四-克隆-gitee-仓库"></a> <strong>四、克隆 gitee 仓库</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/06b6dc19ab3b4d649ef82bddd14d8b91~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057d656f48ad4b148314963894e33d04~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="五-提交代码"><a class="markdownIt-Anchor" href="#五-提交代码"></a> <strong>五、提交代码</strong></h1><h2 id="将想要提交的拖到克隆下来的目录下面"><a class="markdownIt-Anchor" href="#将想要提交的拖到克隆下来的目录下面"></a> 将想要提交的拖到克隆下来的目录下面</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b126314b4374036abd2c31894e19fb1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="六-执行指令"><a class="markdownIt-Anchor" href="#六-执行指令"></a> <strong>六、执行指令</strong></h1><p><strong>1. 执行 git add 文件名    （如果是git add .    表示当前目录下的所有内容），注意，add后要一个空格</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名</span><br></pre></td></tr></tbody></table></figure><p>可能会出现如下报错，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/941d8084850446b697719e9e2f5f472e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>则需要输入 git init  然后回车就好了</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></tbody></table></figure><p>然后再重新执行添加文件就可以了（注意，一定要将目录切换到仓库目录，负责执行命令时会报fatal: pathspec ‘hotel-demo’ did not match any files）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/13ae7146357d46df8dc579c28bce7b71~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>2.  执行git <strong><a href="https://so.csdn.net/so/search?q=commit&amp;spm=1001.2101.3001.7020" title="commit">commit</a></strong> -m “注释的内容”  （ 提交到本地仓库）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "注释的内容"</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ad1bbba49ec64fdfb17e0358353c2d1e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>3. 提交代码到 gitee</strong></p><p>执行命令: git remote add origin 远程项目的 Https 地址</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin 远程项目的 Https 地址</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21db2300c57e41dd8dcc87632479577e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>可能有人会报如下错误（没有的话可以忽略）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dfcbfdc4a73545c29858ea2ed8b30b3e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>解决：执行 git remote rm origin 删除关联的origin的远程库</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9fa0139624d420ab5a298a92f816250~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>然后再重新执行 git remote add origin 远程项目的 Https 地址即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b306387bd5304e05a851187d6a87c9ea~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>4. git push -u origin master （ 最后这一步就可以推送到自己的仓库了）</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master </span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/789bb4e8738f4111a0e278d2f2deb6b8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0665d6efe4eb48cb84474db680e01ea1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>完成 !!</strong></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker restart xxx重启容器报错：Error response from daemon Cannot restart container es</title>
      <link href="/2022/11/10/Docker/docker%20restart%20xxx%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9AError%20response%20from%20daemon%20Cannot%20restart%20container%20es/"/>
      <url>/2022/11/10/Docker/docker%20restart%20xxx%E9%87%8D%E5%90%AF%E5%AE%B9%E5%99%A8%E6%8A%A5%E9%94%99%EF%BC%9AError%20response%20from%20daemon%20Cannot%20restart%20container%20es/</url>
      
        <content type="html"><![CDATA[<p>1.报错：<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/821e52df48964f178aa83dbc6157dbf4~tplv-k3u1fbpfcp-zoom-1.image" style="zoom:50%;"></p><ol start="2"><li><p>原因：重启服务器后，我重启过网络 network 。我想大概是这个影响了 docker　的网络。</p></li><li><p>解决：　重启 docker 服务即可：</p></li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></tbody></table></figure><ol start="4"><li>重启容器即可成功</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart 容器名</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/396cbd693e724deaa7dfad44cf8a25f3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker镜像仓库</title>
      <link href="/2022/11/10/Docker/Docker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/"/>
      <url>/2022/11/10/Docker/Docker%E9%95%9C%E5%83%8F%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p>Docker镜像仓库</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95f0ea430c0c49fbb0e02770a6547a1f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd5290c4efc6463bbbe3142834794a72~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a282dde2bd04742801d934133fd6d5d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/640c6c2974f547528709d0d546dbc8c7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e1a659c9d8444ebbba9da70932abef7b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d529023faf4417198f564653a97a54b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3acf7107043f48cd83de8f964de490d5~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>去网页进行访问</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e7fe09df2c44584bea5fe9147325bde~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3ef9a288e9fe4a6a9a718268d3777bbb~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/871a56c43a00445ba0f8147c02b34d42~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c28079d54474f54a99f8f90d0ccfee8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>删除镜像，之后再拉取回镜像</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/44ad2222b49b4ac29c77d278aab85f02~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5feba34a268347749d31de6d6bece1a4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker删除镜像是报错:Error response from daemon:conflict:unable to remove repository</title>
      <link href="/2022/11/10/Docker/Docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%98%AF%E6%8A%A5%E9%94%99Error%20response%20from%20daemon%20conflict%20unable%20to%20remove%20repository%20/"/>
      <url>/2022/11/10/Docker/Docker%E5%88%A0%E9%99%A4%E9%95%9C%E5%83%8F%E6%98%AF%E6%8A%A5%E9%94%99Error%20response%20from%20daemon%20conflict%20unable%20to%20remove%20repository%20/</url>
      
        <content type="html"><![CDATA[<p>Error response from daemon: conflict: unable to remove repository reference “nginx:latest” (must force) - container 50a3d44fa9aa is using its referenced image 605c77e624dd</p><p>翻译是：</p><pre><code>    来自守护程序的错误响应：冲突：无法删除存储库引用“nginx：latest”（必须强制） - 容器 50a3d44fa9aa 正在使用其引用的映像 605c77e624dd  </code></pre><p>错误原因是：</p><pre><code>    因为在使用镜像的时候启动了容器，故得把前面使用的容器先给删除，才能继续删除镜像。</code></pre><p>解决：</p><pre><code>    直接将指令改为：docker rmi -f [镜像ID] 即可    -f 强制删除</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3510b4b2e1ba4ac0ad6bca2ab322a9a3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity微服务权限方案</title>
      <link href="/2022/11/09/SpringSecurity/SpringSecurity%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/"/>
      <url>/2022/11/09/SpringSecurity/SpringSecurity%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p><img src="../../images/image-20221109210902180.png" alt="image-20221109210902180"></p><h1 id="1认证授权过程分析"><a class="markdownIt-Anchor" href="#1认证授权过程分析"></a> 1.认证授权过程分析</h1><h2 id="微服务本质"><a class="markdownIt-Anchor" href="#微服务本质"></a> 微服务本质：</h2><p><img src="../../images/image-20221109210128213.png" alt="image-20221109210128213"></p><p><img src="../../images/image-20221109210445793.png" alt="image-20221109210445793"></p><h2 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h2><p><img src="../../images/image-20221109211556120.png" alt="image-20221109211556120"></p><h2 id="数据模型介绍"><a class="markdownIt-Anchor" href="#数据模型介绍"></a> 数据模型介绍：</h2><p><img src="../../images/image-20221109214015143.png" alt="image-20221109214015143"></p><h2 id="使用技术说明"><a class="markdownIt-Anchor" href="#使用技术说明"></a> 使用技术说明：</h2><p><img src="../../images/image-20221110144805581.png" alt="image-20221110144805581"></p><h2 id="搭建项目工程"><a class="markdownIt-Anchor" href="#搭建项目工程"></a> 搭建项目工程：</h2><p>对应教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP?p=25&amp;vd_source=746b9336d739b80b11820809545b6604">25-尚硅谷-SpringSecurity-微服务权限案例-引入项目依赖_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221110145058838.png" alt="image-20221110145058838"></p><p><img src="../../images/image-20221110150906119.png" alt="image-20221110150906119"></p><h2 id="启动redis和nacos"><a class="markdownIt-Anchor" href="#启动redis和nacos"></a> 启动Redis和Nacos:</h2><p><img src="../../images/image-20221110180707351.png" alt="image-20221110180707351"></p><h2 id="编写common工具类"><a class="markdownIt-Anchor" href="#编写common工具类"></a> 编写common工具类：</h2><p>对应教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP?p=27&amp;vd_source=746b9336d739b80b11820809545b6604">27-尚硅谷-SpringSecurity-微服务权限案例-编写common工具类_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221110184003848.png" alt="image-20221110184003848"></p><h2 id="编写security工具类"><a class="markdownIt-Anchor" href="#编写security工具类"></a> 编写security工具类：</h2><p>对应教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP/?p=28&amp;spm_id_from=333.851.header_right.history_list.click&amp;vd_source=746b9336d739b80b11820809545b6604">28-尚硅谷-SpringSecurity-微服务权限案例-编写security工具类_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221110205032587.png" alt="image-20221110205032587"></p><h4 id="21-密码处理工具类"><a class="markdownIt-Anchor" href="#21-密码处理工具类"></a> 2.1 密码处理工具类</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import atguigu.utils.utils.MD5;</span><br><span class="line">import org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/10</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DefaultPasswordEncoder implements PasswordEncoder {</span><br><span class="line"></span><br><span class="line">    public DefaultPasswordEncoder() {</span><br><span class="line">        // 调用有参构造方法，传值 -1</span><br><span class="line">        this(-1);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    public DefaultPasswordEncoder(int strength) {</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行MD5加密</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public String encode(CharSequence charSequence) {</span><br><span class="line">        return MD5.encrypt(charSequence.toString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 进行密码比对</span><br><span class="line">     * 比对一样的话返回 true，不一样的话返回false</span><br><span class="line">     * @param charSequence    加密后的密码</span><br><span class="line">     * @param encodedPassword 传入的密码</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean matches(CharSequence charSequence, String encodedPassword) {</span><br><span class="line">        return encodedPassword.equals(MD5.encrypt(charSequence.toString()));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="22-token操作工具类"><a class="markdownIt-Anchor" href="#22-token操作工具类"></a> 2.2 token操作工具类</h4><p>先导入依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>使用jwt生成token代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.security;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.CompressionCodecs;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * token工具类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenManager</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * token有效时长</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">tokenExpiration</span> <span class="operator">=</span> <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码密钥</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">tokenSignKey</span> <span class="operator">=</span> <span class="string">"123456"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 使用 jwt 根据用户名生成token</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(String username)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 设置主体信息</span></span><br><span class="line">                .setSubject(username)</span><br><span class="line">                <span class="comment">// 设置有效时长</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + tokenExpiration))</span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, tokenSignKey).compressWith(CompressionCodecs.GZIP).compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 根据token字符串得到用户信息</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUserInfoFromToken</span><span class="params">(String token)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">userinfo</span> <span class="operator">=</span> Jwts.parser().setSigningKey(tokenSignKey).parseClaimsJws(token).getBody().getSubject();</span><br><span class="line">        <span class="keyword">return</span> userinfo;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 删除token</span></span><br><span class="line"><span class="comment">     * 但是这个删除方法其实不需要我们写，因为token不需要咱们删，客户端不携带 token 就可以了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeToken</span><span class="params">(String token)</span> {}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h4 id="23-退出处理器"><a class="markdownIt-Anchor" href="#23-退出处理器"></a> 2.3 退出处理器</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> atguigu.utils.utils.R;</span><br><span class="line"><span class="keyword">import</span> atguigu.utils.utils.ResponseUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.logout.LogoutHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 退出处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenLogoutHandler</span> <span class="keyword">implements</span> <span class="title class_">LogoutHandler</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenLogoutHandler</span><span class="params">(TokenManager tokenManager, RedisTemplate redisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tokenManager = tokenManager;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logout</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Authentication authentication)</span> {</span><br><span class="line">        <span class="comment">// 1. 从header里面获取token</span></span><br><span class="line">        <span class="comment">// 2. token不为空，移除token， 从redis删除token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 移除</span></span><br><span class="line">            tokenManager.removeToken(token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从token获取用户名</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> tokenManager.getUserInfoFromToken(token);</span><br><span class="line">            <span class="comment">// key : username</span></span><br><span class="line">            redisTemplate.delete(username);</span><br><span class="line">        }</span><br><span class="line">        ResponseUtil.out(response, R.ok());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="24-未授权统一处理类"><a class="markdownIt-Anchor" href="#24-未授权统一处理类"></a> 2.4 未授权统一处理类</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import atguigu.utils.utils.R;</span><br><span class="line">import atguigu.utils.utils.ResponseUtil;</span><br><span class="line">import org.springframework.security.core.AuthenticationException;</span><br><span class="line">import org.springframework.security.web.AuthenticationEntryPoint;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line">import javax.servlet.http.HttpServletResponse;</span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 未授权统一处理类</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/10</span><br><span class="line"> */</span><br><span class="line">public class UnauthEntryPoint implements AuthenticationEntryPoint {</span><br><span class="line">    @Override</span><br><span class="line">    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {</span><br><span class="line">        ResponseUtil.out(response, R.error());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="编写security认证过滤器"><a class="markdownIt-Anchor" href="#编写security认证过滤器"></a> 编写security认证过滤器:</h2><p>对应教程视频;<a href="https://www.bilibili.com/video/BV15a411A7kP?p=29&amp;vd_source=746b9336d739b80b11820809545b6604">29-尚硅谷-SpringSecurity-微服务权限案例-编写security认证过滤器_哔哩哔哩_bilibili</a></p><h4 id="1-认证的过滤器"><a class="markdownIt-Anchor" href="#1-认证的过滤器"></a> 1. 认证的过滤器</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> atguigu.utils.utils.R;</span><br><span class="line"><span class="keyword">import</span> atguigu.utils.utils.ResponseUtil;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.SecurityUser;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.security.security.TokenManager;</span><br><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.Authentication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.AuthenticationException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.util.matcher.AntPathRequestMatcher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenLoginFilter</span> <span class="keyword">extends</span> <span class="title class_">UsernamePasswordAuthenticationFilter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由springsecurity封装的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenLoginFilter</span><span class="params">(AuthenticationManager authenticationManager, TokenManager tokenManager, RedisTemplate redisTemplate)</span> {</span><br><span class="line">        <span class="built_in">this</span>.authenticationManager = authenticationManager;</span><br><span class="line">        <span class="built_in">this</span>.tokenManager = tokenManager;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">        <span class="comment">// 设置为不仅仅是post提交</span></span><br><span class="line">        <span class="built_in">this</span>.setPostOnly(<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">// 设置登录路径，且匹配post提交</span></span><br><span class="line">        <span class="built_in">this</span>.setRequiresAuthenticationRequestMatcher(<span class="keyword">new</span> <span class="title class_">AntPathRequestMatcher</span>(<span class="string">"/admin/acl/login"</span>, <span class="string">"POST"</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1. 获取表单提交用户名和密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Authentication <span class="title function_">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException {</span><br><span class="line">        <span class="comment">// 获取表单提交数据</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().readValue(request.getInputStream(), User.class);</span><br><span class="line">            <span class="keyword">return</span> authenticationManager.authenticate(<span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(user.getUsername(), user.getPassword(),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2. 认证成功时会调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">successfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="comment">// 这个方法可以获取认证通过后的用户的信息，然后根据用户名生成token，再把它放到redis中</span></span><br><span class="line">        <span class="type">SecurityUser</span> <span class="variable">user</span> <span class="operator">=</span> (SecurityUser) authResult.getPrincipal();</span><br><span class="line">        <span class="comment">// 根据用户名生成token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenManager.createToken(user.getCurrentUserInfo().getUsername());</span><br><span class="line">        <span class="comment">// 把用户名称和用户权限列表放到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(user.getCurrentUserInfo().getUsername(), user.getPermissionValueList());</span><br><span class="line">        <span class="comment">// 返回token</span></span><br><span class="line">        ResponseUtil.out(response, R.ok().data(<span class="string">"token"</span>, token));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3. 认证失败时会调用的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">unsuccessfulAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed)</span></span><br><span class="line">            <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="comment">// 返回错误的提示</span></span><br><span class="line">        ResponseUtil.out(response, R.error());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2授权过滤器"><a class="markdownIt-Anchor" href="#2授权过滤器"></a> 2.授权过滤器</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.security.security.TokenManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.RedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.AuthenticationManager;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.authentication.UsernamePasswordAuthenticationToken;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.web.authentication.www.BasicAuthenticationFilter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.FilterChain;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenAuthFilter</span> <span class="keyword">extends</span> <span class="title class_">BasicAuthenticationFilter</span> {</span><br><span class="line">    <span class="keyword">private</span> TokenManager tokenManager;</span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenAuthFilter</span><span class="params">(AuthenticationManager authenticationManager)</span> {</span><br><span class="line">        <span class="built_in">super</span>(authenticationManager);</span><br><span class="line">        <span class="built_in">this</span>.tokenManager = tokenManager;</span><br><span class="line">        <span class="built_in">this</span>.redisTemplate = redisTemplate;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException {</span><br><span class="line">        <span class="comment">// 获取当前认证成功用户权限信息</span></span><br><span class="line">        <span class="type">UsernamePasswordAuthenticationToken</span> <span class="variable">authRequest</span> <span class="operator">=</span> getAuthentication(request);</span><br><span class="line">        <span class="comment">// 判断如果有权限信息，放到权限上下文中</span></span><br><span class="line">        <span class="keyword">if</span> (authRequest != <span class="literal">null</span>) {</span><br><span class="line">            SecurityContextHolder.getContext().setAuthentication(authRequest);</span><br><span class="line">        }</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> UsernamePasswordAuthenticationToken <span class="title function_">getAuthentication</span><span class="params">(HttpServletRequest request)</span> {</span><br><span class="line">        <span class="comment">// 从header获取token</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">"token"</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span>) {</span><br><span class="line">            <span class="comment">// 从token获取用户</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> tokenManager.getUserInfoFromToken(token);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从redis获取对应权限列表</span></span><br><span class="line">            List&lt;String&gt; permissionValueList = (List&lt;String&gt;) redisTemplate.opsForValue().get(username);</span><br><span class="line">            Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> ( String permissionValue : permissionValueList ) {</span><br><span class="line">                <span class="type">SimpleGrantedAuthority</span> <span class="variable">auth</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleGrantedAuthority</span>(permissionValue);</span><br><span class="line">                authorities.add(auth);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UsernamePasswordAuthenticationToken</span>(username, token, authorities)</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="编写entity"><a class="markdownIt-Anchor" href="#编写entity"></a> 编写entity:</h1><p>SecurityUser实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> {</span><br><span class="line">    <span class="comment">//当前登录用户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> User currentUserInfo;</span><br><span class="line">    <span class="comment">//当前权限</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissionValueList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">(User user)</span> {</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) {</span><br><span class="line">            <span class="built_in">this</span>.currentUserInfo = user;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() {</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String permissionValue : permissionValueList) {</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(permissionValue)) {</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="type">SimpleGrantedAuthority</span> <span class="variable">authority</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">SimpleGrantedAuthority</span>(permissionValue);</span><br><span class="line">            authorities.add(authority);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getPassword();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getUsername();</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>User用户实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = "用户实体类")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ApiModelProperty</span>用于swapper测试的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "微信openid")</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "密码")</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "昵称")</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "用户头像")</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = "用户签名")</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="整合网关和前端"><a class="markdownIt-Anchor" href="#整合网关和前端"></a> 整合网关和前端：</h1><p>解决跨域配置：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.reactive.CorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.reactive.CorsWebFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.util.pattern.PathPatternParser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解决跨域</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsWebFilter <span class="title function_">corsWebFilter</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">// 表示该服务器允许任何类型的请求</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 允许任何域名来源的请求</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">        <span class="comment">// 允许携带任何请求头</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">source</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>(<span class="keyword">new</span> <span class="title class_">PathPatternParser</span>());</span><br><span class="line">        <span class="comment">// 表示所有路径都允许访问</span></span><br><span class="line">        source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsWebFilter</span>((CorsConfigurationSource) source);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>配置文件：</strong></p><p><strong>application.properties：</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 端口号</span><br><span class="line">server.port=<span class="number">8222</span></span><br><span class="line"># 服务名</span><br><span class="line">spring.application.name=service-gateway</span><br><span class="line"># nacos服务地址</span><br><span class="line">spring.cloud.nacos.discovery.server-addr=<span class="number">222.177</span><span class="number">.66</span><span class="number">.230</span>:<span class="number">8848</span></span><br><span class="line"># 使服务发现路由</span><br><span class="line">spring.cloud.gateway.discovery.locator.enabled=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"># 配置路由规则</span><br><span class="line">spring.cloud.gateway.routes[<span class="number">0</span>].id=service-acl</span><br><span class="line"># 设置路由uri  lb:<span class="comment">//注册服务名称</span></span><br><span class="line">spring.cloud.gateway.routes[<span class="number">0</span>].uri=lb:<span class="comment">//service-acl</span></span><br><span class="line"># 具体路径规则</span><br><span class="line">spring.cloud.gateway.routes[<span class="number">0</span>].predicates= path=<span class="comment">/*/acl/**</span></span><br></pre></td></tr></tbody></table></figure><p>整合网关：</p><p><img src="../../images/image-20221111165948445.png" alt="image-20221111165948445"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>云服务器上部署一个Springboot的web项目（图文讲解）</title>
      <link href="/2022/11/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AASpringboot%E7%9A%84web%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%EF%BC%89/"/>
      <url>/2022/11/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E9%83%A8%E7%BD%B2%E4%B8%80%E4%B8%AASpringboot%E7%9A%84web%E9%A1%B9%E7%9B%AE%EF%BC%88%E5%9B%BE%E6%96%87%E8%AE%B2%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><strong>（PS：在部署之前，</strong></p><p><strong>1.你的虚拟机需要安装有jdk(这个Centos内部应该自带有，我的就是)和mysql（注意，如果你使用的数据库是8.0版本以上的，则需要安装mysql8.0以上的），没有安装到这两个的先自行去安装好</strong></p><p><strong>2.Linux安装好mysql后，去用sqlyog（或是Navicat或其他）连接你虚拟机的数据库</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2296b37c16204c2c8d38359697a6918d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>1.双击packege，打包项目。（注意，先鼠标选中Maven中的test然后跟着黄色箭头点击(让test被划掉)，使得在打包项目的时候跳过test步骤，不然会执行项目的测试，从而可能改动数据库的原有数据）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebb4c2a5357143c2a45ccf285a6864d4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>2.找到打包好的项目的所在目录</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eca7a429f81942b5b5f330fcc62ba0be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>3.（这一步有多种方法，我习惯这一种）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ae9faa9689464d1d83694d2b338b8e13~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>4.进入到Linux的相应目录，然后执行最后一条命令来启动springboot项目</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35d901c9c4af4ee79a05bafd8bdbcd15~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5859ee35d0744080a9e7a7f867392dda~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>5.启动成功，然后去根据虚拟机的ip端口去访问项目</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba0c92e9585a45c28b10ee909898c3f3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>(ps：如果访问超时，则需要去Linux关闭防火墙</p><p>1.首先切换回到 /root/bin目录下</p><p>2.执行命令：systemctl stop firewalld.service（关闭防火墙)</p><p>systemctl disable firewalld.service（关闭防火墙自动启动）</p><p>4.查看防火墙状态：systemctl status firewalld.service（查看防火墙服务状态）</p><p>看到这样就OK了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ad7c29b91b74c32a0a6beb7cc2fbba6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>然后再去浏览器访问，便不会超时了</p><p>）</p><p>另一种启动方式，启动过程中不会显示出日志信息，还可用命令将日志信息存到server.log中，或是存到自己创建的文件中也行</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff1b88ebd29c4ba39150042f29a9cbcb~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>这是我保存的日志信息</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77676acd5dea48d28a875724cda4fe1b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>(实体类没有写get和set方法若的祸啦)No serializer found for class com.example.domain</title>
      <link href="/2022/11/08/debug/(%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%86%99get%E5%92%8Cset%E6%96%B9%E6%B3%95%E8%8B%A5%E7%9A%84%E7%A5%B8%E5%95%A6)No%20serializer%20found%20for%20class%20com.example.domain/"/>
      <url>/2022/11/08/debug/(%E5%AE%9E%E4%BD%93%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%86%99get%E5%92%8Cset%E6%96%B9%E6%B3%95%E8%8B%A5%E7%9A%84%E7%A5%B8%E5%95%A6)No%20serializer%20found%20for%20class%20com.example.domain/</url>
      
        <content type="html"><![CDATA[<p>报错：<br>No serializer found for class com.example.domain.Men and no properties discovered to create Bean…</p><p>springboot中使用@RestController注解前台页面返回不到对象数据异常<br>异常信息<br>首页控制台会打印如下异常：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/905ba06e04a44e4d9804fc48b3b66b5b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>红色框里详细如下</p><p>No serializer found for class com.example.domain.Men and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: java.util.ArrayList[0])</p><p>原因：实体类没有写有对应的get()和set方法</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0cf9ba46ba3240a8b14b445a75e9b3f2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="解决"><a class="markdownIt-Anchor" href="#解决"></a> 解决</h2><p>在实体类写上set() 和 get() 方法即可，并在其方法前要有public</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6689833168ec45f58c52a4ec13892692~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>service层传来的总是null?</title>
      <link href="/2022/11/08/debug/service%E5%B1%82%E4%BC%A0%E6%9D%A5%E7%9A%84%E6%80%BB%E6%98%AFnull/"/>
      <url>/2022/11/08/debug/service%E5%B1%82%E4%BC%A0%E6%9D%A5%E7%9A%84%E6%80%BB%E6%98%AFnull/</url>
      
        <content type="html"><![CDATA[<p>开始写了四个接口，都没有问题，但是在写第五个接口时不行了，然后更可恶的是，前面的四个也都不行了！这这倒到底是怎么回事呢？接下来给大家分享我的情况：</p><p>报错如下图：在postman中访问接口出现报错</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/090908c0b8c145a68847eb624ad2852d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>上图表示dataSectionService返回是空，问题原因是因为上头注入DataSectionService时定义成了static，切记是这样是不能的，否则就是会报异常，即便你的dao层的返回是正常的，但是在中间service层返回给controller层时是空的了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39ddf278b52948f09394d44e41096353~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/00f4a73faacc4bfcb329fa07794e4c9d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Field restTemplate in cn.itcast.order.service.OrderService required a bean of ty</title>
      <link href="/2022/11/08/debug/Field%20restTemplate%20in%20cn.itcast.order.service.OrderService%20required%20a%20bean%20of%20ty/"/>
      <url>/2022/11/08/debug/Field%20restTemplate%20in%20cn.itcast.order.service.OrderService%20required%20a%20bean%20of%20ty/</url>
      
        <content type="html"><![CDATA[<p>错误</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0b2b4cf586a493bb7762b9241059196~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>这个错说明没有找到<a href="https://so.csdn.net/so/search?q=restTemplate&amp;spm=1001.2101.3001.7020" title="restTemplate">restTemplate</a>模板，说明没有注入到spring容器中去</p><p>解决：再Applocation上注入即可</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e68b5eeebb5b4b968a824854ef7f8efa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
        <tags>
            
            <tag> debug </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将maven项目改造成springboot项目</title>
      <link href="/2022/11/08/springboot/%E5%B0%86maven%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0%E6%88%90springboot%E9%A1%B9%E7%9B%AE/"/>
      <url>/2022/11/08/springboot/%E5%B0%86maven%E9%A1%B9%E7%9B%AE%E6%94%B9%E9%80%A0%E6%88%90springboot%E9%A1%B9%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<ol><li>pom.xml配置之springboot<br>1.1 继承springboot父项目依赖</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.7.0&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></tbody></table></figure><p>1.2  插件依赖</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>启动类配置</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SquareApplication {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        SpringApplication.run(SquareApplication.class,args);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>application.yml</li></ol>]]></content>
      
      
      <categories>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nohup命令让服务器上的程序在后台一直运行，退出终端也可以保持程序运行</title>
      <link href="/2022/11/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/nohup%E5%91%BD%E4%BB%A4%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%90%8E%E5%8F%B0%E4%B8%80%E7%9B%B4%E8%BF%90%E8%A1%8C%EF%BC%8C%E9%80%80%E5%87%BA%E7%BB%88%E7%AB%AF%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C/"/>
      <url>/2022/11/08/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/nohup%E5%91%BD%E4%BB%A4%E8%AE%A9%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84%E7%A8%8B%E5%BA%8F%E5%9C%A8%E5%90%8E%E5%8F%B0%E4%B8%80%E7%9B%B4%E8%BF%90%E8%A1%8C%EF%BC%8C%E9%80%80%E5%87%BA%E7%BB%88%E7%AB%AF%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BF%9D%E6%8C%81%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<p><strong>（本博文的方法对于阿里云和腾讯与服务器都适用 ）</strong></p><p><strong>场景：</strong></p><p>部署一个后端程序（climate-0.0.1-SNAPSHOT.jar）到我腾讯云的服务器上，常规启动命令如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar climate-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/812888ca0a09465b93439f5340381300~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>上图表示项目部署成功，便可以在浏览器上进行访问</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d91c267b89cf408c878ad9251d38dc0e~tplv-k3u1fbpfcp-zoom-1.image" alt="">但是关闭终端后，就不能访问了，也就达不到上线的效果。</p><p>而我们想项目程序在关闭退出终端后，也一样继续运行，</p><p>这时候需要使用 <strong>nohup</strong> 命令启动（该命令可以在你退出帐户/关闭终端之后继续运行相应的进程）</p><p><strong>输入如下命令：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar climate-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></tbody></table></figure><p>但是会报错（表示：执行nohup命令的时候，经常会没有写入权限的错误）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6b49d58086a4b30b43a7a9a3252bc3e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>1、原因</strong></p><p>是因为使用 nohup 会产生日志文件，默认写入到 nohup.out</p><p><strong>2、解决</strong></p><p>将 nohup 的日志输出到 /dev/null，这个目录会让所有到它这的信息自动消失</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar climate-0.0.1-SNAPSHOT.jar &gt; /dev/null 2&gt; /dev/null &amp;</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f75f1cf0fbc344d9834b1d36075e0c17~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>其它解决方法：</strong><br>就是在末尾直接加一个&amp;就就能够直接在后台运行</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar climate-0.0.1-SNAPSHOT.jar &amp; </span><br></pre></td></tr></tbody></table></figure><p><strong>停止进程</strong></p><p>如果想停止进程运行的话，可通过命令（kill -9 进程号PID）进程号来杀死</p><p>另外也可以使用 ps -def | grep “进程名” 命令来查找PID。</p><p>找到 PID 后，就可以使用 kill PID 来删除。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9  进程号PID</span><br></pre></td></tr></tbody></table></figure><p><em><strong>*如果发现启动时，查看日志发现端口号被占了*</strong></em></p><p>用 <em><strong>*lsof -i:[端口号]*</strong></em> 查看使用某端口的进程</p><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lsof</span> <span class="selector-tag">-i</span>:<span class="selector-attr">[端口号]</span> </span><br></pre></td></tr></tbody></table></figure><p>然后使用kill杀掉进城后再启动</p><p>终止后台运行的进程</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9  进程号PID</span><br></pre></td></tr></tbody></table></figure><p>比如：发现 6868 端口被占用了</p><p><img src="../../images/image-20230430132617648.png" alt="image-20230430132617648"></p>]]></content>
      
      
      <categories>
          
          <category> 云服务器 </category>
          
          <category> 部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云服务器 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot-MyBatis配置带下划线命名的字段自动转换驼峰命名解决方案</title>
      <link href="/2022/11/08/springboot/Spring%20Boot-MyBatis%E9%85%8D%E7%BD%AE%E5%B8%A6%E4%B8%8B%E5%88%92%E7%BA%BF%E5%91%BD%E5%90%8D%E7%9A%84%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2022/11/08/springboot/Spring%20Boot-MyBatis%E9%85%8D%E7%BD%AE%E5%B8%A6%E4%B8%8B%E5%88%92%E7%BA%BF%E5%91%BD%E5%90%8D%E7%9A%84%E5%AD%97%E6%AE%B5%E8%87%AA%E5%8A%A8%E8%BD%AC%E6%8D%A2%E9%A9%BC%E5%B3%B0%E5%91%BD%E5%90%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>问题描述<br>MyBatis无法查询出属性名和数据库字段名不完全相同的数据。</p><p>即：属性名和数据库字段名分别为驼峰命名和下划线命名时查出的数据为NULL。</p><p>问题分析<br>MyBatis默认是属性名和数据库字段名一一对应的，即</p><blockquote><p>数据库表列：user_name</p><p>实体类属性：user_name</p></blockquote><p>但是java中一般使用驼峰命名</p><blockquote><p>数据库表列：user_name</p><p>实体类属性：userName</p></blockquote><p>实体类属性：userName</p><p><strong>解决方案 (开启驼峰命名转换)</strong><br>在Spring Boot中，可以通过设置<strong>map-underscore-to-camel-case</strong>属性为true来开启驼峰功能。</p><p>MyBatis配置：</p><p><strong>application.properties中：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></tbody></table></figure><p><strong>application.yml中：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">    map-underscore-to-camel-case: true</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatisplus </category>
          
          <category> springboot </category>
          
      </categories>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> mybatisplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mybatisplus + 数据库 相关注解</title>
      <link href="/2022/11/08/springboot/mybatisplus%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93%20%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/"/>
      <url>/2022/11/08/springboot/mybatisplus%20+%20%E6%95%B0%E6%8D%AE%E5%BA%93%20%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>关联：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5591d4a48c140d190c89a416d1e0e30~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>pom.xml配置注入依赖：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c519c49613b4b95b4635e6a0e4c78d4~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="" alt="" title="点击并拖拽以移动"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--        mybatisplus+数据库相关开始--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.4.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;!--        mybatisplus+数据库相关结束--&gt;</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> mybatisplus </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mybatisplus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（rabbitmq的高级特性）消息可靠性</title>
      <link href="/2022/11/08/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
      <url>/2022/11/08/MQ/%EF%BC%88rabbitmq%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%EF%BC%89%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="对应的教程视频"><a class="markdownIt-Anchor" href="#对应的教程视频"></a> 对应的教程视频：</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1LQ4y127n4?p=158&amp;spm_id_from=333.851.header_right.history_list.click&amp;vd_source=746b9336d739b80b11820809545b6604" title="高级篇Day5-01-MQ常见问题及消息可靠性_哔哩哔哩_bilibili">高级篇Day5-01-MQ常见问题及消息可靠性_哔哩哔哩_bilibili</a></p></blockquote><h1 id="一-生产者消息确认"><a class="markdownIt-Anchor" href="#一-生产者消息确认"></a> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/976c4e3d38b843599bc3342a347cdce9~tplv-k3u1fbpfcp-zoom-1.image" alt="">一、生产者消息确认</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9499d135a8b84556bd7d16d790c1594f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="1在生成者这个微服务的apllicationyml中添加配置"><a class="markdownIt-Anchor" href="#1在生成者这个微服务的apllicationyml中添加配置"></a> 1.在生成者这个微服务的apllication.yml中添加配置<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a8b6d8c3569343339e077fe63939adb3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/977d66ad1951428e86d00bd13147c136~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  rabbitmq:</span><br><span class="line">    publisher-confirm-type: correlated</span><br><span class="line">    publisher-returns: true</span><br><span class="line">    template:</span><br><span class="line">      mandatory: true</span><br></pre></td></tr></tbody></table></figure><h3 id="2每个rabbittemplate只能配置一个returncallback因此需要在项目启动过程中配置"><a class="markdownIt-Anchor" href="#2每个rabbittemplate只能配置一个returncallback因此需要在项目启动过程中配置"></a> 2.每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目启动过程中配置</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8058dadf229f4f089249b9b905e33bf9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/23223eb1f684431ebba0fe3d179676f0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>代码：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.BeansException;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.context.ApplicationContextAware;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">/*</span><br><span class="line">ApplicationContextAware ： spring 的bean工厂的通知</span><br><span class="line"> */</span><br><span class="line">@Slf4j  //记录日志</span><br><span class="line">@Configuration</span><br><span class="line">public class CommonConfig implements ApplicationContextAware {</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {</span><br><span class="line">        // 从bean工厂中获取 RabbitTemplate 对象</span><br><span class="line">        RabbitTemplate rabbitTemplate = applicationContext.getBean( RabbitTemplate.class );</span><br><span class="line">        // 配置ReturnCallback</span><br><span class="line">//        rabbitTemplate.setReturnCallback(new RabbitTemplate.ReturnCallback() {</span><br><span class="line">//            // 像这种里面只有一个方法的，把鼠标方法 new 前面，会提醒 推荐用lambda表达式，快捷键 Alt + Enter</span><br><span class="line">//            @Override</span><br><span class="line">//            public void returnedMessage(Message message, int i, String s, String s1, String s2) {</span><br><span class="line">//</span><br><span class="line">//            }</span><br><span class="line">//        });</span><br><span class="line">        // 像这种里面只有一个方法的，把鼠标方法 new 前面，会提醒 推荐用lambda表达式，快捷键 Alt + Enter</span><br><span class="line">        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {</span><br><span class="line">            // 记录日志 【 {}是占位符，replyCode, replyText, exchange...会依次填进占位符里的 】</span><br><span class="line">            log.error( "消息发送到队列失败，响应码：{}, 失败原因：{}, 交换机：{}, 路由key：{}, 消息：{}", </span><br><span class="line">                    replyCode, replyText, exchange, routingKey, message.toString() );</span><br><span class="line"></span><br><span class="line">            // 如果有需要的话，可以重发消息</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3发送消息指定消息id-消息confirmcallback"><a class="markdownIt-Anchor" href="#3发送消息指定消息id-消息confirmcallback"></a> 3.发送消息，指定消息ID、消息ConfirmCallback</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/562749aa0959434bac83cf26a34124a3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line">import org.springframework.util.concurrent.FailureCallback;</span><br><span class="line">import org.springframework.util.concurrent.SuccessCallback;</span><br><span class="line"></span><br><span class="line">import java.util.UUID;</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringAmqpTest {</span><br><span class="line">    @Autowired</span><br><span class="line">    private RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testSendMessage2SimpleQueue() throws InterruptedException {</span><br><span class="line">        // 1.准备消息</span><br><span class="line">        String message = "hello, spring amqp!";</span><br><span class="line"></span><br><span class="line">        // 2.准备CorrelationData</span><br><span class="line">        // 2.1.消息ID</span><br><span class="line">        CorrelationData correlationData = new CorrelationData( UUID.randomUUID().toString() );</span><br><span class="line">        // 2.2.准备ConfirmCallback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        correlationData.getFuture().addCallback(result -&gt; {   //成功回调</span><br><span class="line">            // 判断结果</span><br><span class="line">            if( result.isAck() ) {</span><br><span class="line">                // ACK</span><br><span class="line">                log.debug( "消息成功投递到交换机！消息ID：{}", correlationData.getId() );</span><br><span class="line">            } else {</span><br><span class="line">                //NACK</span><br><span class="line">                log.error( "消息投递到交换机失败！消息ID：{}", correlationData.getId() );</span><br><span class="line">                // 重发消息</span><br><span class="line">            }</span><br><span class="line">        }, ex -&gt; {   //失败回调</span><br><span class="line">            //记录日志</span><br><span class="line">            log.error( "消息发送失败！", ex );</span><br><span class="line">        });</span><br><span class="line">        // 2.发送消息</span><br><span class="line">        rabbitTemplate.convertAndSend("amq.topic", "simple.text", message);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试：</p><p>（给交换机添加绑定关系，这一步看情况做，如果绑定关系已经有的了的表不需要这一步）</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/467fcbdbb5a44297aa42c52fdb8e1baf~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>测试错误例子</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2a8933eca3e4ec7ade295c93c9ad222~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>4.总结</strong></p><p><strong>SpringAMQP中处理消息确认的几种情况：</strong></p><p><strong>publisher-comfirm：</strong></p><p>• 消息成功发送到exchange，返回ack</p><p>• 消息发送失败，没有到达交换机，返回nack</p><p>• 消息发送过程中出现异常，没有收到回执</p><p><strong>消息成功发送到exchange，但没有路由到queue，调用ReturnCallback</strong></p><p>​</p><h1 id="二-消息持久化"><a class="markdownIt-Anchor" href="#二-消息持久化"></a> 二、消息持久化</h1><p>MQ默认的是内存存储，如果mq发生了宕机，数据是可能丢失。如果要想数据安全，就要做到持久化，也就是能将数据写进磁盘里</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82eff0c6db2c4e1da180b1e059bd4b3c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb553ed03d294385affcf50f0427df5a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码：</h3><p>交换机和队列持久化</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.*;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CommonConfig {</span><br><span class="line"></span><br><span class="line">    // 交换机持久化</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange simpleDirect() {</span><br><span class="line">        // 三个参数：              交换机名称、是否持久化、 当没有queue与其绑定时是否自动删除</span><br><span class="line">        return new DirectExchange( "simple.direct", true, false );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    // 队列持久化</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue simpleQueue() {</span><br><span class="line">        // 使用QueueBuilder构建队列，durable就是持久化的   nonDurable()非持久化的</span><br><span class="line">        return QueueBuilder.durable( "simple.queue" ).build();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>交换机、队列持久了，但并不代表消息就能持久了，所以必须做消息持久化</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66f17c8189b145d190787baebca25d49~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 1.准备消息   MessageDeliveryMode.PERSISTENT 消息持久化，这样重启mq消息也可以保留</span><br><span class="line">        Message message =  MessageBuilder.withBody( "hello, spring".getBytes(StandardCharsets.UTF_8) )</span><br><span class="line">                .setDeliveryMode( MessageDeliveryMode.PERSISTENT )</span><br><span class="line">                .build();</span><br></pre></td></tr></tbody></table></figure><p><font color="blue"><strong>交换机 和 队列 创建 以及 发送消息 的源码其实<mark>默认的就是 持久化</mark> 的</strong></font></p><p><strong>而之所以学，是因为我们有时候为了提高性能，便可以将一些非必要的设置为 非持久化</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/87c46b7545ef43dcb468372b93620180~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32741e57ce240bd8761e095794c2193~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><h1 id="三-消费者消息确认"><a class="markdownIt-Anchor" href="#三-消费者消息确认"></a> 三、消费者消息确认</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fad642f6fcf4ab9b966cef09c4b3445~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>测试 auto：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2e1291b6a64428d87c95da9ef5016f4~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>进入simple.queue生产一条消息</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94c067caf9eb425d8c4de611b67a865b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>填写 消息并发送</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8a08671d0cb84bf29df8fd390436d54b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>刷新</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ef90187423a43648814b93947f13ac1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3a2bbbd542374023830cdc420f643ac0~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><font color="red"> <strong>当消费者出现异常后，消息会不断requeue（重新入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力</strong></font>：<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f6cdddbe6e854216b3a503de4280709b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>auto模式 这种情况下，虽然也不好，mq一直在尝试，但是至少消息不会丢失，</p><p>auto的这种遇到处理失败后一直投递再投递，这种处理方式不太友好，但是可以改的，看<strong>四、失败重试机制</strong></p><h1 id="四-失败重试机制"><a class="markdownIt-Anchor" href="#四-失败重试机制"></a> 四、失败重试机制</h1><h1 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6111acbe4a3e4f06a3855f43490dfa68~tplv-k3u1fbpfcp-zoom-1.image" alt=""></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba41987a46c8400e8ab03b2c2504eb2d~tplv-k3u1fbpfcp-zoom-1.image" alt=""><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3201199944734eaeb90e58883dc1a6ff~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>重试次数耗尽之后，其实会返回一个reject拒绝，然后就会把消息丢弃，<strong>这是重试机制的默认策略</strong><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6e70936b61b43e6bc7e35afaee51c62~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>重试次数耗尽之后，会把消息丢弃，事实上丢弃也没事，因为已经重试了那么多次了，还是失败的，即便把消息再丢回给mq，mq再投递给你，也还是会失败。</p><p>那么除了丢弃，还有没有其它的策略呢？有的…</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7e2fd1adaeb342e1bfa9663c7efad8b2~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>这种方案是最健康的方案了，也建议在生产环境下 使用这种方案</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc1f72677ca147068b7be687d1ba882d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package cn.itcast.mq.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.DirectExchange;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line">import org.springframework.amqp.rabbit.retry.MessageRecoverer;</span><br><span class="line">import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class ErrormessageConfig {</span><br><span class="line"></span><br><span class="line">    //首先，定义接收失败消息的交换机、队列及其绑定关系：</span><br><span class="line">    @Bean</span><br><span class="line">    public DirectExchange errorMessageExchange() {</span><br><span class="line">        return new DirectExchange( "error.direct" );</span><br><span class="line">    }</span><br><span class="line">    @Bean</span><br><span class="line">    public Queue errorQueue() {</span><br><span class="line">        return new Queue( "error.queue" );</span><br><span class="line">    }</span><br><span class="line">    @Bean</span><br><span class="line">    public Binding errorMessageBinding() {</span><br><span class="line">        return BindingBuilder.bind( errorQueue() ).to( errorMessageExchange() ).with( "errpr" );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //定义RepublishMessageRecoverer 会 覆盖spring默认的默bean (我们想覆盖spring默认的bean，重新定义一个bean即可)</span><br><span class="line">    @Bean</span><br><span class="line">    public MessageRecoverer republishMessageRecoverer( RabbitTemplate rabbitTemplate ) {</span><br><span class="line">        return new RepublishMessageRecoverer( rabbitTemplate,  "error.direct", "error" );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7188c75381374c40869984b806ae0369~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/60d536df891f4153a02300de3ea88a63~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9720db6dd8c14a87b2b82299baaeb1d3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/631d7785be334e069f5d327a1db94a2a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> MQ </category>
          
          <category> rabbitmq </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rabbitmq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo博客上的图片路径问题解决方法</title>
      <link href="/2022/11/07/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo%E4%B8%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/"/>
      <url>/2022/11/07/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo%E4%B8%8A%E5%9B%BE%E7%89%87%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<ol><li>通过下面命令下载插件:</li></ol><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-renderer-marked</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20221107182147634.png" alt="image-20221107182147634"></p><ol start="2"><li>在自己的博客的source路劲下新建一个images文件夹</li></ol><p><img src="../../images/image-20221107182334417.png" alt="image-20221107182334417"></p><ol start="3"><li>在typora，进入到 文件–&gt;偏好设置–&gt;图像，然后选择复制到指定路径，选到上面新建的images文件夹路径，勾选下面红框的选项</li></ol><p><img src="../../images/image-20221107182509496.png" alt="image-20221107182509496"></p><ol start="4"><li><p>修改你博客的配置文件**_config.yml**</p><ol><li><p>修改配置：<img src="../../images/image-20221107183227789.png" alt="image-20221107183227789"></p></li><li><p>添加上下面语句：<img src="../../images/image-20221107183236670.png" alt="image-20221107183236670"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">marked:</span><br><span class="line">  prependRoot: true</span><br><span class="line">  postAsset: true</span><br></pre></td></tr></tbody></table></figure></li></ol></li></ol><p>之后，你每次复制图片过来，图片路径就是相对路径了<img src="../../images/image-20221107182744468.png" alt="image-20221107182744468"></p><p>当然，对于网络位置的图片回自动是网络上的图片链接，这种图片在博客上是完全没问题的，比如：</p><p><img src="../../images/image-20221107182938178.png" alt="image-20221107182938178"></p>]]></content>
      
      
      <categories>
          
          <category> hexo博客 </category>
          
          <category> 解决问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mapping索引属性 &amp; 创建索的操作</title>
      <link href="/2022/11/07/elasticsearch/mapping%E7%B4%A2%E5%BC%95%E5%B1%9E%E6%80%A7%20&amp;%20%E5%88%9B%E5%BB%BA%E7%B4%A2%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/07/elasticsearch/mapping%E7%B4%A2%E5%BC%95%E5%B1%9E%E6%80%A7%20&amp;%20%E5%88%9B%E5%BB%BA%E7%B4%A2%E7%9A%84%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p><strong>概念对比</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ae5fe2a56a242239dfbb8d5ffad5c77~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="一-mapping索引属性"><a class="markdownIt-Anchor" href="#一-mapping索引属性"></a> 一. mapping索引属性</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2d5c03e735ed4dcd83fba915c066cdb3~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="二-索引库的操作"><a class="markdownIt-Anchor" href="#二-索引库的操作"></a> 二. 索引库的操作</h1><h2 id="1-创建索引库"><a class="markdownIt-Anchor" href="#1-创建索引库"></a> 1. 创建索引库</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b8c0a579dbdb483a84a112d0f1e0db78~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe320ace6ee740d3b1c269b71a2becad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>实例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#创建索引库</span><br><span class="line">PUT /heima</span><br><span class="line">{</span><br><span class="line">  "mappings": {</span><br><span class="line">    "properties": {</span><br><span class="line">      "info": {</span><br><span class="line">        "type": "text",</span><br><span class="line">        "analyzer": "ik_smart"</span><br><span class="line">      },</span><br><span class="line">      "email": {</span><br><span class="line">        "type": "keyword",</span><br><span class="line">        "index": false</span><br><span class="line">      },</span><br><span class="line">      "name": {</span><br><span class="line">        "type": "object",</span><br><span class="line">        "properties": {</span><br><span class="line">          "firstname": {</span><br><span class="line">            "type": "keyword"</span><br><span class="line">          },</span><br><span class="line">          "lastname": {</span><br><span class="line">            "type": "keyword"</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6f29631d07cc4265b1c347cea62657f9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="2-索引库的其他操作查看删除修改只能添加新的字段"><a class="markdownIt-Anchor" href="#2-索引库的其他操作查看删除修改只能添加新的字段"></a> 2. 索引库的其他操作（<strong>查看，删除，修改（只能添加新的字段</strong>））：</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a19018b3b804d24875641aba2283dfe~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9adc29f8d9a74cfebce28a884ff52f8f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>ps:索引库创建好后</p><pre><code>    理论上是可以进行修改的    但是实际开发中，是**禁止去修改**原有的字段的（**但可以添加新的字段**），因为修改会**对性能的影响是很大**的，可能会导致整个库都不可用</code></pre><p>​</p><p>（实例）代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 查询</span><br><span class="line">GET /heima</span><br><span class="line"></span><br><span class="line"># 修改索引库，添加新字段</span><br><span class="line">PUT /heima/_mapping</span><br><span class="line">{</span><br><span class="line">  "properties": {</span><br><span class="line">    "age": {</span><br><span class="line">      "type": "integer"</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line">DELETE /heima</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestClient操作索引库-初始化RestClient</title>
      <link href="/2022/11/07/elasticsearch/RestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93-%E5%88%9D%E5%A7%8B%E5%8C%96RestClient/"/>
      <url>/2022/11/07/elasticsearch/RestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93-%E5%88%9D%E5%A7%8B%E5%8C%96RestClient/</url>
      
        <content type="html"><![CDATA[<p>1.引入es的RestHighLevelClient依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--elasticsearch--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">     &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;</span><br><span class="line">     &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;</span><br><span class="line">     &lt;version&gt;7.12.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p>2.因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5786c69065043e093ba25dbd976d6d7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>3.初始化RestHighLevelClient：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return new RestHighLevelClient(RestClient.builder(</span><br><span class="line">                HttpHost.create("http://192.168.150.101:9200")</span><br><span class="line">));</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef0bee698bbd4d65a9ae016cd3db8af6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestAPI实现自动补全 &amp; 案例实现（搜索框输入进行自动补全）</title>
      <link href="/2022/11/07/elasticsearch/RestAPI%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%20&amp;%20%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%90%9C%E7%B4%A2%E6%A1%86%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%EF%BC%89/"/>
      <url>/2022/11/07/elasticsearch/RestAPI%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%20&amp;%20%E6%A1%88%E4%BE%8B%E5%AE%9E%E7%8E%B0%EF%BC%88%E6%90%9C%E7%B4%A2%E6%A1%86%E8%BE%93%E5%85%A5%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="一-restapi实现自动补全查询代码讲解"><a class="markdownIt-Anchor" href="#一-restapi实现自动补全查询代码讲解"></a> 一、RestAPI实现自动补全查询（代码讲解）</h1><h1 id=""><a class="markdownIt-Anchor" href="#"></a> <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/691a87ed40d74802b9a828ac3e6d9143~tplv-k3u1fbpfcp-zoom-1.image" alt=""></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9c9b7ccedcac4942bf81110db9feb355~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/11c56098294b43ef8f5d0e973ba0f217~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b93f6065a15a48209cd50596642890b6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    @Autowired</span><br><span class="line">    private RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void testSuggestion() throws IOException {</span><br><span class="line">        //1.准备Request</span><br><span class="line">        SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">        //2.准备DSL</span><br><span class="line">        request.source().suggest(new SuggestBuilder().addSuggestion(</span><br><span class="line">                "suggestions",</span><br><span class="line">                SuggestBuilders.completionSuggestion("suggestion")</span><br><span class="line">                        .prefix("hm")</span><br><span class="line">                        .skipDuplicates(true)</span><br><span class="line">                        .size(10)</span><br><span class="line">        ));</span><br><span class="line">        //3.发起请求</span><br><span class="line">        SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        //4.解析结果</span><br><span class="line">        Suggest suggest = response.getSuggest();</span><br><span class="line">        //4.1 根据补全查询名称，获取更全的结果</span><br><span class="line">        CompletionSuggestion suggestions = suggest.getSuggestion("suggestions");</span><br><span class="line">        //4,2 获取options</span><br><span class="line">        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">        //4.3 遍历</span><br><span class="line">        for( CompletionSuggestion.Entry.Option option : options){</span><br><span class="line">            String text = option.getText().toString();</span><br><span class="line">            System.out.println(text);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">//        System.out.println(response);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>其中：</p><p>@Autowired<br>private RestHighLevelClient client;</p><p>要在项目启动方法里面注入到bean里</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f87a3158ddd345dd91aef1107db73bbd~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="二-以下进行黑马旅游网的案例实现自动补全功能"><a class="markdownIt-Anchor" href="#二-以下进行黑马旅游网的案例实现自动补全功能"></a> 二、以下进行黑马旅游网的案例实现自动补全功能：</h1><p>开始时，输入x，不能自动补全</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7fa557cad6c04bf59cc42408b716f3aa~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>RestAPI实现自动补全：</p><h2 id="1在controller层写好接口"><a class="markdownIt-Anchor" href="#1在controller层写好接口"></a> （1）在controller层写好接口</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e106fbadcc474ebab6cece2e59aa5f68~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@GetMapping("suggestion")</span><br><span class="line">    public List&lt;String&gt; getSuggestions(@RequestParam("key") String predix){</span><br><span class="line">        return hotelService.getSuggestions(predix);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h2 id="2在service层写好"><a class="markdownIt-Anchor" href="#2在service层写好"></a> （2）在service层写好</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/eb71b469d2954c14a6c1bbc199626447~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public List&lt;String&gt; getSuggestions(String predix) {</span><br><span class="line">       try {</span><br><span class="line">           //1.准备Request</span><br><span class="line">           SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">           //2.准备DSL</span><br><span class="line">           request.source().suggest(new SuggestBuilder().addSuggestion(</span><br><span class="line">                   "suggestions",</span><br><span class="line">                   SuggestBuilders.completionSuggestion("suggestion")</span><br><span class="line">                           .prefix(predix)</span><br><span class="line">                           .skipDuplicates(true)</span><br><span class="line">                           .size(10)</span><br><span class="line">           ));</span><br><span class="line">           //3.发起请求</span><br><span class="line">           SearchResponse response = client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">           //4.解析结果</span><br><span class="line">           Suggest suggest = response.getSuggest();</span><br><span class="line">           //4.1 根据补全查询名称，获取更全的结果</span><br><span class="line">           CompletionSuggestion suggestions = suggest.getSuggestion("suggestions");</span><br><span class="line">           //4,2 获取options</span><br><span class="line">           List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">           //4.3 遍历</span><br><span class="line">           List&lt;String&gt; list = new ArrayList&lt;String&gt;(options.size());</span><br><span class="line">           for( CompletionSuggestion.Entry.Option option : options){</span><br><span class="line">               String text = option.getText().toString();</span><br><span class="line">               System.out.println(text);</span><br><span class="line">               list.add(text);</span><br><span class="line">           }</span><br><span class="line">           return list;</span><br><span class="line">       } catch (IOException e) {</span><br><span class="line">           throw  new RuntimeException();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><h2 id="3重新启动项目"><a class="markdownIt-Anchor" href="#3重新启动项目"></a> (3)重新启动项目</h2><p>便可以进行自动补全了</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ec50f82380f64659a212c21acf7788e9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设置索引库结构，给用户添加可自动补全的suggestion,并将一些字段变成集合放到suggestion里面去</title>
      <link href="/2022/11/07/elasticsearch/%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95%E5%BA%93%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E5%8F%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%9A%84suggestion,%E5%B9%B6%E5%B0%86%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%98%E6%88%90%E9%9B%86%E5%90%88%E6%94%BE%E5%88%B0suggestion%E9%87%8C%E9%9D%A2%E5%8E%BB/"/>
      <url>/2022/11/07/elasticsearch/%E8%AE%BE%E7%BD%AE%E7%B4%A2%E5%BC%95%E5%BA%93%E7%BB%93%E6%9E%84%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%B7%BB%E5%8A%A0%E5%8F%AF%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E7%9A%84suggestion,%E5%B9%B6%E5%B0%86%E4%B8%80%E4%BA%9B%E5%AD%97%E6%AE%B5%E5%8F%98%E6%88%90%E9%9B%86%E5%90%88%E6%94%BE%E5%88%B0suggestion%E9%87%8C%E9%9D%A2%E5%8E%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="设置索引库结构给用户添加可自动补全的suggestion并将一些字段变成集合放到suggestion里面去"><a class="markdownIt-Anchor" href="#设置索引库结构给用户添加可自动补全的suggestion并将一些字段变成集合放到suggestion里面去"></a> 设置索引库结构，给用户添加可自动补全的suggestion,并将一些字段变成集合放到suggestion里面去</h2><p><img src="../../images/image-20230313225514389.png" alt="image-20230313225514389"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c58d88178fb4eff90f30708588d655a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="若business有多个sss值可进行切割"><a class="markdownIt-Anchor" href="#若business有多个sss值可进行切割"></a> 若business有多个sss值，可进行切割</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59f563f1828449d48c8bf840d977022d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h2 id="进行切割"><a class="markdownIt-Anchor" href="#进行切割"></a> 进行切割</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//将brand 和 business 变成集合放到suggestion里</span><br><span class="line">       if(this.business.contains("/")){</span><br><span class="line">           //business有多个值，需要切割</span><br><span class="line">           String[] arr = this.business.split("/");</span><br><span class="line">           //添加元素</span><br><span class="line">           this.suggestion = new ArrayList&lt;String&gt;();</span><br><span class="line">           Collections.addAll(this.suggestion,arr);</span><br><span class="line">       }else</span><br><span class="line">           this.suggestion = Arrays.asList(this.brand,this.business);</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c2384e18ccb4c8aa3cbecddfd1cb08e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>切割成功</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fc609a734bf546588dc599cac6669bd1~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSL实现自动补全查询</title>
      <link href="/2022/11/07/elasticsearch/DSL%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2/"/>
      <url>/2022/11/07/elasticsearch/DSL%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html" title="Completion Suggester">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><p>• 参与补全查询的字段必须是<strong>completion</strong>类型。</p><pre><code>   • 字段的内容一般是用来补全的多个词条形成的**数组**。</code></pre><p>查询语法如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 自动补全查询</span><br><span class="line">GET /test/_search</span><br><span class="line">{</span><br><span class="line">  "suggest": {</span><br><span class="line">    "title_suggest": {</span><br><span class="line">      "text": "s", // 关键字</span><br><span class="line">      "completion": {</span><br><span class="line">        "field": "title", // 补全查询的字段</span><br><span class="line">        "skip_duplicates": true, // 跳过重复的</span><br><span class="line">        "size": 10 // 获取前10条结果</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>测试：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ebc7c2dd979d46109816b3b5e157e466~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动补全 &amp; （自定义）拼音分词器 &amp; 搜索时注意事项</title>
      <link href="/2022/11/07/elasticsearch/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%20&amp;%20%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%89%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8%20&amp;%20%E6%90%9C%E7%B4%A2%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
      <url>/2022/11/07/elasticsearch/%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8%20&amp;%20%EF%BC%88%E8%87%AA%E5%AE%9A%E4%B9%89%EF%BC%89%E6%8B%BC%E9%9F%B3%E5%88%86%E8%AF%8D%E5%99%A8%20&amp;%20%E6%90%9C%E7%B4%A2%E6%97%B6%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="自动补全"><a class="markdownIt-Anchor" href="#自动补全"></a> 自动补全：</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/727c6f47f37f4bd8b83ecb9bebb33aab~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin" title="GitHub - medcl/elasticsearch-analysis-pinyin: This Pinyin Analysis plugin is used to do conversion between Chinese characters and Pinyin.">GitHub - medcl/elasticsearch-analysis-pinyin: This Pinyin Analysis plugin is used to do conversion between Chinese characters and Pinyin.</a></p><h2 id="用初始化的拼音分词器进行分词"><a class="markdownIt-Anchor" href="#用初始化的拼音分词器进行分词"></a> 用初始化的拼音分词器进行分词：</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20550059a1414aeba684b69474dbd00f~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>为了实现得到的分词有中文也有拼音，我门需要</p><h1 id="自定义拼音分词器中文-拼音"><a class="markdownIt-Anchor" href="#自定义拼音分词器中文-拼音"></a> 自定义拼音分词器（中文 + 拼音）</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/54b101fabd25411aada38a0d4bf707f7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/97823625e9e74820b861218b2a14d764~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 自定义拼音分词器</span><br><span class="line">PUT /test</span><br><span class="line">{</span><br><span class="line">  "settings": {</span><br><span class="line">    "analysis": {</span><br><span class="line">      "analyzer": { </span><br><span class="line">        "my_analyzer": { </span><br><span class="line">          "tokenizer": "ik_max_word",</span><br><span class="line">          "filter": "py"</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      "filter": {</span><br><span class="line">        "py": { </span><br><span class="line">          "type": "pinyin",</span><br><span class="line">          "keep_full_pinyin": false,</span><br><span class="line">          "keep_joined_full_pinyin": true,</span><br><span class="line">          "keep_original": true,</span><br><span class="line">          "limit_first_letter_length": 16,</span><br><span class="line">          "remove_duplicated_term": true,</span><br><span class="line">          "none_chinese_pinyin_tokenize": false</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  "mappings": {</span><br><span class="line">    "properties": {</span><br><span class="line">      "name":{</span><br><span class="line">        "type": "text",</span><br><span class="line">        "analyzer": "my_analyzer"</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="测试方式1"><a class="markdownIt-Anchor" href="#测试方式1"></a> 测试方式1：</h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f58e13d1768e44b6b6556198ecca868b~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 测试 自定义的分词器 的方式1</span><br><span class="line">POST /test/_analyze</span><br><span class="line">{</span><br><span class="line">  "text": ["如家酒店还不错"],</span><br><span class="line">  "analyzer": "my_analyzer"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="测试-自定义的分词器-的方式2-先添加两个-拼音相同的-字段-后搜索"><a class="markdownIt-Anchor" href="#测试-自定义的分词器-的方式2-先添加两个-拼音相同的-字段-后搜索"></a> <strong>测试 自定义的分词器 的方式2: 先添加两个 拼音相同的 字段， 后搜索</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b83a41a21ac44b8ba1bb160d05dfb0ad~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 测试 自定义的分词器 的方式2</span><br><span class="line">#先添加两个 拼音相同的 字段， 后搜索</span><br><span class="line">POST /test/_doc/1</span><br><span class="line">{</span><br><span class="line">  "id": 1,</span><br><span class="line">  "name": "狮子"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">POST /test/_doc/2</span><br><span class="line">{</span><br><span class="line">  "id": 2,</span><br><span class="line">  "name": "虱子"</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">GET /test/_search</span><br><span class="line">{</span><br><span class="line">  "query": {</span><br><span class="line">    "match": {</span><br><span class="line">      "name": "shizi"</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="注意事项"><a class="markdownIt-Anchor" href="#注意事项"></a> 注意事项：</h1><pre><code>    问题：当我用自定义的拼音分词器去搜索一段又狮子的中文时，却也搜出了库里面的的虱子，因为“狮子”和“虱子”有着相同的拼音，而拼音分词器就是可以将相同拼音的中文都搜出来</code></pre><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a08f04fd4074946bc7e792a8722dc6d~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>解决：</p><pre><code>  为了避免搜索到同拼音字，搜索时不要用拼音分词器</code></pre><p>​</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2687fedd3364fabbefedb2c55c6289a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>删库，重设置和重建索引库，再重新测试上面的测试方式2就可以了</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a5c99ca9c04e4707a474d6acbaaf1aa9~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><strong>代码：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//删除库</span><br><span class="line">DELETE /test</span><br><span class="line"></span><br><span class="line">// 自定义拼音分词器</span><br><span class="line">PUT /test</span><br><span class="line">{</span><br><span class="line">  "settings": {</span><br><span class="line">    "analysis": {</span><br><span class="line">      "analyzer": { </span><br><span class="line">        "my_analyzer": { </span><br><span class="line">          "tokenizer": "ik_max_word",</span><br><span class="line">          "filter": "py"</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      "filter": {</span><br><span class="line">        "py": { </span><br><span class="line">          "type": "pinyin",</span><br><span class="line">          "keep_full_pinyin": false,</span><br><span class="line">          "keep_joined_full_pinyin": true,</span><br><span class="line">          "keep_original": true,</span><br><span class="line">          "limit_first_letter_length": 16,</span><br><span class="line">          "remove_duplicated_term": true,</span><br><span class="line">          "none_chinese_pinyin_tokenize": false</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  },</span><br><span class="line">  "mappings": {</span><br><span class="line">    "properties": {</span><br><span class="line">      "name":{</span><br><span class="line">        "type": "text",</span><br><span class="line">        "analyzer": "my_analyzer",</span><br><span class="line">        "search_analyzer": "ik_smart"</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>测试（和上面的测试方式2一样）：</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ab02a4a307ec45f888e27b2cda2a30f6~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>总结：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4aabf0e2fdbe468b9434e69eda633850~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="dsl实现自动补全查询"><a class="markdownIt-Anchor" href="#dsl实现自动补全查询"></a> DSL实现自动补全查询：</h1><p><a href="https://blog.csdn.net/QRLYLETITBE/article/details/125784439?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22125784439%22%2C%22source%22%3A%22QRLYLETITBE%22%7D&amp;ctrtid=H8ap4" title="(45条消息) DSL实现自动补全查询_其然乐衣的博客-CSDN博客">(45条消息) DSL实现自动补全查询_其然乐衣的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestClient-多条件聚合</title>
      <link href="/2022/11/07/elasticsearch/RestClient-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E8%81%9A%E5%90%88/"/>
      <url>/2022/11/07/elasticsearch/RestClient-%E5%A4%9A%E6%9D%A1%E4%BB%B6%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/706377c31d5a4e9b8c4e7f6d2e0c52be~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>在对应的service层里面写：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/327ec6a5daef4bfd9070a4611fae8b4c~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e9cf3f32805433283776afded9729d7~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p>HotelService里的代码如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public Map&lt;String, List&lt;String&gt;&gt; filters()  {</span><br><span class="line"></span><br><span class="line">        try {</span><br><span class="line">            //1. 准备Request</span><br><span class="line">            SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">            //2. 准备DSL</span><br><span class="line">            //2.1 设置size</span><br><span class="line">            request.source().size(0);</span><br><span class="line">            //2.2 聚合</span><br><span class="line">            buildAggretgaion(request);</span><br><span class="line"></span><br><span class="line">            //3. 发出请求</span><br><span class="line">            SearchResponse response = client.search(request,RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">            //4. 解析结果</span><br><span class="line">            Map&lt;String,List&lt;String&gt;&gt; result = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">            Aggregations aggregations = response.getAggregations();</span><br><span class="line">            //4.1 根据品牌（聚合名称）名称获取品牌的结果</span><br><span class="line">            List&lt;String&gt; brandList = getAddByName(aggregations,"brandAgg");</span><br><span class="line">            result.put("品牌",brandList); //放入map</span><br><span class="line">            //4.2 根据城市（聚合名称）名称获取品牌的结果</span><br><span class="line">            List&lt;String&gt; cityList = getAddByName(aggregations,"cityList");</span><br><span class="line">            result.put("城市",cityList); //放入map</span><br><span class="line">            //4.3 根据星级（聚合名称）名称获取品牌的结果</span><br><span class="line">            List&lt;String&gt; starList = getAddByName(aggregations,"starList");</span><br><span class="line">            result.put("星级",starList); //放入map</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line"></span><br><span class="line">        } catch (IOException e) {</span><br><span class="line">            throw new RuntimeException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //(抽取出来的) 根据名称获取品牌的结果</span><br><span class="line">    private List&lt;String&gt; getAddByName(Aggregations aggregations, String aggName) {</span><br><span class="line">        //4.1 根据聚合名称获取聚合结果</span><br><span class="line">        Terms brandTerms = aggregations.get(aggName);</span><br><span class="line">        //4.2 获取buckets</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">        //4.3 遍历</span><br><span class="line">        List&lt;String&gt; brandList = new ArrayList&lt;String&gt;();</span><br><span class="line">        for(Terms.Bucket bucket : buckets){</span><br><span class="line">            //4.4 获取key</span><br><span class="line">            String key = bucket.getKeyAsString();</span><br><span class="line">            brandList.add(key);</span><br><span class="line"></span><br><span class="line">            System.out.println(key);</span><br><span class="line">        }</span><br><span class="line">        return brandList;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //抽取出来的 聚合</span><br><span class="line">    private void buildAggretgaion(SearchRequest request) {</span><br><span class="line">        request.source().aggregation(AggregationBuilders</span><br><span class="line">                .terms("brandAgg")</span><br><span class="line">                .field("brand")</span><br><span class="line">                .size(10)</span><br><span class="line">        );</span><br><span class="line">        request.source().aggregation(AggregationBuilders</span><br><span class="line">                .terms("cityAgg")</span><br><span class="line">                .field("city")</span><br><span class="line">                .size(10)</span><br><span class="line">        );</span><br><span class="line">        request.source().aggregation(AggregationBuilders</span><br><span class="line">                .terms("starAgg")</span><br><span class="line">                .field("starName.keyword")</span><br><span class="line">                .size(10)</span><br><span class="line">        );</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestAPI实现聚合</title>
      <link href="/2022/11/07/elasticsearch/RestAPI%E5%AE%9E%E7%8E%B0%E8%81%9A%E5%90%88/"/>
      <url>/2022/11/07/elasticsearch/RestAPI%E5%AE%9E%E7%8E%B0%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/570bde95e90d44658df8da0c790f6586~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9d513b0401de41e39c3596a888c18b17~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d0e18347de8447ef8b03ecf8d9f6ef10~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    void testAggredation() throws IOException {</span><br><span class="line">        //1. 准备Request</span><br><span class="line">        SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">        //2. 准备DSL</span><br><span class="line">        //2.1 设置size</span><br><span class="line">        request.source().size(0);</span><br><span class="line">        //2.2 聚合</span><br><span class="line">        request.source().aggregation(AggregationBuilders</span><br><span class="line">                .terms("brandAgg")</span><br><span class="line">                .field("brand")</span><br><span class="line">                .size(10)</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        //3. 发出请求</span><br><span class="line">        SearchResponse response = client.search(request,RequestOptions.DEFAULT);</span><br><span class="line">        //4. 解析结果</span><br><span class="line">        Aggregations aggregations = response.getAggregations();</span><br><span class="line">        //4.1 根据聚合名称获取聚合结果</span><br><span class="line">        Terms brandTerms = aggregations.get("brandAgg");</span><br><span class="line">        //4.2 获取buckets</span><br><span class="line">        List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">        //4.3 遍历</span><br><span class="line">        for(Terms.Bucket bucket : buckets){</span><br><span class="line">            //4.4 获取key</span><br><span class="line">            String key = bucket.getKeyAsString();</span><br><span class="line"></span><br><span class="line">            System.out.println(key);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><strong>ps:</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/94d360f6ab8944398727066af9c9263e~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSL实现Metrics 聚合</title>
      <link href="/2022/11/07/elasticsearch/DSL%E5%AE%9E%E7%8E%B0Metrics%20%E8%81%9A%E5%90%88/"/>
      <url>/2022/11/07/elasticsearch/DSL%E5%AE%9E%E7%8E%B0Metrics%20%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>举例：</p><pre><code>    我们要求获取每个品牌的用户评分的min、max、avg等值.    我们可以利用stats聚合：(stats可以计算min、max、avg等)</code></pre><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 嵌套聚合metric</span><br><span class="line">GET /hotel/_search</span><br><span class="line">{</span><br><span class="line">  "size":0,</span><br><span class="line">  "aggs": {</span><br><span class="line">    "brandAgg": {</span><br><span class="line">      "terms": {</span><br><span class="line">        "field": "brand.keyword",</span><br><span class="line">        "size": 20,</span><br><span class="line">        "order": {</span><br><span class="line">          "scoreAgg.avg": "desc"</span><br><span class="line">        }</span><br><span class="line">      },</span><br><span class="line">      "aggs": {                 // 是brands聚合的子聚合，也就是分组后对每组分别计算</span><br><span class="line">        "scoreAgg": {           // 聚合名称</span><br><span class="line">          "stats": {            // 聚合类型，这里stats可以计算min、max、avg等</span><br><span class="line">            "field": "score"    // 聚合字段，这里是score</span><br><span class="line">          }</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1c4d58b87fb14cec86b17ff1adba0b35~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringSecurity基本原理&amp;web权限方案</title>
      <link href="/2022/11/06/SpringSecurity/SpringSecurity%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&amp;web%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/"/>
      <url>/2022/11/06/SpringSecurity/SpringSecurity%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86&amp;web%E6%9D%83%E9%99%90%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="1-基本原理"><a class="markdownIt-Anchor" href="#1-基本原理"></a> 1. 基本原理：</h1><ol><li><p><img src="../../images/image-20221106162517079.png" alt="image-20221106162517079"></p></li><li><p><img src="../../images/image-20221106163157990.png" alt="image-20221106163157990"></p></li><li><p><img src="../../images/image-20221106163919356.png" alt="image-20221106163919356"></p></li></ol><h1 id="2-web权限方案-用户认证设置用户名密码"><a class="markdownIt-Anchor" href="#2-web权限方案-用户认证设置用户名密码"></a> 2 .web权限方案-用户认证（设置用户名密码）</h1><ol><li><p>设置登录用户名和密码</p><ol><li>方式一：通过配置文件</li></ol><p>properties为例</p>   <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.port=<span class="number">8111</span></span><br><span class="line">spring.security.user.name=atguigu</span><br><span class="line">spring.security.user.password=atguigu</span><br></pre></td></tr></tbody></table></figure><ol start="2"><li><p>方式二：通过配置类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        <span class="type">BCryptPasswordEncoder</span> <span class="variable">passwordEncoder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">        <span class="comment">// 加密</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> passwordEncoder.encode(<span class="string">"123"</span>);</span><br><span class="line">        auth.inMemoryAuthentication().withUser(<span class="string">"lucy"</span>).password(password).roles(<span class="string">"admin"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PasswordEncoder <span class="title function_">password</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li><li><p>方式三：自定义编写实体类</p><p>在验证过程中，它会首先去找你的配置文件、配置类，如果发现其中有用户名和密码，那么它就会去找这个用户名和密码。但如果没有设置，它就会去找一个接口<strong>UserDetailsService</strong>，到这个接口你可以找通过表单提交或是查数据库或是其它方式设置的密码，然后去验证</p><p>到UserDetailsService中找到你返回的用户名和密码和权限</p><p>第一步：创建配置类，设置使用哪个userDetailsService实现类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springsecurity.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfigTest</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDetailsService userDetailsService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">        auth.userDetailsService(userDetailsService).passwordEncoder(password());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    PasswordEncoder <span class="title function_">password</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>第二步：编写实现类，返回User对象，User对象有用户名、密码和操作权限</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.springsecurity.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.AuthorityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.User;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/6</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyUserDetailsService</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException {</span><br><span class="line">        List&lt;GrantedAuthority&gt; auths = AuthorityUtils.commaSeparatedStringToAuthorityList(<span class="string">"role"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">"mary"</span>, <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">"123"</span>), auths);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>引用场景：</strong></p><p>一般实际开发中用的比较多的是第三种方式</p><p>第一、二种方式：比如要超级管理员的时候，就只能用admin这个用户来登录，这个时候就而已用第一或第二种方式来配置。</p><p>第三种方式：主要需求用于查数据库的时候</p></li></ol></li></ol><h1 id="3-自定义登录页面"><a class="markdownIt-Anchor" href="#3-自定义登录页面"></a> <strong>3.  自定义登录页面：</strong></h1><p><img src="../../images/image-20221109105645708.png" alt="image-20221109105645708"></p><h1 id="4-用户授权基于权限-访问控制"><a class="markdownIt-Anchor" href="#4-用户授权基于权限-访问控制"></a> 4. 用户授权（基于权限  访问控制）</h1><p><img src="../../images/image-20221109110430894.png" alt="image-20221109110430894"></p><p><img src="../../images/image-20221109112842988.png" alt="image-20221109112842988"></p><p><img src="../../images/image-20221109112951312.png" alt="image-20221109112951312"></p><p><img src="../../images/image-20221109112800334.png" alt="image-20221109112800334"></p><h1 id="5-自定义403页面"><a class="markdownIt-Anchor" href="#5-自定义403页面"></a> 5. 自定义403页面</h1><p><img src="../../images/image-20221109113727226.png" alt="image-20221109113727226"></p><p><img src="../../images/image-20221109113838590.png" alt="image-20221109113838590"></p><h1 id="6-用户授权注解使用"><a class="markdownIt-Anchor" href="#6-用户授权注解使用"></a> 6. 用户授权（注解使用）</h1><p><img src="../../images/image-20221109113927963.png" alt="image-20221109113927963"></p><p><img src="../../images/image-20221109114120340.png" alt="image-20221109114120340"></p><p><img src="../../images/image-20221109115959853.png" alt="image-20221109115959853"></p><p><img src="../../images/image-20221109120027475.png" alt="image-20221109120027475"></p><p><img src="../../images/image-20221109120049901.png" alt="image-20221109120049901"></p><p><img src="../../images/image-20221109120114195.png" alt="image-20221109120114195"></p><h1 id="7web权限方案用户注销"><a class="markdownIt-Anchor" href="#7web权限方案用户注销"></a> 7.web权限方案—用户注销</h1><p><img src="../../images/image-20221109172751444.png" alt="image-20221109172751444"></p><h1 id="8"><a class="markdownIt-Anchor" href="#8"></a> **8. **</h1><h1 id="81-web权限方案自动登录原理分析"><a class="markdownIt-Anchor" href="#81-web权限方案自动登录原理分析"></a> <strong>8.1 web权限方案—自动登录</strong>（原理分析）</h1><p>对应的教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP?p=17&amp;vd_source=746b9336d739b80b11820809545b6604">17-尚硅谷-SpringSecurity-web权限方案-自动登录（原理分析）_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221109184845677.png" alt="image-20221109184845677"></p><h2 id="811"><a class="markdownIt-Anchor" href="#811"></a> 8.1.1</h2><p><img src="../../images/image-20221109181738239.png" alt="image-20221109181738239"></p><p>上图红框过程的原理和源码如下：</p><p>通过<strong>UsernamePasswordAuthenticationFilter</strong>来获取用户名和密码，之后验证验证成功后，在调用父类<strong>AbsxtractAuthenticationProcessingFilter</strong>里的<strong>successfulAuthentication</strong>方法，然后<strong>successfulAuthentication</strong>方法里面有<strong>RememberMeServices</strong>对象，在里面先用<strong>TokenRepository</strong>生成Token，然后把值放到浏览器Cookies中，并且用<strong>JdbcTokenRepositoryImpl</strong>里面封装的方法把生成的Token值写到数据库中</p><p><img src="../../images/image-20221109180628066.png" alt="image-20221109180628066"></p><p><img src="../../images/image-20221109180549961.png" alt="image-20221109180549961"></p><p><img src="../../images/image-20221109181409113.png" alt="image-20221109181409113"></p><h2 id="812"><a class="markdownIt-Anchor" href="#812"></a> 8.1.2</h2><p><img src="../../images/image-20221109182017954.png" alt="image-20221109182017954"></p><p>浏览器发送请求，就会调用这个<strong>RememberMeAuthenticationFilter</strong>过滤器，里面有<strong>dofilter</strong>里面的<strong>RememberMeServices</strong>对象的<strong>autoLogin</strong>方法进行自动登录</p><p><img src="../../images/image-20221109183735806.png" alt="image-20221109183735806"></p><p><img src="../../images/image-20221109184615969.png" alt="image-20221109184615969"></p><p>上图check方法的判断过程源码：</p><p><img src="../../images/image-20221109184412419.png" alt="image-20221109184412419"></p><h1 id="82-web权限方案自动登录功能实现"><a class="markdownIt-Anchor" href="#82-web权限方案自动登录功能实现"></a> <strong>8.2 web权限方案—自动登录</strong>（功能实现）</h1><p>对应的教程视频：<a href="https://www.bilibili.com/video/BV15a411A7kP?p=18&amp;vd_source=746b9336d739b80b11820809545b6604">18-尚硅谷-SpringSecurity-web权限方案-自动登录（功能实现）_哔哩哔哩_bilibili</a></p><p><img src="../../images/image-20221109191135868.png" alt="image-20221109191135868"></p><p><img src="../../images/image-20221109191228869.png" alt="image-20221109191228869"></p><p>注意：<img src="../../images/image-20221109191528085.png" alt="image-20221109191528085"></p><h4 id="第一步创建表"><a class="markdownIt-Anchor" href="#第一步创建表"></a> 第一步：创建表</h4><p>表不一定要我们自己创建，它可以自动我们生成，但是为了看得方便，所以自己可以创建一下，建表语句它里面有提供，可以自己去源码里面复制出来即可，如下：</p><p><img src="../../images/image-20221109185400076.png" alt="image-20221109185400076"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table persistent_logins (</span><br><span class="line">username varchar(64) not null, </span><br><span class="line">series varchar(64) primary key, </span><br><span class="line">token varchar(64) not null, </span><br><span class="line">last_used timestamp not null</span><br><span class="line">)</span><br></pre></td></tr></tbody></table></figure><p><img src="../../images/image-20221109185839379.png" alt="image-20221109185839379"></p><p><img src="../../images/image-20221109190502459.png" alt="image-20221109190502459"></p><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注入数据源</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PersistentTokenRepository <span class="title function_">persistentTokenRepository</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">JdbcTokenRepositoryImpl</span> <span class="variable">jdbcTokenRepository</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTokenRepositoryImpl</span>();</span><br><span class="line">        jdbcTokenRepository.setDataSource(dataSource);</span><br><span class="line">        <span class="comment">// 下面语句表示在使用时把表创建，而我们以及自己创建了，就不用了</span></span><br><span class="line">        <span class="comment">// jdbcTokenRepository.setCreateTableOnStartup(true);</span></span><br><span class="line">        <span class="keyword">return</span> jdbcTokenRepository;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h1 id="9-csrf的功能"><a class="markdownIt-Anchor" href="#9-csrf的功能"></a> 9. CSRF的功能</h1><p>CSRF的详解：<a href="https://zhuanlan.zhihu.com/p/398601816">Web漏洞之CSRF(跨站请求伪造漏洞）详解 - 知乎 (zhihu.com)</a></p><p><img src="../../images/image-20221109203052376.png" alt="image-20221109203052376"></p><p>在源码中的过程：就是验证之后，生成<strong>csrfToken</strong>，token存在session里面，每次携带token进行请求，然后拿着<strong>csrfToken</strong>跟session中的内容作比较，如果它们相同就可以访问，不相同就不能访问。主要代码就是在<strong>CsrfFilter</strong>里面：</p><p><img src="../../images/image-20221109204032040.png" alt="image-20221109204032040"></p><p>在配置类中如果添加下面这个语句就是关闭CSRF保护，不加上的话，springsecurity是默认开启CSRF保护的</p><p><img src="../../images/image-20221109205622267.png" alt="image-20221109205622267"></p>]]></content>
      
      
      <categories>
          
          <category> SpringSecurity </category>
          
          <category> 零碎笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池应用_定时执行任务</title>
      <link href="/2022/11/06/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8_%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/"/>
      <url>/2022/11/06/juc/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%BA%94%E7%94%A8_%E5%AE%9A%E6%97%B6%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>直接上代码，解决 "如何让每周四 18:00:00 定时执行任务 ？"类似问题</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.time.DayOfWeek;</span><br><span class="line">import java.time.Duration;</span><br><span class="line">import java.time.LocalDateTime;</span><br><span class="line">import java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/10/15</span><br><span class="line"> */</span><br><span class="line">public class TestSchedule {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *如何让每周四 18:00:00 定时执行任务 ？</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        // 获取当前时间</span><br><span class="line">        LocalDateTime now = LocalDateTime.now();</span><br><span class="line">        System.out.println( now );</span><br><span class="line"></span><br><span class="line">        // 获取周四时间</span><br><span class="line">        LocalDateTime time = now.withHour(18).withMinute(0).withSecond(0).withNano(0).with(DayOfWeek.THURSDAY);</span><br><span class="line">        // 如果 当前时间 &gt; 本周四时间，必须找到下周周四</span><br><span class="line">        if ( now.compareTo( time ) &gt;0 ) {</span><br><span class="line">            // 加一周</span><br><span class="line">            time = time.plusWeeks( 1 );</span><br><span class="line">        }</span><br><span class="line">        System.out.println( time );</span><br><span class="line"></span><br><span class="line">        // initialDelay 代表当前时间和周四的时间差</span><br><span class="line">        // period 一周的间隔时间</span><br><span class="line">        long initialDelay = Duration.between(now, time).toMillis();</span><br><span class="line">        long period = 1000 * 60 * 60 * 24 * 7;</span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool( 1 );</span><br><span class="line">        pool.scheduleAtFixedRate( () -&gt; {</span><br><span class="line">            System.out.println( "running..." );</span><br><span class="line">        }, initialDelay, period, TimeUnit.MILLISECONDS );</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>Duration类专门用于做时间间隔运算的，如Duration.between( 时间1，时间2 ).toMillis()</p>]]></content>
      
      
      <categories>
          
          <category> juc </category>
          
          <category> 应用代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> juc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DSL实现Bucket聚合</title>
      <link href="/2022/11/06/elasticsearch/DSL%E5%AE%9E%E7%8E%B0Bucket%E8%81%9A%E5%90%88/"/>
      <url>/2022/11/06/elasticsearch/DSL%E5%AE%9E%E7%8E%B0Bucket%E8%81%9A%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>聚合（aggregations）可以实现对文档数据的统计、分析、运算。聚合常见的有三类：</p><p>桶（Bucket）聚合：用来对文档做分组</p><pre><code>    •TermAggregation：按照文档字段值分组    •Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</code></pre><h1 id="1-dsl实现bucket聚合"><a class="markdownIt-Anchor" href="#1-dsl实现bucket聚合"></a> <strong>1、DSL</strong>实现Bucket聚合</h1><p>我们要统计所有数据中的品牌有几种，此时可以根据品牌的名称做聚合。</p><p>类型为term类型，DSL示例：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 聚合功能</span><br><span class="line">GET /hotel/_search</span><br><span class="line">{</span><br><span class="line">  "size": 0,  // 设置size为0，结果中不包含文档，只包含聚合结果</span><br><span class="line">  "aggs": { // 定义聚合</span><br><span class="line">    "brandAgg": { //给聚合起个名字</span><br><span class="line">      "terms": { // 聚合的类型，按照品牌值聚合，所以选择term</span><br><span class="line">        "field": "brand", // 参与聚合的字段</span><br><span class="line">        "size": 20 // 希望获取的聚合结果数量</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2-bucket聚合聚合结果排序"><a class="markdownIt-Anchor" href="#2-bucket聚合聚合结果排序"></a> <strong>2、</strong> <strong>Bucket</strong>聚合聚合结果排序</h1><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为 <strong>_count</strong>，并且按照_count降序排序。</p><p>我们可以修改结果排序方式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 聚合功能,自定义排序规则</span><br><span class="line">GET /hotel/_search</span><br><span class="line">{</span><br><span class="line">  "size":0,</span><br><span class="line">  "aggs": {</span><br><span class="line">    "brandAgg": {</span><br><span class="line">      "terms": {</span><br><span class="line">        "field": "brand.keyword",</span><br><span class="line">        "size": 20,</span><br><span class="line">        "order": {</span><br><span class="line">          "_count": "asc"  // 按照_count升序排列</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bd76668c3da4a2bb1c21f680b2800f8~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p><h1 id="3-bucket聚合限定聚合范围"><a class="markdownIt-Anchor" href="#3-bucket聚合限定聚合范围"></a> <strong>3、Bucket</strong>聚合限定聚合范围</h1><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合的（当数据过于庞大时，会严重影响性能），我们可以限定要聚合的文档范围，只要添加<strong>query</strong>条件即可</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 聚合功能，限定聚合范围</span><br><span class="line">GET /hotel/_search</span><br><span class="line">{</span><br><span class="line">  "query": {</span><br><span class="line">    "range": {</span><br><span class="line">      "price": {</span><br><span class="line">        "lte": 200   // 只对200元以下的文档聚合</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }, </span><br><span class="line">  </span><br><span class="line">  "size":0,</span><br><span class="line">  "aggs": {</span><br><span class="line">    "brandAgg": {</span><br><span class="line">      "terms": {</span><br><span class="line">        "field": "brand.keyword",</span><br><span class="line">        "size": 20</span><br><span class="line">        }</span><br><span class="line">      }</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4-总结"><a class="markdownIt-Anchor" href="#4-总结"></a> <strong>4 、总结</strong></h1><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43800f552eb747088e5c6abc3164a30a~tplv-k3u1fbpfcp-zoom-1.image" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2022/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/11/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.runoob.com/design-pattern/design-pattern-intro.html">设计模式简介 | 菜鸟教程 (runoob.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>零碎笔记</title>
      <link href="/2022/11/06/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/06/%E9%9B%B6%E7%A2%8E%E7%9F%A5%E8%AF%86&amp;%E7%AC%94%E8%AE%B0/%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>RestTemplate</li></ol><p><a href="https://www.jianshu.com/p/58949f8334f5">Spring之RestTemplate详解 - 简书 (jianshu.com)</a></p><ol start="2"><li>@ApiModel</li></ol><p><a href="https://www.cnblogs.com/cy0628/p/15164994.html">Swagger注释API :@ApiModel - Chen洋 - 博客园 (cnblogs.com)</a></p><p>导入swagger依赖：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.swagger&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;swagger-annotations&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.13&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@ApiModel这个注解</span><br><span class="line">  这个注解的是作用在类上面的，是用来描述类的一些基本信息的。下面，我们会逐个的进行讲解。</span><br><span class="line"></span><br><span class="line">value属性</span><br><span class="line">  这个属性，提供的是类的一个备用名。如果我们不设置，那么默认情况下，将使用的是class类的名字。</span><br><span class="line"></span><br><span class="line">description属性</span><br><span class="line">  对于类，提供一个详细的描述信息</span><br><span class="line"></span><br><span class="line">parent属性</span><br><span class="line">  这个属性，描述的是类的一些父类的信息。</span><br><span class="line"></span><br><span class="line">discriminator属性</span><br><span class="line">  这个属性解释起来有些麻烦，因为这个类主要是体现出了断言当中。</span><br><span class="line"></span><br><span class="line">subTypes属性</span><br><span class="line">  举个实例，如果我们此时有一个父类Animal。同时，对于这个父类，我们的系统中有这个类的子类Cat、Dog、Pig等。如果我们在我们的父类上，通过这个属性，指定了我们想要使用的子类的话，那么在生成Swagger的文档的话，会自动的展示的是Animal这个属性，但是在属性的字段中，会显示出子类的一些独有的属性，其实在这里，是不推荐使用的。因为这样会让别人认为，这些子类独有的属性，也是父类才有的。</span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>? 泛型通配符</li></ol><p>？泛型通配符的特性：只能从泛型容器种取值，而不能向其中设置值（唯独null特许地可以设置）</p><p><img src="../../images/image-20230204161656614.png" alt="image-20230204161656614"></p>]]></content>
      
      
      <categories>
          
          <category> 零碎知识&amp;笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零碎知识&amp;笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java关键字</title>
      <link href="/2022/11/06/%E5%85%B3%E9%94%AE%E5%AD%97/java%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2022/11/06/%E5%85%B3%E9%94%AE%E5%AD%97/java%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<p>transient表示当加序列化时，不会被序列化</p><p><img src="/.com//C:%5CUsers%5C%E5%85%B6%E7%84%B6%E4%B9%90%E8%A1%A3Letitbe%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20221010191347950.png" alt="image-20221010191347950"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题总结</title>
      <link href="/2022/11/06/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2022/11/06/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="1-java的split方法使用多种分隔符切分字符串"><a class="markdownIt-Anchor" href="#1-java的split方法使用多种分隔符切分字符串"></a> 1. Java的split方法使用多种分隔符切分字符串</h1><p><strong>方法一：</strong><br>多个分隔符使用**‘|’**分开，例如：</p><pre><code>  String str = "abc;123,456?999|haha";  String[] strs=str.split(";|,");  for(String s : strs){  System.out.println(s);      }</code></pre><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">123</span><br><span class="line">456?999|haha</span><br></pre></td></tr></tbody></table></figure><p><strong>方法二：</strong><br>使用中括号括起来**[“…”]**，例如:</p><pre><code>String str = "abc;123,456?999|haha";String[] strs = str.split("[;,?|25]");for(String s : strs){System.out.println(s);    }</code></pre><p>输出：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">6</span><br><span class="line">999</span><br><span class="line">haha</span><br></pre></td></tr></tbody></table></figure><h1 id="2位运算"><a class="markdownIt-Anchor" href="#2位运算"></a> 2.位运算</h1><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">重要的 位运算 算法公式</span><br><span class="line"></span><br><span class="line">num1 &amp;= num1 - <span class="number">1</span>; <span class="comment">// 最低的 1 变成 0</span></span><br><span class="line"></span><br><span class="line">num1 |= num1 + <span class="number">1</span>; <span class="comment">// 最低的 0 变成 1</span></span><br></pre></td></tr></tbody></table></figure><p>双指针：</p><p><img src="../../images/image-20221122120748208.png" alt="image-20221122120748208"></p><p>例子1：<img src="../../images/image-20221122120312644.png" alt="image-20221122120312644"></p><p>例子2：</p><p><img src="../../images/image-20221122120556570.png" alt="image-20221122120556570"></p><p><img src="../../images/image-20221122120612009.png" alt="image-20221122120612009"></p><p>滑动窗口：</p><h1 id="滑动窗口法的大体框架"><a class="markdownIt-Anchor" href="#滑动窗口法的大体框架"></a> 滑动窗口法的大体框架</h1><p>在介绍滑动窗口的框架时候，大家先从字面理解下：</p><ul><li>**滑动：**说明这个窗口是移动的，也就是移动是按照一定方向来的。</li><li>**窗口：**窗口大小并不是固定的，可以不断扩容直到满足一定的条件；也可以不断缩小，直到找到一个满足条件的最小窗口；当然也可以是固定大小。</li></ul><p>为了便于理解，这里采用的是字符串来讲解。但是对于数组其实也是一样的。滑动窗口算法的思路是这样：</p><ol><li>我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。</li><li>我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。</li><li>此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。</li><li>重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。</li></ol><p>这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。</p><p>下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。</p><p>初始状态：<br><img src="https://img-blog.csdnimg.cn/2019101621574345.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>增加 right，直到窗口 [left, right] 包含了 T 中所有字符：<br><img src="https://img-blog.csdnimg.cn/20191016215752186.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>现在开始增加 left，缩小窗口 [left, right]。</p><p><img src="https://img-blog.csdnimg.cn/20191016215807735.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>直到窗口中的字符串不再符合要求，left 不再继续移动。</p><p><img src="https://img-blog.csdnimg.cn/20191016215824468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0RieV9mcmVlZG9t,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。</p><p>如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。</p><p><strong><font color="greanjj">持续更新…</font></strong></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引库中的文档的操作</title>
      <link href="/2022/11/06/elasticsearch/%E7%B4%A2%E5%BC%95%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/11/06/elasticsearch/%E7%B4%A2%E5%BC%95%E5%BA%93%E4%B8%AD%E7%9A%84%E6%96%87%E6%A1%A3%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="索引库中的文档的操作"><a class="markdownIt-Anchor" href="#索引库中的文档的操作"></a> 索引库中的文档的操作</h1><p><img src="https://img-blog.csdnimg.cn/31cfbf19cd1941909e0aaa594f2bd5d0.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/41a470384f02452a8565ca97a2681702.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/264b09d6e2a94a8a87ac5527907b8c25.png" alt="img"><img src="https://img-blog.csdnimg.cn/9839abedff6b41709b41fdbf1d021320.png" alt="img"></p><p>（实例）代码：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># 插入文档</span><br><span class="line">POST /heima/_doc/1</span><br><span class="line">{</span><br><span class="line">  "info": "黑马程序员java讲师",</span><br><span class="line">  "email": "zy@itcast.cn",</span><br><span class="line">  "name": {</span><br><span class="line">    "firstname": "云",</span><br><span class="line">    "lastname": "赵"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"># 查询文档</span><br><span class="line">GET /heima/_doc/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 删除文档</span><br><span class="line">DELETE /heima/_doc/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改文档，方式1：全量修改文档，如果存在则删除旧的，新的覆盖旧的，如果原先没有，则新增该文档（所以放修改方式相当于也是一种插入文档的方法）</span><br><span class="line">POST /heima/_doc/1</span><br><span class="line">{</span><br><span class="line">  "info": "黑马程序员java讲师",</span><br><span class="line">  "email": "zhaoyun@itcast.cn",</span><br><span class="line">  "name": {</span><br><span class="line">    "firstname": "云",</span><br><span class="line">    "lastname": "赵"</span><br><span class="line">  }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改文档，方式2: 局部修改文档字段</span><br><span class="line">POST /heima/_update/1</span><br><span class="line">{</span><br><span class="line">  "doc":{</span><br><span class="line">    "email": "ZY@itcast.cn"</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>运行截图：</p><p><img src="https://img-blog.csdnimg.cn/069e55bbd4ec47308b0147aa38adab91.png" alt="img"><img src="https://img-blog.csdnimg.cn/6e1212cd2f794a579424363b32fb9adc.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/640be243e52d45a18b47ef5dfe0b3095.png" alt="img"><img src="https://img-blog.csdnimg.cn/4aa5f5fd7ce74a6a814f9338b68beae5.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/e7ddbb1bb05f40078872f81abe3e60c9.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/06615bad2d7942acb41706e51cc56bdc.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RestClient查询文档</title>
      <link href="/2022/11/06/elasticsearch/RestClient%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/"/>
      <url>/2022/11/06/elasticsearch/RestClient%E6%9F%A5%E8%AF%A2%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a class="markdownIt-Anchor" href="#快速入门"></a> 快速入门：</h1><p><img src="https://img-blog.csdnimg.cn/65c0ab898d754d8e97699b41931b2426.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h1 id="match_all查询"><a class="markdownIt-Anchor" href="#match_all查询"></a> match_all查询：</h1><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//match_all查询</span><br><span class="line">    @Test</span><br><span class="line">    void testMatchAll() throws IOException {</span><br><span class="line">        String index  = "tb_disable_date_diary";</span><br><span class="line">        //1.准备Request</span><br><span class="line">        SearchRequest request = new SearchRequest(index);</span><br><span class="line">        //2.准备DSL</span><br><span class="line">        request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">        //3.发送请求</span><br><span class="line">        SearchResponse response = client.search(request,RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        //解析响应</span><br><span class="line">        handleResponce(response);</span><br><span class="line"></span><br><span class="line">        System.out.println(response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    //解析响应</span><br><span class="line">    private void handleResponce(SearchResponse response) {</span><br><span class="line">        //4.解析响应</span><br><span class="line">        SearchHits searchHits = response.getHits();</span><br><span class="line">        //4.1获取总条数</span><br><span class="line">        long total = searchHits.getTotalHits().value;</span><br><span class="line">        System.out.println("共搜索到"+total+"条数据");</span><br><span class="line">        //4.2文档数据</span><br><span class="line">        SearchHit[] hits = searchHits.getHits();</span><br><span class="line">        //4.3遍历</span><br><span class="line">        for(SearchHit hit : hits){</span><br><span class="line">            //获取文档source</span><br><span class="line">            String json = hit.getSourceAsString();</span><br><span class="line">            //反序列化</span><br><span class="line">            Diary diary = JSON.parseObject(json,Diary.class);</span><br><span class="line">            System.out.println("diary = "+diary);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/48392c3346d746448e7109a3c8d960c0.png" alt="img"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">//分页和排序</span><br><span class="line">   @Test</span><br><span class="line">   void restPageAndSort() throws IOException {</span><br><span class="line">       //页码，每页大小</span><br><span class="line">       int page = 2,size = 5;</span><br><span class="line"></span><br><span class="line">       //1.准备Request</span><br><span class="line">       SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">       //2.准备DSL</span><br><span class="line">       //2.1 query</span><br><span class="line">       request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">       //2.2 排序 sort</span><br><span class="line">       request.source().sort("price", SortOrder.ASC);</span><br><span class="line">       //2.3 分页from，size</span><br><span class="line">       request.source().from((page - 1) * size).size(5);</span><br><span class="line"></span><br><span class="line">       //3.发送请求</span><br><span class="line">       SearchResponse response = client.search(request,RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">       handleResponce(response);</span><br><span class="line"></span><br><span class="line">       System.out.println(response);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   private void handleResponce(SearchResponse response) {</span><br><span class="line">       //4.解析响应</span><br><span class="line">       SearchHits searchHits = response.getHits();</span><br><span class="line">       //4.1获取总条数</span><br><span class="line">       long total = searchHits.getTotalHits().value;</span><br><span class="line">       System.out.println("共搜索到"+total+"条数据");</span><br><span class="line">       //4.2文档数据</span><br><span class="line">       SearchHit[] hits = searchHits.getHits();</span><br><span class="line">       //4.3遍历</span><br><span class="line">       for(SearchHit hit : hits){</span><br><span class="line">           //获取文档source</span><br><span class="line">           String json = hit.getSourceAsString();</span><br><span class="line">           //反序列化</span><br><span class="line">           HotelDoc hotelDoc = JSON.parseObject(json,HotelDoc.class);</span><br><span class="line">           System.out.println("hotelDoc = "+hotelDoc);</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="高亮"><a class="markdownIt-Anchor" href="#高亮"></a> <strong>高亮</strong></h2><p><img src="https://img-blog.csdnimg.cn/84cfb92b326c4ff18403e7089b76f7a9.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/8b969709155446f48b193ac2e9fa59f7.png" alt="img"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">//高亮</span><br><span class="line">    @Test</span><br><span class="line">    void testHighlight() throws IOException {</span><br><span class="line">        //1.准备Request</span><br><span class="line">        SearchRequest request = new SearchRequest("hotel");</span><br><span class="line">        //2.准备DSL</span><br><span class="line">        //2.1 query</span><br><span class="line">        request.source().query(QueryBuilders.matchQuery("all","如家"));</span><br><span class="line">        //2.2 高亮</span><br><span class="line">        request.source().highlighter(new HighlightBuilder().field("name").requireFieldMatch(false));</span><br><span class="line"></span><br><span class="line">        //3.发送请求</span><br><span class="line">        SearchResponse response = client.search(request,RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">        handleResponce1(response);</span><br><span class="line"></span><br><span class="line">        System.out.println(response);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    private void handleResponce1(SearchResponse response) {</span><br><span class="line">        //4.解析响应</span><br><span class="line">        SearchHits searchHits = response.getHits();</span><br><span class="line">        //4.1获取总条数</span><br><span class="line">        long total = searchHits.getTotalHits().value;</span><br><span class="line">        System.out.println("共搜索到"+total+"条数据");</span><br><span class="line">        //4.2文档数组</span><br><span class="line">        SearchHit[] hits = searchHits.getHits();</span><br><span class="line">        //4.3遍历</span><br><span class="line">        for(SearchHit hit : hits){</span><br><span class="line">            //获取文档source</span><br><span class="line">            String json = hit.getSourceAsString();</span><br><span class="line">            //反序列化</span><br><span class="line">            HotelDoc hotelDoc = JSON.parseObject(json,HotelDoc.class);</span><br><span class="line"></span><br><span class="line">            //获取高亮结果</span><br><span class="line">            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">            if(!CollectionUtils.isEmpty(highlightFields)){</span><br><span class="line">                //根据各字段名获取高亮结果</span><br><span class="line">                HighlightField highlightField = highlightFields.get("name");</span><br><span class="line">                if(highlightField != null){</span><br><span class="line">                    //获取高亮</span><br><span class="line">                    String name = highlightField.getFragments()[0].string();</span><br><span class="line">                    //覆盖非高亮结果</span><br><span class="line">                    hotelDoc.setName(name);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            System.out.println("hotelDoc = "+hotelDoc);</span><br><span class="line">        }</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/e569b9e6eae2472cb508245fe942dd15.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaRestClient操作索引库和文档</title>
      <link href="/2022/11/06/elasticsearch/javaRestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93%E5%92%8C%E6%96%87%E6%A1%A3/"/>
      <url>/2022/11/06/elasticsearch/javaRestClient%E6%93%8D%E4%BD%9C%E7%B4%A2%E5%BC%95%E5%BA%93%E5%92%8C%E6%96%87%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-创建索引库"><a class="markdownIt-Anchor" href="#1-创建索引库"></a> <strong>1. 创建索引库：</strong></h1><p><img src="https://img-blog.csdnimg.cn/0fb9368cceef43ddbd2bb17ed8d24088.png" alt="img"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//创建索引库</span><br><span class="line">   @Test</span><br><span class="line">   void createHotelIndex() throws IOException {</span><br><span class="line">       //1.创建Request对象</span><br><span class="line">       CreateIndexRequest request = new CreateIndexRequest("hotel");</span><br><span class="line">       //2.准备请求的参数：DSL语句</span><br><span class="line">       request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">       //3.发送请求</span><br><span class="line">       client.indices().create(request,RequestOptions.DEFAULT);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">public static final String MAPPING_TEMPLATE = "{\n" +</span><br><span class="line">            "  \"mappings\": {\n" +</span><br><span class="line">            "    \"properties\": {\n" +</span><br><span class="line">            "      \"id\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"name\":{\n" +</span><br><span class="line">            "        \"type\":\"text\",\n" +</span><br><span class="line">            "        \"analyzer\": \"ik_max_word\",\n" +</span><br><span class="line">            "        \"copy_to\": \"all\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"address\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\",\n" +</span><br><span class="line">            "        \"index\":\"false\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"price\":{\n" +</span><br><span class="line">            "        \"type\":\"integer\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"score\":{\n" +</span><br><span class="line">            "        \"type\":\"integer\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"brand\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\",\n" +</span><br><span class="line">            "        \"copy_to\": \"all\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"city\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"starName\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"business\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\",\n" +</span><br><span class="line">            "        \"copy_to\": \"all\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"location\":{\n" +</span><br><span class="line">            "        \"type\":\"geo_point\"\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"pic\":{\n" +</span><br><span class="line">            "        \"type\":\"keyword\",\n" +</span><br><span class="line">            "        \"index\":false\n" +</span><br><span class="line">            "      },\n" +</span><br><span class="line">            "      \"all\":{\n" +</span><br><span class="line">            "        \"type\":\"text\",\n" +</span><br><span class="line">            "        \"analyzer\": \"ik_max_word\"\n" +</span><br><span class="line">            "      }\n" +</span><br><span class="line">            "    }\n" +</span><br><span class="line">            "  }\n" +</span><br><span class="line">            "}";</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/18a3d3fc162e4e2ab8f61c956df60776.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/feb2d88bfe144638b243e9d89a0d7392.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/ad59b410007345dc967234c73e5ba534.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><h2 id="2-删除索引库"><a class="markdownIt-Anchor" href="#2-删除索引库"></a> 2. 删除索引库：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//删除索引库</span><br><span class="line">    @Test</span><br><span class="line">    void textDeleteHotelIndex() throws IOException {</span><br><span class="line">        //1.创建Request对象</span><br><span class="line">        DeleteIndexRequest request = new DeleteIndexRequest("hotel");</span><br><span class="line"></span><br><span class="line">        //2.发送请求</span><br><span class="line">        client.indices().delete(request,RequestOptions.DEFAULT);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-旁段是否存在索引库"><a class="markdownIt-Anchor" href="#3-旁段是否存在索引库"></a> 3. 旁段是否存在索引库：</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//判断是否存在索引库</span><br><span class="line">   @Test</span><br><span class="line">   void textExistsHotelIndex() throws IOException {</span><br><span class="line">       //1.创建Request对象</span><br><span class="line">       GetIndexRequest request = new GetIndexRequest("hotel");</span><br><span class="line"></span><br><span class="line">       //2.发送请求</span><br><span class="line">       boolean exists = client.indices().exists(request,RequestOptions.DEFAULT);</span><br><span class="line">       System.out.println(exists ? "索引库已经存在！" : "索引库不存在！");</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/69ddc8f23003493eb829f87158800d7e.png" alt="img"></p><h2 id="4-修改文档"><a class="markdownIt-Anchor" href="#4-修改文档"></a> 4. 修改文档</h2><p><img src="https://img-blog.csdnimg.cn/fcab1400718748bea29dc7c0466a2437.png" alt="img"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//修改文档</span><br><span class="line">    @Test</span><br><span class="line">    void testUpdateDocument() throws IOException {</span><br><span class="line">        //1.准备Request</span><br><span class="line">        UpdateRequest request = new UpdateRequest("hotel","61083");</span><br><span class="line"></span><br><span class="line">        //2.准备请求参数</span><br><span class="line">        request.doc(</span><br><span class="line">                "price","952",</span><br><span class="line">                "starName","四钻"</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        //3.发送请求</span><br><span class="line">        client.update(request,RequestOptions.DEFAULT);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="5-查询文档"><a class="markdownIt-Anchor" href="#5-查询文档"></a> 5. 查询文档</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//根据id查询</span><br><span class="line">   @Test</span><br><span class="line">   void testAddDocumentById() throws IOException {</span><br><span class="line"></span><br><span class="line">       //1.准备好request</span><br><span class="line">       GetRequest request = new GetRequest("hotel","61083");</span><br><span class="line">       //2.发送请求 ，得到响应</span><br><span class="line">       GetResponse response = client.get(request,RequestOptions.DEFAULT);</span><br><span class="line">       //3.解析响应结果</span><br><span class="line">       String json = response.getSourceAsString();</span><br><span class="line"></span><br><span class="line">       HotelDoc hotelDoc= JSON.parseObject(json,HotelDoc.class);</span><br><span class="line">       System.out.println(hotelDoc);</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="6-批量添加文档"><a class="markdownIt-Anchor" href="#6-批量添加文档"></a> 6. 批量添加文档</h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">//批量添加</span><br><span class="line">    @Test</span><br><span class="line">    void testBulkRequest() throws IOException {</span><br><span class="line">        //批量查询酒店的数量</span><br><span class="line">        List&lt;Hotel&gt; hotels = new hotelService.list();</span><br><span class="line"></span><br><span class="line">        for(Hotel hotel : hotels){</span><br><span class="line">            HotelDoc hotelDoc = new HotelDoc(hotel);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //1.创建Request</span><br><span class="line">        BulkRequest request = new BulkRequest();</span><br><span class="line">        //2.准备参数，添加多个新增的Request</span><br><span class="line">        for(Hotel hotel : hotels){</span><br><span class="line">            //转换为文档类型的HotelDoc</span><br><span class="line">            HotelDoc hotelDoc = new HotelDoc(hotel);</span><br><span class="line">            //创建新增文档的Request对象</span><br><span class="line">            request.add(new IndexRequest("hotel")</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc),XContentType.JSON));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        //3.发送请求</span><br><span class="line">        client.bulk(request,RequestOptions.DEFAULT);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="https://img-blog.csdnimg.cn/8611bf94e9a9441a8a2eda88060392a2.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES聚合分析报错:“reason“</title>
      <link href="/2022/11/06/elasticsearch/ES%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90%E6%8A%A5%E9%94%99%EF%BC%9A%E2%80%9Creason%E2%80%9C%20/"/>
      <url>/2022/11/06/elasticsearch/ES%E8%81%9A%E5%90%88%E5%88%86%E6%9E%90%E6%8A%A5%E9%94%99%EF%BC%9A%E2%80%9Creason%E2%80%9C%20/</url>
      
        <content type="html"><![CDATA[<p>因为<code>brand</code>的<code>type</code>是<code>text，``text</code>或<code>annotated_text</code>字段<code>doc_values</code>默认为<code>false</code>。</p><p>简单理解，就是<code>text</code>字段作为一个整体，默认没有索引。</p><p><img src="https://img-blog.csdnimg.cn/7167950f76224359bedc252c4fb816da.png" alt="img"></p><p>解释：</p><p>​    因为brand的type是<strong>text</strong>，<strong>text</strong>或<strong>annotated_text</strong>字段doc_values默认为false。简单理解，就是text字段作为一个整体，默认没有索引。</p><p>​    不过text分词之后的keyword是有索引的，因而可以对brand.keyword进行聚合。如下：</p><p><img src="https://img-blog.csdnimg.cn/642629de221a4b4abbc09b979c654f63.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> Elasticsearch </category>
          
          <category> DSL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合使用云服务器上的Redis</title>
      <link href="/2022/11/05/redis/springboot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Redis/"/>
      <url>/2022/11/05/redis/springboot%E6%95%B4%E5%90%88%E4%BD%BF%E7%94%A8%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84Redis/</url>
      
        <content type="html"><![CDATA[<h1 id="一-前提条件"><a class="markdownIt-Anchor" href="#一-前提条件"></a> 一、前提条件</h1><p>修改redis.conf配置文件</p><p><strong>1、protected-mode yes（默认的） 修改成 protected-mode no，解除保护模式</strong></p><p><img src="../../images/f1f4347079c44f87b15fe6d63b5a1372.png" alt="img"></p><p><strong>2、注释掉绑定ip ，绑定ip的话，使得除了本机（服务器）以外的主机无法访问redis数据库</strong></p><p><img src="../../images/88a1f690a1da4699996b12882112fdbd.png" alt="img"></p><p><strong>3、将守护进程模式关闭 daemonize yes 改成 daemonize no</strong></p><p><img src="../../images/5c5c95f6922d424eaec6bb514bf989e7.png" alt="img"></p><p>4、<strong>最后，一定记住要redis-server redis.conf重启redis的配置文件，否则修改不生效！！！</strong></p><h1 id="二-整合步骤"><a class="markdownIt-Anchor" href="#二-整合步骤"></a> 二、整合步骤</h1><p><strong>1、导入依赖</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--redis--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>2、配置yml配置文件</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: 你的云服务器的ip</span><br><span class="line">    port: 6379                # Redis的端口</span><br><span class="line">    password: redis密码         # Redis服务器连接密码</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>3、注入RedisTemplate</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>使用例子</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void redisTestSet(  ) {</span><br><span class="line"></span><br><span class="line">    ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">    ops.set( "username", 41);</span><br><span class="line">    System.out.println(  );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void redisTestGet(  ) {</span><br><span class="line">    ValueOperations ops = redisTemplate.opsForValue();</span><br><span class="line">    Object name = ops.get( "username");</span><br><span class="line">    System.out.println( name );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h1 id="三-可能遇到的坑"><a class="markdownIt-Anchor" href="#三-可能遇到的坑"></a> 三、可能遇到的坑</h1><p><strong>报错1：</strong></p><p><img src="../../images/4c85fac031a34ec1a8db6ec0f3126bd9.png" alt="img"></p><p>解决方式1：在redis.conf配置文件中requirepass后空一一格，然后加上密码</p><p><img src="../../images/61f205b1ecdd45b49cce8dd743d0ae1e.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>解决方式2：命令模式</p><p>1）登录redis</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>2)设置密码 （比如我设置密码为12345678）</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set requirepass 12345678</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>3）验证 ：输入默认用户名 auth 和 密码</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auth 12345678</span><br></pre></td></tr></tbody></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><img src="../../images/751ef059325d4675a73cc12881de3f72.png" alt="img"></p><p><strong>错误2：</strong></p><p>启动项目时报错：java.net.ConnectException: Connection refused: no further information</p><p>原因：开头的前提条件2可能没有弄好，或是弄了但没有和重新启动redis</p>]]></content>
      
      
      <categories>
          
          <category> redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理及应用第三章知识点思维导图（SQL SERVER）</title>
      <link href="/2022/11/05/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%88SQL%20SERVER%EF%BC%89/"/>
      <url>/2022/11/05/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8%E7%AC%AC%E4%B8%89%E7%AB%A0%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%EF%BC%88SQL%20SERVER%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>直接上图：</p><p><img src="https://img-blog.csdnimg.cn/5584f01c08764c0bb05bbc22c577a0cb.jpeg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> sql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/11/05/hello-world/"/>
      <url>/2022/11/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start"><a class="markdownIt-Anchor" href="#quick-start"></a> Quick Start</h2><h3 id="create-a-new-post"><a class="markdownIt-Anchor" href="#create-a-new-post"></a> Create a new post</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server"><a class="markdownIt-Anchor" href="#run-server"></a> Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files"><a class="markdownIt-Anchor" href="#generate-static-files"></a> Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites"><a class="markdownIt-Anchor" href="#deploy-to-remote-sites"></a> Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="../images/image-20221121220556724.png" alt="image-20221121220556724"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>1-Elasticsearch</title>
      <link href="/2022/07/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E01/"/>
      <url>/2022/07/09/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E01/</url>
      
        <content type="html"><![CDATA[<h1 id="分布式搜索引擎01"><a class="markdownIt-Anchor" href="#分布式搜索引擎01"></a> 分布式搜索引擎01</h1><p>– elasticsearch基础</p><h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1><h1 id="1初识elasticsearch"><a class="markdownIt-Anchor" href="#1初识elasticsearch"></a> 1.初识elasticsearch</h1><h2 id="11了解es"><a class="markdownIt-Anchor" href="#11了解es"></a> 1.1.了解ES</h2><h3 id="111elasticsearch的作用"><a class="markdownIt-Anchor" href="#111elasticsearch的作用"></a> 1.1.1.elasticsearch的作用</h3><p>elasticsearch是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p><p>例如：</p><ul><li><p>在GitHub搜索代码</p><p><img src="../../../images/image-20210720193623245.png" alt="image-20210720193623245"></p></li><li><p>在电商网站搜索商品</p><p><img src="../../../images/image-20210720193633483.png" alt="image-20210720193633483"></p></li><li><p>在百度搜索答案</p><p><img src="../../../images/image-20210720193641907.png" alt="image-20210720193641907"></p></li><li><p>在打车软件搜索附近的车</p><p><img src="../../../images/image-20210720193648044.png" alt="image-20210720193648044"></p></li></ul><h3 id="112elk技术栈"><a class="markdownIt-Anchor" href="#112elk技术栈"></a> 1.1.2.ELK技术栈</h3><p>elasticsearch结合kibana、Logstash、Beats，也就是elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域：</p><p><img src="../../../images/image-20210720194008781.png" alt="image-20210720194008781"></p><p>而elasticsearch是elastic stack的核心，负责存储、搜索、分析数据。</p><p><img src="../../../images/image-20210720194230265.png" alt="image-20210720194230265"></p><h3 id="113elasticsearch和lucene"><a class="markdownIt-Anchor" href="#113elasticsearch和lucene"></a> 1.1.3.elasticsearch和lucene</h3><p>elasticsearch底层是基于<strong>lucene</strong>来实现的。</p><p><strong>Lucene</strong>是一个Java语言的搜索引擎类库，是Apache公司的顶级项目，由DougCutting于1999年研发。官网地址：<a href="https://lucene.apache.org/">https://lucene.apache.org/</a> 。</p><p><img src="../../../images/image-20210720194547780.png" alt="image-20210720194547780"></p><p><strong>elasticsearch</strong>的发展历史：</p><ul><li>2004年Shay Banon基于Lucene开发了Compass</li><li>2010年Shay Banon 重写了Compass，取名为Elasticsearch。</li></ul><p><img src="../../../images/image-20210720195001221.png" alt="image-20210720195001221"></p><h3 id="114为什么不是其他搜索技术"><a class="markdownIt-Anchor" href="#114为什么不是其他搜索技术"></a> 1.1.4.为什么不是其他搜索技术？</h3><p>目前比较知名的搜索引擎技术排名：</p><p><img src="../../../images/image-20210720195142535.png" alt="image-20210720195142535"></p><p>虽然在早期，Apache Solr是最主要的搜索引擎技术，但随着发展elasticsearch已经渐渐超越了Solr，独占鳌头：</p><p><img src="../../../images/image-20210720195306484.png" alt="image-20210720195306484"></p><h3 id="115总结"><a class="markdownIt-Anchor" href="#115总结"></a> 1.1.5.总结</h3><p>什么是elasticsearch？</p><ul><li>一个开源的分布式搜索引擎，可以用来实现搜索、日志统计、分析、系统监控等功能</li></ul><p>什么是elastic stack（ELK）？</p><ul><li>是以elasticsearch为核心的技术栈，包括beats、Logstash、kibana、elasticsearch</li></ul><p>什么是Lucene？</p><ul><li>是Apache的开源搜索引擎类库，提供了搜索引擎的核心API</li></ul><h2 id="12倒排索引"><a class="markdownIt-Anchor" href="#12倒排索引"></a> 1.2.倒排索引</h2><p>倒排索引的概念是基于MySQL这样的正向索引而言的。</p><h3 id="121正向索引"><a class="markdownIt-Anchor" href="#121正向索引"></a> 1.2.1.正向索引</h3><p>那么什么是正向索引呢？例如给下表（tb_goods）中的id创建索引：</p><p><img src="../../../images/image-20210720195531539.png" alt="image-20210720195531539"></p><p>如果是根据id查询，那么直接走索引，查询速度非常快。</p><p>但如果是基于title做模糊查询，只能是逐行扫描数据，流程如下：</p><p>1）用户搜索数据，条件是title符合<code>"%手机%"</code></p><p>2）逐行获取数据，比如id为1的数据</p><p>3）判断数据中的title是否符合用户搜索条件</p><p>4）如果符合则放入结果集，不符合则丢弃。回到步骤1</p><p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p><h3 id="122倒排索引"><a class="markdownIt-Anchor" href="#122倒排索引"></a> 1.2.2.倒排索引</h3><p>倒排索引中有两个非常重要的概念：</p><ul><li>文档（<code>Document</code>）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li><li>词条（<code>Term</code>）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li></ul><p><strong>创建倒排索引</strong>是对正向索引的一种特殊处理，流程如下：</p><ul><li>将每一个文档的数据利用算法分词，得到一个个词条</li><li>创建表，每行数据包括词条、词条所在文档id、位置等信息</li><li>因为词条唯一性，可以给词条创建索引，例如hash表结构索引</li></ul><p>如图：</p><p><img src="../../../images/image-20210720200457207.png" alt="image-20210720200457207"></p><p>倒排索引的<strong>搜索流程</strong>如下（以搜索"华为手机"为例）：</p><p>1）用户输入条件<code>"华为手机"</code>进行搜索。</p><p><strong>2）<strong>对用户输入内容</strong>分词</strong>，得到词条：<code>华为</code>、<code>手机</code>。</p><p>3）拿着词条在倒排索引中查找，可以得到包含词条的文档id：1、2、3。</p><p>4）拿着文档id到正向索引中查找具体文档。</p><p>如图：</p><p><img src="../../../images/image-20210720201115192.png" alt="image-20210720201115192"></p><p>虽然要先查询倒排索引，再查询正向索引，但是无论是词条、还是文档id都建立了索引，查询速度非常快！无需全表扫描。</p><h3 id="123正向和倒排"><a class="markdownIt-Anchor" href="#123正向和倒排"></a> 1.2.3.正向和倒排</h3><p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p><ul><li><p><strong>正向索引</strong>是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是<strong>根据文档找词条的过程</strong>。</p></li><li><p>而<strong>倒排索引</strong>则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的id，然后根据id获取文档。是<strong>根据词条找文档的过程</strong>。</p></li></ul><p>是不是恰好反过来了？</p><p>那么两者方式的优缺点是什么呢？</p><p><strong>正向索引</strong>：</p><ul><li>优点：<ul><li>可以给多个字段创建索引</li><li>根据索引字段搜索、排序速度非常快</li></ul></li><li>缺点：<ul><li>根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li></ul></li></ul><p><strong>倒排索引</strong>：</p><ul><li>优点：<ul><li>根据词条搜索、模糊搜索时，速度非常快</li></ul></li><li>缺点：<ul><li>只能给词条创建索引，而不是字段</li><li>无法根据字段做排序</li></ul></li></ul><h2 id="13es的一些概念"><a class="markdownIt-Anchor" href="#13es的一些概念"></a> 1.3.es的一些概念</h2><p>elasticsearch中有很多独有的概念，与mysql中略有差别，但也有相似之处。</p><h3 id="131文档和字段"><a class="markdownIt-Anchor" href="#131文档和字段"></a> 1.3.1.文档和字段</h3><p>elasticsearch是面向**文档（Document）**存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为json格式后存储在elasticsearch中：</p><p><img src="../../../images/image-20210720202707797.png" alt="image-20210720202707797"></p><p>而Json文档中往往包含很多的<strong>字段（Field）</strong>，类似于数据库中的列。</p><h3 id="132索引和映射"><a class="markdownIt-Anchor" href="#132索引和映射"></a> 1.3.2.索引和映射</h3><p><strong>索引（Index）</strong>，就是相同类型的文档的集合。</p><p>例如：</p><ul><li>所有用户文档，就可以组织在一起，称为用户的索引；</li><li>所有商品的文档，可以组织在一起，称为商品的索引；</li><li>所有订单的文档，可以组织在一起，称为订单的索引；</li></ul><p><img src="../../../images/image-20210720203022172.png" alt="image-20210720203022172"></p><p>因此，我们可以把索引当做是数据库中的表。</p><p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有<strong>映射（mapping）</strong>，是索引中文档的字段约束信息，类似表的结构约束。</p><h3 id="133mysql与elasticsearch"><a class="markdownIt-Anchor" href="#133mysql与elasticsearch"></a> 1.3.3.mysql与elasticsearch</h3><p>我们统一的把mysql与elasticsearch的概念做一下对比：</p><table><thead><tr><th><strong>MySQL</strong></th><th><strong>Elasticsearch</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>Table</td><td>Index</td><td>索引(index)，就是文档的集合，类似数据库的表(table)</td></tr><tr><td>Row</td><td>Document</td><td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td></tr><tr><td>Column</td><td>Field</td><td>字段（Field），就是JSON文档中的字段，类似数据库中的列（Column）</td></tr><tr><td>Schema</td><td>Mapping</td><td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td></tr><tr><td>SQL</td><td>DSL</td><td>DSL是elasticsearch提供的JSON风格的请求语句，用来操作elasticsearch，实现CRUD</td></tr></tbody></table><p>是不是说，我们学习了elasticsearch就不再需要mysql了呢？</p><p>并不是如此，两者各自有自己的擅长支出：</p><ul><li><p>Mysql：擅长事务类型操作，可以确保数据的安全和一致性</p></li><li><p>Elasticsearch：擅长海量数据的搜索、分析、计算</p></li></ul><p>ElasticSearch和MySql分工不同，MySQL负责存储数据，ElasticSearch负责搜索数据</p><ul><li>MySQL有事务性而ElasticSearch<mark>没有事务性</mark>，所以你<font color="red">删了的数据是无法恢复的</font>。</li><li>ElasticSearch<mark>没有物理外键</mark>这个特性，如果你的数据强一致性要求比较高还是建议慎用</li></ul><p>因此在企业中，往往是两者结合使用：</p><ul><li>对安全性要求较高的写操作，使用mysql实现</li><li>对查询性能要求较高的搜索需求，使用elasticsearch实现</li><li>两者再基于某种方式，实现数据的同步，保证一致性</li></ul><p><img src="../../../images/image-20210720203534945.png" alt="image-20210720203534945"></p><h2 id="14安装es-kibana"><a class="markdownIt-Anchor" href="#14安装es-kibana"></a> 1.4.安装es、kibana</h2><h3 id="141安装"><a class="markdownIt-Anchor" href="#141安装"></a> 1.4.1.安装</h3><p>参考课前资料：</p><p><img src="../../../images/image-20210720203805350.png" alt="image-20210720203805350"></p><h3 id="142分词器"><a class="markdownIt-Anchor" href="#142分词器"></a> 1.4.2.分词器</h3><p>参考课前资料：</p><p><img src="../../../images/image-20210720203805350.png" alt="image-20210720203805350"></p><h3 id="143总结"><a class="markdownIt-Anchor" href="#143总结"></a> 1.4.3.总结</h3><p>分词器的作用是什么？</p><ul><li>创建倒排索引时对文档分词</li><li>用户搜索时，对输入的内容分词</li></ul><p>IK分词器有几种模式？</p><ul><li>ik_smart：智能切分，粗粒度</li><li>ik_max_word：最细切分，细粒度</li></ul><p>IK分词器如何拓展词条？如何停用词条？</p><ul><li>利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典</li><li>在词典中添加拓展词条或者停用词条</li></ul><h1 id="2索引库操作"><a class="markdownIt-Anchor" href="#2索引库操作"></a> 2.索引库操作</h1><p>索引库就类似数据库表，mapping映射就类似表的结构。</p><p>我们要向es中存储数据，必须先创建“库”和“表”。</p><h2 id="21mapping映射属性"><a class="markdownIt-Anchor" href="#21mapping映射属性"></a> 2.1.mapping映射属性</h2><p>mapping是对索引库中文档的约束，常见的mapping属性包括：</p><ul><li>type：字段数据类型，常见的简单类型有：<ul><li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）</li><li>数值：long、integer、short、byte、double、float、</li><li>布尔：boolean</li><li>日期：date</li><li>对象：object</li></ul></li><li>index：是否创建索引，默认为true</li><li>analyzer：使用哪种分词器</li><li>properties：该字段的子字段</li></ul><p>例如下面的json文档：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"age"</span><span class="punctuation">:</span>&nbsp;<span class="number">21</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"weight"</span><span class="punctuation">:</span>&nbsp;<span class="number">52.1</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"isMarried"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"info"</span><span class="punctuation">:</span>&nbsp;<span class="string">"黑马程序员Java讲师"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"email"</span><span class="punctuation">:</span>&nbsp;<span class="string">"zy@itcast.cn"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="number">99.1</span><span class="punctuation">,</span> <span class="number">99.5</span><span class="punctuation">,</span> <span class="number">98.9</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"firstName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"云"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lastName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"赵"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>对应的每个字段映射（mapping）：</p><ul><li>age：类型为 integer；参与搜索，因此需要index为true；无需分词器</li><li>weight：类型为float；参与搜索，因此需要index为true；无需分词器</li><li>isMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器</li><li>info：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart</li><li>email：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器</li><li>score：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器</li><li>name：类型为object，需要定义多个子属性<ul><li>name.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li><li>name.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器</li></ul></li></ul><h2 id="22索引库的crud"><a class="markdownIt-Anchor" href="#22索引库的crud"></a> 2.2.索引库的CRUD</h2><p>这里我们统一使用Kibana编写DSL的方式来演示。</p><h3 id="221创建索引库和映射"><a class="markdownIt-Anchor" href="#221创建索引库和映射"></a> 2.2.1.创建索引库和映射</h3><h4 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法：</h4><ul><li>请求方式：PUT</li><li>请求路径：/索引库名，可以自定义</li><li>请求参数：mapping映射</li></ul><p>格式：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/索引库名称</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段名"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_smart"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段名2"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"index"</span><span class="punctuation">:</span>&nbsp;<span class="string">"false"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段名3"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"子字段"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"keyword"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="comment">// ...略</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="示例"><a class="markdownIt-Anchor" href="#示例"></a> 示例：</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/heima</span><br><span class="line">{</span><br><span class="line">&nbsp;&nbsp;<span class="string">"mappings"</span>:&nbsp;{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"properties"</span>:&nbsp;{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"info"</span>:{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"type"</span>:&nbsp;<span class="string">"text"</span>,</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"analyzer"</span>:&nbsp;<span class="string">"ik_smart"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"email"</span>:{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"type"</span>:&nbsp;<span class="string">"keyword"</span>,</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"index"</span>:&nbsp;<span class="string">"falsae"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"name"</span>:{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"properties"</span>:&nbsp;{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"firstName"</span>:&nbsp;{</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"type"</span>:&nbsp;<span class="string">"keyword"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},</span><br><span class="line">      // ... 略</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;}</span><br><span class="line">&nbsp;&nbsp;}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="222查询索引库"><a class="markdownIt-Anchor" href="#222查询索引库"></a> 2.2.2.查询索引库</h3><p><strong>基本语法</strong>：</p><ul><li><p>请求方式：GET</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /索引库名</span><br></pre></td></tr></tbody></table></figure><p><strong>示例</strong>：</p><p><img src="../../../images/image-20210720211019329.png" alt="image-20210720211019329"></p><h3 id="223修改索引库"><a class="markdownIt-Anchor" href="#223修改索引库"></a> 2.2.3.修改索引库</h3><p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库<strong>一旦创建，无法修改mapping</strong>。</p><p>虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/索引库名/_mapping</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"新字段名"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"integer"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>示例</strong>：</p><p><img src="../../../images/image-20210720212357390.png" alt="image-20210720212357390"></p><h3 id="224删除索引库"><a class="markdownIt-Anchor" href="#224删除索引库"></a> 2.2.4.删除索引库</h3><p><strong>语法：</strong></p><ul><li><p>请求方式：DELETE</p></li><li><p>请求路径：/索引库名</p></li><li><p>请求参数：无</p></li></ul><p><strong>格式：</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /索引库名</span><br></pre></td></tr></tbody></table></figure><p>在kibana中测试：</p><p><img src="../../../images/image-20210720212123420.png" alt="image-20210720212123420"></p><h3 id="225总结"><a class="markdownIt-Anchor" href="#225总结"></a> 2.2.5.总结</h3><p>索引库操作有哪些？</p><ul><li>创建索引库：PUT /索引库名</li><li>查询索引库：GET /索引库名</li><li>删除索引库：DELETE /索引库名</li><li>添加字段：PUT /索引库名/_mapping</li></ul><h1 id="3文档操作"><a class="markdownIt-Anchor" href="#3文档操作"></a> 3.文档操作</h1><h2 id="31新增文档"><a class="markdownIt-Anchor" href="#31新增文档"></a> 3.1.新增文档</h2><p><strong>语法：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/索引库名/_doc/文档id</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段1"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值1"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段2"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值2"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段3"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"子属性1"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值3"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"子属性2"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值4"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"info"</span><span class="punctuation">:</span>&nbsp;<span class="string">"黑马程序员Java讲师"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"email"</span><span class="punctuation">:</span>&nbsp;<span class="string">"zy@itcast.cn"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"firstName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"云"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lastName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"赵"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>响应：</strong></p><p><img src="../../../images/image-20210720212933362.png" alt="image-20210720212933362"></p><h2 id="32查询文档"><a class="markdownIt-Anchor" href="#32查询文档"></a> 3.2.查询文档</h2><p>根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /<span class="punctuation">{</span>索引库名称<span class="punctuation">}</span>/_doc/<span class="punctuation">{</span>id<span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>通过kibana查看数据：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">GET</span> /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>查看结果：</strong></p><p><img src="../../../images/image-20210720213345003.png" alt="image-20210720213345003"></p><h2 id="33删除文档"><a class="markdownIt-Anchor" href="#33删除文档"></a> 3.3.删除文档</h2><p>删除使用DELETE请求，同样，需要根据id进行删除：</p><p><strong>语法：</strong></p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable constant_">DELETE</span> /{索引库名}/_doc/id值</span><br></pre></td></tr></tbody></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 根据id删除数据</span><br><span class="line">DELETE /heima/_doc/<span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p><strong>结果：</strong></p><p><img src="../../../images/image-20210720213634918.png" alt="image-20210720213634918"></p><h2 id="34修改文档"><a class="markdownIt-Anchor" href="#34修改文档"></a> 3.4.修改文档</h2><p>修改有两种方式：</p><ul><li>全量修改：直接覆盖原来的文档</li><li>增量修改：修改文档中的部分字段</li></ul><h3 id="341全量修改"><a class="markdownIt-Anchor" href="#341全量修改"></a> 3.4.1.全量修改</h3><p>全量修改是覆盖原来的文档，其本质是：</p><ul><li>根据指定的id删除文档</li><li>新增一个相同id的文档</li></ul><p><strong>注意</strong>：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/<span class="punctuation">{</span>索引库名<span class="punctuation">}</span>/_doc/文档id</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段1"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值1"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"字段2"</span><span class="punctuation">:</span>&nbsp;<span class="string">"值2"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/heima/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"info"</span><span class="punctuation">:</span>&nbsp;<span class="string">"黑马程序员高级Java讲师"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"email"</span><span class="punctuation">:</span>&nbsp;<span class="string">"zy@itcast.cn"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"firstName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"云"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lastName"</span><span class="punctuation">:</span>&nbsp;<span class="string">"赵"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="342增量修改"><a class="markdownIt-Anchor" href="#342增量修改"></a> 3.4.2.增量修改</h3><p>增量修改是只修改指定id匹配的文档中的部分字段。</p><p><strong>语法：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/<span class="punctuation">{</span>索引库名<span class="punctuation">}</span>/_update/文档id</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">         <span class="attr">"字段名"</span><span class="punctuation">:</span>&nbsp;<span class="string">"新的值"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>示例：</strong></p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/heima/_update/<span class="number">1</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"doc"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"email"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ZhaoYun@itcast.cn"</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="35总结"><a class="markdownIt-Anchor" href="#35总结"></a> 3.5.总结</h2><p>文档操作有哪些？</p><ul><li>创建文档：POST /{索引库名}/_doc/文档id   { json文档 }</li><li>查询文档：GET /{索引库名}/_doc/文档id</li><li>删除文档：DELETE /{索引库名}/_doc/文档id</li><li>修改文档：<ul><li>全量修改：PUT /{索引库名}/_doc/文档id { json文档 }</li><li>增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}}</li></ul></li></ul><h1 id="4restapi"><a class="markdownIt-Anchor" href="#4restapi"></a> 4.RestAPI</h1><p>ES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：<a href="https://www.elastic.co/guide/en/elasticsearch/client/index.html">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p><p>其中的Java Rest Client又包括两种：</p><ul><li>Java Low Level Rest Client</li><li>Java High Level Rest Client</li></ul><p><img src="../../../images/image-20210720214555863.png" alt="image-20210720214555863"></p><p>我们学习的是Java HighLevel Rest Client客户端API</p><h2 id="40导入demo工程"><a class="markdownIt-Anchor" href="#40导入demo工程"></a> 4.0.导入Demo工程</h2><h3 id="401导入数据"><a class="markdownIt-Anchor" href="#401导入数据"></a> 4.0.1.导入数据</h3><p>首先导入课前资料提供的数据库数据：</p><p><img src="../../../images/image-20210720220400297.png" alt="image-20210720220400297"></p><p>数据结构如下：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>&nbsp;<span class="keyword">TABLE</span>&nbsp;`tb_hotel`&nbsp;(</span><br><span class="line">&nbsp;&nbsp;`id`&nbsp;<span class="type">bigint</span>(<span class="number">20</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店id'</span>,</span><br><span class="line">&nbsp;&nbsp;`name`&nbsp;<span class="type">varchar</span>(<span class="number">255</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店名称；例：7天酒店'</span>,</span><br><span class="line">&nbsp;&nbsp;`address`&nbsp;<span class="type">varchar</span>(<span class="number">255</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店地址；例：航头路'</span>,</span><br><span class="line">&nbsp;&nbsp;`price`&nbsp;<span class="type">int</span>(<span class="number">10</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店价格；例：329'</span>,</span><br><span class="line">&nbsp;&nbsp;`score`&nbsp;<span class="type">int</span>(<span class="number">2</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店评分；例：45，就是4.5分'</span>,</span><br><span class="line">&nbsp;&nbsp;`brand`&nbsp;<span class="type">varchar</span>(<span class="number">32</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店品牌；例：如家'</span>,</span><br><span class="line">&nbsp;&nbsp;`city`&nbsp;<span class="type">varchar</span>(<span class="number">32</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'所在城市；例：上海'</span>,</span><br><span class="line">&nbsp;&nbsp;`star_name`&nbsp;<span class="type">varchar</span>(<span class="number">16</span>)&nbsp;<span class="keyword">DEFAULT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店星级，从低到高分别是：1星到5星，1钻到5钻'</span>,</span><br><span class="line">&nbsp;&nbsp;`business`&nbsp;<span class="type">varchar</span>(<span class="number">255</span>)&nbsp;<span class="keyword">DEFAULT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'商圈；例：虹桥'</span>,</span><br><span class="line">&nbsp;&nbsp;`latitude`&nbsp;<span class="type">varchar</span>(<span class="number">32</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'纬度；例：31.2497'</span>,</span><br><span class="line">&nbsp;&nbsp;`longitude`&nbsp;<span class="type">varchar</span>(<span class="number">32</span>)&nbsp;<span class="keyword">NOT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'经度；例：120.3925'</span>,</span><br><span class="line">&nbsp;&nbsp;`pic`&nbsp;<span class="type">varchar</span>(<span class="number">255</span>)&nbsp;<span class="keyword">DEFAULT</span>&nbsp;<span class="keyword">NULL</span>&nbsp;COMMENT&nbsp;<span class="string">'酒店图片；例:/img/1.jpg'</span>,</span><br><span class="line">&nbsp;&nbsp;<span class="keyword">PRIMARY</span>&nbsp;KEY&nbsp;(`id`)</span><br><span class="line">)&nbsp;ENGINE<span class="operator">=</span>InnoDB&nbsp;<span class="keyword">DEFAULT</span>&nbsp;CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></tbody></table></figure><h3 id="402导入项目"><a class="markdownIt-Anchor" href="#402导入项目"></a> 4.0.2.导入项目</h3><p>然后导入课前资料提供的项目:</p><p><img src="../../../images/image-20210720220503411.png" alt="image-20210720220503411"></p><p>项目结构如图：</p><p><img src="../../../images/image-20210720220647541.png" alt="image-20210720220647541"></p><h3 id="403mapping映射分析"><a class="markdownIt-Anchor" href="#403mapping映射分析"></a> 4.0.3.mapping映射分析</h3><p>创建索引库，最关键的是mapping映射，而mapping映射要考虑的信息包括：</p><ul><li>字段名</li><li>字段数据类型</li><li>是否参与搜索</li><li>是否需要分词</li><li>如果分词，分词器是什么？</li></ul><p>其中：</p><ul><li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li><li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li><li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li><li>分词器，我们可以统一使用ik_max_word</li></ul><p>来看下酒店数据的索引库结构:</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"mappings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"properties"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"id"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"address"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"price"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"score"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"brand"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"city"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"starName"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"business"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"location"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"geo_point"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"pic"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"all"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_max_word"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>几个特殊字段说明：</p><ul><li>location：地理坐标，里面包含精度、纬度</li><li>all：一个组合字段，其目的是将多字段的值 利用copy_to合并，提供给用户搜索</li></ul><p>地理坐标说明：</p><p><img src="../../../images/image-20210720222110126.png" alt="image-20210720222110126"></p><p>copy_to说明：</p><p><img src="../../../images/image-20210720222221516.png" alt="image-20210720222221516"></p><h3 id="404初始化restclient"><a class="markdownIt-Anchor" href="#404初始化restclient"></a> 4.0.4.初始化RestClient</h3><p>在elasticsearch提供的API中，与elasticsearch一切交互都封装在一个名为RestHighLevelClient的类中，必须先完成这个对象的初始化，建立与elasticsearch的连接。</p><p>分为三步：</p><p>1）引入es的RestHighLevelClient依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2）因为SpringBoot默认的ES版本是7.6.2，所以我们需要覆盖默认的ES版本：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch.version</span>&gt;</span>7.12.1<span class="tag">&lt;/<span class="name">elasticsearch.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>3）初始化RestHighLevelClient：</p><p>初始化的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RestHighLevelClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">));</span><br></pre></td></tr></tbody></table></figure><p>这里为了单元测试方便，我们创建一个测试类HotelIndexTest，然后将初始化的代码编写在@BeforeEach方法中：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpHost;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.RestHighLevelClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelIndexTest</span> {</span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">        ));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="41创建索引库"><a class="markdownIt-Anchor" href="#41创建索引库"></a> 4.1.创建索引库</h2><h3 id="411代码解读"><a class="markdownIt-Anchor" href="#411代码解读"></a> 4.1.1.代码解读</h3><p>创建索引库的API如下：</p><p><img src="../../../images/image-20210720223049408.png" alt="image-20210720223049408"></p><p>代码分为三步：</p><ul><li>1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。</li><li>2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。</li><li>3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。</li></ul><h3 id="412完整示例"><a class="markdownIt-Anchor" href="#412完整示例"></a> 4.1.2.完整示例</h3><p>在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelConstants</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">MAPPING_TEMPLATE</span> <span class="operator">=</span> <span class="string">"{\n"</span> +</span><br><span class="line">            <span class="string">"  \"mappings\": {\n"</span> +</span><br><span class="line">            <span class="string">"    \"properties\": {\n"</span> +</span><br><span class="line">            <span class="string">"      \"id\": {\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"name\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"text\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"analyzer\": \"ik_max_word\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"copy_to\": \"all\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"address\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"index\": false\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"price\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"integer\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"score\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"integer\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"brand\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"copy_to\": \"all\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"city\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"copy_to\": \"all\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"starName\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"business\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"location\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"geo_point\"\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"pic\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"keyword\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"index\": false\n"</span> +</span><br><span class="line">            <span class="string">"      },\n"</span> +</span><br><span class="line">            <span class="string">"      \"all\":{\n"</span> +</span><br><span class="line">            <span class="string">"        \"type\": \"text\",\n"</span> +</span><br><span class="line">            <span class="string">"        \"analyzer\": \"ik_max_word\"\n"</span> +</span><br><span class="line">            <span class="string">"      }\n"</span> +</span><br><span class="line">            <span class="string">"    }\n"</span> +</span><br><span class="line">            <span class="string">"  }\n"</span> +</span><br><span class="line">            <span class="string">"}"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">CreateIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CreateIndexRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求的参数：DSL语句</span></span><br><span class="line">    request.source(MAPPING_TEMPLATE, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="42删除索引库"><a class="markdownIt-Anchor" href="#42删除索引库"></a> 4.2.删除索引库</h2><p>删除索引库的DSL语句非常简单：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel</span><br></pre></td></tr></tbody></table></figure><p>与创建索引库相比：</p><ul><li>请求方式从PUT变为DELTE</li><li>请求路径不变</li><li>无请求参数</li></ul><p>所以代码的差异，注意体现在Request对象上。依然是三步走：</p><ul><li>1）创建Request对象。这次是<strong>DeleteIndexRequest</strong>对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用delete方法</li></ul><p>在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">DeleteIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteIndexRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="43判断索引库是否存在"><a class="markdownIt-Anchor" href="#43判断索引库是否存在"></a> 4.3.判断索引库是否存在</h2><p>判断索引库是否存在，本质就是查询，对应的DSL是：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel</span><br></pre></td></tr></tbody></table></figure><p>因此与删除的Java代码流程是类似的。依然是三步走：</p><ul><li>1）创建Request对象。这次是GetIndexRequest对象</li><li>2）准备参数。这里是无参</li><li>3）发送请求。改用exists方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testExistsHotelIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.创建Request对象</span></span><br><span class="line">    <span class="type">GetIndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetIndexRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">exists</span> <span class="operator">=</span> client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.输出</span></span><br><span class="line">    System.err.println(exists ? <span class="string">"索引库已经存在！"</span> : <span class="string">"索引库不存在！"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="44总结"><a class="markdownIt-Anchor" href="#44总结"></a> 4.4.总结</h2><p>JavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。</p><p>索引库操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxIndexRequest。XXX是Create、Get、Delete</li><li>准备DSL（ Create时需要，其它是无参）</li><li>发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete</li></ul><h1 id="5restclient操作文档"><a class="markdownIt-Anchor" href="#5restclient操作文档"></a> 5.RestClient操作文档</h1><p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p><ul><li>初始化RestHighLevelClient</li><li>我们的酒店数据在数据库，需要利用IHotelService去查询，所以注入这个接口</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.pojo.Hotel;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.AfterEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.BeforeEach;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDocumentTest</span> {</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setUp</span><span class="params">()</span> {</span><br><span class="line">        <span class="built_in">this</span>.client = <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">                HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">        ));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">        <span class="built_in">this</span>.client.close();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="51新增文档"><a class="markdownIt-Anchor" href="#51新增文档"></a> 5.1.新增文档</h2><p>我们要将数据库的酒店数据查询出来，写入elasticsearch中。</p><h3 id="511索引库实体类"><a class="markdownIt-Anchor" href="#511索引库实体类"></a> 5.1.1.索引库实体类</h3><p>数据库查询后的结果是一个Hotel类型的对象。结构如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@TableName("tb_hotel")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Hotel</span> {</span><br><span class="line">    <span class="meta">@TableId(type = IdType.INPUT)</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String longitude;</span><br><span class="line">    <span class="keyword">private</span> String latitude;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>与我们的索引库结构存在差异：</p><ul><li>longitude和latitude需要合并为location</li></ul><p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="512语法说明"><a class="markdownIt-Anchor" href="#512语法说明"></a> 5.1.2.语法说明</h3><p>新增文档的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /<span class="punctuation">{</span>索引库名<span class="punctuation">}</span>/_doc/<span class="number">1</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"name"</span><span class="punctuation">:</span> <span class="string">"Jack"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"age"</span><span class="punctuation">:</span> <span class="number">21</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>对应的java代码如图：</p><p><img src="../../../images/image-20210720230027240.png" alt="image-20210720230027240"></p><p>可以看到与创建索引库类似，同样是三步走：</p><ul><li>1）创建Request对象</li><li>2）准备请求参数，也就是DSL中的JSON文档</li><li>3）发送请求</li></ul><p>变化的地方在于，<a href="http://xn--client-vt9in98k266am0d6y0gd5e.xxx">这里直接使用client.xxx</a>()的API，不再需要client.indices()了。</p><h3 id="513完整代码"><a class="markdownIt-Anchor" href="#513完整代码"></a> 5.1.3.完整代码</h3><p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p><ul><li>酒店数据来自于数据库，我们需要先查询出来，得到hotel对象</li><li>hotel对象需要转为HotelDoc对象</li><li>HotelDoc需要序列化为json格式</li></ul><p>因此，代码整体步骤如下：</p><ul><li>1）<strong>根据id查询酒店数据Hotel</strong></li><li>2）将Hotel封装为HotelDoc</li><li>3）将HotelDoc<strong>序列化为JSON</strong></li><li>4）<strong>创建IndexRequest，指定索引库名和id</strong></li><li>5）<strong>准备请求参数，也就是JSON文档</strong></li><li>6）<strong>发送请求</strong></li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.根据id查询酒店数据</span></span><br><span class="line">    <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelService.getById(<span class="number">61083L</span>);</span><br><span class="line">    <span class="comment">// 2.转换为文档类型</span></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">    <span class="comment">// 3.将HotelDoc转json</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> JSON.toJSONString(hotelDoc);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request对象,并指定索引库名和id</span></span><br><span class="line">    <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">"hotel"</span>).id(hotelDoc.getId().toString());</span><br><span class="line">    <span class="comment">// 2.准备Json文档</span></span><br><span class="line">    request.source(json, XContentType.JSON);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="52查询文档"><a class="markdownIt-Anchor" href="#52查询文档"></a> 5.2.查询文档</h2><h3 id="521语法说明"><a class="markdownIt-Anchor" href="#521语法说明"></a> 5.2.1.语法说明</h3><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /hotel/_doc/<span class="punctuation">{</span>id<span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>非常简单，因此代码大概分两步：</p><ul><li>准备Request对象</li><li>发送请求</li></ul><p>不过查询的目的是得到结果，解析为HotelDoc，因此难点是结果的解析。完整代码如下：</p><p><img src="../../../images/image-20210720230811674.png" alt="image-20210720230811674"></p><p>可以看到，结果是一个JSON，其中文档放在一个**<mark><code>_source</code></mark>**属性中，因此解析就是拿到<code>_source</code>，反序列化为Java对象即可。</p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是查询，所以是<mark>GetRequest</mark></li><li>2）发送请求，得到结果。因为是查询，这里调用<mark>client.get()方法</mark></li><li>3）解析结果，就是对JSON做反序列化</li></ul><h3 id="522完整代码"><a class="markdownIt-Anchor" href="#522完整代码"></a> 5.2.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testGetDocumentById</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">GetRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetRequest</span>(<span class="string">"hotel"</span>, <span class="string">"61082"</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求，得到响应</span></span><br><span class="line">    <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.get(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 3.解析响应结果</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> response.getSourceAsString();</span><br><span class="line"></span><br><span class="line">    <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">    System.out.println(hotelDoc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="53删除文档"><a class="markdownIt-Anchor" href="#53删除文档"></a> 5.3.删除文档</h2><p>删除的DSL为是这样的：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /hotel/_doc/<span class="punctuation">{</span>id<span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>与查询相比，仅仅是请求方式从DELETE变成GET，可以想象Java代码应该依然是三步走：</p><ul><li>1）准备Request对象，因为是删除，这次是DeleteRequest对象。要指定索引库名和id</li><li>2）准备参数，无参</li><li>3）发送请求。因为是删除，所以是client.delete()方法</li></ul><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testDeleteDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request,并指定索引库名和id</span></span><br><span class="line">    <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">"hotel"</span>, <span class="string">"61083"</span>);</span><br><span class="line">    <span class="comment">// 2.发送请求</span></span><br><span class="line">    client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="54修改文档"><a class="markdownIt-Anchor" href="#54修改文档"></a> 5.4.修改文档</h2><h3 id="541语法说明"><a class="markdownIt-Anchor" href="#541语法说明"></a> 5.4.1.语法说明</h3><p>修改我们讲过两种方式：</p><ul><li>全量修改：本质是先根据id删除，再新增</li><li>增量修改：修改文档中的指定字段值</li></ul><p>在RestClient的API中，全量修改与新增的API完全一致，判断依据是ID：</p><ul><li>如果新增时，ID已经存在，则修改</li><li>如果新增时，ID不存在，则新增</li></ul><p>这里不再赘述，我们主要关注增量修改。</p><p>代码示例如图：</p><p><img src="../../../images/image-20210720231040875.png" alt="image-20210720231040875"></p><p>与之前类似，也是三步走：</p><ul><li>1）准备Request对象。这次是修改，所以是UpdateRequest</li><li>2）准备参数。也就是JSON文档，里面包含要修改的字段</li><li>3）更新文档。这里调用client.update()方法</li></ul><h3 id="542完整代码"><a class="markdownIt-Anchor" href="#542完整代码"></a> 5.4.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">UpdateRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UpdateRequest</span>(<span class="string">"hotel"</span>, <span class="string">"61083"</span>);</span><br><span class="line">    <span class="comment">// 2.准备请求参数</span></span><br><span class="line">    request.doc(</span><br><span class="line">        <span class="string">"price"</span>, <span class="string">"952"</span>,</span><br><span class="line">        <span class="string">"starName"</span>, <span class="string">"四钻"</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.update(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="55批量导入文档"><a class="markdownIt-Anchor" href="#55批量导入文档"></a> 5.5.批量导入文档</h2><p>案例需求：利用<mark>BulkRequest</mark>批量将数据库数据导入到索引库中。</p><p>步骤如下：</p><ul><li><p>利用mybatis-plus查询酒店数据</p></li><li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p></li><li><p>利用JavaRestClient中的BulkRequest批处理，实现批量新增文档</p></li></ul><h3 id="551语法说明"><a class="markdownIt-Anchor" href="#551语法说明"></a> 5.5.1.语法说明</h3><p>批量处理BulkRequest，其本质就是将多个普通的CRUD请求组合在一起发送。</p><p>其中提供了一个add方法，用来添加其他请求：</p><p><img src="../../../images/image-20210720232105943.png" alt="image-20210720232105943"></p><p>可以看到，能添加的请求包括：</p><ul><li>IndexRequest，也就是新增</li><li>UpdateRequest，也就是修改</li><li>DeleteRequest，也就是删除</li></ul><p>因此Bulk中添加了多个IndexRequest，就是批量新增功能了。示例：</p><p><img src="../../../images/image-20210720232431383.png" alt="image-20210720232431383"></p><p>其实还是三步走：</p><ul><li>1）创建Request对象。这里是BulkRequest</li><li>2）准备参数。批处理的参数，就是其它Request对象，这里就是多个IndexRequest</li><li>3）发起请求。这里是批处理，调用的方法为<mark>client.bulk()</mark>方法</li></ul><p>我们在导入酒店数据时，将上述代码改造成for循环处理即可。</p><h3 id="552完整代码"><a class="markdownIt-Anchor" href="#552完整代码"></a> 5.5.2.完整代码</h3><p>在hotel-demo的HotelDocumentTest测试类中，编写单元测试：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 批量查询酒店数据</span></span><br><span class="line">    List&lt;Hotel&gt; hotels = hotelService.list();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.创建Request</span></span><br><span class="line">    <span class="type">BulkRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BulkRequest</span>();</span><br><span class="line">    <span class="comment">// 2.准备参数，添加多个新增的Request</span></span><br><span class="line">    <span class="keyword">for</span> (Hotel hotel : hotels) {</span><br><span class="line">        <span class="comment">// 2.1.转换为文档类型HotelDoc</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line">        <span class="comment">// 2.2.创建新增文档的Request对象</span></span><br><span class="line">        request.add(<span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">"hotel"</span>)</span><br><span class="line">                    .id(hotelDoc.getId().toString())</span><br><span class="line">                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    client.bulk(request, RequestOptions.DEFAULT);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="56小结"><a class="markdownIt-Anchor" href="#56小结"></a> 5.6.小结</h2><p>文档操作的基本步骤：</p><ul><li>初始化RestHighLevelClient</li><li>创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk</li><li>准备参数（Index、Update、Bulk时需要）</li><li>发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk</li><li>解析结果（Get时需要）</li></ul>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
          <category> Elasticsearch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
