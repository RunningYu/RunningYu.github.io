<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo &amp; github</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-05-20T08:42:13.662Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>其然乐衣</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/"/>
    <id>http://example.com/2023/05/20/Netty/IM%E4%BB%BF%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/IM/</id>
    <published>2023-05-20T08:12:31.462Z</published>
    <updated>2023-05-20T08:42:13.662Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../../images/image-20230520161301132.png" alt="image-20230520161301132"></p><h1 id="网络通信层"><a class="markdownIt-Anchor" href="#网络通信层"></a> 网络通信层</h1><p><strong>Bootstrap</strong></p><p>负责客户端启动并用来连接远程Netty Server</p><p>但这里不用Bootstrap，因为 IM实战的通讯方式是通过WebSocket前端网页来链接连接我们的netty的server端的</p><p><img src="../../../images/image-20230520162251684.png" alt="image-20230520162251684"></p><p><img src="../../../images/image-20230520162457445.png" alt="image-20230520162457445"></p><p><img src="../../../images/image-20230520162426147.png" alt="image-20230520162426147"></p><p>上图的远离机制：</p><p>Client这三个客户端，会发送消息到BossGroup；BossGroup是一个线程池，中有一个Selector主要作用是会生成 SocketChannel；SocketChannel会封装成NIOSocketChannel；NIOSocketChannel会注册到工作线程中的Selector；若要读数据或写数据，那么工作线程中selector就会分发到不同对应的Handler中进行处理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../../../images/image-20230520161301132.png&quot; alt=&quot;image-20230520161301132&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;网络通信层&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; hre</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://example.com/2023/04/29/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2023-04-29T02:18:01.535Z</published>
    <updated>2023-04-29T02:43:34.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器从输入网址到页面展示的过程"><a class="markdownIt-Anchor" href="#浏览器从输入网址到页面展示的过程"></a> 浏览器从输入网址到页面展示的过程</h1><p>完整高频题库仓库地址：<a href="https://github.com/hzfe/awesome-interview"><strong>https://github.com/hzfe/awesome-interview</strong></a></p><p>完整高频题库阅读地址：<a href="https://febook.hzfe.org/"><strong>https://febook.hzfe.org/</strong></a></p><h2 id="回答关键点"><a class="markdownIt-Anchor" href="#回答关键点"></a> <strong>回答关键点</strong></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL` `DNS` `TCP` `渲染</span><br></pre></td></tr></tbody></table></figure><p>浏览器从输入网址到渲染页面主要分为以下几个过程</p><ul><li>URL 输入</li><li>DNS 解析</li><li>建立 TCP 连接</li><li>发送 HTTP / HTTPS 请求（建立 TLS 连接）</li><li>服务器响应请求</li><li>浏览器解析渲染页面</li><li>HTTP 请求结束，断开 TCP 连接</li></ul><h2 id="知识点深入"><a class="markdownIt-Anchor" href="#知识点深入"></a> <strong>知识点深入</strong></h2><h3 id="1-url-输入"><a class="markdownIt-Anchor" href="#1-url-输入"></a> <strong>1. URL 输入</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/2911d132881a03e20edc7c8942e65fed.png?" alt="img"></p><p>URL地址</p><p>URL（统一资源定位符，Uniform Resource Locator）用于定位互联网上资源，俗称网址。</p><p>我们在地址栏输入 HZFE 官方网址 <a href="http://hzfe.org">hzfe.org</a> 后敲下回车，浏览器会对输入的信息进行以下判断：</p><ol><li>检查输入的内容是否是一个合法的 URL 链接。</li><li>是，则判断输入的 URL 是否完整。如果不完整，浏览器可能会对域进行猜测，补全前缀或者后缀。</li><li>否，将输入内容作为搜索条件，使用用户设置的默认搜索引擎来进行搜索。</li></ol><p>大部分浏览器会从历史记录、书签等地方开始查找我们输入的网址，并给出智能提示。</p><h3 id="2-dnsdomain-name-system解析"><a class="markdownIt-Anchor" href="#2-dnsdomain-name-system解析"></a> <strong>2. DNS（Domain Name System）解析</strong></h3><p>因为浏览器不能直接通过域名找到对应的服务器 IP 地址，所以需要进行 DNS 解析，查找到对应的 IP 地址进行访问。</p><p>DNS 解析流程如下：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/eb1b6b726e6cbe7c04beb6b7885202e4.png?" alt="img"></p><p>DNS 解析</p><ol><li>在浏览器中输入 <a href="http://hzfe.org">hzfe.org</a> 域名，操作系统检查浏览器缓存和本地的 hosts 文件中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li><li>查找本地 DNS 解析器缓存中，是否有这个网址记录，有则从记录里面找到对应的 IP 地址，完成域名解析。</li><li>使用 TCP/IP 参数中设置的 DNS 服务器进行查询。如果要查询的域名包含在本地配置区域资源中，则返回解析结果，完成域名解析。</li><li>检查本地 DNS 服务器是否缓存该网址记录，有则返回解析结果，完成域名解析。</li><li>本地 DNS 服务器发送查询报文至根 DNS 服务器，根 DNS 服务器收到请求后，用顶级域 DNS 服务器地址进行响应。</li><li>本地 DNS 服务器发送查询报文至顶级域 DNS 服务器。顶级域 DNS 服务器收到请求后，用权威 DNS 服务器地址进行响应。</li><li>本地 DNS 服务器发送查询报文至权威 DNS 服务器，权威 DNS 服务器收到请求后，用 <a href="http://hzfe.org">hzfe.org</a> 的 IP 地址进行响应，完成域名解析。</li></ol><p>查询通常遵循以上流程，从请求主机到本地 DNS 服务器的查询是递归查询，DNS 服务器获取到所需映射的查询过程是迭代查询。</p><h3 id="3-建立-tcp-连接"><a class="markdownIt-Anchor" href="#3-建立-tcp-连接"></a> <strong>3. 建立 TCP 连接</strong></h3><blockquote><p>世界上几乎所有的 HTTP 通信都是由 TCP/IP 承载的，TCP/IP 是全球计算机及网络设备都在使用的一种常用的分组交换网络分层。 HTTP 的连接实际上就是 TCP 连接以及其使用规则。 –《HTTP 权威指南》</p></blockquote><p>当浏览器获取到服务器的 IP 地址后，浏览器会用一个随机的端口（1024 &lt; 端口 &lt; 65535）向服务器 80 端口发起 TCP 连接请求（注：HTTP 默认约定 80 端口，HTTPS 为 443 端口）。这个连接请求到达服务端后，通过 TCP 三次握手，建立 TCP 的连接。</p><h4 id="31-分层模型"><a class="markdownIt-Anchor" href="#31-分层模型"></a> <strong>3.1 分层模型</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">  ----------------------------------</span><br><span class="line"><span class="number">7</span>|   应用层   |           |   <span class="variable constant_">HTTP</span>  |</span><br><span class="line"></span><br><span class="line"><span class="number">6</span>|   表示层   |   应用层   |</span><br><span class="line"></span><br><span class="line"><span class="number">5</span>|   会话层   |           |         |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">4</span>|   传输层   |   传输层   | <span class="variable constant_">TCP</span> <span class="variable constant_">TLS</span> |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">3</span>|   网络层   |   网络层   |   <span class="variable constant_">IP</span>    |</span><br><span class="line">  ---------------------------------</span><br><span class="line"><span class="number">2</span>|  数据链路层</span><br><span class="line">             |   链路层</span><br><span class="line"><span class="number">1</span>|   物理层</span><br><span class="line">  --------------------------------</span><br><span class="line">     [<span class="variable constant_">OSI</span>]   |   [<span class="variable constant_">TCP</span>/<span class="variable constant_">IP</span>]</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h4 id="32-tcp-三次握手"><a class="markdownIt-Anchor" href="#32-tcp-三次握手"></a> <strong>3.2 TCP 三次握手</strong></h4><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># <span class="variable constant_">SYN</span> 是建立连接时的握手信号，<span class="variable constant_">TCP</span> 中发送第一个 <span class="variable constant_">SYN</span> 包的为客户端，接收的为服务端</span><br><span class="line"># <span class="variable constant_">TCP</span> 中，当发送端数据到达接收端时，接收端返回一个已收到消息的通知。这个消息叫做确认应答 <span class="variable constant_">ACK</span></span><br><span class="line"></span><br><span class="line">  假设有客户端A，服务端B。我们要建立可靠的数据传输。</span><br><span class="line">      <span class="title function_">SYN</span>(=j)       <span class="comment">// SYN: A 请求建立连接</span></span><br><span class="line">  A ----------&gt; B</span><br><span class="line">                |</span><br><span class="line">     <span class="title function_">ACK</span>(=j+<span class="number">1</span>)  |   <span class="comment">// ACK: B 确认应答 A 的 SYN</span></span><br><span class="line">     <span class="title function_">SYN</span>(=k)    |   <span class="comment">// SYN: B 发送一个 SYN</span></span><br><span class="line">  A &lt;-----------</span><br><span class="line">  |</span><br><span class="line">  |  <span class="title function_">ACK</span>(=k+<span class="number">1</span>)</span><br><span class="line">   -----------&gt; B   <span class="comment">// ACK: A 确认应答 B 的包</span></span><br></pre></td></tr></tbody></table></figure><p>复制</p><ol><li>客户端发送 SYN 包（seq = j）到服务器，并进入 SYN_SEND 状态，等待服务器确认。</li><li>服务器收到 SYN 包，必须确认客户的 SYN（ACK = k + 1），同时自己也发送一个 SYN 包（seq = k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态。</li><li>客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK（ACK = k + 1），此包发送完毕，客户端和服务器进入 ESTABLISHED 状态，完成三次握手。</li></ol><h3 id="4-tls-协商"><a class="markdownIt-Anchor" href="#4-tls-协商"></a> <strong>4. TLS 协商</strong></h3><p><img src="https://ask.qcloudimg.com/http-save/4474523/cdb05918db5147cc4f92f12cad6f5d15.png?imageView2/2/w/2560/h/7000" alt="img"></p><p>TLS协商</p><p>建立连接后就可以通过 HTTP 进行数据传输。如果使用 HTTPS，会在 TCP 与 HTTP 之间多添加一层协议做加密及认证的服务。HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport Layer Security） 协议，保障了信息的安全。</p><ul><li>SSL<ul><li>认证用户和服务器，确保数据发送到正确的客户端和服务器。</li><li>加密数据防止数据中途被窃取。</li><li>维护数据的完整性，确保数据在传输过程中不被改变。</li></ul></li><li>TLS<ul><li>用于在两个通信应用程序之间提供保密性和数据完整性。该协议由两层组成：TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。</li></ul></li></ul><h4 id="41-tls-握手协议"><a class="markdownIt-Anchor" href="#41-tls-握手协议"></a> <strong>4.1 TLS 握手协议</strong></h4><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/3ac0cf1dcd3100b2b96c55bf4e827adf.png?imageView2/2/w/2560/h/7000" alt="img"></p><p>TLS握手协议</p><ol><li>客户端发出一个 client hello 消息，携带的信息包括：所支持的 SSL/TLS 版本列表；支持的与加密算法；所支持的数据压缩方法；随机数 A。</li><li>服务端响应一个 server hello 消息，携带的信息包括：协商采用的 SSL/TLS 版本号；会话 ID；随机数 B；服务端数字证书 serverCA；由于双向认证需求，服务端需要对客户端进行认证，会同时发送一个 client certificate request，表示请求客户端的证书。</li><li>客户端校验服务端的数字证书；校验通过之后发送随机数 C，该随机数称为 pre-master-key，使用数字证书中的公钥加密后发出；由于服务端发起了 client certificate request，客户端使用私钥加密一个随机数 clientRandom 随客户端的证书 clientCA 一并发出。</li><li>服务端校验客户端的证书，并成功将客户端加密的随机数 clientRandom 解密；根据随机数 A/随机数 B/随机数 C（pre-master-key） 产生动态密钥 master-key，加密一个 finish 消息发至客户端。</li><li>客户端根据同样的随机数和算法生成 master-key，加密一个 finish 消息发送至服务端。</li><li>服务端和客户端分别解密成功，至此握手完成，之后的数据包均采用 master-key 进行加密传输。</li></ol><h3 id="5-服务器响应"><a class="markdownIt-Anchor" href="#5-服务器响应"></a> <strong>5. 服务器响应</strong></h3><p>当浏览器到 web 服务器的连接建立后，浏览器会发送一个初始的 HTTP GET 请求，请求目标通常是一个 HTML 文件。服务器收到请求后，将<strong>发回一个 HTTP 响应报文</strong>，内容包括相关响应头和 HTML 正文。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line"> <span class="language-xml"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的博客<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">src</span>=<span class="string">"styles.css"</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"heading"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>A paragraph with a <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://hzfe.org/"</span>&gt;</span>link<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">scrIPt</span> <span class="attr">src</span>=<span class="string">"index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">scrIPt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><p>复制</p><h4 id="51-状态码"><a class="markdownIt-Anchor" href="#51-状态码"></a> <strong>5.1 状态码</strong></h4><p>状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五类可能取值</p><ul><li>1xx：指示信息——表示请求已接收，继续处理</li><li>2xx：成功——表示请求已被成功接收、理解、接受</li><li>3xx：重定向——要完成请求必须进行更进一步的操作</li><li>4xx：客户端错误——请求有语法错误或请求无法实现</li><li>5xx：服务器端错误——服务器未能实现合法的请求</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">HTTP 响应状态码 - HTTP | MDN (mozilla.org)</a></p><h4 id="52-常见的请求头和字段"><a class="markdownIt-Anchor" href="#52-常见的请求头和字段"></a> <strong>5.2 常见的请求头和字段</strong></h4><ul><li>Cache-Control：must-revalidate、no-cache、private（是否需要缓存资源）</li><li>Connection：keep-alive（保持连接）</li><li>Content-Encoding：gzip（web 服务器支持的返回内容压缩编码类型）</li><li>Content-Type：text/html；charset=UTF-8（文件类型和字符编码格式）</li><li>Date：Sun， 21 Sep 2021 06:18:21 GMT（服务器消息发出的时间）</li><li>Transfer-Encoding：chunked（服务器发送的资源的方式是分块发送）</li></ul><h4 id="53-http-响应报文"><a class="markdownIt-Anchor" href="#53-http-响应报文"></a> <strong>5.3 HTTP 响应报文</strong></h4><p>响应报文由四部分组成（响应行 + 响应头 + 空行 + 响应体）</p><ul><li>状态行：HTTP 版本 + 空格 + 状态码 + 空格 + 状态码描述 + 回车符（CR） + 换行符（LF）</li><li>响应头：字段名 + 冒号 + 值 + 回车符 + 换行符</li><li>空行：回车符 + 换行符</li><li>响应体：由用户自定义添加，如 post 的 body 等</li></ul><h3 id="6-浏览器解析并绘制"><a class="markdownIt-Anchor" href="#6-浏览器解析并绘制"></a> <strong>6. 浏览器解析并绘制</strong></h3><p>不同的浏览器引擎渲染过程都不太一样，这里以 Chrome 浏览器渲染方式为例。</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/601ac9a205ada2bd56a06ed97996b301.png?imageView2/2/w/2560/h/7000" alt="img"></p><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h3 id="7-tcp-断开连接"><a class="markdownIt-Anchor" href="#7-tcp-断开连接"></a> <strong>7. TCP 断开连接</strong></h3><p>现在的页面为了优化请求的耗时，默认都会开启持久连接（keep-alive），那么一个 TCP 连接确切关闭的时机，是这个 tab 标签页关闭的时候。这个关闭的过程就是<strong>四次挥手</strong>。关闭是一个全双工的过程，发包的顺序是不一定的。一般来说是客户端主动发起的关闭，过程如下图所示：</p><p><img src="https://ask.qcloudimg.com/http-save/yehe-4474523/cd2cb58d98ca10faed28f809eab5b461.png?imageView2/2/w/2560/h/7000" alt="img"></p><ol><li>主动关闭方发送一个 FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发数据了（在 FIN 包之前发送出去的数据，如果没有收到对应的 ACK 确认报文，主动关闭方依然会重发这些数据），但此时主动关闭方还可以接受数据。</li><li>被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号为收到序号+1（与 SYN 相同，一个 FIN 占用一个序号）。</li><li>被动关闭方发送一个 FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。</li><li>主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器从输入网址到页面展示的过程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#浏览器从输入网址到页面展示的过程&quot;&gt;&lt;/a&gt; 浏览器从输入网址到页面展示的过程&lt;/h1&gt;
&lt;p&gt;完整高频题库仓库地址：&lt;a href=&quot;https://gi</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>计算机网络基础（上）</title>
    <link href="http://example.com/2023/04/27/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A/"/>
    <id>http://example.com/2023/04/27/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8A/</id>
    <published>2023-04-26T16:40:12.263Z</published>
    <updated>2023-04-29T16:26:40.704Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络基础"><a class="markdownIt-Anchor" href="#计算机网络基础"></a> 计算机网络基础</h2><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> 网络分层模型</h3><h4 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#osi-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> OSI 七层模型是什么？每一层的作用是什么？</h4><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/osi-7-model.png" alt="OSI 七层模型"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p><p><img src="../../../images/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png" alt="osi七层模型2"></p><h4 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%98%AF%E4%BB%80%E4%B9%88-%E6%AF%8F%E4%B8%80%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> TCP/IP 四层模型是什么？每一层的作用是什么？</h4><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-ip-4-model.png" alt="TCP/IP 四层模型"></p><p>关于每一层作用的详细介绍，请看 <a href="https://javaguide.cn/cs-basics/network/osi&amp;tcp-ip-model.html">OSI 和 TCP/IP 网络分层模型详解（基础）open in new window</a> 这篇文章。</p><h4 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BD%91%E7%BB%9C%E8%A6%81%E5%88%86%E5%B1%82">#</a> 为什么网络要分层？</h4><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E5%B8%B8%E8%A7%81%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">#</a> 常见网络协议</h3><h4 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E5%BA%94%E7%94%A8%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 应用层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/application-layer-protocol.png" alt="应用层常见协议"></p><ul><li><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong> ：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li><li><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong> ：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li><li><strong>POP3/IMAP（邮件接收协议）</strong> ：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li><li><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li><li><strong>Telnet（远程登陆协议）</strong> ：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li><li><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong> ：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</li><li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</li><li><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</li></ul><p>关于这些协议的详细介绍请看 <a href="">应用层常见协议总结（应用层）</a> 这篇文章。</p><h4 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 传输层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/transport-layer-protocol.png" alt="传输层常见协议"></p><ul><li><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</li><li><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</li></ul><h4 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> 网络层有哪些常见的协议？</h4><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/nerwork-layer-protocol.png" alt="网络层常见协议"></p><ul><li><strong>IP（Internet Protocol，网际协议）</strong> ： TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP（Address Resolution Protocol，地址解析协议）</strong> ：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li><li><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong> ：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</li><li><strong>NAT（Network Address Translation，网络地址转换协议）</strong> ：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</li><li><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</li><li><strong>RIP(Routing Information Protocol，路由信息协议）</strong> ：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</li><li><strong>BGP（Border Gateway Protocol，边界网关协议）</strong> ：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</li></ul><h2 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#http">#</a> HTTP</h2><h3 id="-10"><a class="markdownIt-Anchor" href="#-10"></a> <a href="#%E4%BB%8E%E8%BE%93%E5%85%A5-url-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88-%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81">#</a> 从输入 URL 到页面展示到底发生了什么？（非常重要）</h3><blockquote><p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p></blockquote><p>图解（图片来源：《图解 HTTP》）：</p><p><img src="https://oss.javaguide.cn/github/javaguide/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="img"></p><blockquote><p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 <strong>OSPF（Open Shortest Path First，ospf）开放最短路径优先协议</strong>, 是由 Internet 工程任务组开发的路由选择协议</p></blockquote><p>总体来说分为以下几个过程:</p><ol><li>DNS 解析</li><li>TCP 连接</li><li>发送 HTTP 请求</li><li>服务器处理请求并返回 HTTP 报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这两篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700">从输入 URL 到页面加载发生了什么？open in new window</a></li><li><a href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li></ul><h3 id="-11"><a class="markdownIt-Anchor" href="#-11"></a> <a href="#http-%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> HTTP 状态码有哪些？</h3><p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-status-code.png" alt="常见 HTTP 状态码"></p><p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="">HTTP 常见状态码总结（应用层）</a>。</p><h3 id="-12"><a class="markdownIt-Anchor" href="#-12"></a> <a href="#http-header-%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> HTTP Header 中常见的字段有哪些？</h3><table><thead><tr><th style="text-align:left">请求头字段名</th><th style="text-align:left">说明</th><th style="text-align:left">示例</th></tr></thead><tbody><tr><td style="text-align:left">Accept</td><td style="text-align:left">能够接受的回应内容类型（Content-Types）。</td><td style="text-align:left">Accept: text/plain</td></tr><tr><td style="text-align:left">Accept-Charset</td><td style="text-align:left">能够接受的字符集</td><td style="text-align:left">Accept-Charset: utf-8</td></tr><tr><td style="text-align:left">Accept-Datetime</td><td style="text-align:left">能够接受的按照时间来表示的版本</td><td style="text-align:left">Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td></tr><tr><td style="text-align:left">Accept-Encoding</td><td style="text-align:left">能够接受的编码方式列表。参考 HTTP 压缩。</td><td style="text-align:left">Accept-Encoding: gzip, deflate</td></tr><tr><td style="text-align:left">Accept-Language</td><td style="text-align:left">能够接受的回应内容的自然语言列表。</td><td style="text-align:left">Accept-Language: en-US</td></tr><tr><td style="text-align:left">Authorization</td><td style="text-align:left">用于超文本传输协议的认证的认证信息</td><td style="text-align:left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:left">Cache-Control</td><td style="text-align:left">用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td><td style="text-align:left">Cache-Control: no-cache</td></tr><tr><td style="text-align:left">Connection</td><td style="text-align:left">该浏览器想要优先使用的连接类型</td><td style="text-align:left">Connection: keep-alive Connection: Upgrade</td></tr><tr><td style="text-align:left">Content-Length</td><td style="text-align:left">以 八位字节数组 （8 位的字节）表示的请求体的长度</td><td style="text-align:left">Content-Length: 348</td></tr><tr><td style="text-align:left">Content-MD5</td><td style="text-align:left">请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td><td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td></tr><tr><td style="text-align:left">Content-Type</td><td style="text-align:left">请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</td><td style="text-align:left">Content-Type: application/x-www-form-urlencoded</td></tr><tr><td style="text-align:left">Cookie</td><td style="text-align:left">之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td><td style="text-align:left">Cookie: $Version=1; Skin=new;</td></tr><tr><td style="text-align:left">Date</td><td style="text-align:left">发送该消息的日期和时间(按照 RFC 7231 中定义的"超文本传输协议日期"格式来发送)</td><td style="text-align:left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td></tr><tr><td style="text-align:left">Expect</td><td style="text-align:left">表明客户端要求服务器做出特定的行为</td><td style="text-align:left">Expect: 100-continue</td></tr><tr><td style="text-align:left">From</td><td style="text-align:left">发起此请求的用户的邮件地址</td><td style="text-align:left">From: <a href="mailto:user@example.com">user@example.com</a></td></tr><tr><td style="text-align:left">Host</td><td style="text-align:left">服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。</td><td style="text-align:left">Host: <a href="http://en.wikipedia.org:80">en.wikipedia.org:80</a></td></tr><tr><td style="text-align:left">If-Match</td><td style="text-align:left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td><td style="text-align:left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Modified-Since</td><td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td style="text-align:left">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td style="text-align:left">If-None-Match</td><td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td><td style="text-align:left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Range</td><td style="text-align:left">如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td><td style="text-align:left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td></tr><tr><td style="text-align:left">If-Unmodified-Since</td><td style="text-align:left">仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td><td style="text-align:left">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td></tr><tr><td style="text-align:left">Max-Forwards</td><td style="text-align:left">限制该消息可被代理及网关转发的次数。</td><td style="text-align:left">Max-Forwards: 10</td></tr><tr><td style="text-align:left">Origin</td><td style="text-align:left">发起一个针对 跨来源资源共享 的请求。</td><td style="text-align:left">Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.comopen in new window</a></td></tr><tr><td style="text-align:left">Pragma</td><td style="text-align:left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。</td><td style="text-align:left">Pragma: no-cache</td></tr><tr><td style="text-align:left">Proxy-Authorization</td><td style="text-align:left">用来向代理进行认证的认证信息。</td><td style="text-align:left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td></tr><tr><td style="text-align:left">Range</td><td style="text-align:left">仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。</td><td style="text-align:left">Range: bytes=500-999</td></tr><tr><td style="text-align:left">Referer</td><td style="text-align:left">表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td><td style="text-align:left">Referer: <a href="https://en.wikipedia.org/wiki/Main_Page">http://en.wikipedia.org/wiki/Main_Pageopen in new window</a></td></tr><tr><td style="text-align:left">TE</td><td style="text-align:left">浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；</td><td style="text-align:left">TE: trailers, deflate</td></tr><tr><td style="text-align:left">Upgrade</td><td style="text-align:left">要求服务器升级到另一个协议。</td><td style="text-align:left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td></tr><tr><td style="text-align:left">User-Agent</td><td style="text-align:left">浏览器的浏览器身份标识字符串</td><td style="text-align:left">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td></tr><tr><td style="text-align:left">Via</td><td style="text-align:left">向服务器告知，这个请求是由哪些代理发出的。</td><td style="text-align:left">Via: 1.0 fred, 1.1 <a href="http://example.com">example.com</a> (Apache/1.1)</td></tr><tr><td style="text-align:left">Warning</td><td style="text-align:left">一个一般性的警告，告知，在实体内容体中可能存在错误。</td><td style="text-align:left">Warning: 199 Miscellaneous warning</td></tr></tbody></table><h3 id="-13"><a class="markdownIt-Anchor" href="#-13"></a> <a href="#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">#</a> HTTP 和 HTTPS 有什么区别？（重要）</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http-vs-https.png" alt="HTTP 和 HTTPS 对比"></p><ul><li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li><li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li><li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，<strong>加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密</strong>。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li><li><strong>SEO（搜索引擎优化）</strong> ：搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护。使用 HTTPS 协议的网站在搜索结果中可能会被优先显示，从而对 SEO 产生影响。</li></ul><p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP vs HTTPS（应用层）</a> 。</p><h3 id="-14"><a class="markdownIt-Anchor" href="#-14"></a> <a href="#http-1-0-%E5%92%8C-http-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/1.0 和 HTTP/1.1 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.0-vs-http1.1.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p><ul><li><strong>连接方式</strong> : HTTP/1.0 为短连接，HTTP/1.1 支持长连接。</li><li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li><li><strong>缓存机制</strong> : 在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽</strong> ：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li><li><strong>Host 头（Host Header）处理</strong> :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。</li></ul><p>关于 HTTP/1.0 和 HTTP/1.1 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP/1.0 vs HTTP/1.1（应用层）</a> 。</p><h3 id="-15"><a class="markdownIt-Anchor" href="#-15"></a> <a href="#http-1-1-%E5%92%8C-http-2-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/1.1 和 HTTP/2.0 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http1.1-vs-http2.0.png" alt="HTTP/1.0 和 HTTP/1.1 对比"></p><ul><li><strong>IO 多路复用（Multiplexing）</strong> ：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</li><li><strong>二进制帧（Binary Frames）</strong> ：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</li><li><strong>头部压缩（Header Compression）</strong> ：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，减少了网络开销。</li><li><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</li></ul><h3 id="-16"><a class="markdownIt-Anchor" href="#-16"></a> <a href="#http-2-0-%E5%92%8C-http-3-0-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP/2.0 和 HTTP/3.0 有什么区别？</h3><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/http2.0-vs-http3.0.png" alt="HTTP/2.0 和 HTTP/3.0 对比"></p><ul><li><strong>传输协议</strong> ：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了<mark> <strong>QUIC</strong>（Quick UDP Internet Connections）</mark> 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</li><li><strong>连接建立</strong> ：HTTP/2.0 需要经过经典的 TCP 三次握手过程（一般是 3 个 RTT）。由于 QUIC 协议的特性，HTTP/3.0 可以避免 TCP 三次握手的延迟，允许在第一次连接时发送数据（0 个 RTT ，零往返时间）。</li><li><strong>队头阻塞</strong> ：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其它数据流不受影响（本质上是多路复用+轮询）。</li><li><strong>错误恢复</strong> ：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</li><li><strong>安全性</strong> ：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</li></ul><h3 id="-17"><a class="markdownIt-Anchor" href="#-17"></a> <a href="#http-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81">#</a> HTTP 是不保存状态的协议, 如何保存用户状态?</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p><h3 id="-18"><a class="markdownIt-Anchor" href="#-18"></a> <a href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> URI 和 URL 的区别是什么?</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><h3 id="-19"><a class="markdownIt-Anchor" href="#-19"></a> <a href="#cookie-%E5%92%8C-session-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> Cookie 和 Session 有什么区别？</h3><p>准确点来说，这个问题属于认证授权的范畴，你可以在 <a href="https://javaguide.cn/system-design/security/basis-of-authority-certification.html">认证授权基础概念详解open in new window</a> 这篇文章中找到详细的答案。</p><h2 id="-20"><a class="markdownIt-Anchor" href="#-20"></a> <a href="#ping">#</a> PING</h2><h3 id="-21"><a class="markdownIt-Anchor" href="#-21"></a> <a href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> PING 命令的作用是什么？</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p><p>这里简单举一个例子，我们来 PING 一下百度。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送4个PING请求数据包到 www.baidu.com</span></span><br><span class="line">❯ ping -c 4 www.baidu.com</span><br><span class="line"></span><br><span class="line">PING www.a.shifen.com (14.119.104.189): 56 data bytes</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms</span><br><span class="line">64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms</span><br><span class="line"></span><br><span class="line">--- www.a.shifen.com ping statistics ---</span><br><span class="line">4 packets transmitted, 4 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms</span><br></pre></td></tr></tbody></table></figure><p>PING 命令的输出结果通常包括以下几部分信息：</p><ol><li><strong>ICMP Echo Request（请求报文）信息</strong> ：序列号、TTL（Time to Live）值。</li><li><strong>目标主机的域名或 IP 地址</strong> ：输出结果的第一行。</li><li><strong>往返时间（RTT，Round-Trip Time）</strong> ：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li><li><strong>统计结果（Statistics）</strong> ：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li></ol><p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。</p><h3 id="-22"><a class="markdownIt-Anchor" href="#-22"></a> <a href="#ping-%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88">#</a> PING 命令的工作原理是什么？</h3><p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p><p>ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p><ul><li><strong>查询报文类型</strong> ：向目标主机发送请求并期望得到响应。</li><li><strong>差错报文类型</strong> ：向源主机发送错误信息，用于报告网络中的错误情况。</li></ul><p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p><ul><li>PING 命令会向目标主机发送 ICMP Echo Request。</li><li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li></ul><h2 id="-23"><a class="markdownIt-Anchor" href="#-23"></a> <a href="#dns">#</a> DNS</h2><h3 id="-24"><a class="markdownIt-Anchor" href="#-24"></a> <a href="#dns-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88">#</a> DNS 的作用是什么？</h3><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p><p><img src="https://oss.javaguide.cn/github/javaguide/cs-basics/network/dns-overview.png" alt="DNS:域名系统"></p><p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地<code>hosts</code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。</p><p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p><h3 id="-25"><a class="markdownIt-Anchor" href="#-25"></a> <a href="#dns-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B">#</a> DNS 服务器有哪些？</h3><p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p><ul><li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li><li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li><li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li><li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构</li></ul><h3 id="-26"><a class="markdownIt-Anchor" href="#-26"></a> <a href="#dns-%E8%A7%A3%E6%9E%90%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84">#</a> DNS 解析的过程是什么样的？</h3><p>整个过程的步骤比较多，我单独写了一篇文章详细介绍：<a href="">DNS 域名系统详解（应用层）</a> 。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算机网络基础&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#计算机网络基础&quot;&gt;&lt;/a&gt; 计算机网络基础&lt;/h2&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#&quot;&gt;&lt;/a&gt; &lt;a href</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/27/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/QPS/"/>
    <id>http://example.com/2023/03/27/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/QPS/</id>
    <published>2023-03-27T13:13:31.090Z</published>
    <updated>2023-03-27T13:31:01.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="性能测试-峰值qps和计算公式"><a class="markdownIt-Anchor" href="#性能测试-峰值qps和计算公式"></a> 性能测试-峰值QPS和计算公式</h1><p><strong>峰值QPS和计算公式</strong><br><strong>概述</strong><br>因特网上，经常用每秒查询率来衡量域名系统服务器的机器的性能，其即为QPS。 对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。</p><p>计算关系： QPS = 并发量 / 平均响应时间 并发量 = QPS * 平均响应时间</p><p>通常QPS用来表达和衡量当前系统的负载，也可以用RPS来表示， 我们形容当前系统的运行状态时可以说当前QPS已经达到多少多少了， 在系统环境不变的情况下存在支持的最大QPS，但并不应该用来形容机器的性能。 可以通过提高TPS来提升当前系统的处理能力，来增加最大QPS的支持。 TPS用来形容机器的性能。</p><p><strong>QPS计算原理</strong><br>QPS = req/sec = 请求数/秒</p><p>原理:每天80%的访问集中在20%的时间里，这20%时间叫做峰值时间<br>公式:( 总PV数 * 80% ) / ( 每天秒数 * 20% ) = 峰值时间每秒请求数&gt;(QPS)<br>机器:峰值时间每秒QPS / 单台机器的QPS = 需要的机器<br><strong>实例</strong><br>问:每天300w PV 的在单台机器上，这台机器需要多少QPS？</p><p>答:( 3000000 * 0.8 ) / (86400 * 0.2 ) = 139 (QPS)</p><p>问:如果一台机器的QPS是58，需要几台机器来支持？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;性能测试-峰值qps和计算公式&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#性能测试-峰值qps和计算公式&quot;&gt;&lt;/a&gt; 性能测试-峰值QPS和计算公式&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;峰值QPS和计算公式&lt;/strong&gt;&lt;br&gt;
&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/27/interview/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2023/03/27/interview/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2023-03-27T10:14:46.027Z</published>
    <updated>2023-04-30T06:00:01.298Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h1><h2 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h2><p>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNCVCQiVCQiVFNSU4QSVBMSVFNyVBRSVBMSVFNyU5MCU4NiVFNSU5OSVBOC5wbmc?x-oss-process=image/format,png" alt="任务管理器"></p><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2><p>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</p><p>与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultiThread</span> {</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line"><span class="comment">// 获取 Java 线程管理 MXBean</span></span><br><span class="line"><span class="type">ThreadMXBean</span> <span class="variable">threadMXBean</span> <span class="operator">=</span> ManagementFactory.getThreadMXBean();</span><br><span class="line"><span class="comment">// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</span></span><br><span class="line">ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="comment">// 遍历线程信息，仅打印线程 ID 和线程名称信息</span></span><br><span class="line"><span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) {</span><br><span class="line">System.out.println(<span class="string">"["</span> + threadInfo.getThreadId() + <span class="string">"] "</span> + threadInfo.getThreadName());</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述程序输出如下（输出内容可能不同，不用太纠结下面每个线程的作用，只用知道 main 线程执行 main 方法即可）：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[6] Monitor Ctrl-Break //监听线程转储或“线程堆栈跟踪”的线程</span><br><span class="line">[5] Attach Listener //负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者</span><br><span class="line">[4] Signal Dispatcher // 分发处理给 JVM 信号的线程</span><br><span class="line">[3] Finalizer //在垃圾收集前，调用对象 finalize 方法的线程</span><br><span class="line">[2] Reference Handler //用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收的线程</span><br><span class="line">[1] main //main 线程,程序入口</span><br></pre></td></tr></tbody></table></figure><p>从上面的输出内容可以看出：一个 Java 程序的运行是 main 线程和多个其他线程同时运行。</p><h2 id="进程与线程的区别总结"><a class="markdownIt-Anchor" href="#进程与线程的区别总结"></a> 进程与线程的区别总结</h2><p>线程具有许多传统进程所具有的特征，故又称为轻型进程(Light—Weight Process)或进程元；而把传统的进程称为重型进程(Heavy—Weight Process)，它相当于只有一个线程的任务。在引入了线程的操作系统中，通常一个进程都有若干个线程，至少包含一个线程。</p><ul><li><p>**根本区别：**进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p></li><li><p><strong>资源开销</strong>：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p></li><li><p>**包含关系：**如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p></li><li><p>**内存分配：**同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的</p></li><li><p>**影响关系：**一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p></li><li><p>**执行过程：**每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行</p></li></ul><h2 id="从-jvm-角度说进程和线程之间的关系重要"><a class="markdownIt-Anchor" href="#从-jvm-角度说进程和线程之间的关系重要"></a> 从 JVM 角度说进程和线程之间的关系（重要）</h2><h3 id="图解进程和线程的关系"><a class="markdownIt-Anchor" href="#图解进程和线程的关系"></a> 图解进程和线程的关系</h3><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。</p><p><img src="https://img-blog.csdnimg.cn/20191105205545651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly90aGlua3dvbi5ibG9nLmNzZG4ubmV0,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的堆和方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器、虚拟机栈 和 本地方法栈。</p><h2 id="程序计数器为什么是私有的"><a class="markdownIt-Anchor" href="#程序计数器为什么是私有的"></a> 程序计数器为什么是私有的?</h2><p>程序计数器主要有下面两个作用：</p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。</p><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a class="markdownIt-Anchor" href="#虚拟机栈和本地方法栈为什么是私有的"></a> 虚拟机栈和本地方法栈为什么是私有的?</h3><ul><li>**虚拟机栈：**每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li>**本地方法栈：**和虚拟机栈所发挥的作用非常相似，区别是： 虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。<br>所以，为了保证线程中的局部变量不被别的线程访问到，虚拟机栈和本地方法栈是线程私有的。</li></ul><h2 id="一句话简单了解堆和方法区"><a class="markdownIt-Anchor" href="#一句话简单了解堆和方法区"></a> 一句话简单了解堆和方法区</h2><p>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p><h2 id="多进程和多线程区别"><a class="markdownIt-Anchor" href="#多进程和多线程区别"></a> 多进程和多线程区别</h2><p>多进程：操作系统中同时运行的多个程序</p><p>多线程：在同一个进程中同时运行的多个任务</p><p>举个例子，多线程下载软件，可以同时运行多个线程，但是通过程序运行的结果发现，每一次结果都不一致。 因为多线程存在一个特性：随机性。造成的原因：CPU在瞬间不断切换去处理各个线程而导致的，可以理解成多个线程在抢CPU资源。</p><p>多线程提高CPU使用率</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL0pvdXJXb24vaW1hZ2UvbWFzdGVyL0phdmElRTUlQjklQjYlRTUlOEYlOTElRTclQkMlOTYlRTclQTglOEItJUU1JTlGJUJBJUU3JUExJTgwJUU3JTlGJUE1JUU4JUFGJTg2LyVFNSVBNCU5QSVFNyVCQSVCRiVFNyVBOCU4Qi5wbmc?x-oss-process=image/format,png" alt="多线程"></p><p>多线程并不能提高运行速度，但可以提高运行效率，让CPU的使用率更高。但是如果多线程有安全问题或出现频繁的上下文切换时，运算速度可能反而更低。</p><h2 id="java中的多线程"><a class="markdownIt-Anchor" href="#java中的多线程"></a> Java中的多线程</h2><p>Java程序的进程里有几个线程：主线程，垃圾回收线程(后台线程)等</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>Java支持多线程，当Java程序执行main方法的时候，就是在执行一个名字叫做main的线程，可以在main方法执行时，开启多个线程A,B,C，多个线程 main,A,B,C同时执行，相互抢夺CPU，Thread类是java.lang包下的一个常用类,每一个Thread类的对象，就代表一个处于某种状态的线程</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;进程和线程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程和线程&quot;&gt;&lt;/a&gt; 进程和线程&lt;/h1&gt;
&lt;h2 id=&quot;进程&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#进程&quot;&gt;&lt;/a&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>多态</title>
    <link href="http://example.com/2023/03/19/interview/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%80%81/"/>
    <id>http://example.com/2023/03/19/interview/java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%80%81/</id>
    <published>2023-03-19T03:45:19.800Z</published>
    <updated>2023-03-19T10:56:48.321Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态的概述"><a class="markdownIt-Anchor" href="#多态的概述"></a> 多态的概述</h2><p><img src="../../../images/image-20230319114544383.png" alt="image-20230319114544383"></p><h2 id="多态的格式与使用"><a class="markdownIt-Anchor" href="#多态的格式与使用"></a> 多态的格式与使用</h2><p><img src="../../../images/image-20230319115224624.png" alt="image-20230319115224624"></p><p><img src="../../../images/image-20230319114924748.png" alt="image-20230319114924748"></p><p><img src="../../../images/image-20230319115144427.png" alt="image-20230319115144427"></p><h2 id="多态中的成员变量的使用特点其实没有任何变化"><a class="markdownIt-Anchor" href="#多态中的成员变量的使用特点其实没有任何变化"></a> 多态中的成员变量的使用特点（其实没有任何变化）</h2><p>访问成员变量的两种方式：</p><ul><li>直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找</li><li>间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找</li></ul><p>多态中，成员变量不可以发生覆盖重写（比如，可以在子类的成员变量上添加@Override，会发现报错），只有方法可以发生覆盖重写</p><p><img src="../../../images/image-20230319115914276.png" alt="image-20230319115914276"></p><p><img src="../../../images/image-20230319115854891.png" alt="image-20230319115854891"></p><p><img src="../../../images/image-20230319115831384.png" alt="image-20230319115831384"></p><h2 id="多态中的成员方法的使用特点"><a class="markdownIt-Anchor" href="#多态中的成员方法的使用特点"></a> 多态中的成员方法的使用特点</h2><p>在多态的代码中，成员方法的访问规则：</p><ul><li>看 new 的是谁，就优先用谁，没有则向上找</li></ul><p>口诀：编译看左边，运行看右边</p><p>对比：</p><ul><li>成员变量：编译看左边，运行还看左边</li><li>成员方法：编译看左边，运行看右边</li></ul><p><img src="../../../images/image-20230319120823517.png" alt="image-20230319120823517"></p><h2 id="多态的好处"><a class="markdownIt-Anchor" href="#多态的好处"></a> 多态的好处</h2><p><img src="../../../images/image-20230319181831562.png" alt="image-20230319181831562"></p><h2 id="对象的向上转型"><a class="markdownIt-Anchor" href="#对象的向上转型"></a> 对象的向上转型</h2><p><img src="../../../images/image-20230319182510068.png" alt="image-20230319182510068"></p><h2 id="对象的向下转型"><a class="markdownIt-Anchor" href="#对象的向下转型"></a> 对象的向下转型</h2><p><img src="../../../images/image-20230319183246604.png" alt="image-20230319183246604"></p><p><img src="../../../images/image-20230319184116304.png" alt="image-20230319184116304"></p><h3 id="instanceof"><a class="markdownIt-Anchor" href="#instanceof"></a> instanceof</h3><p>如何知道一个父类引用的对象本来是哪个子类，怎么知道向哪个子类进行向下转型呢？</p><p>方案：用 instanceof</p><p>格式：  <strong>对象 instanceof 类名称</strong>      这会得到一个boolean值的结果，也就是判断前面的对象能不能当作后面类型的实例</p><p><img src="../../../images/image-20230319185037444.png" alt="image-20230319185037444"></p><p>向下转型时，在未知原本类型时，一定要用 instanceof，否则容易出异常</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多态的概述&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#多态的概述&quot;&gt;&lt;/a&gt; 多态的概述&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;../../../images/image-20230319114544383.png&quot; alt=&quot;ima</summary>
      
    
    
    
    <category term="java基础" scheme="http://example.com/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java基础" scheme="http://example.com/tags/java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/16/interview/Spring%E9%9D%A2%E8%AF%95/Spring/"/>
    <id>http://example.com/2023/03/16/interview/Spring%E9%9D%A2%E8%AF%95/Spring/</id>
    <published>2023-03-16T14:30:14.984Z</published>
    <updated>2023-03-16T15:23:01.828Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring中controlle单例"><a class="markdownIt-Anchor" href="#spring中controlle单例"></a> Spring中Controlle单例</h1><ul><li>controller默认是单例的，不要使用非静态的成员变量，否则会发生数据逻辑混乱。 正因为单例所以不是线程安全的。</li></ul><p>我们下面来简单的验证下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.riemann.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeTestController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>我们首先访问 <a href="http://localhost:8080/testScope%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF1%EF%BC%9B">http://localhost:8080/testScope，得到的答案是1；</a></li><li>然后我们再访问<a href="http://localhost:8080/testScope2%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF">http://localhost:8080/testScope2，得到的答案是</a> 2。</li></ul><p><strong>得到的不同的值，这是线程不安全的。</strong></p><p>接下来我们再来给controller增加作用多例 <mark>@Scope(“prototype”)</mark></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.riemann.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@Scope("prototype")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScopeTestController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping("/testScope2")</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScope2</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(++num);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>我们依旧首先访问 <a href="http://localhost:8080/testScope%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E6%98%AF1%EF%BC%9B">http://localhost:8080/testScope，得到的答案是1；</a></li><li>然后我们再访问 <a href="http://localhost:8080/testScope2%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%AD%94%E6%A1%88%E8%BF%98%E6%98%AF">http://localhost:8080/testScope2，得到的答案还是</a> 1。</li></ul><p>相信大家不难发现 ：</p><p><a href="https://so.csdn.net/so/search?q=%E5%8D%95%E4%BE%8B&amp;spm=1001.2101.3001.7020">单例</a>是不安全的，会导致属性重复使用。</p><p>解决方案</p><ol><li>不要在controller中定义成员变量。</li><li>万一必须要定义一个非静态成员变量时候，则通过注解@Scope(“prototype”)，将其设置为多例模式。</li><li>在Controller中使用ThreadLocal变量</li></ol><p><font color="red">Spring MVC默认是单例模式，Controller、Service、Dao都是单例</font>所以在使用不当存在一定的安全隐患。Controller单例模式的好处在与：</p><ul><li>提高性能，不用每次创建Controller实例，减少了对象创建和垃圾收集的时间</li><li>没多例的必要，由于只有一个Controller的实例，当多个线程同时调用它的时候，它的成员变量就不是线程安全的。<br>当然在大多数情况下，<strong>我们根本不需要Controller考虑线程安全的问题，除非在类中声明了<mark>成员变量</mark></strong>。因此Spring MVC的Contrller在编码时，尽量避免使用实例变量。如果一定要使用实例变量，则可以改用以下方式：<br>Controller中声明 scope=”prototype”，即设置为多例模式<br>在Controller中使用ThreadLocal变量,如：private ThreadLocal count = new ThreadLocal();</li></ul><h1 id="springmvc-singleton有几种解决方法"><a class="markdownIt-Anchor" href="#springmvc-singleton有几种解决方法"></a> springmvc singleton有几种解决方法：</h1><p>1、在控制器中不使用实例变量（可以使用方法参数的形式解决，参考博文 Spring Bean Scope 有状态的Bean 无状态的Bean）<br>2、将控制器的作用域从单例改为原型，即在spring配置文件Controller中声明 <font color="blue"><strong>scope=“prototype”</strong></font>，每次都创建新的controller<br>3、在Controller中使用<font color="blue"><strong>ThreadLocal</strong></font>变量</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring中controlle单例&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring中controlle单例&quot;&gt;&lt;/a&gt; Spring中Controlle单例&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;controller默认是单例的，不</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal使用与原理</title>
    <link href="http://example.com/2023/03/16/juc/ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2023/03/16/juc/ThreadLocal%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%8E%9F%E7%90%86/</id>
    <published>2023-03-16T14:14:34.460Z</published>
    <updated>2023-03-16T14:22:11.642Z</updated>
    
    <content type="html"><![CDATA[<p>在处理多线程并发安全的方法中，最常用的方法，就是使用锁，通过锁来控制多个不同线程对临界区的访问。</p><p>但是，无论是什么样的锁，乐观锁或者悲观锁，都会在并发冲突的时候对性能产生一定的影响。</p><p>那有没有一种方法，可以彻底避免竞争呢？</p><p>答案是肯定的，这就是ThreadLocal。</p><p>从字面意思上看，ThreadLocal可以解释成线程的局部变量，也就是说一个ThreadLocal的变量只有当前自身线程可以访问，别的线程都访问不了，那么自然就避免了线程竞争。</p><p>因此，ThreadLocal提供了一种与众不同的线程安全方式，它不是在发生线程冲突时想办法解决冲突，而是彻底的<mark>避免了冲突的发生</mark>。</p><h2 id="threadlocal的基本使用"><a class="markdownIt-Anchor" href="#threadlocal的基本使用"></a> ThreadLocal的基本使用</h2><p>创建一个ThreadLocal对象：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; localInt = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br></pre></td></tr></tbody></table></figure><p>上述代码创建一个localInt变量，由于ThreadLocal是一个泛型类，这里指定了localInt的类型为整数。</p><p>下面展示了如果设置和获取这个变量的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">setAndGet</span><span class="params">()</span>{</span><br><span class="line">    localInt.set(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">return</span> localInt.get();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上述代码设置变量的值为8，接着取得这个值。</p><p>由于ThreadLocal里设置的值，只有当前线程自己看得见，这意味着你不可能通过其他线程为它初始化值。为了弥补这一点，ThreadLocal提供了一个withInitial()方法统一初始化所有线程的ThreadLocal的值：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;Integer&gt; localInt = ThreadLocal.withInitial(() -&gt; <span class="number">6</span>);</span><br></pre></td></tr></tbody></table></figure><p>上述代码将ThreadLocal的初始值设置为6，这对全体线程都是可见的。</p><h2 id="threadlocal的实现原理"><a class="markdownIt-Anchor" href="#threadlocal的实现原理"></a> ThreadLocal的实现原理</h2><p>ThreadLocal变量只在单个线程内可见，那它是如何做到的呢？我们先从最基本的get()方法说起：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">//获得当前线程</span></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">    <span class="comment">//每个线程 都有一个自己的ThreadLocalMap，</span></span><br><span class="line">    <span class="comment">//ThreadLocalMap里就保存着所有的ThreadLocal变量</span></span><br><span class="line">    <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">//ThreadLocalMap的key就是当前ThreadLocal对象实例，</span></span><br><span class="line">        <span class="comment">//多个ThreadLocal变量都是放在这个map中的</span></span><br><span class="line">        ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) {</span><br><span class="line">            <span class="meta">@SuppressWarnings("unchecked")</span></span><br><span class="line">            <span class="comment">//从map里取出来的值就是我们需要的这个ThreadLocal变量</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 如果map没有初始化，那么在这里初始化一下</span></span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>可以看到，所谓的ThreadLocal变量就是保存在每个线程的map中的。这个map就是Thread对象中的threadLocals字段。如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal.<span class="type">ThreadLocalMap</span> <span class="variable">threadLocals</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure><p>ThreadLocal.ThreadLocalMap是一个比较特殊的Map，它的每个Entry的key都是一个弱引用：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span> <span class="keyword">extends</span> <span class="title class_">WeakReference</span>&lt;ThreadLocal&lt;?&gt;&gt; {</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    <span class="comment">//key就是一个弱引用</span></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) {</span><br><span class="line">        <span class="built_in">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样设计的好处是，如果这个变量不再被其他对象使用时，可以自动回收这个ThreadLocal对象，避免可能的内存泄露（注意，Entry中的value，依然是强引用，如何回收，见下文分解）。</p><h2 id="理解threadlocal中的内存泄漏问题"><a class="markdownIt-Anchor" href="#理解threadlocal中的内存泄漏问题"></a> 理解ThreadLocal中的内存泄漏问题</h2><p>虽然ThreadLocalMap中的key是弱引用，当不存在外部强引用的时候，就会自动被回收，但是Entry中的value依然是强引用。这个value的引用链条如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/68348e17e2588eec1a2c2f03939c5e4b.png" alt="img"></p><p>可以看到，只有当Thread被回收时，这个value才有被回收的机会，否则，只要线程不退出，value总是会存在一个强引用。但是，要求每个Thread都会退出，是一个极其苛刻的要求，对于线程池来说，大部分线程会一直存在在系统的整个生命周期内，那样的话，就会造成value对象出现泄漏的可能。处理的方法是，在ThreadLocalMap进行set(),get(),remove()的时候，都会进行清理：</p><p>以getEntry()为例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    <span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="comment">//如果找到key，直接返回</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果找不到，就会尝试清理，如果你总是访问存在的key，那么这个清理永远不会进来</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>下面是getEntryAfterMiss()的实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Entry <span class="title function_">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="type">int</span> i, Entry e)</span> {</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 整个e是entry ，也就是一个弱引用</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//如果找到了，就返回</span></span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//如果key为null，说明弱引用已经被回收了</span></span><br><span class="line">            <span class="comment">//那么就要在这里回收里面的value了</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果key不是要找的那个，那说明有hash冲突，这里是处理冲突，找下一个entry</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>真正用来回收value的是expungeStaleEntry()方法，在remove()和set()方法中，都会直接或者间接调用到这个方法进行value的清理：</p><p>从这里可以看到，ThreadLocal为了避免内存泄露，也算是花了一番大心思。不仅使用了弱引用维护key，还会在每个操作上检查key是否被回收，进而再回收value。</p><p>但是从中也可以看到，ThreadLocal并不能100%保证不发生内存泄漏。</p><p>比如，很不幸的，你的get()方法总是访问固定几个一直存在的ThreadLocal，那么清理动作就不会执行，如果你没有机会调用set()和remove()，那么这个内存泄漏依然会发生。</p><p>因此，一个良好的习惯依然是：当你不需要这个ThreadLocal变量时，主动调用remove()，这样对整个系统是有好处的。</p><h2 id="threadlocalmap中的hash冲突处理"><a class="markdownIt-Anchor" href="#threadlocalmap中的hash冲突处理"></a> ThreadLocalMap中的Hash冲突处理</h2><p>ThreadLocalMap作为一个HashMap和java.util.HashMap的实现是不同的。对于java.util.HashMap使用的是链表法来处理冲突：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/ed997859830e2a95ad92f272c84e8714.png" alt="img"></p><p>但是，对于ThreadLocalMap，它使用的是简单的线性探测法，如果发生了元素冲突，那么就使用下一个槽位存放：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/aa2d77a8245005b80f2da0c3ad65b492.png" alt="img"></p><p>具体来说，整个set()的过程如下：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/4ea4acee93016a8918a2af70a55943bc.png" alt="img"></p><h2 id="可以被继承的threadlocalinheritablethreadlocal"><a class="markdownIt-Anchor" href="#可以被继承的threadlocalinheritablethreadlocal"></a> 可以被继承的ThreadLocal——InheritableThreadLocal</h2><p>在实际开发过程中，我们可能会遇到这么一种场景。主线程开了一个子线程，但是我们希望在子线程中可以访问主线程中的ThreadLocal对象，也就是说有些数据需要进行父子线程间的传递。比如像这样：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">ThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>();</span><br><span class="line">    IntStream.range(<span class="number">0</span>,<span class="number">10</span>).forEach(i -&gt; {</span><br><span class="line">        <span class="comment">//每个线程的序列号，希望在子线程中能够拿到</span></span><br><span class="line">        threadLocal.set(i);</span><br><span class="line">        <span class="comment">//这里来了一个子线程，我们希望可以访问上面的threadLocal</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; {</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">":"</span> + threadLocal.get());</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>执行上述代码，你会看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">2</span>:<span class="literal">null</span></span><br><span class="line">Thread-<span class="number">3</span>:<span class="literal">null</span></span><br></pre></td></tr></tbody></table></figure><p>因为在子线程中，是没有threadLocal的。如果我们希望子线可以看到父线程的ThreadLocal，那么就可以使用InheritableThreadLocal。顾名思义，这就是一个支持线程间父子继承的ThreadLocal，将上述代码中的threadLocal使用InheritableThreadLocal：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">InheritableThreadLocal</span> <span class="variable">threadLocal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritableThreadLocal</span>();</span><br></pre></td></tr></tbody></table></figure><p>再执行，就能看到：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread-<span class="number">0</span>:<span class="number">0</span></span><br><span class="line">Thread-<span class="number">1</span>:<span class="number">1</span></span><br><span class="line">Thread-<span class="number">2</span>:<span class="number">2</span></span><br><span class="line">Thread-<span class="number">3</span>:<span class="number">3</span></span><br><span class="line">Thread-<span class="number">4</span>:<span class="number">4</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，每个线程都可以访问到从父进程传递过来的一个数据。虽然InheritableThreadLocal看起来挺方便的，但是依然要注意以下几点：</p><p>变量的传递是发生在线程创建的时候，如果不是新建线程，而是用了线程池里的线程，就不灵了<br>变量的赋值就是从主线程的map复制到子线程，它们的value是同一个对象，如果这个对象本身不是线程安全的，那么就会有线程安全问题</p><h2 id="写在最后的话"><a class="markdownIt-Anchor" href="#写在最后的话"></a> 写在最后的话</h2><p>今天，我们介绍了ThreadLocal，ThreadLocal在Java的多线程开发中有着十分重要的作用。</p><p>在这里，我们介绍了ThreadLocal的基本使用和实现原理，尤其重点介绍了基于当前实现原理下可能存在的内存泄漏问题。</p><p>最后，还介绍了一个用于在父子线程间传递数据的特殊的ThreadLocal实现，希望对大家有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在处理多线程并发安全的方法中，最常用的方法，就是使用锁，通过锁来控制多个不同线程对临界区的访问。&lt;/p&gt;
&lt;p&gt;但是，无论是什么样的锁，乐观锁或者悲观锁，都会在并发冲突的时候对性能产生一定的影响。&lt;/p&gt;
&lt;p&gt;那有没有一种方法，可以彻底避免竞争呢？&lt;/p&gt;
&lt;p&gt;答案是肯</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>CAS</title>
    <link href="http://example.com/2023/03/16/juc/CAS/"/>
    <id>http://example.com/2023/03/16/juc/CAS/</id>
    <published>2023-03-16T01:34:43.961Z</published>
    <updated>2023-03-17T04:19:22.741Z</updated>
    
    <content type="html"><![CDATA[<h1 id="并发编程的灵魂cas机制详解"><a class="markdownIt-Anchor" href="#并发编程的灵魂cas机制详解"></a> 并发编程的灵魂：CAS机制详解</h1><p>Java中提供了很多原子操作类来保证共享变量操作的原子性。这些原子操作的底层原理都是使用了CAS机制。在使用一门技术之前，了解这个技术的底层原理是非常重要的，所以本篇文章就先来讲讲什么是CAS机制，CAS机制存在的一些问题以及在Java中怎么使用CAS机制。</p><p>其实Java并发框架的基石一共有两块，一块是本文介绍的CAS，另一块就是AQS，后续也会写文章介绍。</p><h2 id="什么是cas机制"><a class="markdownIt-Anchor" href="#什么是cas机制"></a> 什么是CAS机制</h2><p>CAS机制是一种数据更新的方式。在具体讲什么是CAS机制之前，我们先来聊下在多线程环境下，对共享变量进行数据更新的两种模式：悲观锁模式和乐观锁模式。</p><p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源，所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如你的更新操作其实是非常快的，这种情况下你还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比你的更新操作的时间还要长。</p><p>乐观锁更新方式认为:在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现。</p><p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p><ul><li>主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li><li>工作内存中共享变量的副本值，也叫预期值：A</li><li>需要将共享变量更新到的最新值：B</li></ul><p><img src="https://pic1.zhimg.com/80/v2-f32df3fde2dc0132c05533572e2b659c_720w.webp" alt="img"></p><p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。</p><p>值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。</p><h2 id="cas机制优缺点"><a class="markdownIt-Anchor" href="#cas机制优缺点"></a> CAS机制优缺点</h2><h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3><p><strong>1. ABA问题</strong><br>ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p><p><strong>2. 可能会消耗较高的CPU</strong><br>看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p><p><strong>3. 不能保证代码块的原子性</strong><br>Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p><h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3><ul><li>可以保证变量操作的原子性；</li><li>并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li><li>在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li></ul><h2 id="java提供的cas操作类unsafe类"><a class="markdownIt-Anchor" href="#java提供的cas操作类unsafe类"></a> Java提供的CAS操作类–Unsafe类</h2><p>从Java5开始引入了对CAS机制的底层的支持，在这之前需要开发人员编写相关的代码才可以实现CAS。在原子变量类Atomic<strong>中（例如AtomicInteger、AtomicLong）可以看到CAS操作的代码，在这里的代码都是调用了底层（核心代码调用native修饰的方法）的实现方法。在AtomicInteger源码中可以看getAndSet方法和compareAndSet方法之间的关系，compareAndSet方法调用了底层的实现，该方法可以实现与一个volatile变量的读取和写入相同的效果。在前面说到了volatile不支持例如i++这样的复合操作，在Atomic</strong>中提供了实现该操作的方法。JVM对CAS的支持通过这些原子类（Atomic）暴露出来，供我们使用。</p><p>而Atomic系类的类底层调用的是Unsafe类的API，Unsafe类提供了一系列的compareAndSwap*方法，下面就简单介绍下Unsafe类的API：</p><ul><li>long objectFieldOffset（Field field）方法：返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe函数中访问指定字段时使用。如下代码使用Unsafe类获取变量value在AtomicLong对象中的内存偏移。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static {</span><br><span class="line">   try {</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">           (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">   } catch (Exception ex) { throw new Error(ex); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>int arrayBaseOffset（Class arrayClass）方法：获取数组中第一个元素的地址。</li><li>int arrayIndexScale（Class arrayClass）方法：获取数组中一个元素占用的字节。</li><li>boolean compareAndSwapLong（Object obj, long offset, long expect, long update）方法：比较对象obj中偏移量为offset的变量的值是否与expect相等，相等则使用update值更新，然后返回true，否则返回false。</li><li>public native long getLongvolatile（Object obj, long offset）方法：获取对象obj中偏移量为offset的变量对应volatile语义的值。</li><li>void putLongvolatile（Object obj, long offset, long value）方法：设置obj对象中offset偏移的类型为long的field的值为value，支持volatile语义。</li><li>void putOrderedLong（Object obj, long offset, long value）方法：设置obj对象中offset偏移地址对应的long型field的值为value。这是一个有延迟的putLongvolatile方法，并且不保证值修改对其他线程立刻可见。只有在变量使用volatile修饰并且预计会被意外修改时才使用该方法。</li><li>void park（boolean isAbsolute, long time）方法：阻塞当前线程，其中参数isAbsolute等于false且time等于0表示一直阻塞。time大于0表示等待指定的time后阻塞线程会被唤醒，这个time是个相对值，是个增量值，也就是相对当前时间累加time后当前线程就会被唤醒。如果isAbsolute等于true，并且time大于0，则表示阻塞的线程到指定的时间点后会被唤醒，这里time是个绝对时间，是将某个时间点换算为ms后的值。另外，当其他线程调用了当前阻塞线程的interrupt方法而中断了当前线程时，当前线程也会返回，而当其他线程调用了unPark方法并且把当前线程作为参数时当前线程也会返回。</li><li>void unpark（Object thread）方法：唤醒调用park后阻塞的线程。</li></ul><p>下面是JDK8新增的函数，这里只列出Long类型操作。</p><ul><li>long getAndSetLong（Object obj, long offset, long update）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量volatile语义的值为update。</li></ul><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个方法只是封装了compareAndSwapLong的使用，不需要自己写重试机制</span><br><span class="line">public final long getAndSetLong(Object var1, long var2, long var4) {</span><br><span class="line">    long var6;</span><br><span class="line">    do {</span><br><span class="line">        var6 = this.getLongVolatile(var1, var2);</span><br><span class="line">    } while(!this.compareAndSwapLong(var1, var2, var6, var4));</span><br><span class="line"></span><br><span class="line">    return var6;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>long getAndAddLong（Object obj, long offset, long addValue）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量值为原始值+addValue，原理和上面的方法类似。</li></ul><h2 id="cas使用场景"><a class="markdownIt-Anchor" href="#cas使用场景"></a> CAS使用场景</h2><ul><li>使用一个变量统计网站的访问量；</li><li>Atomic类操作；</li><li>数据库乐观锁更新。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;并发编程的灵魂cas机制详解&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#并发编程的灵魂cas机制详解&quot;&gt;&lt;/a&gt; 并发编程的灵魂：CAS机制详解&lt;/h1&gt;
&lt;p&gt;Java中提供了很多原子操作类来保证共享变量操作的原子性。这些原子操作</summary>
      
    
    
    
    <category term="juc" scheme="http://example.com/categories/juc/"/>
    
    
    <category term="juc" scheme="http://example.com/tags/juc/"/>
    
  </entry>
  
  <entry>
    <title>聚合的分类</title>
    <link href="http://example.com/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/"/>
    <id>http://example.com/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/</id>
    <published>2023-03-13T14:10:42.070Z</published>
    <updated>2023-03-13T14:36:00.032Z</updated>
    
    <content type="html"><![CDATA[<p><img src="../../images/image-20230313221322812.png" alt="image-20230313221322812"></p><p><img src="../../images/image-20230313221351783.png" alt="image-20230313221351783"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;../../images/image-20230313221322812.png&quot; alt=&quot;image-20230313221322812&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../images/image-20230313221351783.</summary>
      
    
    
    
    <category term="Elasticsearch" scheme="http://example.com/categories/Elasticsearch/"/>
    
    <category term="DSL" scheme="http://example.com/categories/Elasticsearch/DSL/"/>
    
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-12T07:06:34.463Z</published>
    <updated>2023-03-12T07:15:29.793Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT</span> <span class="operator">=</span> <span class="string">"parent"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHILD</span> <span class="operator">=</span> <span class="string">"child"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> {</span><br><span class="line">    System.out.print(PARENT + <span class="string">"A "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">   System.out.print(PARENT + <span class="string">"B "</span>);</span><br><span class="line">    }</span><br><span class="line">    {</span><br><span class="line">    System.out.print(PARENT + <span class="string">"C "</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> {</span><br><span class="line">    System.out.print(CHILD + <span class="string">"A "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">    System.out.print(CHILD + <span class="string">"B "</span>);</span><br><span class="line">    }</span><br><span class="line">        {</span><br><span class="line">        System.out.print(CHILD + <span class="string">"C "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>输出结果：parentB childB parentC parentA childC childA</p><p>官方解析：考察父类、子类的加载顺序：</p><p><strong>父类的静态代码块 &gt; 子类的静态代码块 &gt; 父类的动态代码块 &gt; 父类的构造方法 &gt; 子类的动态代码块 &gt; 子类的构造方法。</strong></p><h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2、</h2><p><img src="../../images/image-20230312151036608.png" alt="image-20230312151036608"></p><h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3、</h2><p><img src="../../images/image-20230312151525256.png" alt="image-20230312151525256"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>3-Elasticsearch</title>
    <link href="http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/"/>
    <id>http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/</id>
    <published>2023-03-05T07:37:10.157Z</published>
    <updated>2023-03-07T16:10:08.948Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式搜索引擎03"><a class="markdownIt-Anchor" href="#分布式搜索引擎03"></a> 分布式搜索引擎03</h1><h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1><h1 id="1数据聚合"><a class="markdownIt-Anchor" href="#1数据聚合"></a> 1.数据聚合</h1><p>**<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p><ul><li>什么品牌的手机最受欢迎？</li><li>这些手机的平均价格、最高价格、最低价格？</li><li>这些手机每月的销售情况如何？</li></ul><p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p><h2 id="11聚合的种类"><a class="markdownIt-Anchor" href="#11聚合的种类"></a> 1.1.聚合的种类</h2><p>聚合常见的有三类：</p><ul><li><p>**桶（Bucket）**聚合：用来对文档做分组</p><ul><li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li><li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li></ul></li><li><p>**度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等</p><ul><li>Avg：求平均值</li><li>Max：求最大值</li><li>Min：求最小值</li><li>Stats：同时求max、min、avg、sum等</li></ul></li><li><p>**管道（pipeline）**聚合：其它聚合的结果为基础做聚合</p></li></ul><blockquote><p>**注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型</p></blockquote><h2 id="12dsl实现聚合"><a class="markdownIt-Anchor" href="#12dsl实现聚合"></a> 1.2.DSL实现聚合</h2><p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p><h3 id="121bucket聚合语法"><a class="markdownIt-Anchor" href="#121bucket聚合语法"></a> 1.2.1.Bucket聚合语法</h3><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;定义聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//给聚合起个名字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;参与聚合的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span>&nbsp;<span class="comment">//&nbsp;希望获取的聚合结果数量</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>结果如图：</p><p><img src="../../../images/image-20210723171948228.png" alt="image-20210723171948228"></p><h3 id="122聚合结果排序"><a class="markdownIt-Anchor" href="#122聚合结果排序"></a> 1.2.2.聚合结果排序</h3><p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p><p>我们可以指定order属性，自定义聚合的排序方式：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_count"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span> <span class="comment">//&nbsp;按照_count升序排列</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="123限定聚合范围"><a class="markdownIt-Anchor" href="#123限定聚合范围"></a> 1.2.3.限定聚合范围</h3><p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p><p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这次，聚合得到的品牌明显变少了：</p><p><img src="../../../images/image-20210723172404836.png" alt="image-20210723172404836"></p><h3 id="124metric聚合语法"><a class="markdownIt-Anchor" href="#124metric聚合语法"></a> 1.2.4.Metric聚合语法</h3><p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p><p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"score_stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"score"</span>&nbsp;<span class="comment">//&nbsp;聚合字段，这里是score</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p><p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p><p><img src="../../../images/image-20210723172917636.png" alt="image-20210723172917636"></p><h3 id="125小结"><a class="markdownIt-Anchor" href="#125小结"></a> 1.2.5.小结</h3><p>aggs代表聚合，与query同级，此时query的作用是？</p><ul><li>限定聚合的的文档范围</li></ul><p>聚合必须的三要素：</p><ul><li>聚合名称</li><li>聚合类型</li><li>聚合字段</li></ul><p>聚合可配置属性有：</p><ul><li>size：指定聚合结果数量</li><li>order：指定聚合结果排序方式</li><li>field：指定聚合字段</li></ul><h2 id="13restapi实现聚合"><a class="markdownIt-Anchor" href="#13restapi实现聚合"></a> 1.3.RestAPI实现聚合</h2><h3 id="131api语法"><a class="markdownIt-Anchor" href="#131api语法"></a> 1.3.1.API语法</h3><p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p><p>聚合条件的语法：</p><p><img src="../../../images/image-20210723173057733.png" alt="image-20210723173057733"></p><p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p><p><img src="../../../images/image-20210723173215728.png" alt="image-20210723173215728"></p><h3 id="132业务需求"><a class="markdownIt-Anchor" href="#132业务需求"></a> 1.3.2.业务需求</h3><p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p><p><img src="../../../images/image-20210723192605566.png" alt="image-20210723192605566"></p><p>分析：</p><p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p><p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p><p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p><p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p><p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p><p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p><p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p><p><img src="../../../images/image-20210723193730799.png" alt="image-20210723193730799"></p><p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p><p>返回值类型就是页面要展示的最终结果：</p><p><img src="../../../images/image-20210723203915982.png" alt="image-20210723203915982"></p><p>结果是一个Map结构：</p><ul><li>key是字符串，城市、星级、品牌、价格</li><li>value是集合，例如多个城市的名称</li></ul><h3 id="133业务实现"><a class="markdownIt-Anchor" href="#133业务实现"></a> 1.3.3.业务实现</h3><p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p><ul><li>请求方式：<code>POST</code></li><li>请求路径：<code>/hotel/filters</code></li><li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li><li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li></ul><p>代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("filters")</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">getFilters</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">    <span class="keyword">return</span> hotelService.getFilters(params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这里调用了IHotelService中的getFilters方法，尚未实现。</p><p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure><p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.设置size</span></span><br><span class="line">        request.source().size(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2.3.聚合</span></span><br><span class="line">        buildAggregation(request);</span><br><span class="line">        <span class="comment">// 3.发出请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">        <span class="comment">// 4.1.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; brandList = getAggByName(aggregations, <span class="string">"brandAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"品牌"</span>, brandList);</span><br><span class="line">        <span class="comment">// 4.2.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; cityList = getAggByName(aggregations, <span class="string">"cityAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"城市"</span>, cityList);</span><br><span class="line">        <span class="comment">// 4.3.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; starList = getAggByName(aggregations, <span class="string">"starAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"星级"</span>, starList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildAggregation</span><span class="params">(SearchRequest request)</span> {</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"brandAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"brand"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"cityAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"city"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"starAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"starName"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getAggByName</span><span class="params">(Aggregations aggregations, String aggName)</span> {</span><br><span class="line">    <span class="comment">// 4.1.根据聚合名称获取聚合结果</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(aggName);</span><br><span class="line">    <span class="comment">// 4.2.获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;String&gt; brandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) {</span><br><span class="line">        <span class="comment">// 4.4.获取key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        brandList.add(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> brandList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="2自动补全"><a class="markdownIt-Anchor" href="#2自动补全"></a> 2.自动补全</h1><p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p><p><img src="../../../images/image-20210723204936367.png" alt="image-20210723204936367"></p><p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p><p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p><h2 id="21拼音分词器"><a class="markdownIt-Anchor" href="#21拼音分词器"></a> 2.1.拼音分词器</h2><p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p><p><img src="../../../images/image-20210723205932746.png" alt="image-20210723205932746"></p><p>课前资料中也提供了拼音分词器的安装包：</p><p><img src="../../../images/image-20210723205722303.png" alt="image-20210723205722303"></p><p>安装方式与IK分词器一样，分三步：</p><p>​①解压</p><p>​②上传到虚拟机中，elasticsearch的plugin目录</p><p>​③重启elasticsearch</p><p>​④测试</p><p>详细安装步骤可以参考IK分词器的安装过程。</p><p>测试用法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/_analyze</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家酒店还不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>结果：</p><p><img src="../../../images/image-20210723210126506.png" alt="image-20210723210126506"></p><h2 id="22自定义分词器"><a class="markdownIt-Anchor" href="#22自定义分词器"></a> 2.2.自定义分词器</h2><p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p><p>elasticsearch中分词器（analyzer）的组成包含三部分：</p><ul><li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li><li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li><li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li></ul><p>文档分词时会依次由这三部分来处理文档：</p><p><img src="../../../images/image-20210723210427878.png" alt="image-20210723210427878"></p><p>声明自定义分词器的语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"settings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analysis"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义分词器</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"my_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;&nbsp;<span class="comment">//&nbsp;分词器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"tokenizer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="string">"py"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义tokenizer&nbsp;filter</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"py"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;过滤器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;过滤器类型，这里是pinyin</span></span><br><span class="line">  <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_original"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span>&nbsp;<span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"my_analyzer"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"search_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_smart"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>测试：</p><p><img src="../../../images/image-20210723211829150.png" alt="image-20210723211829150"></p><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3><p>如何使用拼音分词器？</p><ul><li><p>①下载pinyin分词器</p></li><li><p>②解压并放到elasticsearch的plugin目录</p></li><li><p>③重启即可</p></li></ul><p>如何自定义分词器？</p><ul><li><p>①创建索引库时，在settings中配置，可以包含三部分</p></li><li><p>②character filter</p></li><li><p>③tokenizer</p></li><li><p>④filter</p></li></ul><p>拼音分词器注意事项？</p><ul><li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li></ul><h2 id="23自动补全查询"><a class="markdownIt-Anchor" href="#23自动补全查询"></a> 2.3.自动补全查询</h2><p>elasticsearch提供了<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p><ul><li><p>参与补全查询的字段必须是completion类型。</p></li><li><p>字段的内容一般是用来补全的多个词条形成的数组。</p></li></ul><p>比如，一个这样的索引库：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;创建索引库</span></span><br><span class="line">PUT&nbsp;test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"completion"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>然后插入下面的数据：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Sony"</span><span class="punctuation">,</span>&nbsp;<span class="string">"WH-1000XM3"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"SK-II"</span><span class="punctuation">,</span>&nbsp;<span class="string">"PITERA"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Nintendo"</span><span class="punctuation">,</span>&nbsp;<span class="string">"switch"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>查询的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;自动补全查询</span></span><br><span class="line">GET&nbsp;/test/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title_suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"s"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;关键字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"completion"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"title"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;补全查询的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"skip_duplicates"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;跳过重复的</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span>&nbsp;<span class="comment">//&nbsp;获取前10条结果</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h2 id="24实现酒店搜索框自动补全"><a class="markdownIt-Anchor" href="#24实现酒店搜索框自动补全"></a> 2.4.实现酒店搜索框自动补全</h2><p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p><p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p><p>因此，总结一下，我们需要做的事情包括：</p><ol><li><p>修改hotel索引库结构，设置自定义拼音分词器</p></li><li><p>修改索引库的name、all字段，使用自定义分词器</p></li><li><p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p></li><li><p>给HotelDoc类添加suggestion字段，内容包含brand、business</p></li><li><p>重新导入数据到hotel库</p></li></ol><h3 id="241修改酒店映射结构"><a class="markdownIt-Anchor" href="#241修改酒店映射结构"></a> 2.4.1.修改酒店映射结构</h3><p>代码如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"settings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"analysis"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"text_anlyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"completion_analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"py"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"pinyin"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_original"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"mappings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"properties"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"id"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"address"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"price"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"score"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"brand"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"city"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"starName"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"business"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"location"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"geo_point"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"pic"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"all"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"suggestion"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"completion"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"completion_analyzer"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="242修改hoteldoc实体"><a class="markdownIt-Anchor" href="#242修改hoteldoc实体"></a> 2.4.2.修改HotelDoc实体</h3><p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p><p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p><p>代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.business.contains(<span class="string">"/"</span>)){</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="built_in">this</span>.business.split(<span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="built_in">this</span>.suggestion = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.suggestion.add(<span class="built_in">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="built_in">this</span>.suggestion, arr);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.suggestion = Arrays.asList(<span class="built_in">this</span>.brand, <span class="built_in">this</span>.business);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="243重新导入"><a class="markdownIt-Anchor" href="#243重新导入"></a> 2.4.3.重新导入</h3><p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p><p><img src="../../../images/image-20210723213546183.png" alt="image-20210723213546183"></p><h3 id="244自动补全查询的javaapi"><a class="markdownIt-Anchor" href="#244自动补全查询的javaapi"></a> 2.4.4.自动补全查询的JavaAPI</h3><p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p><p><img src="../../../images/image-20210723213759922.png" alt="image-20210723213759922"></p><p>而自动补全的结果也比较特殊，解析的代码如下：</p><p><img src="../../../images/image-20210723213917524.png" alt="image-20210723213917524"></p><h3 id="245实现搜索框自动补全"><a class="markdownIt-Anchor" href="#245实现搜索框自动补全"></a> 2.4.5.实现搜索框自动补全</h3><p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p><p><img src="../../../images/image-20210723214021062.png" alt="image-20210723214021062"></p><p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p><p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("suggestion")</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(<span class="meta">@RequestParam("key")</span> String prefix)</span> {</span><br><span class="line">    <span class="keyword">return</span> hotelService.getSuggestions(prefix);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span>;</span><br></pre></td></tr></tbody></table></figure><p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        request.source().suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">            <span class="string">"suggestions"</span>,</span><br><span class="line">            SuggestBuilders.completionSuggestion(<span class="string">"suggestion"</span>)</span><br><span class="line">            .prefix(prefix)</span><br><span class="line">            .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">            .size(<span class="number">10</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3.发起请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">        <span class="comment">// 4.1.根据补全查询名称，获取补全结果</span></span><br><span class="line">        <span class="type">CompletionSuggestion</span> <span class="variable">suggestions</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">"suggestions"</span>);</span><br><span class="line">        <span class="comment">// 4.2.获取options</span></span><br><span class="line">        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">        <span class="comment">// 4.3.遍历</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(options.size());</span><br><span class="line">        <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().toString();</span><br><span class="line">            list.add(text);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3数据同步"><a class="markdownIt-Anchor" href="#3数据同步"></a> 3.数据同步</h1><p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p><p><img src="../../../images/image-20210723214758392.png" alt="image-20210723214758392"></p><h2 id="31思路分析"><a class="markdownIt-Anchor" href="#31思路分析"></a> 3.1.思路分析</h2><p>常见的数据同步方案有三种：</p><ul><li>同步调用</li><li>异步通知</li><li>监听binlog</li></ul><h3 id="311同步调用"><a class="markdownIt-Anchor" href="#311同步调用"></a> 3.1.1.同步调用</h3><p>方案一：同步调用</p><p><img src="../../../images/image-20210723214931869.png" alt="image-20210723214931869"></p><p>基本步骤如下：</p><ul><li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li><li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li></ul><h3 id="312异步通知"><a class="markdownIt-Anchor" href="#312异步通知"></a> 3.1.2.异步通知</h3><p>方案二：异步通知</p><p><img src="../../../images/image-20210723215140735.png" alt="image-20210723215140735"></p><p>流程如下：</p><ul><li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li><li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li></ul><h3 id="313监听binlog"><a class="markdownIt-Anchor" href="#313监听binlog"></a> 3.1.3.监听binlog</h3><p>方案三：监听binlog</p><p><img src="../../../images/image-20210723215518541.png" alt="image-20210723215518541"></p><p>流程如下：</p><ul><li>给mysql开启binlog功能</li><li>mysql完成增、删、改操作都会记录在binlog中</li><li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li></ul><h3 id="314选择"><a class="markdownIt-Anchor" href="#314选择"></a> 3.1.4.选择</h3><p>方式一：同步调用</p><ul><li>优点：实现简单，粗暴</li><li>缺点：业务耦合度高</li></ul><p>方式二：异步通知</p><ul><li>优点：低耦合，实现难度一般</li><li>缺点：依赖mq的可靠性</li></ul><p>方式三：监听binlog</p><ul><li>优点：完全解除服务间耦合</li><li>缺点：开启binlog增加数据库负担、实现复杂度高</li></ul><h2 id="32实现数据同步"><a class="markdownIt-Anchor" href="#32实现数据同步"></a> 3.2.实现数据同步</h2><h3 id="321思路"><a class="markdownIt-Anchor" href="#321思路"></a> 3.2.1.思路</h3><p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p><p>步骤：</p><ul><li><p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p></li><li><p>声明exchange、queue、RoutingKey</p></li><li><p>在hotel-admin中的增、删、改业务中完成消息发送</p></li><li><p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p></li><li><p>启动并测试数据同步功能</p></li></ul><h3 id="322导入demo"><a class="markdownIt-Anchor" href="#322导入demo"></a> 3.2.2.导入demo</h3><p>导入课前资料提供的hotel-admin项目：</p><p><img src="../../../images/image-20210723220237930.png" alt="image-20210723220237930"></p><p>运行后，访问 <a href="http://localhost:8099">http://localhost:8099</a></p><p><img src="../../../images/image-20210723220354464.png" alt="image-20210723220354464"></p><p>其中包含了酒店的CRUD功能：</p><p><img src="../../../images/image-20210723220511090.png" alt="image-20210723220511090"></p><h3 id="323声明交换机-队列"><a class="markdownIt-Anchor" href="#323声明交换机-队列"></a> 3.2.3.声明交换机、队列</h3><p>MQ结构如图：</p><p><img src="../../../images/image-20210723215850307.png" alt="image-20210723215850307"></p><h4 id="1引入依赖"><a class="markdownIt-Anchor" href="#1引入依赖"></a> 1）引入依赖</h4><p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2声明队列交换机名称"><a class="markdownIt-Anchor" href="#2声明队列交换机名称"></a> 2）声明队列交换机名称</h4><p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constatnts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstants</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"hotel.topic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.insert.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.delete.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">"hotel.insert"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_KEY</span> <span class="operator">=</span> <span class="string">"hotel.delete"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3声明队列交换机"><a class="markdownIt-Anchor" href="#3声明队列交换机"></a> 3）声明队列交换机</h4><p>在hotel-demo中，定义配置类，声明队列、交换机：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="324发送mq消息"><a class="markdownIt-Anchor" href="#324发送mq消息"></a> 3.2.4.发送MQ消息</h3><p>在hotel-admin中的增、删、改业务中分别发送MQ消息：</p><p><img src="../../../images/image-20210723221843816.png" alt="image-20210723221843816"></p><h3 id="325接收mq消息"><a class="markdownIt-Anchor" href="#325接收mq消息"></a> 3.2.5.接收MQ消息</h3><p>hotel-demo接收到MQ消息要做的事情包括：</p><ul><li>新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库</li><li>删除消息：根据传递的hotel的id删除索引库中的一条数据</li></ul><p>1）首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中新增新增、删除业务</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></tbody></table></figure><p>2）给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中实现业务：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">"hotel"</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">"hotel"</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3）编写监听器</p><p>在hotel-demo中的<code>cn.itcast.hotel.mq</code>包新增一个类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4集群"><a class="markdownIt-Anchor" href="#4集群"></a> 4.集群</h1><p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p><ul><li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li><li>单点故障问题：将分片数据在不同节点备份（replica ）</li></ul><p><strong>ES集群相关概念</strong>:</p><ul><li><p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p></li><li><p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p></li><li><p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p><p>解决问题：数据量太大，单点存储量有限的问题。</p><p><img src="../../../images/image-20200104124440086-5602723.png" alt="image-20200104124440086"></p><blockquote><p>此处，我们把数据分成3片：shard0、shard1、shard2</p></blockquote></li><li><p>主分片（Primary shard）：相对于副本分片的定义。</p></li><li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p><p>​</p></li></ul><p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p><p><img src="../../../images/image-20200104124551912.png" alt="image-20200104124551912"></p><p>现在，每个分片都有1个备份，存储在3个节点：</p><ul><li>node0：保存了分片0和1</li><li>node1：保存了分片0和2</li><li>node2：保存了分片1和2</li></ul><h2 id="41搭建es集群"><a class="markdownIt-Anchor" href="#41搭建es集群"></a> 4.1.搭建ES集群</h2><p>参考课前资料的文档：</p><p><img src="../../../images/image-20210723222732427.png" alt="image-20210723222732427"></p><p>其中的第四章节：</p><p><img src="../../../images/image-20210723222812619.png" alt="image-20210723222812619"></p><h2 id="42集群脑裂问题"><a class="markdownIt-Anchor" href="#42集群脑裂问题"></a> 4.2.集群脑裂问题</h2><h3 id="421集群职责划分"><a class="markdownIt-Anchor" href="#421集群职责划分"></a> 4.2.1.集群职责划分</h3><p>elasticsearch中集群节点有不同的职责划分：</p><p><img src="../../../images/image-20210723223008967.png" alt="image-20210723223008967"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master节点：对CPU要求高，但是内存要求第</li><li>data节点：对CPU和内存要求都高</li><li>coordinating节点：对网络带宽、CPU要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的es集群职责划分如图：</p><p><img src="../../../images/image-20210723223629142.png" alt="image-20210723223629142"></p><h3 id="422脑裂问题"><a class="markdownIt-Anchor" href="#422脑裂问题"></a> 4.2.2.脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="../../../images/image-20210723223804995.png" alt="image-20210723223804995"></p><p>此时，node2和node3认为node1宕机，就会重新选主：</p><p><img src="../../../images/image-20210723223845754.png" alt="image-20210723223845754"></p><p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="../../../images/image-20210723224000555.png" alt="image-20210723224000555"></p><p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p><h3 id="423小结"><a class="markdownIt-Anchor" href="#423小结"></a> 4.2.3.小结</h3><p>master eligible节点的作用是什么？</p><ul><li>参与集群选主</li><li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li></ul><p>data节点的作用是什么？</p><ul><li>数据的CRUD</li></ul><p>coordinator节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="43集群分布式存储"><a class="markdownIt-Anchor" href="#43集群分布式存储"></a> 4.3.集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p><h3 id="431分片存储测试"><a class="markdownIt-Anchor" href="#431分片存储测试"></a> 4.3.1.分片存储测试</h3><p>插入三条数据：</p><p><img src="../../../images/image-20210723225006058.png" alt="image-20210723225006058"></p><p><img src="../../../images/image-20210723225034637.png" alt="image-20210723225034637"></p><p><img src="../../../images/image-20210723225112029.png" alt="image-20210723225112029"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="../../../images/image-20210723225227928.png" alt="image-20210723225227928"></p><p>结果：</p><p><img src="../../../images/image-20210723225342120.png" alt="image-20210723225342120"></p><h3 id="432分片存储原理"><a class="markdownIt-Anchor" href="#432分片存储原理"></a> 4.3.2.分片存储原理</h3><p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p><p><img src="../../../images/image-20210723224354904.png" alt="image-20210723224354904"></p><p>说明：</p><ul><li>_routing默认是文档的id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="../../../images/image-20210723225436084.png" alt="image-20210723225436084"></p><p>解读：</p><ul><li>1）新增一个id=1的文档</li><li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li><li>3）shard-2的主分片在node3节点，将数据路由到node3</li><li>4）保存文档</li><li>5）同步给shard-2的副本replica-2，在node2节点</li><li>6）返回结果给coordinating-node节点</li></ul><h2 id="44集群分布式查询"><a class="markdownIt-Anchor" href="#44集群分布式查询"></a> 4.4.集群分布式查询</h2><p>elasticsearch的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="../../../images/image-20210723225809848.png" alt="image-20210723225809848"></p><h2 id="45集群故障转移"><a class="markdownIt-Anchor" href="#45集群故障转移"></a> 4.5.集群故障转移</h2><p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="../../../images/image-20210723225945963.png" alt="image-20210723225945963"></p><p>现在，node1是主节点，其它两个节点是从节点。</p><p>2）突然，node1发生了故障：</p><p><img src="../../../images/image-20210723230020574.png" alt="image-20210723230020574"></p><p>宕机后的第一件事，需要重新选主，例如选中了node2：</p><p><img src="../../../images/image-20210723230055974.png" alt="image-20210723230055974"></p><p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p><p><img src="../../../images/image-20210723230216642.png" alt="image-20210723230216642"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式搜索引擎03&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式搜索引擎03&quot;&gt;&lt;/a&gt; 分布式搜索引擎03&lt;/h1&gt;
&lt;h1 id=&quot;0学习目标&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#0学习</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Elasticsearch" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>2-Elasticsearch</title>
    <link href="http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/"/>
    <id>http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/</id>
    <published>2023-03-05T07:37:03.155Z</published>
    <updated>2023-03-09T12:59:25.448Z</updated>
    
    <content type="html"><![CDATA[<h1 id="分布式搜索引擎02"><a class="markdownIt-Anchor" href="#分布式搜索引擎02"></a> 分布式搜索引擎02</h1><p>在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p><p>所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p><h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1><h1 id="1dsl查询文档"><a class="markdownIt-Anchor" href="#1dsl查询文档"></a> 1.DSL查询文档</h1><p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p><h2 id="11dsl查询分类"><a class="markdownIt-Anchor" href="#11dsl查询分类"></a> 1.1.DSL查询分类</h2><p>Elasticsearch提供了基于JSON的DSL（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p><ul><li><p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p></li><li><p><strong>全文检索（full text）查询</strong>：<mark>利用分词器对用户输入<strong>内容分词</strong>，然后去<strong>倒排索引库</strong>中匹配</mark>。例如：</p><ul><li>match_query</li><li>multi_match_query</li></ul></li><li><p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p><ul><li>ids</li><li>range</li><li>term</li></ul></li><li><p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p><ul><li>geo_distance</li><li>geo_bounding_box</li></ul></li><li><p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p><ul><li>bool</li><li>function_score</li></ul></li></ul><p>查询的语法基本一致：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询类型"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询条件"</span><span class="punctuation">:</span>&nbsp;<span class="string">"条件值"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>我们以查询所有为例，其中：</p><ul><li>查询类型为match_all</li><li>没有查询条件</li></ul><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p><h2 id="12全文检索查询"><a class="markdownIt-Anchor" href="#12全文检索查询"></a> 1.2.全文检索查询</h2><h3 id="121使用场景"><a class="markdownIt-Anchor" href="#121使用场景"></a> 1.2.1.使用场景</h3><p>全文检索查询的基本流程如下：</p><ul><li>对用户搜索的内容做分词，得到词条</li><li>根据词条去倒排索引库中匹配，得到文档id</li><li>根据文档id找到文档，返回给用户</li></ul><p>比较常用的场景包括：</p><ul><li>商城的输入框搜索</li><li>百度输入框搜索</li></ul><p>例如京东：</p><p><img src="../../../images/image-20210721165326938.png" alt="image-20210721165326938"></p><p>因为是拿着词条去匹配，因此<font color="red">参与搜索的字段也必须是可分词的text类型</font>的字段。</p><h3 id="122基本语法"><a class="markdownIt-Anchor" href="#122基本语法"></a> 1.2.2.基本语法</h3><p>常见的全文检索查询包括：</p><ul><li>match查询：单字段查询</li><li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li></ul><p>match查询语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>mulit_match语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"multi_match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"FIELD1"</span><span class="punctuation">,</span>&nbsp;<span class="string">" FIELD12"</span><span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="123示例"><a class="markdownIt-Anchor" href="#123示例"></a> 1.2.3.示例</h3><p>match查询示例：</p><p><img src="../../../images/image-20210721170455419.png" alt="image-20210721170455419"></p><p>multi_match查询示例：</p><p><img src="../../../images/image-20210721170720691.png" alt="image-20210721170720691"></p><p>可以看到，两种查询结果是一样的，为什么？</p><p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p><p>但是，<strong>搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</strong></p><h3 id="124总结"><a class="markdownIt-Anchor" href="#124总结"></a> 1.2.4.总结</h3><p>match和multi_match的区别是什么？</p><ul><li>match：根据一个字段查询</li><li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li></ul><h2 id="13精准查询"><a class="markdownIt-Anchor" href="#13精准查询"></a> 1.3.精准查询</h2><p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p><ul><li>term：根据词条精确值查询</li><li>range：根据值的范围查询</li></ul><h3 id="131term查询"><a class="markdownIt-Anchor" href="#131term查询"></a> 1.3.1.term查询</h3><p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p><p>语法说明：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;term查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"value"</span><span class="punctuation">:</span>&nbsp;<span class="string">"VALUE"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p>当我搜索的是精确词条时，能正确查询出结果：</p><p><img src="../../../images/image-20210721171655308.png" alt="image-20210721171655308"></p><p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p><p><img src="../../../images/image-20210721171838378.png" alt="image-20210721171838378"></p><h3 id="132range查询"><a class="markdownIt-Anchor" href="#132range查询"></a> 1.3.2.range查询</h3><p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p><p>基本语法：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;range查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p><img src="../../../images/image-20210721172307172.png" alt="image-20210721172307172"></p><h3 id="133总结"><a class="markdownIt-Anchor" href="#133总结"></a> 1.3.3.总结</h3><p>精确查询常见的有哪些？</p><ul><li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li><li>range查询：根据数值范围查询，可以是数值、日期的范围</li></ul><h2 id="14地理坐标查询"><a class="markdownIt-Anchor" href="#14地理坐标查询"></a> 1.4.地理坐标查询</h2><p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p><p>常见的使用场景包括：</p><ul><li>携程：搜索我附近的酒店</li><li>滴滴：搜索我附近的出租车</li><li>微信：搜索我附近的人</li></ul><p>附近的酒店：</p><p><img src="../../../images/image-20210721172645103.png" alt="image-20210721172645103"></p><p>附近的车：</p><p><img src="../../../images/image-20210721172654880.png" alt="image-20210721172654880"></p><h3 id="141矩形范围查询"><a class="markdownIt-Anchor" href="#141矩形范围查询"></a> 1.4.1.矩形范围查询</h3><p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p><p><img src="../../../images/DKV9HZbVS6.gif" alt="DKV9HZbVS6"></p><p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p><p>语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_bounding_box查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_bounding_box"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"top_left"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 左上点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.5</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bottom_right"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 右下点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.7</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这种并不符合“附近的人”这样的需求，所以我们就不做了。</p><h3 id="142附近查询"><a class="markdownIt-Anchor" href="#142附近查询"></a> 1.4.2.附近查询</h3><p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p><p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/vZrdKAh19C.gif" alt="vZrdKAh19C"></p><p>语法说明：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_distance 查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_distance"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"distance"</span><span class="punctuation">:</span>&nbsp;<span class="string">"15km"</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"31.21,121.5"</span> <span class="comment">// 圆心</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>示例：</p><p>我们先搜索陆家嘴附近15km的酒店：</p><p><img src="../../../images/image-20210721175443234.png" alt="image-20210721175443234"></p><p>发现共有47家酒店。</p><p>然后把半径缩短到3公里：</p><p><img src="../../../images/image-20210721182031475.png" alt="image-20210721182031475"></p><p>可以发现，搜索到的酒店数量减少到了5家。</p><h2 id="15复合查询"><a class="markdownIt-Anchor" href="#15复合查询"></a> 1.5.复合查询</h2><p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p><ul><li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li><li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li></ul><h3 id="151相关性算分"><a class="markdownIt-Anchor" href="#151相关性算分"></a> 1.5.1.相关性算分</h3><p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p><p>例如，我们搜索 “虹桥如家”，结果如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"虹桥如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"外滩如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"迪士尼如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure><p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p><p><img src="../../../images/image-20210721190152134.png" alt="image-20210721190152134"></p><p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p><p><img src="../../../images/image-20210721190416214.png" alt="image-20210721190416214"></p><p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p><p><img src="../../../images/image-20210721190907320.png" alt="image-20210721190907320"></p><p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p><ul><li>TF-IDF算法</li><li>BM25算法，elasticsearch5.1版本后采用的算法</li></ul><h3 id="152算分函数查询"><a class="markdownIt-Anchor" href="#152算分函数查询"></a> 1.5.2.算分函数查询</h3><p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p><p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p><p><img src="../../../images/image-20210721191144560.png" alt="image-20210721191144560"></p><p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p><h4 id="1语法说明"><a class="markdownIt-Anchor" href="#1语法说明"></a> 1）语法说明</h4><p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p><p>function score 查询中包含四部分内容：</p><ul><li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li><li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li><li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数<ul><li>weight：函数结果是常量</li><li>field_value_factor：以文档中的某个字段值作为函数结果</li><li>random_score：以随机数作为函数结果</li><li>script_score：自定义算分函数算法</li></ul></li><li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul><li>multiply：相乘</li><li>replace：用function score替换query score</li><li>其它，例如：sum、avg、max、min</li></ul></li></ul><p>function score的运行流程如下：</p><ul><li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li><li>2）根据<strong>过滤条件</strong>，过滤文档</li><li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li><li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li></ul><p>因此，其中的关键点是：</p><ul><li>过滤条件：决定哪些文档的算分被修改</li><li>算分函数：决定函数算分的算法</li><li>运算模式：决定最终算分结果</li></ul><h4 id="2示例"><a class="markdownIt-Anchor" href="#2示例"></a> 2）示例</h4><p>需求：给“如家”这个品牌的酒店排名靠前一些</p><p>翻译一下这个需求，转换为之前说的四个要点：</p><ul><li>原始条件：不确定，可以任意变化</li><li>过滤条件：brand = “如家”</li><li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li><li>运算模式：比如求和</li></ul><p>因此最终的DSL语句如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"function_score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>  .... <span class="punctuation">}</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"functions"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span>&nbsp;<span class="comment">//&nbsp;算分函数</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;满足的条件，品牌必须是如家</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"weight"</span><span class="punctuation">:</span>&nbsp;<span class="number">2</span>&nbsp;<span class="comment">//&nbsp;算分权重为2</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"boost_mode"</span><span class="punctuation">:</span> <span class="string">"sum"</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>测试，在未添加算分函数时，如家得分如下：</p><p><img src="../../../images/image-20210721193152520.png" alt="image-20210721193152520"></p><p>添加了算分函数后，如家得分就提升了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721193458182.png" alt="image-20210721193458182"></p><h4 id="3小结"><a class="markdownIt-Anchor" href="#3小结"></a> 3）小结</h4><p>function score query定义的三要素是什么？</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><h3 id="153布尔查询"><a class="markdownIt-Anchor" href="#153布尔查询"></a> 1.5.3.布尔查询</h3><p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p><ul><li>must：必须匹配每个子查询，类似“与”</li><li>should：选择性匹配子查询，类似“或”</li><li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li><li>filter：必须匹配，<strong>不参与算分</strong></li></ul><p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p><p><img src="../../../images/image-20210721193822848.png" alt="image-20210721193822848"></p><p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p><p>需要注意的是，搜索时，参与**<mark>打分的字段越多，查询的性能也越差</mark>**。因此这种多条件查询时，建议这样做：</p><ul><li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li><li>其它过滤条件，采用filter查询。不参与算分</li></ul><h4 id="1语法示例"><a class="markdownIt-Anchor" href="#1语法示例"></a> 1）语法示例：</h4><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bool"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"city"</span><span class="punctuation">:</span>&nbsp;<span class="string">"上海"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"should"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"皇冠假日"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"华美达"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must_not"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">500</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">45</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2示例-2"><a class="markdownIt-Anchor" href="#2示例-2"></a> 2）示例</h4><p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p><p>分析：</p><ul><li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li><li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li><li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li></ul><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721194744183.png" alt="image-20210721194744183"></p><h4 id="3小结-2"><a class="markdownIt-Anchor" href="#3小结-2"></a> 3）小结</h4><p>bool查询有几种逻辑关系？</p><ul><li>must：必须匹配的条件，可以理解为“与”</li><li>should：选择性匹配的条件，可以理解为“或”</li><li>must_not：必须不匹配的条件，不参与打分</li><li>filter：必须匹配的条件，不参与打分</li></ul><h1 id="2搜索结果处理"><a class="markdownIt-Anchor" href="#2搜索结果处理"></a> 2.搜索结果处理</h1><p>搜索的结果可以按照用户指定的方式去处理或展示。</p><h2 id="21排序"><a class="markdownIt-Anchor" href="#21排序"></a> 2.1.排序</h2><p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p><h3 id="211普通字段排序"><a class="markdownIt-Anchor" href="#211普通字段排序"></a> 2.1.1.普通字段排序</h3><p>keyword、数值、日期类型排序的语法基本一致。</p><p><strong>语法</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span> </span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"desc"</span>&nbsp;&nbsp;<span class="comment">//&nbsp;排序字段、排序方式ASC、DESC</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p><p><strong>示例</strong>：</p><p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p><p><img src="../../../images/image-20210721195728306.png" alt="image-20210721195728306"></p><h3 id="212地理坐标排序"><a class="markdownIt-Anchor" href="#212地理坐标排序"></a> 2.1.2.地理坐标排序</h3><p>地理坐标排序略有不同。</p><p><strong>语法说明</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span> <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这个查询的含义是：</p><ul><li>指定一个坐标，作为目标点</li><li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li><li>根据距离排序</li></ul><p><strong>示例：</strong></p><p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p><p>提示：获取你的位置的经纬度的方式：<a href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p><p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p><p><img src="../../../images/image-20210721200214690.png" alt="image-20210721200214690"></p><h2 id="22分页"><a class="markdownIt-Anchor" href="#22分页"></a> 2.2.分页</h2><p><strong>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了</strong>。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p><ul><li>from：从第几个文档开始</li><li>size：总共查询几个文档</li></ul><p>类似于mysql中的<code>limit ?, ?</code></p><h3 id="221基本的分页"><a class="markdownIt-Anchor" href="#221基本的分页"></a> 2.2.1.基本的分页</h3><p>分页的基本语法如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="222深度分页问题"><a class="markdownIt-Anchor" href="#222深度分页问题"></a> 2.2.2.深度分页问题</h3><p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">990</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p><p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p><p><img src="../../../images/image-20210721200643029.png" alt="image-20210721200643029"></p><p>查询TOP1000，如果es是单点模式，这并无太大影响。</p><p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p><p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p><p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p><p><img src="../../../images/image-20210721201003229.png" alt="image-20210721201003229"></p><p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p><p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p><p>针对深度分页，ES提供了两种解决方案，<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p><ul><li><mark>search after</mark>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li><li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li></ul><h3 id="223小结"><a class="markdownIt-Anchor" href="#223小结"></a> 2.2.3.小结</h3><p>分页查询的常见实现方案以及优缺点：</p><ul><li><p><code>from + size</code>：</p><ul><li>优点：支持随机翻页</li><li>缺点：深度分页问题，默认查询上限（from + size）是10000</li><li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li></ul></li><li><p><code>after search</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：只能向后逐页查询，不支持随机翻页</li><li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li></ul></li><li><p><code>scroll</code>：</p><ul><li>优点：没有查询上限（单次查询的size不超过10000）</li><li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li><li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li></ul></li></ul><h2 id="23高亮"><a class="markdownIt-Anchor" href="#23高亮"></a> 2.3.高亮</h2><h3 id="231高亮原理"><a class="markdownIt-Anchor" href="#231高亮原理"></a> 2.3.1.高亮原理</h3><p>什么是高亮显示呢？</p><p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p><p><img src="../../../images/image-20210721202705030.png" alt="image-20210721202705030"></p><p>高亮显示的实现分为两步：</p><ul><li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li><li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li></ul><h3 id="232实现高亮"><a class="markdownIt-Anchor" href="#232实现高亮"></a> 2.3.2.实现高亮</h3><p><strong>高亮的语法</strong>：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"highlight"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;指定要高亮的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"pre_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;em&gt;"</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的前置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"post_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;/em&gt;"</span>&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的后置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p><strong>注意：</strong></p><ul><li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li><li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li><li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li></ul><p><strong>示例</strong>：</p><p><img src="../../../images/image-20210721203349633.png" alt="image-20210721203349633"></p><h2 id="24总结"><a class="markdownIt-Anchor" href="#24总结"></a> 2.4.总结</h2><p>查询的DSL是一个大的JSON对象，包含下列属性：</p><ul><li>query：查询条件</li><li>from和size：分页条件</li><li>sort：排序条件</li><li>highlight：高亮条件</li></ul><p>示例：</p><p><img src="../../../images/image-20210721203657850.png" alt="image-20210721203657850"></p><h1 id="3restclient查询文档"><a class="markdownIt-Anchor" href="#3restclient查询文档"></a> 3.RestClient查询文档</h1><p>文档的查询同样适用前面学习的 RestHighLevelClient对象，基本步骤包括：</p><ul><li>1）准备Request对象</li><li>2）准备请求参数</li><li>3）发起请求</li><li>4）解析响应</li></ul><h2 id="31快速入门"><a class="markdownIt-Anchor" href="#31快速入门"></a> 3.1.快速入门</h2><p>我们以match_all查询为例</p><h3 id="311发起查询请求"><a class="markdownIt-Anchor" href="#311发起查询请求"></a> 3.1.1.发起查询请求</h3><p><img src="../../../images/image-20210721203950559.png" alt="image-20210721203950559"></p><p>代码解读：</p><ul><li><p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p></li><li><p>第二步，利用<font color="red"><code>request.source()</code></font>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p><ul><li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li></ul></li><li><p>第三步，利用client.search()发送请求，得到响应</p></li></ul><p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p><p><img src="../../../images/image-20210721215640790.png" alt="image-20210721215640790"></p><p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p><p><img src="../../../images/image-20210721215729236.png" alt="image-20210721215729236"></p><h3 id="312解析响应"><a class="markdownIt-Anchor" href="#312解析响应"></a> 3.1.2.解析响应</h3><p>响应结果的解析：</p><p><img src="../../../images/image-20210721214221057.png" alt="image-20210721214221057"></p><p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p><ul><li><code>hits</code>：命中的结果<ul><li><code>total</code>：总条数，其中的value是具体的总条数值</li><li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li><li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象<ul><li><code>_source</code>：文档中的原始数据，也是json对象</li></ul></li></ul></li></ul><p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p><ul><li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果<ul><li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li><li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组<ul><li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li></ul></li></ul></li></ul><h3 id="313完整代码"><a class="markdownIt-Anchor" href="#313完整代码"></a> 3.1.3.完整代码</h3><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="314小结"><a class="markdownIt-Anchor" href="#314小结"></a> 3.1.4.小结</h3><p>查询的基本步骤是：</p><ol><li><p>创建SearchRequest对象</p></li><li><p>准备Request.source()，也就是DSL。</p><p>① QueryBuilders来构建查询条件</p><p>② 传入Request.source() 的 query() 方法</p></li><li><p>发送请求，得到结果</p></li><li><p>解析结果（参考JSON结果，从外到内，逐层解析）</p></li></ol><h2 id="32match查询"><a class="markdownIt-Anchor" href="#32match查询"></a> 3.2.match查询</h2><p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p><p><img src="../../../images/image-20210721215923060.png" alt="image-20210721215923060"></p><p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p><p><img src="../../../images/image-20210721215843099.png" alt="image-20210721215843099"></p><p>而结果解析代码则完全一致，可以抽取并共享。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="33精确查询"><a class="markdownIt-Anchor" href="#33精确查询"></a> 3.3.精确查询</h2><p>精确查询主要是两者：</p><ul><li>term：词条精确匹配</li><li>range：范围查询</li></ul><p>与之前的查询相比，差异同样在查询条件，其它都一样。</p><p>查询条件构造的API如下：</p><p><img src="../../../images/image-20210721220305140.png" alt="image-20210721220305140"></p><h2 id="34布尔查询"><a class="markdownIt-Anchor" href="#34布尔查询"></a> 3.4.布尔查询</h2><p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p><p><img src="../../../images/image-20210721220927286.png" alt="image-20210721220927286"></p><p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">"city"</span>, <span class="string">"杭州"</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">"price"</span>).lte(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="35排序-分页"><a class="markdownIt-Anchor" href="#35排序-分页"></a> 3.5.排序、分页</h2><p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p><p>对应的API如下：</p><p><img src="../../../images/image-20210721221121266.png" alt="image-20210721221121266"></p><p>完整代码示例：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">"price"</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="36高亮"><a class="markdownIt-Anchor" href="#36高亮"></a> 3.6.高亮</h2><p>高亮的代码与之前代码差异较大，有两点：</p><ul><li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li><li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li></ul><h3 id="361高亮请求构建"><a class="markdownIt-Anchor" href="#361高亮请求构建"></a> 3.6.1.高亮请求构建</h3><p>高亮请求的构建API如下：</p><p><img src="../../../images/image-20210721221744883.png" alt="image-20210721221744883"></p><p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">"name"</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="362高亮结果解析"><a class="markdownIt-Anchor" href="#362高亮结果解析"></a> 3.6.2.高亮结果解析</h3><p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p><p>因此解析高亮的代码需要额外处理：</p><p><img src="../../../images/image-20210721222057212.png" alt="image-20210721222057212"></p><p>代码解读：</p><ul><li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li><li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li><li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li><li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li><li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li></ul><p>完整代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) {</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="4黑马旅游案例"><a class="markdownIt-Anchor" href="#4黑马旅游案例"></a> 4.黑马旅游案例</h1><p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。</p><p>我们实现四部分功能：</p><ul><li>酒店搜索和分页</li><li>酒店结果过滤</li><li>我周边的酒店</li><li>酒店竞价排名</li></ul><p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a href="http://localhost:8090">http://localhost:8090</a>，就能看到项目页面了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721223159598.png" alt="image-20210721223159598"></p><h2 id="41酒店搜索和分页"><a class="markdownIt-Anchor" href="#41酒店搜索和分页"></a> 4.1.酒店搜索和分页</h2><p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p><h3 id="411需求分析"><a class="markdownIt-Anchor" href="#411需求分析"></a> 4.1.1.需求分析</h3><p>在项目的首页，有一个大大的搜索框，还有分页按钮：</p><p><img src="../../../images/image-20210721223859419.png" alt="image-20210721223859419"></p><p>点击搜索按钮，可以看到浏览器控制台发出了请求：</p><p><img src="../../../images/image-20210721224033789.png" alt="image-20210721224033789"></p><p>请求参数如下：</p><p><img src="../../../images/image-20210721224112708.png" alt="image-20210721224112708"></p><p>由此可以知道，我们这个请求的信息如下：</p><ul><li>请求方式：POST</li><li>请求路径：/hotel/list</li><li>请求参数：JSON对象，包含4个字段：<ul><li>key：搜索关键字</li><li>page：页码</li><li>size：每页大小</li><li>sortBy：排序，目前暂不实现</li></ul></li><li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：<ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul></li></ul><p>因此，我们实现业务的流程如下：</p><ul><li>步骤一：定义实体类，接收请求参数的JSON对象</li><li>步骤二：编写controller，接收页面的请求</li><li>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页</li></ul><h3 id="412定义实体类"><a class="markdownIt-Anchor" href="#412定义实体类"></a> 4.1.2.定义实体类</h3><p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p><p>1）请求参数</p><p>前端请求的json结构如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"key"</span><span class="punctuation">:</span> <span class="string">"搜索关键字"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"page"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"size"</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sortBy"</span><span class="punctuation">:</span> <span class="string">"default"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>2）返回值</p><p>分页查询，需要返回分页结果PageResult，包含两个属性：</p><ul><li><code>total</code>：总条数</li><li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li></ul><p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> {</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> {</span><br><span class="line">        <span class="built_in">this</span>.total = total;</span><br><span class="line">        <span class="built_in">this</span>.hotels = hotels;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="413定义controller"><a class="markdownIt-Anchor" href="#413定义controller"></a> 4.1.3.定义controller</h3><p>定义一个HotelController，声明查询接口，满足下列要求：</p><ul><li>请求方式：Post</li><li>请求路径：/hotel/list</li><li>请求参数：对象，类型为RequestParam</li><li>返回值：PageResult，包含两个属性<ul><li><code>Long total</code>：总条数</li><li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li></ul></li></ul><p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/hotel")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"><span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping("/list")</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="414实现搜索业务"><a class="markdownIt-Anchor" href="#414实现搜索业务"></a> 4.1.4.实现搜索业务</h3><p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。</p><p>1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure><p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestHighLevelClient <span class="title function_">client</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">    ));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="keyword">private</span> PageResult <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line"><span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, hotels);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="42酒店结果过滤"><a class="markdownIt-Anchor" href="#42酒店结果过滤"></a> 4.2.酒店结果过滤</h2><p>需求：添加品牌、城市、星级、价格等过滤功能</p><h3 id="421需求分析"><a class="markdownIt-Anchor" href="#421需求分析"></a> 4.2.1.需求分析</h3><p>在页面搜索框下面，会有一些过滤项：</p><p><img src="../../../images/image-20210722091940726.png" alt="image-20210722091940726"></p><p>传递的参数如图：</p><p><img src="../../../images/image-20210722092051994.png" alt="image-20210722092051994"></p><p>包含的过滤条件有：</p><ul><li>brand：品牌值</li><li>city：城市</li><li>minPrice~maxPrice：价格范围</li><li>starName：星级</li></ul><p>我们需要做两件事情：</p><ul><li>修改请求参数的对象RequestParams，接收上述参数</li><li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li></ul><h3 id="422修改实体类"><a class="markdownIt-Anchor" href="#422修改实体类"></a> 4.2.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="423修改搜索业务"><a class="markdownIt-Anchor" href="#423修改搜索业务"></a> 4.2.3.修改搜索业务</h3><p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。</p><p>在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p><ul><li>品牌过滤：是keyword类型，用term查询</li><li>星级过滤：是keyword类型，用term查询</li><li>价格过滤：是数值类型，用range查询</li><li>城市过滤：是keyword类型，用term查询</li></ul><p>多个查询条件组合，肯定是boolean查询来组合：</p><ul><li>关键字搜索放到must中，参与算分</li><li>其它过滤条件放到filter中，不参与算分</li></ul><p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：</p><p><img src="../../../images/image-20210722092935453.png" alt="image-20210722092935453"></p><p>buildBasicQuery的代码如下：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line"><span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="43我周边的酒店"><a class="markdownIt-Anchor" href="#43我周边的酒店"></a> 4.3.我周边的酒店</h2><p>需求：我附近的酒店</p><h3 id="431需求分析"><a class="markdownIt-Anchor" href="#431需求分析"></a> 4.3.1.需求分析</h3><p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：</p><p><img src="../../../images/image-20210722093414542.png" alt="image-20210722093414542"></p><p>并且，在前端会发起查询请求，将你的坐标发送到服务端：</p><p><img src="../../../images/image-20210722093642382.png" alt="image-20210722093642382"></p><p>我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p><ul><li>修改RequestParams参数，接收location字段</li><li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li></ul><h3 id="432修改实体类"><a class="markdownIt-Anchor" href="#432修改实体类"></a> 4.3.2.修改实体类</h3><p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="433距离排序api"><a class="markdownIt-Anchor" href="#433距离排序api"></a> 4.3.3.距离排序API</h3><p>我们以前学习过排序功能，包括两种：</p><ul><li>普通字段排序</li><li>地理坐标排序</li></ul><p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"> &nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span>&nbsp;&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><p>对应的java代码示例：</p><p><img src="../../../images/image-20210722095227059.png" alt="image-20210722095227059"></p><h3 id="434添加距离排序"><a class="markdownIt-Anchor" href="#434添加距离排序"></a> 4.3.4.添加距离排序</h3><p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p><p><img src="../../../images/image-20210722095902314.png" alt="image-20210722095902314"></p><p>完整代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="literal">null</span> &amp;&amp; !location.equals(<span class="string">""</span>)) {</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">"location"</span>, <span class="keyword">new</span> <span class="title class_">GeoPoint</span>(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="435排序距离显示"><a class="markdownIt-Anchor" href="#435排序距离显示"></a> 4.3.5.排序距离显示</h3><p>重启服务后，测试我的酒店功能：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100040674.png" alt="image-20210722100040674"></p><p>发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？</p><p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p><p><img src="../../../images/image-20210722095648542.png" alt="image-20210722095648542"></p><p>因此，我们在结果解析阶段，除了解析source部分以外，还要得到<mark><strong>sort</strong></mark>部分，也就是排序的距离，然后放到响应结果中。</p><p>我们要做两件事：</p><ul><li>修改HotelDoc，添加排序距离字段，用于页面显示</li><li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li></ul><p>1）修改HotelDoc类，添加距离字段</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>2）修改HotelService中的handleResponse方法</p><p><img src="../../../images/image-20210722100613966.png" alt="image-20210722100613966"></p><p>重启后测试，发现页面能成功显示距离了：</p><p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100838604.png" alt="image-20210722100838604"></p><h2 id="44酒店竞价排名"><a class="markdownIt-Anchor" href="#44酒店竞价排名"></a> 4.4.酒店竞价排名</h2><p>需求：让指定的酒店在搜索结果中排名置顶</p><h3 id="441需求分析"><a class="markdownIt-Anchor" href="#441需求分析"></a> 4.4.1.需求分析</h3><p>要让指定酒店在搜索结果中排名置顶，效果如图：</p><p><img src="../../../images/image-20210722100947292.png" alt="image-20210722100947292"></p><p>页面会给指定的酒店添加<strong>广告</strong>标记。</p><p>那怎样才能让指定的酒店排名置顶呢？</p><p>我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p><ul><li>过滤条件：哪些文档要加分</li><li>算分函数：如何计算function score</li><li>加权方式：function score 与 query score如何运算</li></ul><p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。</p><p>比如，我们给酒店添加一个字段：isAD，Boolean类型：</p><ul><li>true：是广告</li><li>false：不是广告</li></ul><p>这样function_score包含3个要素就很好确定了：</p><ul><li>过滤条件：判断isAD 是否为true</li><li>算分函数：我们可以用最简单暴力的weight，固定加权值</li><li>加权方式：可以用默认的相乘，大大提高算分</li></ul><p>因此，业务的实现步骤包括：</p><ol><li><p>给HotelDoc类添加isAD字段，Boolean类型</p></li><li><p>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</p></li><li><p>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</p></li></ol><h3 id="442修改hoteldoc实体"><a class="markdownIt-Anchor" href="#442修改hoteldoc实体"></a> 4.4.2.修改HotelDoc实体</h3><p>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：</p><p><img src="../../../images/image-20210722101908062.png" alt="image-20210722101908062"></p><h3 id="443添加广告标记"><a class="markdownIt-Anchor" href="#443添加广告标记"></a> 4.4.3.添加广告标记</h3><p>接下来，我们挑几个酒店，添加isAD字段，设置为true：</p><figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure><h3 id="444添加算分函数查询"><a class="markdownIt-Anchor" href="#444添加算分函数查询"></a> 4.4.4.添加算分函数查询</h3><p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p><p>function_score查询结构如下：</p><p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p><p>对应的JavaAPI如下：</p><p><img src="../../../images/image-20210722102850818.png" alt="image-20210722102850818"></p><p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p><p>修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    <span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQuery</span> <span class="operator">=</span></span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]{</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">"isAD"</span>, <span class="literal">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        });</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;分布式搜索引擎02&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#分布式搜索引擎02&quot;&gt;&lt;/a&gt; 分布式搜索引擎02&lt;/h1&gt;
&lt;p&gt;在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Elasticsearch" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Elasticsearch" scheme="http://example.com/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/</id>
    <published>2023-03-05T07:18:41.560Z</published>
    <updated>2023-03-30T14:33:04.455Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><h1 id="1-elasticsearch是什么"><a class="markdownIt-Anchor" href="#1-elasticsearch是什么"></a> 1、Elasticsearch是什么</h1><h2 id="11-概念"><a class="markdownIt-Anchor" href="#11-概念"></a> 1.1 概念:</h2><p>Elasticsearch是由 Java语言开发<strong>基于Lucene</strong>的一款开源的搜索、聚合分析和存储引擎。同时它也可以称作是一种非关系型文档数据库。</p><p><img src="../../images/image-20230305161034119.png" alt="image-20230305161034119"></p><h2 id="es可以替代mysql吗"><a class="markdownIt-Anchor" href="#es可以替代mysql吗"></a> ES可以替代MySQL吗？</h2><p>ElasticSearch和MySql分工不同，MySQL负责存储数据，ElasticSearch负责搜索数据</p><ul><li><p>MySQL有事务性，而ElasticSearch<mark>没有事务性</mark>，所以你<font color="red">删了的数据是无法恢复的</font>。</p></li><li><p>ElasticSearch<mark>没有物理外键</mark>这个特性，如果你的数据强一致性要求比较高还是建议慎用</p></li></ul><p><img src="../../images/image-20230305161337185.png" alt="image-20230305161337185"></p><h2 id="12特点"><a class="markdownIt-Anchor" href="#12特点"></a> 1.2特点</h2><ul><li>天生分布式、高性能（PB数据下可以秒读）、高可用、易扩展、易维护</li><li>跨语言、跨平台:几乎支持所有主流编程语言，并且支持在“Linux、Windows、MacOs”多平台部署</li><li>支持结构化、非结构化、地理位置搜索等</li></ul><h2 id="13适用场景"><a class="markdownIt-Anchor" href="#13适用场景"></a> 1.3适用场景</h2><ul><li>海量数据的全文检索，搜索引擎、垂直搜索、站内搜索:<ul><li>百度、知乎、微博、CSDN</li><li>导航、外卖、团购等软件</li><li>以京东、淘宝为代表的垂直搜索</li><li>B站、抖音、爱奇艺、QQ音乐等音视频软件Glthub</li></ul></li><li>数据分析和聚合查询.</li><li>日志系统 : ELK</li></ul><h1 id="elasticsearch核心概念"><a class="markdownIt-Anchor" href="#elasticsearch核心概念"></a> Elasticsearch核心概念</h1><p><img src="../../images/image-20230305161535075.png" alt="image-20230305161535075"></p><p><img src="../../images/image-20230305161817337.png" alt="image-20230305161817337"></p><p><img src="../../images/image-20230305162010287.png" alt="image-20230305162010287"></p><h1 id="mysql数据库查询存在的问题"><a class="markdownIt-Anchor" href="#mysql数据库查询存在的问题"></a> MySQL数据库查询存在的问题：</h1><p><img src="../../images/image-20230305153910496.png" alt="image-20230305153910496"></p><p><img src="../../images/image-20230305154253699.png" alt="image-20230305154253699"></p><h1 id="es的倒排索引"><a class="markdownIt-Anchor" href="#es的倒排索引"></a> ES的倒排索引</h1><p><img src="../../images/image-20230305154901840.png" alt="image-20230305154901840"></p><h1 id="elasticsearch数据的存储和搜索原理"><a class="markdownIt-Anchor" href="#elasticsearch数据的存储和搜索原理"></a> Elasticsearch数据的存储和搜索原理</h1><p><img src="../../images/image-20230305155606164.png" alt="image-20230305155606164"></p><p><img src="../../images/image-20230305155847211.png" alt="image-20230305155847211"></p><h3 id="1-解决性能低问题"><a class="markdownIt-Anchor" href="#1-解决性能低问题"></a> 1. 解决性能低问题：</h3><h4 id="如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"><a class="markdownIt-Anchor" href="#如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"></a> <strong>如果倒排索引中tearm词条太多不会导致一样要遍历很久吗？不会</strong></h4><p>因为ES生成的到排序索引中，词条会排序，形成一颗树形结构，提升词条的查询速度。</p><h3 id="2-解决功能弱问题"><a class="markdownIt-Anchor" href="#2-解决功能弱问题"></a> 2. 解决功能弱问题：</h3><p>ES会先对查询关键字进行分词，再进行查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;hr&gt;
&lt;h1 id=&quot;1-elasticsearch是什么&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-elasticsearch是什么&quot;&gt;&lt;/a&gt; 1、Elasticsearch是什么&lt;/h1&gt;
&lt;h2 id=&quot;11-概念&quot;&gt;&lt;a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Netty面试题</title>
    <link href="http://example.com/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/"/>
    <id>http://example.com/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/</id>
    <published>2023-03-04T02:25:13.345Z</published>
    <updated>2023-03-08T11:47:06.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1><h2 id="1-什么是-netty"><a class="markdownIt-Anchor" href="#1-什么是-netty"></a> 1、什么是 Netty？</h2><p>Netty 是由 JBOSS 提供的一个 Java 开源框架。Netty 提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序,是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</p><h2 id="2-netty-的优势"><a class="markdownIt-Anchor" href="#2-netty-的优势"></a> 2、Netty 的优势？</h2><ul><li><p>使用简单：封闭了 Java 原生 NIO 类库繁琐的 API，使用起来更加高效；</p></li><li><p>功能强大：预置多种编码能力，支持多种主流协议。同时通过 <mark>ChannelHandler</mark> 可以进行灵活的拓展，支持很强的定制能力；</p></li><li><p>高性能：与其它业界主流 NIO 框架相比，Netty 综合更优。主要体现在<mark>吞吐量更高、延迟更低、减少资源消耗以及最小化不必要的内存复制；</mark></p></li><li><p>社区活跃与稳定：版本更新周期短，BUG 修复速度快，让开发者可以专注业务本身。</p></li></ul><h2 id="3-netty-有什么特点"><a class="markdownIt-Anchor" href="#3-netty-有什么特点"></a> 3、Netty 有什么特点？</h2><ul><li><p><strong>高并发</strong>：Netty 是一款基于 NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架。</p></li><li><p><strong>传输快</strong>：Netty 使用零拷贝特性，尽量减少不必要的内存拷贝，实现更快的传输效率。</p></li><li><p><strong>封装好</strong>：Netty 封装了 NIO 操作的很多细节，提供易于使用的 API。</p></li></ul><h2 id="4-netty-有哪些应用场景"><a class="markdownIt-Anchor" href="#4-netty-有哪些应用场景"></a> 4、Netty 有哪些应用场景？</h2><p>理论上来说，NIO 可以做的事情，Netty 都可以做并且更好。Netty 主要用来做网络通信：</p><ul><li>RPC 框架的网络通信工具；</li><li>实现一个 HTTP 服务器；</li><li>实现一个即时通讯系统；</li><li>实现消息推送系统。</li></ul><h2 id="5-netty-的高性能体现在"><a class="markdownIt-Anchor" href="#5-netty-的高性能体现在"></a> 5、Netty 的高性能体现在？</h2><ul><li><strong>IO 线程模型</strong>：同步非阻塞；</li><li><strong>零拷贝</strong>：尽量做到不必要的内存拷贝：</li><li><strong>内存池设计</strong>：使用直接内存，并且可重复利用；</li><li><strong>串行化处理读写</strong>：避免使用锁带来的额外开销；</li><li><strong>高性能序列化协议</strong>：支持 protobuf 等高性能序列化协议。</li></ul><h2 id="6-相比原生-nio-的优势"><a class="markdownIt-Anchor" href="#6-相比原生-nio-的优势"></a> 6、相比原生 NIO 的优势？</h2><p>1）易用性：Netty 在 NIO 基础上封装了更加人性化的 API，大大降低开发人员的学习成本，同时还提供了很多开箱即用的工具。</p><p>2）稳定性：Netty 修复了 Java NIO 较多已知问题，如 select 空转导致 CPU 100%，TCP 断线重连，Keep-alive 检测等问题。</p><p>3）高性能：对象池复用（通过对象复用避免频繁创建和销毁带来的开销）和零拷贝技术。</p><h2 id="7-netty-和-tomcat-的区别"><a class="markdownIt-Anchor" href="#7-netty-和-tomcat-的区别"></a> 7、Netty 和 Tomcat 的区别？</h2><p>Netty 和 Tomcat 最大的区别在于对通信协议的支持：</p><ul><li><p>Tomcat 是基于 Http 协议的，本质是一个基于 http 协议的 web 容器，而 Netty 不仅支持 HTTP，还能通过编程自定义各种协议，通过 codec 自定义编码/解码字节流，完成数据传输。</p></li><li><p>Tomcat 需要遵循 Servlet 规范（HTTP 协议的请求-响应模型），而 Netty 不需要受到 Servlet 规范约束，可以发挥 NIO 最大特性。</p></li></ul><h2 id="8-bio-nio-aio-分别是什么"><a class="markdownIt-Anchor" href="#8-bio-nio-aio-分别是什么"></a> 8、BIO. NIO. AIO 分别是什么？</h2><ul><li><p><strong>BIO（同步阻塞 IO）</strong><br>服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK 1.4 以前的唯一选择，但程序直观简单易理解。</p></li><li><p><strong>NIO（同步非阻塞 IO）</strong><br>服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 IO 请求时才启动一个线程进行处理。NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK 1.4 开始支持。</p></li><li><p><strong>AIO（异步非阻塞 IO）</strong><br>服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK 1.7 开始支持。</p></li></ul><h2 id="9-select-poll-epoll-的区别"><a class="markdownIt-Anchor" href="#9-select-poll-epoll-的区别"></a> 9、Select、Poll、Epoll 的区别？</h2><p>ref</p><h2 id="10-什么是-reactor-模型"><a class="markdownIt-Anchor" href="#10-什么是-reactor-模型"></a> 10、什么是 Reactor 模型？</h2><h1 id="2-架构组件"><a class="markdownIt-Anchor" href="#2-架构组件"></a> 2 架构组件</h1><h2 id="1-netty-有哪些核心组件"><a class="markdownIt-Anchor" href="#1-netty-有哪些核心组件"></a> 1、Netty 有哪些核心组件？</h2><ul><li><p><strong>Channel</strong><br>基础的 IO 操作，如绑定、连接、读写等都依赖于底层网络传输所提供的原语，在 Java 的网络编程中，基础核心类是 Socket，而 Netty 的 Channel 提供了一组 API，极大地简化了直接与 Socket 进行操作的复杂性，并且 Channel 是很多类的父类，如 EmbeddedChannel、LocalServerChannel、NioDatagramChannel、NioSctpChannel、NioSocketChannel 等。</p></li><li><p><strong>EventLoop</strong><br>EventLoop 定义了处理在连接过程中发生的事件的核心抽象。</p></li></ul><p>​说白了，EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 IO 操作的处理。</p><p>​<strong>那 Channel 和 EventLoop 直接有啥联系呢？</strong></p><p>​Channel 为 Netty 网络操作（<strong>读写</strong>等操作）抽象类，EventLoop 负责处理注册到其上的 Channel 处理 IO 操作，两者配合参与 IO 操作。</p><ul><li><p><strong>ChannelFuture</strong></p><ul><li>由于 Netty 是异步非阻塞的，所有的 IO 操作也都为异步的，我们不能立刻得到操作是否执行成功，因此 Netty 提供 ChannelFuture 接口，使用其 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</li><li>并且，我们还可以通过 ChannelFuture 的 channel() 方法获取关联的Channel，甚至使用 sync() 方法让异步的操作变成同步的。</li></ul></li><li><p><strong>ChannelHandler 和 ChannelPipeline</strong></p><ul><li>从应用开发者看来，ChannelHandler 是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。ChannelHandler 的方法被网络事件触发，可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。如其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据。</li><li>ChannelPipeline为ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。当创建 Channel 时，会自动创建一个附属的 ChannelPipeline。</li></ul></li><li><p><strong>Bootstrap 和 ServerBootstrap</strong><br>Netty 的引导类应用程序网络层配置提供容器，其涉及将进程绑定到给定端口或连接一个进程到在指定主机上指定端口上运行的另一进程。引导类分为客户端引导 Bootstrap 和服务端引导 ServerBootstrap。</p></li></ul><h2 id="2-什么是-eventloop-和-eventloopgroup"><a class="markdownIt-Anchor" href="#2-什么是-eventloop-和-eventloopgroup"></a> 2、什么是 EventLoop 和 EventLoopGroup？</h2><p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程），上面我们已经说了 EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</p><p>并且 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p><p>上图是一个服务端对 EventLoopGroup 使用的大致模块图，其中 Boss EventloopGroup 用于接收连接，Worker EventloopGroup 用于具体的处理（消息的读写以及其他逻辑处理）。</p><p><img src="../../images/image-20230304103657806.png" alt="image-20230304103657806"></p><p>从上图可以看出：当客户端通过 connect 方法连接服务端时，bossGroup 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 workerGroup 来处理，然后 workerGroup 负责处理其 IO 相关操作。</p><h2 id="3-说说-netty-的线程模型"><a class="markdownIt-Anchor" href="#3-说说-netty-的线程模型"></a> 3、说说 Netty 的线程模型？</h2><p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。</p><ul><li><strong>单线程模型</strong><br>所有 IO 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求，向服务端发起连接，又要发送、读取请求或应答、响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、高并发的应用场景不合适。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">boobtstrap.group(eventGroup, eventGroup) </span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>多线程模型</strong><br>有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。</li></ul><p><img src="https://img-blog.csdnimg.cn/1d2358f8e6484e0db5a574a4701960bf.png#pic_center" alt="在这里插入图片描述"></p><p>对于代码：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><strong>主从多线程模型</strong><br>Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 IO 的读写等操作，从而保证主 Reactor 只负责接入认证、握手等操作。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</li></ul><p><img src="https://img-blog.csdnimg.cn/993566982c15443eb242cf628adc4d9b.png#pic_center" alt="在这里插入图片描述"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-netty-服务端的启动过程"><a class="markdownIt-Anchor" href="#4-netty-服务端的启动过程"></a> 4、Netty 服务端的启动过程？</h2><p>先来看一段代码实现：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap </span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  <span class="comment">// (非必备)打印日志  </span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 4.指定 IO 模型 </span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">         <span class="meta">@Override</span> </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> {</span><br><span class="line">             <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline(); </span><br><span class="line">             <span class="comment">//5.可以自定义客户端消息的业务处理逻辑 </span></span><br><span class="line">             p.addLast(<span class="keyword">new</span> <span class="title class_">HelloServerHandler</span>()); </span><br><span class="line">        } </span><br><span class="line">    }); </span><br><span class="line">    <span class="comment">// 6.绑定端口,调用 sync 方法阻塞知道绑定完成 </span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">    <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法) </span></span><br><span class="line">    f.channel().closeFuture().sync(); </span><br><span class="line">} <span class="keyword">finally</span> { </span><br><span class="line">    <span class="comment">//8.优雅关闭相关线程组资源 </span></span><br><span class="line">    bossGroup.shutdownGracefully(); </span><br><span class="line">    workerGroup.shutdownGracefully(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h1 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3 具体实现</h1><h2 id="1-netty-的无锁化体现在哪里"><a class="markdownIt-Anchor" href="#1-netty-的无锁化体现在哪里"></a> 1、Netty 的无锁化体现在哪里？</h2><p>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p><p><img src="https://img-blog.csdnimg.cn/1ed6fd9de8a64328806c5225edfc6bdb.png#pic_center" alt="在这里插入图片描述"></p><p>Netty 的 NioEventLoop 读取到消息后，直接调用 ChannelPipeline 的 fireChannelRead（Object msg），只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁竞争，从性能角度看是最优的。</p><h2 id="2-如何解决-jdk-epoll-空轮询问题"><a class="markdownIt-Anchor" href="#2-如何解决-jdk-epoll-空轮询问题"></a> 2、如何解决 JDK epoll 空轮询问题？</h2><p>这个 BUG 是指 Java 的 NIO 在 Linux 下进行 selector.select() 时，本来如果轮询的结果为空并且不调用 wakeup 方法的话，这个 selector.select() 应该是一直阻塞的，但是 Java 却会打破阻塞，继续执行，导致程序无限空转，造成 CPU 使用率 100%。（这个问题只存在 Linux 是因为 Linux 的 NIO 是基于 epoll 实现的，而 Java 实现的 epoll 存在 BUG，windows 下 NIO 基于 poll 就不存在此问题）</p><p><strong>Netty 的解决方案：</strong></p><p>为 Selector 的 select 操作设置超时时间，同时定义可以跳出阻塞的四种情况：</p><ul><li>有事件发生</li><li>wakeup</li><li>超时</li><li>空轮询 BUG</li></ul><p>而前两种返回值不为 0，可以跳出循环，超时有时间戳记录，所以每次空轮询，有专门的计数器进行 +1，如果空轮询的次数超过了 512 次（默认），就认为其触发了空轮询 BUG。</p><p>当触发 BUG 后，Netty 直接重建一个 Selector，将原来的 Channel 重新注册到新的 Selector 上，并将旧的 Selector 关掉。</p><h2 id="3-什么是拆包和粘包"><a class="markdownIt-Anchor" href="#3-什么是拆包和粘包"></a> 3、什么是拆包和粘包？</h2><p>TCP 是一个面向流的传输协议，所谓流，就是没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP <strong>粘包和拆包问题</strong>。</p><p>粘包和拆包是 TCP 网络编程中不可避免的，无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑 TCP 底层的粘包/拆包机制。</p><p><img src="https://img-blog.csdnimg.cn/6e67b9fbe3fa41e5b087e648a74c3af3.png#pic_center" alt="在这里插入图片描述"></p><p>数据从发送方到接收方需要经过操作系统的缓冲区，而造成粘包和拆包的主要原因就在这个缓冲区上。粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起，而拆包可以理解为发送的数据大于缓冲区，进行拆分处理。</p><p>详细来说，造成粘包和拆包的原因主要有以下三个：</p><p>1）应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p><p>2）进行 MSS 大小的 TCP 分段；</p><p>3）以太网帧的 payload 大于 MTU 进行 IP 分片。</p><h2 id="4-拆包粘包的解决方案"><a class="markdownIt-Anchor" href="#4-拆包粘包的解决方案"></a> 4、拆包粘包的解决方案？</h2><p>由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议可以归纳出以下解决方案：</p><p>1）消息长度固定，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息。</p><p>2）将特殊的分隔符作为消息的结束标志，如回车换行符。</p><p>3）通过在消息头中定义长度字段来标识消息的总长度。</p><h2 id="5-netty-如何解决拆包粘包"><a class="markdownIt-Anchor" href="#5-netty-如何解决拆包粘包"></a> 5、Netty 如何解决拆包粘包？</h2><p>相比粘包，拆包问题比较简单，用户可以自己定义自己的编码器进行处理，Netty 并没有提供相应的组件。对于粘包的问题，代码比较繁琐，Netty 提供了 4 种解码器来解决，分别如下：</p><ul><li><strong>固定长度的拆包器</strong>（FixedLengthFrameDecoder），每个应用层数据包的都拆分成都是固定长度的大小；</li><li><strong>行拆包器</strong>（LineBasedFrameDecoder），每个应用层数据包都以换行符作为分隔符，进行分割拆分；</li><li>**分隔符拆包器(**DelimiterBasedFrameDecoder），每个应用层数据包，都通过自定义的分隔符，进行分割拆分；</li><li><strong>基于数据包长度的拆包器</strong>（LengthFieldBasedFrameDecoder），将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度。</li></ul><h2 id="6-netty-零拷贝体现在哪里"><a class="markdownIt-Anchor" href="#6-netty-零拷贝体现在哪里"></a> 6、Netty 零拷贝体现在哪里？</h2><p>Zero-copy 就是在操作数据时, 不需要将数据 buffer从 一个内存区域拷贝到另一个内存区域。 少了一次内存的拷贝，CPU 效率就得到的提升。</p><ul><li><p>接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝；</p></li><li><p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作；</p></li><li><p>文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p></li></ul><p><strong>和操作系统上的零拷贝的区别？</strong></p><p>Netty 的 Zero-copy 完全是在用户态（Java 应用层）的, 更多的偏向于优化数据操作。而在 OS 层面上的 Zero-copy 通常指避免在用户态（User-space）与内核态（Kernel-space）之间来回拷贝数据。</p><h2 id="7-tcp-的长连接和短连接"><a class="markdownIt-Anchor" href="#7-tcp-的长连接和短连接"></a> 7、TCP 的长连接和短连接？</h2><p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p><p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p><p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p><h2 id="8-netty-长连接-心跳机制了解么"><a class="markdownIt-Anchor" href="#8-netty-长连接-心跳机制了解么"></a> 8、Netty 长连接、心跳机制了解么？</h2><p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入<strong>心跳机制</strong>。</p><p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互（即处于 idle 状态）时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 <font color="red">PING-PONG</font> 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性。</p><p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<font color="red">SO_KEEPALIVE</font>。但 TCP 协议层面的长连接灵活性不够，所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。</p><h2 id="9-说说-netty-的对象池技术"><a class="markdownIt-Anchor" href="#9-说说-netty-的对象池技术"></a> 9、说说 Netty 的对象池技术？</h2><p>对象池其实就是缓存一些对象从而避免大量创建同一个类型的对象，类似线程池的概念。对象池缓存了一些已经创建好的对象，避免需要时才创建对象，同时限制了实例的个数。池化技术最终要的就是重复的使用池内已经创建的对象。从上面的内容就可以看出对象池适用于以下几个场景：</p><ul><li>创建对象的开销大；</li><li>会创建大量的实例；</li><li>限制一些资源的使用。</li></ul><p>Netty 自己实现了一套轻量级的对象池。在 Netty 中，通常会有多个 IO 线程独立工作（基于 NioEventLoop 实现）。每个 IO 线程轮询单独的 Selector 实例来检索 IO 事件，并在 IO 来临时开始处理。最常见的 IO 操作就是读写，具体到 NIO 就是从内核缓冲区拷贝数据到用户缓冲区或者从用户缓冲区拷贝数据到内核缓冲区。这里会涉及到大量的创建和回收 Buffer， Netty 对 Buffer 进行了池化从而降低系统开销。</p><p>ref</p><h2 id="10-有哪些序列化协议"><a class="markdownIt-Anchor" href="#10-有哪些序列化协议"></a> 10 有哪些序列化协议？</h2><p><strong>序列化</strong>（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p><p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p><p><strong>目前几种主流协议</strong></p><ul><li><p><strong>Java 默认提供的序列化</strong><br>无法跨语言、序列化后的码流太大、序列化的性能差。</p></li><li><p><strong>XML</strong><br>优点是人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p></li><li><p><strong>JSON</strong><br>是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p></li><li><p><strong>Fastjson</strong><br>采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端。</p></li><li><p><strong>Thrift</strong><br>不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案。</p></li><li><p><strong>Avro</strong><br>Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p></li><li><p><strong>Protobuf</strong><br>将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-基本概念&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-基本概念&quot;&gt;&lt;/a&gt; 1 基本概念&lt;/h1&gt;
&lt;h2 id=&quot;1-什么是-netty&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#1-什么是-</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot面试题</title>
    <link href="http://example.com/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://example.com/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2023-03-03T11:20:43.310Z</published>
    <updated>2023-03-03T14:52:04.997Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-boot面试题总结最全面的面试题"><a class="markdownIt-Anchor" href="#spring-boot面试题总结最全面的面试题"></a> Spring Boot面试题（总结最全面的面试题！！！）</h1><p>2020年04月13日</p><blockquote><p>Java面试总结汇总，整理了包括Java重点知识，以及常用开源框架，欢迎大家阅读。文章可能有错误的地方，因为个人知识有限，欢迎各位大佬指出！文章持续更新中…</p></blockquote><blockquote><table><thead><tr><th>ID</th><th>标题</th><th>地址</th></tr></thead><tbody><tr><td>1</td><td>设计模式面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125721772039">juejin.cn/post/684490…</a></td></tr><tr><td>2</td><td>Java基础知识面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738631">juejin.cn/post/684490…</a></td></tr><tr><td>3</td><td>Java集合面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125939843079">juejin.cn/post/684490…</a></td></tr><tr><td>4</td><td>JavaIO、BIO、NIO、AIO、Netty面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125700784136">juejin.cn/post/684490…</a></td></tr><tr><td>5</td><td>Java并发编程面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125755293710">juejin.cn/post/684490…</a></td></tr><tr><td>6</td><td>Java异常面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904128959741965">juejin.cn/post/684490…</a></td></tr><tr><td>7</td><td>Java虚拟机（JVM）面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125696573448">juejin.cn/post/684490…</a></td></tr><tr><td>8</td><td>Spring面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127051513864">juejin.cn/post/684490…</a></td></tr><tr><td>9</td><td>Spring MVC面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722253">juejin.cn/post/684490…</a></td></tr><tr><td>10</td><td>Spring Boot面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125709156359">juejin.cn/post/684490…</a></td></tr><tr><td>11</td><td>Spring Cloud面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125717544973">juejin.cn/post/684490…</a></td></tr><tr><td>12</td><td>Redis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127055527950">juejin.cn/post/684490…</a></td></tr><tr><td>13</td><td>MyBatis面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935648776">juejin.cn/post/684490…</a></td></tr><tr><td>14</td><td>MySQL面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127047139335">juejin.cn/post/684490…</a></td></tr><tr><td>15</td><td>TCP、UDP、Socket、HTTP面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125692379143">juejin.cn/post/684490…</a></td></tr><tr><td>16</td><td>Nginx面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125784653837">juejin.cn/post/684490…</a></td></tr><tr><td>17</td><td>ElasticSearch面试题</td><td></td></tr><tr><td>18</td><td>kafka面试题</td><td></td></tr><tr><td>19</td><td>RabbitMQ面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904125935665160">juejin.cn/post/684490…</a></td></tr><tr><td>20</td><td>Dubbo面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499463">juejin.cn/post/684490…</a></td></tr><tr><td>21</td><td>ZooKeeper面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127076499464">juejin.cn/post/684490…</a></td></tr><tr><td>22</td><td>Netty面试题（总结最全面的面试题）</td><td></td></tr><tr><td>23</td><td>Tomcat面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059722247">juejin.cn/post/684490…</a></td></tr><tr><td>24</td><td>Linux面试题（总结最全面的面试题）</td><td><a href="https://juejin.cn/post/6844904127059738637">juejin.cn/post/684490…</a></td></tr><tr><td>25</td><td>互联网相关面试题（总结最全面的面试题）</td><td></td></tr><tr><td>26</td><td>互联网安全面试题（总结最全面的面试题）</td><td></td></tr></tbody></table></blockquote><h3 id="什么是-spring-boot"><a class="markdownIt-Anchor" href="#什么是-spring-boot"></a> 什么是 Spring Boot？</h3><ul><li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li></ul><h3 id="为什么要用springboot"><a class="markdownIt-Anchor" href="#为什么要用springboot"></a> 为什么要用SpringBoot</h3><ul><li>快速开发，快速整合，配置简化、内嵌服务容器</li></ul><h3 id="springboot与springcloud-区别"><a class="markdownIt-Anchor" href="#springboot与springcloud-区别"></a> SpringBoot与SpringCloud 区别</h3><ul><li>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</li></ul><h3 id="spring-boot-有哪些优点"><a class="markdownIt-Anchor" href="#spring-boot-有哪些优点"></a> Spring Boot 有哪些优点？</h3><ul><li>Spring Boot 主要有如下优点：<ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li><li>开箱即用，远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li><li>快速轻松地开发基于 Spring 的应用程序；</li><li>无需部署war文件；</li><li>创建独立应用程序的能力；</li><li>帮助将 Tomcat、Jetty 或 Undertow 直接嵌入到应用程序中；</li><li>无需XML配置；</li><li>减少源代码数量；</li><li>额外的开箱即用功能；</li><li>轻松启动；</li><li>简单的设置和管理；</li></ol></li></ul><h3 id="spring-boot-的核心注解是哪个它主要由哪几个注解组成的"><a class="markdownIt-Anchor" href="#spring-boot-的核心注解是哪个它主要由哪几个注解组成的"></a> Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3><ul><li>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：<ul><li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：<code>java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</code></li><li>@ComponentScan：Spring组件扫描。</li></ul></li></ul><h3 id="spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"><a class="markdownIt-Anchor" href="#spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"></a> Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h3><ul><li>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</li></ul><h3 id="spring-boot-中的-starter-到底是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的-starter-到底是什么"></a> Spring Boot 中的 starter 到底是什么 ?</h3><ul><li>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</li></ul><h3 id="springboot-starter的工作原理"><a class="markdownIt-Anchor" href="#springboot-starter的工作原理"></a> SpringBoot Starter的工作原理</h3><ul><li><code>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</code></li><li>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</li></ul><h3 id="spring-boot-2x-有什么新特性与-1x-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-2x-有什么新特性与-1x-有什么区别"></a> Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h3><ul><li>配置变更</li><li>JDK 版本升级</li><li>第三方类库升级</li><li>响应式 Spring 编程支持</li><li>HTTP/2 支持</li><li>配置属性绑定</li><li>更多改进与加强</li></ul><h3 id="springboot支持什么前端模板"><a class="markdownIt-Anchor" href="#springboot支持什么前端模板"></a> SpringBoot支持什么前端模板，</h3><ul><li>thymeleaf，freemarker，jsp，官方不推荐JSP会有限制</li></ul><h3 id="springboot的缺点"><a class="markdownIt-Anchor" href="#springboot的缺点"></a> SpringBoot的缺点</h3><p>尽管 Spring Boot 有很多优点，但它仍然有一些缺点需要牢记：</p><ul><li>由于不用自己做的配置，<mark>报错时很难定位</mark>。</li><li>缺乏控制。 Spring Boot 会<mark>创建大量未使用的依赖项，导致部署文件很大</mark>；</li><li>将遗留或现有 Spring 项目转换为 Spring Boot 应用程序的复杂且耗时的过程；</li><li>不适合大型项目。 尽管它非常适合使用微服务，但许多开发人员声称 Spring Boot 不适合构建单体应用程序。</li></ul><h3 id="运行-spring-boot-有哪几种方式"><a class="markdownIt-Anchor" href="#运行-spring-boot-有哪几种方式"></a> 运行 Spring Boot 有哪几种方式？</h3><ol><li>打包用命令或者放到容器中运行</li><li>用 Maven/ Gradle 插件运行</li><li>直接执行 main 方法运行</li></ol><h3 id="spring-boot-需要独立的容器运行吗"><a class="markdownIt-Anchor" href="#spring-boot-需要独立的容器运行吗"></a> Spring Boot 需要独立的容器运行吗？</h3><ul><li>可以不需要，内置了 Tomcat/ Jetty 等容器。</li></ul><h3 id="开启-spring-boot-特性有哪几种方式"><a class="markdownIt-Anchor" href="#开启-spring-boot-特性有哪几种方式"></a> 开启 Spring Boot 特性有哪几种方式？</h3><h4 id="1-继承spring-boot-starter-parent项目"><a class="markdownIt-Anchor" href="#1-继承spring-boot-starter-parent项目"></a> 1. 继承spring-boot-starter-parent项目</h4><parent><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter-parent</artifactid>    <version>2.2.6.RELEASE</version></parent><p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p><dependencies><dependency><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter</artifactid></dependency></dependencies><h4 id="2-导入spring-boot-dependencies项目依赖"><a class="markdownIt-Anchor" href="#2-导入spring-boot-dependencies项目依赖"></a> 2. 导入spring-boot-dependencies项目依赖</h4><dependencymanagement>    <dependencies>      <dependency>        <groupid>org.springframework.boot</groupid>        <artifactid>spring-boot-dependencies</artifactid>        <version>1.5.4.RELEASE</version>        <type>pom</type>        <scope>import</scope>      </dependency>    </dependencies></dependencymanagement><p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p><dependencies><dependency><groupid>org.springframework.boot</groupid>    <artifactid>spring-boot-starter</artifactid></dependency></dependencies><h3 id="springboot-实现热部署有哪几种方式"><a class="markdownIt-Anchor" href="#springboot-实现热部署有哪几种方式"></a> SpringBoot 实现热部署有哪几种方式？</h3><ul><li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li><li>主要有两种方式：<ul><li>Spring Loaded</li><li>Spring-boot-devtools</li></ul></li></ul><h3 id="springboot事务的使用"><a class="markdownIt-Anchor" href="#springboot事务的使用"></a> SpringBoot事务的使用</h3><ul><li>SpringBoot的事务很简单，首先使用注解@EnableTransactionManagement开启事务之后，然后在Service方法上添加注解@Transactional便可。</li></ul><h3 id="async异步调用方法"><a class="markdownIt-Anchor" href="#async异步调用方法"></a> Async异步调用方法</h3><ul><li>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入**@EnableAsync<strong>使异步调用</strong>@Async**注解生效。</li></ul><h3 id="如何在-spring-boot-启动的时候运行一些特定的代码"><a class="markdownIt-Anchor" href="#如何在-spring-boot-启动的时候运行一些特定的代码"></a> 如何在 Spring Boot 启动的时候运行一些特定的代码？</h3><p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</p><h4 id="1-applicationrunner"><a class="markdownIt-Anchor" href="#1-applicationrunner"></a> 1. ApplicationRunner</h4><ul><li>在项目中，可能会遇到这样一个问题：在项目启动完成之后，紧接着执行一段代码。<br>在SpringBoot中，提供了一个接口：ApplicationRunner。该接口中，只有一个run方法，他执行的时机是：spring容器启动完成之后，就会紧接着执行这个接口实现类的run方法。</li><li>实现了ApplicationRunner接口的类，并重写run方法，在springBoot项目启动后就是调用执行一次run方法</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImplApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">        System.out.println(<span class="string">"测试ApplicationRunner接口1"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>@Component注解<br>这个实现类，要注入到spring容器中，这里使用了@Component注解；<br>在同一个项目中，可以定义多个ApplicationRunner的实现类，他们的执行顺序通过注解@Order注解或者再实现Ordered接口来实现。</p></li><li><p>run方法的参数：ApplicationArguments可以获取到当前项目执行的命令参数。（比如把这个项目打成jar执行的时候，带的参数可以通过ApplicationArguments获取到）；由于该方法是在容器启动完成之后，才执行的，所以，这里可以从spring容器中拿到其他已经注入的bean。</p></li><li><p>@Order注解<br>如果有多个实现类，而你需要他们按一定顺序执行的话，可以在实现类上加上@Order注解。@Order(value=整数值)。SpringBoot会按照@Order中的value值从小到大依次执行。<br>@order，使用注解方式使bean的加载顺序得到控制,@Order标记定义了组件的加载顺序，值越小拥有越高的优先级，可为负数。值越小，越先被加载。</p></li><li><p>@Order(-1)优先于@Order(0)<br>@Order(1)优先于@Order(2)</p></li></ul><h4 id="2-commandlinerunner"><a class="markdownIt-Anchor" href="#2-commandlinerunner"></a> 2. CommandLineRunner</h4><p><strong>背景</strong></p><p>项目启动之前，预先加载数据。比如，权限容器、特殊用户数据等。通常我们可以使用监听器、事件来操作。但是，springboot提供了一个简单的方式来实现此类需求，即，CommandLineRunner。</p><p>先了解一下这个类</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span></span><br><span class="line"><span class="comment"> * a {<span class="doctag">@link</span> SpringApplication}. Multiple {<span class="doctag">@link</span> CommandLineRunner} beans can be defined</span></span><br><span class="line"><span class="comment"> * within the same application context and can be ordered using the {<span class="doctag">@link</span> Ordered}</span></span><br><span class="line"><span class="comment"> * interface or {<span class="doctag">@link</span> Order <span class="doctag">@Order</span>} annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you need access to {<span class="doctag">@link</span> ApplicationArguments} instead of the raw String array</span></span><br><span class="line"><span class="comment"> * consider using {<span class="doctag">@link</span> ApplicationRunner}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationRunner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback used to run the bean.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>文档中，我们可以知道以下几点。</p><ul><li>这是一个接口，用户可以自定义实现该接口，具体实现run方法</li><li>任何在上下文容器之内的bean都可以实现run方法</li><li>如果在上下文中，存在多个该接口实现类，可以通过@order注解，指定加载顺序</li></ul><p>所以我们基本上大概已经了解了这个接口的作用以及用法。</p><p><strong>案例说明</strong><br>分别定义一个数据加载类MyStartupRunner1，排序为2；另一个数据加载类MyStartupRunner2,排序为1。看看它们记载数据的顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner1</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">       System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner1 order 2 &lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">   System.out.println(<span class="string">"&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner2 order 1 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot-有哪几种读取配置的方式"><a class="markdownIt-Anchor" href="#spring-boot-有哪几种读取配置的方式"></a> Spring Boot 有哪几种读取配置的方式？</h3><ul><li>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</li></ul><h3 id="什么是-javaconfig"><a class="markdownIt-Anchor" href="#什么是-javaconfig"></a> 什么是 JavaConfig？</h3><ul><li>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他，它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：<ul><li>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</li><li>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</li><li>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</li></ul></li><li>常用的Java config：<ul><li>@Configuration：在类上打上写下此注解，表示这个类是配置类</li><li>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。</li><li>@Bean：bean的注入：相当于以前的&lt; bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /&gt;</li><li>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;</li><li>@ImportResource： 相当于xml的 &lt; import resource=“applicationContext-cache.xml”&gt;</li></ul></li></ul><h3 id="springboot的自动配置原理是什么"><a class="markdownIt-Anchor" href="#springboot的自动配置原理是什么"></a> SpringBoot的自动配置原理是什么</h3><ul><li>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</li><li>有了这个EnableAutoConfiguration的话就会：<ol><li>从配置文件META_INF/Spring.factories加载可能用到的自动配置类</li><li>去重，并将exclude和excludeName属性携带的类排除</li><li>过滤，将满足条件（@Conditional）的自动配置类返回</li></ol></li></ul><h3 id="你如何理解-spring-boot-配置加载顺序"><a class="markdownIt-Anchor" href="#你如何理解-spring-boot-配置加载顺序"></a> 你如何理解 Spring Boot 配置加载顺序？</h3><ul><li><p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p><ul><li>1.properties文件；</li><li>2.YAML文件；</li><li>3.系统环境变量；</li><li>4.命令行参数；</li><li>等等……</li></ul><p>常用配置文件中读取配置的结论：config配置中心 =&gt; jvm参数 =&gt; 系统环境变量 =&gt; 项目内的application-xxx.yaml =&gt; 项目内的application.yaml =&gt; bootstrap.yaml</p></li></ul><h3 id="什么是-yaml"><a class="markdownIt-Anchor" href="#什么是-yaml"></a> 什么是 YAML？</h3><ul><li>YAML 是一种<mark>人类可读的数据序列化语言</mark>。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</li><li>YAML 的语法比较简洁直观，特点是使用空格来表达层次结构，其最大优势在于<strong>数据结构</strong>方面的表达，所以 YAML 更多应用于<strong>编写配置文件</strong>，其文件一般以 <strong>.yml</strong> 为后缀。</li></ul><h3 id="yaml-配置的优势在哪里"><a class="markdownIt-Anchor" href="#yaml-配置的优势在哪里"></a> YAML 配置的优势在哪里 ?</h3><ul><li>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？<ul><li>配置有序，在一些特殊的场景下，配置有序很关键</li><li>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</li><li>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</li></ul></li></ul><h3 id="spring-boot-是否可以使用-xml-配置"><a class="markdownIt-Anchor" href="#spring-boot-是否可以使用-xml-配置"></a> Spring Boot 是否可以使用 XML 配置 ?</h3><ul><li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</li></ul><h3 id="spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"><a class="markdownIt-Anchor" href="#spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"></a> spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3><ul><li>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</li><li>spring boot 核心的两个配置文件：<ul><li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；</li><li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 <mark>spring boot 项目的<strong>自动化配置</strong></mark>。</li></ul></li></ul><h3 id="什么是-spring-profiles"><a class="markdownIt-Anchor" href="#什么是-spring-profiles"></a> 什么是 Spring Profiles？</h3><ul><li>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能</li><li>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</li></ul><h3 id="springboot多数据源拆分的思路"><a class="markdownIt-Anchor" href="#springboot多数据源拆分的思路"></a> SpringBoot多数据源拆分的思路</h3><ul><li>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中</li></ul><h3 id="springboot多数据源事务如何管理"><a class="markdownIt-Anchor" href="#springboot多数据源事务如何管理"></a> SpringBoot多数据源事务如何管理</h3><ul><li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li><li>第二种是使用jta-atomikos实现分布式事务管理</li></ul><h3 id="保护-spring-boot-应用有哪些方法"><a class="markdownIt-Anchor" href="#保护-spring-boot-应用有哪些方法"></a> 保护 Spring Boot 应用有哪些方法？</h3><ul><li>在生产中使用HTTPS</li><li>使用Snyk检查你的依赖关系</li><li>升级到最新版本</li><li>启用CSRF保护</li><li>使用内容安全策略防止XSS攻击</li></ul><h3 id="如何实现-spring-boot-应用程序的安全性"><a class="markdownIt-Anchor" href="#如何实现-spring-boot-应用程序的安全性"></a> 如何实现 Spring Boot 应用程序的安全性？</h3><ul><li>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</li></ul><h3 id="比较一下-spring-security-和-shiro-各自的优缺点"><a class="markdownIt-Anchor" href="#比较一下-spring-security-和-shiro-各自的优缺点"></a> 比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3><ul><li>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：<ul><li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li><li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li><li>Spring Security 功能强大；Shiro 功能简单</li></ul></li></ul><h3 id="spring-boot-中如何解决跨域问题"><a class="markdownIt-Anchor" href="#spring-boot-中如何解决跨域问题"></a> Spring Boot 中如何解决跨域问题 ?</h3><ul><li>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>) <span class="comment">//可以被跨域的路径</span></span><br><span class="line">            .allowedOrigins(<span class="string">"*"</span>) <span class="comment">//域名的白名单</span></span><br><span class="line">            .allowedMethods(<span class="string">"*"</span>)<span class="comment">/*"GET", "POST", "DELETE", "PUT"*/</span></span><br><span class="line">            .allowedHeaders(<span class="string">"*"</span>) <span class="comment">//允许所有的请求header访问，可以自定义设置任意请求头信息</span></span><br><span class="line">            .maxAge(<span class="number">3600</span>); <span class="comment">//这个复杂请求是预检用的，设置预检多久失效</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="如何使用-spring-boot-实现全局异常处理"><a class="markdownIt-Anchor" href="#如何使用-spring-boot-实现全局异常处理"></a> 如何使用 Spring Boot 实现全局异常处理？</h3><ul><li>Spring 提供了一种使用 <mark>ControllerAdvice</mark> 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</li></ul><h4 id="controlleradvice-作用"><a class="markdownIt-Anchor" href="#controlleradvice-作用"></a> @ControllerAdvice 作用</h4><p><font color="red"><strong>controller 的增强，用于对controller 做一些统一的操作，一般是用于全局的异常处理，也可以用于全局结果的返回处理</strong></font></p><p>可以在一定程度上简化代码，减少代码的书写量，统一对所有结果和异常做处理，包括异常信息的返回和错误日志的答应等</p><p>@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。主要作用有一下三种 :</p><ul><li>通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。</li><li>注解了@ControllerAdvice的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。<ul><li>@ExceptionHandler：用于全局处理控制器里的异常，进行全局异常处理</li><li>@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中，全局数据预处理。</li><li>@ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对 ，全局数据绑定。</li></ul></li><li>@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上。</li></ul><p>需要配合@ExceptionHandler使用。 当将异常抛到controller时,可以对异常进行统一处理,规定返回的json格式或是跳转到一个错误页面</p><p>全局异常处理举例以及说明<br>@ControllerAdvice ，@ExceptionHandler 的全局处理</p><p>Slf4j 为日志注解</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request, MyException e)</span> {</span><br><span class="line">        log.error(<span class="string">"错误信息:{}"</span>, e.getMessage(), e);</span><br><span class="line"><span class="keyword">return</span> Response.failMessage(e.getCode(), e.getMessage());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @Valid 校验框架抛出的特殊异常类</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleValidException</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException e)</span> {</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) {</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError allError : allErrors) {</span><br><span class="line">                message.append(allError.getDefaultMessage()).append(<span class="string">", "</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(message.toString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认其他的所有异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleOtherException</span><span class="params">(HttpServletRequest request, Exception e)</span> {</span><br><span class="line">        log.error(<span class="string">"request error Exception:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(e.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot-中的监视器是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的监视器是什么"></a> Spring Boot 中的监视器是什么？</h3><ul><li><p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您<mark>访问生产环境中正在运行的应用程序的当前状态</mark>。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p></li><li><p>Spring Boot自带监控组件—Actuator，它可以帮助实现对程序内部运行情况的监控。本章首先介绍Actuator轻松实现应用程序的监控治理，比如健康状况、审计、统计和HTTP追踪、Bean加载情况、环境变量、日志信息、线程信息等，然后介绍如何使用Spring Boot Admin构建完整的运维监控平台。<br><strong>Actuator的核心是端点（Endpoint）</strong>，它用来监视、提供应用程序的信息，Spring Boot提供的spring-boot-actuator组件中已经内置了非常多的Endpoint（health、info、beans、metrics、httptrace、shutdown等），每个端点都可以启用和禁用。</p><p><strong>监控端点分类：</strong><br>1）应用配置类：可以查看应用在运行期的静态信息，比如自动配置信息、加载的Spring Bean信息、YML文件配置信息、环境信息、请求映射信息。<br>2）度量指标类：主要是运行期的动态信息，如堆栈、请求连接、健康状态、系统性能等<br>3）操作控制类：主要是指shutdown，用户可以发送一个请求将应用的监控功能关闭。</p></li></ul><h3 id="我们如何监视所有-spring-boot-微服务"><a class="markdownIt-Anchor" href="#我们如何监视所有-spring-boot-微服务"></a> 我们如何监视所有 Spring Boot 微服务？</h3><ul><li>Spring Boot 提供 <strong>监视器端点</strong> 以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 <strong>Spring Boot Actuator</strong> 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li></ul><h3 id="springboot性能如何优化"><a class="markdownIt-Anchor" href="#springboot性能如何优化"></a> SpringBoot性能如何优化</h3><ul><li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围</li><li>在项目启动时设置JVM初始内存和最大内存相同</li><li>将springboot内置服务器由tomcat设置为undertow</li></ul><h3 id="如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"><a class="markdownIt-Anchor" href="#如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"></a> 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3><ul><li>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（<mark><strong>DevTools</strong></mark>）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</li></ul><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="spring-boot微服务中如何实现-session-共享"><a class="markdownIt-Anchor" href="#spring-boot微服务中如何实现-session-共享"></a> Spring Boot微服务中如何实现 session 共享 ?</h3><ul><li>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，<mark>常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session </mark>。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</li></ul><h3 id="您使用了哪些-starter-maven-依赖项"><a class="markdownIt-Anchor" href="#您使用了哪些-starter-maven-依赖项"></a> 您使用了哪些 starter maven 依赖项？</h3><ul><li>使用了下面的一些依赖项<ul><li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li><li>spring-boot-starter-data-jpa 数据库支持</li><li>spring-boot-starter-data-redis redis数据库支持</li><li>spring-boot-starter-data-solr solr支持</li><li>mybatis-spring-boot-starter 第三方的mybatis集成starter</li><li>自定义的starter(如果自己开发过就可以说出来)</li></ul></li></ul><h3 id="spring-boot-中如何实现定时任务"><a class="markdownIt-Anchor" href="#spring-boot-中如何实现定时任务"></a> Spring Boot 中如何实现定时任务 ?</h3><ul><li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 <mark>@Scheduled 注解</mark>，另一个则是使用第三方框架 <mark>Quartz</mark>。</li><li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li></ul><h3 id="spring-boot-starter-parent-有什么用"><a class="markdownIt-Anchor" href="#spring-boot-starter-parent-有什么用"></a> spring-boot-starter-parent 有什么用 ?</h3><ul><li><p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p><ol><li><p>定义了 Java 编译版本为 1.8 。</p></li><li><p>使用 UTF-8 格式编码。</p></li><li><p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。看源码发现：</p><p><img src="../../images/image-20230303224702882.png" alt="image-20230303224702882"></p></li><li><p>执行打包操作的配置。</p></li><li><p>自动化的资源过滤。</p></li><li><p>自动化的插件配置。</p></li><li><p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p></li></ol></li><li><p>总结就是打包用的</p></li></ul><h3 id="springboot如何实现打包"><a class="markdownIt-Anchor" href="#springboot如何实现打包"></a> SpringBoot如何实现打包</h3><ul><li>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包</li><li>或者点击右边选项栏中的Maven，先点击clean在点击package</li></ul><h3 id="spring-boot-打成的-jar-和普通的-jar-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-打成的-jar-和普通的-jar-有什么区别"></a> Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3><ul><li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li><li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;spring-boot面试题总结最全面的面试题&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#spring-boot面试题总结最全面的面试题&quot;&gt;&lt;/a&gt; Spring Boot面试题（总结最全面的面试题！！！）&lt;/h1&gt;
&lt;p&gt;2020</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Sentinel-限流规则(流控模式：直接、关联、链路)</title>
    <link href="http://example.com/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/"/>
    <id>http://example.com/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/</id>
    <published>2023-02-26T04:28:58.799Z</published>
    <updated>2023-03-08T14:11:02.201Z</updated>
    
    <content type="html"><![CDATA[<ul><li>​<strong>QPS</strong> <code>Queries Per Second</code> 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</li></ul><p><img src="https://img-blog.csdnimg.cn/061b8c23ef694d6e9d18abe3647c9dbe.png" alt="img"></p><h1 id="一-流控模式-直接"><a class="markdownIt-Anchor" href="#一-流控模式-直接"></a> 一、流控模式-直接</h1><p>添加规则：</p><p><img src="https://img-blog.csdnimg.cn/6d5781b7da1345f59e3321b3c8806571.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/8df1b81beca34a90a71af4aa2f1b8026.png" alt="img"></p><p>测试例子分析：</p><p><img src="https://img-blog.csdnimg.cn/39b96b130c9046078bc6d632580aff3e.png" alt="img"></p><p>启动测试</p><p><img src="https://img-blog.csdnimg.cn/5ec171ee24494c7488e3b09e3d7d8b47.png" alt="img"></p><p>点击 <strong>察看结果树</strong></p><p><img src="https://img-blog.csdnimg.cn/cc093a02f2be44fd938dfcc603a06ca3.png" alt="img"></p><p>上面测试例子，到Sentinel控制台的实时监控可以看到<img src="https://img-blog.csdnimg.cn/3dd6594966864a3a8f8d230c66387980.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/57592224a235458b826fc55819f5ea3d.png" alt="img"></p><h1 id="二-流控模式-关联"><a class="markdownIt-Anchor" href="#二-流控模式-关联"></a> 二、流控模式-关联</h1><p>•<strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p><p>•<strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p><p><img src="https://img-blog.csdnimg.cn/b8cf0fa094f0443db55cd6567f70b192.png" alt="img"></p><p>当**/write<strong>资源访问量触发阈值时，就会对</strong>/read**资源限流，避免影响/write资源。</p><h2 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例：</h2><p>​    需求：</p><p>​     •在OrderController新建两个端点：/order/query和/order/update，无需实现业务</p><p>​     •配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流</p><h2 id="1-编写测试controller方法"><a class="markdownIt-Anchor" href="#1-编写测试controller方法"></a> 1. 编写测试controller方法:</h2><p><img src="https://img-blog.csdnimg.cn/dfda223212c6437a96852a8aa4d744e0.png" alt="img"></p><h2 id="2-添加规则想给谁限流就给谁添加规则"><a class="markdownIt-Anchor" href="#2-添加规则想给谁限流就给谁添加规则"></a> 2. 添加规则（想给谁限流，就给谁添加规则）</h2><h2 id="img"><a class="markdownIt-Anchor" href="#img"></a> <img src="https://img-blog.csdnimg.cn/9fc5937b14504fce8dde85b0c1a5cfb6.png" alt="img"></h2><h2 id="img-2"><a class="markdownIt-Anchor" href="#img-2"></a> <img src="https://img-blog.csdnimg.cn/d93155d750694872a0818677f4cb81a8.png" alt="img"></h2><h2 id="img-3"><a class="markdownIt-Anchor" href="#img-3"></a> <img src="https://img-blog.csdnimg.cn/ddfa4ee5ed00436c9c0f3e147d8c7b6d.png" alt="img"></h2><h2 id="3-借助jmeter进行测试"><a class="markdownIt-Anchor" href="#3-借助jmeter进行测试"></a> 3. 借助JMeter进行测试：</h2><p><img src="https://img-blog.csdnimg.cn/5ff99d435d124355914f816b525b9a7a.png" alt="img"></p><h2 id="img-4-去网页访问验证img"><a class="markdownIt-Anchor" href="#img-4-去网页访问验证img"></a> <img src="https://img-blog.csdnimg.cn/38c110824b1f478883e86b43a4df0017.png" alt="img"> 4. 去网页访问验证:<img src="https://img-blog.csdnimg.cn/6d7e4884e3314d76a707bf0e0e6548d0.png" alt="img"></h2><p>query被限流 <img src="https://img-blog.csdnimg.cn/21342817472a4d2587669ada29df161c.png" alt="img"></p><h2 id="5-总结-满足下面条件可以使用关联模式"><a class="markdownIt-Anchor" href="#5-总结-满足下面条件可以使用关联模式"></a> 5. 总结： 满足下面条件可以使用关联模式</h2><ol><li><p>两个有<mark>竞争关系</mark>的资源</p></li><li><p>一个优先级较高，一个优先级较低（优先级高的触发阈值时（本案例的order），对优先级低的限流（本案例的query））</p></li></ol><h1 id="三-流控模式-链路"><a class="markdownIt-Anchor" href="#三-流控模式-链路"></a> 三、流控模式-链路</h1><p><img src="https://img-blog.csdnimg.cn/56e2dc9f451441a2bbb8483750137bf4.png" alt="img"></p><h2 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> 案例：</h2><p><img src="https://img-blog.csdnimg.cn/00c8c659e1c44e098c46b7ce5fd7b219.png" alt="img"></p><h2 id="1-编写测试代码"><a class="markdownIt-Anchor" href="#1-编写测试代码"></a> 1. 编写测试代码：</h2><p><img src="https://img-blog.csdnimg.cn/540402db64874fab953436a286717e02.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/32565b6a61534e3d87a9de1d1d9b7446.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/b0c343dd8ae54320bed317a725bda5d6.png" alt="img"></p><h2 id="2-注意"><a class="markdownIt-Anchor" href="#2-注意"></a> <strong>2. 注意：</strong></h2><p>Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用<mark><strong>@SentinelResource</strong>注解</mark></p><p>去配置文件里配置，<mark>关闭contextM</mark>，就可以让controller里的方法单独成为一个链路；不关闭context的话，controller里的方法都会默认进去sentinel默认的根链路里，这样就只有一条链路，无法流控链路模式</p><p><img src="https://img-blog.csdnimg.cn/dba8e68e6bc049b18fceab90848e5a24.png" alt="img"></p><h2 id="3-启动之后并到网页里分别访问了orderquery和ordersave接口后"><a class="markdownIt-Anchor" href="#3-启动之后并到网页里分别访问了orderquery和ordersave接口后"></a> 3. 启动之后，并到网页里分别访问了/order/query和/order/save接口后</h2><p><img src="https://img-blog.csdnimg.cn/bb6e754ffb7e4e4f8b715fe3910cbecd.png" alt="img"></p><h2 id="4-添加规则对query做限制save没有做限制"><a class="markdownIt-Anchor" href="#4-添加规则对query做限制save没有做限制"></a> 4. 添加规则：(对query做限制，save没有做限制)</h2><p><img src="https://img-blog.csdnimg.cn/cc38bc601afc440f9405972e04257f5b.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/feb37cb8556e49c4a151ff9c8397497f.png" alt="img"></p><h2 id="5-借助jmeter来测试"><a class="markdownIt-Anchor" href="#5-借助jmeter来测试"></a> 5. 借助JMeter来测试：</h2><p><img src="https://img-blog.csdnimg.cn/ed662f7afdb54e60a0455ce48d55c18e.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/7f1e916b436d43379585d1e9a52828a4.png" alt="img"></p><p>启动测试 <img src="https://img-blog.csdnimg.cn/4917bbf6a6b34670aed4ad9d3c751b02.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/45dd3918b3124af6983bfb648adfbb3a.png" alt="img"></p><p><img src="https://img-blog.csdnimg.cn/df349c02421040b9bc8e00a398be0c9d.png" alt="img"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;​	&lt;strong&gt;QPS&lt;/strong&gt; &lt;code&gt;Queries Per Second&lt;/code&gt; 是每秒查询率 ,是&lt;strong&gt;一台服务器&lt;/strong&gt;每秒能够相应的查询次数，是对一个特定的查询服务器&lt;strong&gt;在规定时间内&lt;/stron</summary>
      
    
    
    
    <category term="微服务" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Sentinel" scheme="http://example.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/"/>
    
    
    <category term="微服务" scheme="http://example.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    <category term="Sentinel" scheme="http://example.com/tags/Sentinel/"/>
    
  </entry>
  
  <entry>
    <title>应用层常见协议总结（应用层）</title>
    <link href="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/"/>
    <id>http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/</id>
    <published>2023-02-20T05:55:49.239Z</published>
    <updated>2023-03-04T02:54:21.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="http超文本传输协议"><a class="markdownIt-Anchor" href="#http超文本传输协议"></a> HTTP:超文本传输协议</h2><p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p><p><img src="../../../images/image-20230220135638150.png" alt="image-20230220135638150"></p><p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p><p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#smtp-%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93-%E5%8F%91%E9%80%81-%E5%8D%8F%E8%AE%AE">#</a> SMTP:简单邮件<font color="red">传输(发送)</font>协议</h2><p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p><p><img src="../../../images/image-20230220135632455.png" alt="image-20230220135632455"></p><p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p><p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p><ol><li>电子邮件的发送过程</li><li>如何判断邮箱是真正存在的？</li></ol><p><strong>电子邮件的发送过程？</strong></p><p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p><ol><li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li><li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li><li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li></ol><p><strong>如何判断邮箱是真正存在的？</strong></p><p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p><ol><li>查找邮箱域名对应的 SMTP 服务器地址</li><li>尝试与服务器建立连接</li><li>连接成功后尝试向需要验证的邮箱发送邮件</li><li>根据返回结果判定邮箱地址的真实性</li></ol><p>推荐几个在线邮箱是否有效检测工具：</p><ol><li><a href="https://verify-email.org/">https://verify-email.org/</a></li><li><a href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li><li><a href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li></ol><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#pop3-imap-%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> POP3/IMAP:邮件<font color="red">接收</font>的协议</h2><p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p><p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p><h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#ftp-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> FTP:文件传输协议</h2><p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p><p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p><blockquote><p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p><ol><li>控制连接：用于传送控制信息（命令和响应）</li><li>数据连接：用于数据传送；</li></ol><p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p></blockquote><p><img src="../../../images/image-20230220135623263.png" alt="image-20230220135623263"></p><h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#telnet-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AE">#</a> Telnet:远程登陆协议</h2><p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p><h2 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#ssh-%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> SSH:安全的网络传输协议</h2><p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p><p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p><p><img src="../../../images/image-20230220135616527.png" alt="image-20230220135616527"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;http超文本传输协议&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#http超文本传输协议&quot;&gt;&lt;/a&gt; HTTP:超文本传输协议&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;超文本传输协议（HTTP，HyperText Transfer Prot</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>TCP 传输可靠性保障（传输层）</title>
    <link href="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/"/>
    <id>http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/</id>
    <published>2023-02-20T05:53:11.455Z</published>
    <updated>2023-04-29T17:25:40.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="tcp-如何保证传输的可靠性"><a class="markdownIt-Anchor" href="#tcp-如何保证传输的可靠性"></a> TCP 如何保证传输的可靠性？</h2><ol><li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li><li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li><li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失open in new window</a>并进行重传。</li><li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的**滑动窗口协议（**TCP 利用滑动窗口实现流量控制）。</li><li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li></ol><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">#</a> TCP 如何实现流量控制？</h2><p><strong>TCP 利用<font color="red">滑动窗口</font>实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><h3 id="为什么需要流量控制"><a class="markdownIt-Anchor" href="#为什么需要流量控制"></a> <strong>为什么需要流量控制?</strong></h3><p>这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p><p>这里需要注意的是（常见误区）：</p><ul><li>发送端不等同于客户端</li><li>接收端不等同于服务端</li></ul><p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是接收端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p><h3 id="tcp-发送窗口可以划分成四个部分"><a class="markdownIt-Anchor" href="#tcp-发送窗口可以划分成四个部分"></a> <strong>TCP 发送窗口可以划分成四个部分</strong> ：</h3><ol><li>已经发送并且确认的TCP段（<strong>已经发送并确认</strong>）；</li><li>已经发送但是没有确认的TCP段（<strong>已经发送未确认</strong>）；</li><li>未发送但是接收方准备接收的TCP段（<strong>可以发送</strong>）；</li><li>未发送并且接收方也并未准备接受的TCP段（<strong>不可发送</strong>）。</li></ol><h3 id="tcpfont-colorred发送font窗口结构图示"><a class="markdownIt-Anchor" href="#tcpfont-colorred发送font窗口结构图示"></a> <strong>TCP<font color="red">发送</font>窗口结构图示</strong> ：</h3><p><img src="../../../images/image-20230220135411913.png" alt="image-20230220135411913"></p><ul><li><strong>SND.WND</strong> ：发送窗口。</li><li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li><li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li></ul><p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p><h3 id="tcp-font-colorred接收font窗口可以划分成三个部分"><a class="markdownIt-Anchor" href="#tcp-font-colorred接收font窗口可以划分成三个部分"></a> <strong>TCP <font color="red">接收</font>窗口可以划分成三个部分</strong> ：</h3><ol><li>已经接收并且已经确认的 TCP 段（<strong>已经接收并确认</strong>）；</li><li>等待接收且允许发送方发送 TCP 段（<strong>可以接收未确认</strong>）；</li><li>不可接收且不允许发送方发送TCP段（<strong>不可接收</strong>）。</li></ol><h3 id="tcp-接收窗口结构图示"><a class="markdownIt-Anchor" href="#tcp-接收窗口结构图示"></a> <strong>TCP 接收窗口结构图示</strong> ：</h3><p><img src="../../../images/image-20230220135419120.png" alt="image-20230220135419120"></p><p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p><p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p><h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> TCP 的拥塞控制是怎么实现的？</h2><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><img src="../../../images/image-20230220135425341.png" alt="image-20230220135425341"></p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li><li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul><h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#arq-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97">#</a> ARQ 协议了解吗?（Automatic Repeat-reQuest）</h2><p><font color="red"><strong>自动重传请求</strong></font>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的<strong>错误纠正协</strong>议之一。<strong>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输</strong>。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括<strong>停止等待 ARQ 协议</strong>和<strong>连续 ARQ 协议</strong>。</p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a> 停止等待 ARQ 协议</h3><p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><h4 id="1-无差错情况"><a class="markdownIt-Anchor" href="#1-无差错情况"></a> <strong>1) 无差错情况:</strong></h4><p>发送方发送分组, 接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><h4 id="2-出现差错情况超时重传"><a class="markdownIt-Anchor" href="#2-出现差错情况超时重传"></a> <strong>2) 出现差错情况（超时重传）:</strong></h4><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><h4 id="3-确认丢失和确认迟到"><a class="markdownIt-Anchor" href="#3-确认丢失和确认迟到"></a> <strong>3) 确认丢失和确认迟到</strong></h4><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE">#</a> 连续 ARQ 协议</h3><p>连续 ARQ 协议可<strong>提高信道利用率</strong>。发送方维持一个<strong>发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对<mark>按序到达</mark>的<mark>最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</mark></p><h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> <strong>优点：</strong></h4><p>信道利用率高，容易实现，即使确认丢失，也不必重传。</p><h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> <strong>缺点：</strong></h4><p>不能向发送方反映出接收方已经正确收到的所有分组的信息。 <font color="blue">比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认</font>。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;tcp-如何保证传输的可靠性&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#tcp-如何保证传输的可靠性&quot;&gt;&lt;/a&gt; TCP 如何保证传输的可靠性？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;基于数据块传输&lt;/strong&gt; ：应用数</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>OSI 和 TCP/IP 网络分层模型详解（基础）</title>
    <link href="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/"/>
    <id>http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/</id>
    <published>2023-02-19T09:06:44.282Z</published>
    <updated>2023-03-15T05:35:24.668Z</updated>
    
    <content type="html"><![CDATA[<p><strong>OSI模型</strong>: 即<strong>开放式通信系统互联参考模型</strong>（<strong>Open System Interconnection Reference Model</strong>），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。</p><h2 id="osi-七层模型"><a class="markdownIt-Anchor" href="#osi-七层模型"></a> OSI 七层模型</h2><p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p><p><img src="../../../images/image-20230220134708482.png" alt="image-20230220134708482"></p><p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p><p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p><p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p><p><img src="../../../images/image-20230220134715273.png" alt="image-20230220134715273"></p><p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p><p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p><ol><li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li><li>OSI 的协议实现起来过分复杂，而且运行效率很低</li><li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li><li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li></ol><p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p><p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p><p><img src="../../../images/image-20230220134722147.png" alt="image-20230220134722147"></p><h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> TCP/IP 四层模型</h2><p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p><ol><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ol><p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p><p><img src="../../../images/image-20230220134732543.png" alt="image-20230220134732543"></p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#%E5%BA%94%E7%94%A8%E5%B1%82-application-layer">#</a> 应用层（Application layer）</h3><p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p><p><img src="../../../images/image-20230220134737489.png" alt="image-20230220134737489"></p><p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p><p><img src="../../../images/image-20230220134743725.png" alt="image-20230220134743725"></p><p>应用层常见协议总结，请看这篇文章：<a href="">应用层常见协议总结（应用层）</a>。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#%E4%BC%A0%E8%BE%93%E5%B1%82-transport-layer">#</a> 传输层（Transport layer）</h3><p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p><p><strong>运输层主要使用以下两种协议：</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li></ol><p><img src="../../../images/image-20230220134748906.png" alt="image-20230220134748906"></p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%B1%82-network-layer">#</a> 网络层（Network layer）</h3><p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p><p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p><p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p><p><img src="../../../images/image-20230220134754055.png" alt="image-20230220134754055"></p><p><strong>网络层常见协议</strong> ：</p><ul><li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li><li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li><li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li><li>…</li></ul><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-network-interface-layer">#</a> 网络接口层（Network interface layer）</h3><p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p><ol><li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li><li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li></ol><p><img src="../../../images/image-20230220134759211.png" alt="image-20230220134759211"></p><h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h3><p>简单总结一下每一层包含的协议和核心技术:</p><p><img src="../../../images/image-20230220134804106.png" alt="image-20230220134804106"></p><p><strong>应用层协议</strong> :</p><ul><li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li><li>DHCP 协议（动态主机配置）</li><li>DNS 系统原理（域名系统）</li><li>FTP 协议（文件传输协议）</li><li>Telnet协议（远程登陆协议）</li><li>电子邮件协议等（SMTP、POP3、IMAP）</li><li>…</li></ul><p><strong>传输层协议</strong> :</p><ul><li>TCP 协议<ul><li>报文段结构</li><li>可靠数据传输</li><li>流量控制</li><li>拥塞控制</li></ul></li><li>UDP 协议<ul><li>报文段结构</li><li>RDT（可靠数据传输协议）</li></ul></li></ul><p><strong>网络层协议</strong> :</p><ul><li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li><li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li><li>ICMP 协议（控制报文协议，用于发送控制消息）</li><li>NAT 协议（网络地址转换协议）</li><li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li><li>…</li></ul><p><strong>网络接口层</strong> :</p><ul><li>差错检测技术</li><li>多路访问协议（信道复用技术）</li><li>CSMA/CD 协议</li><li>MAC 协议</li><li>以太网技术</li><li>…</li></ul><h2 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0">#</a> 网络分层的原因</h2><p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p><p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p><ol><li>Repository（数据库操作）</li><li>Service（业务操作）</li><li>Controller（前后端数据交互）</li></ol><p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p><p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p><ol><li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li><li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li><li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li></ol><p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;OSI模型&lt;/strong&gt;: 即&lt;strong&gt;开放式通信系统互联参考模型&lt;/strong&gt;（&lt;strong&gt;Open System Interconnection Reference Model&lt;/strong&gt;），是国际标准化组织（ISO）提出的一个试</summary>
      
    
    
    
    <category term="面试题" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="面试题" scheme="http://example.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="计算机网络" scheme="http://example.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
