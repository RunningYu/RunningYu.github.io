<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>152</strong><br>文章</div></a>
      <a href="/categories"><div><strong>83</strong><br>分类</div></a>
      <a href="/tags"><div><strong>55</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/4. 虚拟机栈" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" class="article-date">
  <time class="post-time" datetime="2022-11-16T09:42:58.146Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/">4. 虚拟机栈</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="4-虚拟机栈"><a href="#4-虚拟机栈" class="headerlink" title="4. 虚拟机栈"></a>4. 虚拟机栈</h1><h2 id="4-1-虚拟机栈概述"><a href="#4-1-虚拟机栈概述" class="headerlink" title="4.1. 虚拟机栈概述"></a>4.1. 虚拟机栈概述</h2><h3 id="4-1-1-虚拟机栈出现的背景"><a href="#4-1-1-虚拟机栈出现的背景" class="headerlink" title="4.1.1. 虚拟机栈出现的背景"></a>4.1.1. 虚拟机栈出现的背景</h3><p>由于跨平台性的设计，Java 的指令都是根据栈来设计的。不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p>
<p><mark>优点是跨平台，指令集小，编译器容易实现，缺点是性能下降，实现同样的功能需要更多的指令</mark>。</p>
<h3 id="4-1-2-初步印象"><a href="#4-1-2-初步印象" class="headerlink" title="4.1.2. 初步印象"></a>4.1.2. 初步印象</h3><p>有不少 Java 开发人员一提到 Java 内存结构，就会非常粗粒度地将 JVM 中的内存区理解为仅有 Java 堆（heap）和 Java 栈（stack）？为什么？</p>
<h3 id="4-1-3-内存中的栈与堆"><a href="#4-1-3-内存中的栈与堆" class="headerlink" title="4.1.3. 内存中的栈与堆"></a>4.1.3. 内存中的栈与堆</h3><p><mark>栈是运行时的单位，而堆是存储的单位</mark></p>
<ul>
<li>栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。</li>
<li>堆解决的是数据存储的问题，即数据怎么放，放哪里</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2d195f3aafd8b1f426efad75f0a52478.png" alt="image-20200705163928652"></p>
<h3 id="4-1-4-虚拟机栈基本内容"><a href="#4-1-4-虚拟机栈基本内容" class="headerlink" title="4.1.4. 虚拟机栈基本内容"></a>4.1.4. 虚拟机栈基本内容</h3><h4 id="Java-虚拟机栈是什么？"><a href="#Java-虚拟机栈是什么？" class="headerlink" title="Java 虚拟机栈是什么？"></a>Java 虚拟机栈是什么？</h4><p>Java 虚拟机栈（Java Virtual Machine Stack），早期也叫 Java 栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的 Java 方法调用，是线程私有的。</p>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>生命周期和线程一致</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>主管 Java 程序的运行，它保存方法的局部变量、部分结果，并参与方法的调用和返回。</p>
<h4 id="栈的特点-优点"><a href="#栈的特点-优点" class="headerlink" title="栈的特点 ( 优点 )"></a>栈的特点 ( 优点 )</h4><p>栈是一种快速有效的分配存储方式，访问速度仅次于罹序计数器。</p>
<p>JVM 直接对 Java 栈的操作只有两个：</p>
<ul>
<li>每个方法执行，伴随着进栈（入栈、压栈）</li>
<li>执行结束后的出栈工作</li>
</ul>
<p>对于栈来说不存在垃圾回收问题（栈存在溢出的情况）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d4e4445f4faee685dc98d54129344bb3.png" alt="image-20200705165025382"></p>
<h4 id><a href="#" class="headerlink" title></a></h4><p><img src="/../../../images/image-20221116180408869.png" alt="image-20221116180408869"></p>
<h4 id="面试题：开发中遇到哪些异常？"><a href="#面试题：开发中遇到哪些异常？" class="headerlink" title="面试题：开发中遇到哪些异常？"></a>面试题：开发中遇到哪些异常？</h4><p><strong>栈中可能出现的异常</strong></p>
<p>Java 虚拟机规范允许<mark>Java 栈的大小是动态的或者是固定不变的</mark>。</p>
<ul>
<li><p>如果采用固定大小的 Java 虚拟机栈，那每一个线程的 Java 虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过 Java 虚拟机栈允许的最大容量，Java 虚拟机将会抛出一个<mark>StackOverflowError </mark>异常。</p>
</li>
<li><p>如果 Java 虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那 Java 虚拟机将会抛出一个<mark> OutOfMemoryError </mark>异常。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抛出异常：Exception in thread&quot;main&quot;java.lang.StackoverflowError</span></span><br><span class="line"><span class="comment">//程序不断的进行递归调用，而且没有退出条件，就会导致不断地进行压栈。</span></span><br></pre></td></tr></table></figure>



<p><strong>设置栈内存大小</strong></p>
<p>我们可以使用参数 -Xss 选项来设置线程的最大栈空间，栈的大小直接决定了函数调用的最大可达深度</p>
<p><img src="/../../../images/image-20221116184119213.png" alt="image-20221116184119213"></p>
<h2 id="4-2-栈的存储单位"><a href="#4-2-栈的存储单位" class="headerlink" title="4.2. 栈的存储单位"></a>4.2. 栈的存储单位</h2><h3 id="4-2-1-栈中存储什么？"><a href="#4-2-1-栈中存储什么？" class="headerlink" title="4.2.1. 栈中存储什么？"></a>4.2.1. 栈中存储什么？</h3><p>每个线程都有自己的栈，栈中的数据都是以<mark>栈帧（Stack Frame）的格式存在</mark>。</p>
<p>在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。</p>
<p>栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。</p>
<h3 id="4-2-2-栈运行原理"><a href="#4-2-2-栈运行原理" class="headerlink" title="4.2.2. 栈运行原理"></a>4.2.2. 栈运行原理</h3><p>JVM 直接对 Java 栈的操作只有两个，就是对<mark>栈帧的压栈和出栈，遵循“先进后出”&#x2F;“后进先出”原则</mark>。</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行的方法的栈帧（栈顶栈帧）是有效的，这个栈帧被称为<mark>当前栈帧（Current Frame）</mark>，与当前栈帧相对应的方法就是<mark>当前方法（Current Method）</mark>，定义这个方法的类就是<mark>当前类（Current Class）</mark>。</p>
<p>执行引擎运行的所有字节码指令只针对当前栈帧进行操作。</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧会被创建出来，放在栈的顶端，成为新的当前帧。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/893126a7a33507917e11377fd3e4b639.png" alt="image-20200705203142545"></p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧之中引用另外一个线程的栈帧。</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧。</p>
<p>Java 方法有两种返回函数的方式，<mark>一种是正常的函数返回，使用 return 指令；另外一种是抛出异常。不管使用哪种方式，都会导致栈帧被弹出</mark>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CurrentFrameTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodA</span><span class="params">()</span>&#123;</span><br><span class="line">        system.out.println（<span class="string">&quot;当前栈帧对应的方法-&gt;methodA&quot;</span>);</span><br><span class="line">        methodB();</span><br><span class="line">        system.out.println（<span class="string">&quot;当前栈帧对应的方法-&gt;methodA&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">methodB</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println（<span class="string">&quot;当前栈帧对应的方法-&gt;methodB&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-栈帧的内部结构"><a href="#4-2-3-栈帧的内部结构" class="headerlink" title="4.2.3. 栈帧的内部结构"></a>4.2.3. 栈帧的内部结构</h3><p>每个栈帧中存储着：</p>
<ul>
<li><mark>局部变量表（Local Variables）</mark></li>
<li><mark>操作数栈（operand Stack）（或表达式栈）</mark></li>
<li>动态链接（DynamicLinking）（或指向运行时常量池的方法引用）</li>
<li>方法返回地址（Return Address）（或方法正常退出或者异常退出的定义）</li>
<li>一些附加信息</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0ed2029b435d547547f32540077bb082.png" alt="image-20200705204836977"></p>
<p>虚拟机栈中的栈帧的数量取决于栈帧的大小，栈帧的大小主要取决于局部变量表和操作数栈的大小。</p>
<p>并行每个线程下的栈都是私有的，因此每个线程都有自己各自的栈，并且每个栈里面都有很多栈帧，栈帧的大小主要由局部变量表 和 操作数栈决定的</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2451fa6f061c426179e3674bb6813e46.png" alt="image-20200705205443993"></p>
<h2 id="4-3-局部变量表-Local-Variables"><a href="#4-3-局部变量表-Local-Variables" class="headerlink" title="4.3. 局部变量表(Local Variables)"></a>4.3. 局部变量表(Local Variables)</h2><p>局部变量表也被称之为局部变量数组或本地变量表</p>
<ul>
<li><p><mark>定义为一个数字数组，主要用于存储方法参数和定义在方法体内的局部变量</mark>，这些数据类型包括各类基本数据类型、对象引用（reference），以及 returnAddress 类型。</p>
</li>
<li><p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<mark>不存在数据安全问题</mark></p>
</li>
<li><p><mark>局部变量表所需的容量大小是在编译期确定下来的</mark>，并保存在方法的 Code 属性的 maximum local variables 数据项中。在方法运行期间是不会改变局部变量表的大小的。</p>
</li>
<li><p><mark>方法嵌套调用的次数由栈的大小决定</mark>。一般来说，栈越大，方法嵌套调用次数越多。对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。</p>
</li>
<li><p><mark>局部变量表中的变量只在当前方法调用中有效</mark>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
</li>
</ul>
<h3 id="4-3-1-关于-Slot-的理解"><a href="#4-3-1-关于-Slot-的理解" class="headerlink" title="4.3.1. 关于 Slot 的理解"></a>4.3.1. 关于 Slot 的理解</h3><ul>
<li><p>局部变量表，最基本的存储单元是 Slot（变量槽）</p>
</li>
<li><p>参数值的存放总是在局部变量数组的 index0 开始，到数组长度-1 的索引结束。</p>
</li>
<li><p>局部变量表中存放编译期可知的各种基本数据类型（8 种），引用类型（reference），returnAddress 类型的变量。</p>
</li>
<li><p>在局部变量表里，32 位以内的类型只占用一个 slot（包括 returnAddress 类型），64 位的类型（long 和 double）占用两个 slot。</p>
</li>
<li><p>byte、short、char 在存储前被转换为 int，boolean 也被转换为 int，0 表示 false，非 0 表示 true。</p>
</li>
<li><p>JVM 会为局部变量表中的每一个 Slot 都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值</p>
</li>
<li><p>当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会<mark>按照顺序被复制</mark>到局部变量表中的每一个 slot 上</p>
</li>
<li><p><mark>如果需要访问局部变量表中一个 64bit 的局部变量值时，只需要使用前一个索引即可</mark>。（比如：访问 long 或 doub1e 类型变量）</p>
</li>
<li><p>如果当前帧是由构造方法或者实例方法创建的，那么<mark>该对象引用 this 将会存放在 index 为 0 的 slot 处</mark>，其余的参数按照参数表顺序继续排列。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/866e014106701648c63c0b232066fced.png" alt="image-20200705212454445"></p>
<h3 id="4-3-2-Slot-的重复利用"><a href="#4-3-2-Slot-的重复利用" class="headerlink" title="4.3.2. Slot 的重复利用"></a>4.3.2. Slot 的重复利用</h3><p><strong>栈帧中的局部变量表中的槽位是可以重用的</strong>，如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlotTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVarl</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">localVar2</span><span class="params">()</span> &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时的就会复用a的槽位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-静态变量与局部变量的对比"><a href="#4-3-3-静态变量与局部变量的对比" class="headerlink" title="4.3.3. 静态变量与局部变量的对比"></a>4.3.3. 静态变量与局部变量的对比</h3><p>参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。</p>
<p>我们知道类变量表有两次初始化的机会，第一次是在“<mark>准备阶段</mark>”，执行系统初始化，对类变量设置零值，另一次则是在“<mark>初始化</mark>”阶段，赋予程序员在代码中定义的初始值。</p>
<p>和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    System. out. println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样的代码是错误的，没有赋值不能够使用。</p>
<h3 id="4-3-4-补充说明"><a href="#4-3-4-补充说明" class="headerlink" title="4.3.4. 补充说明"></a>4.3.4. 补充说明</h3><p>在栈帧中，与性能调优关系最为密切的部分就是前面提到的局部变量表。在方法执行时，虚拟机使用局部变量表完成方法的传递。</p>
<p><mark>局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收</mark>。</p>
<h2 id="4-4-操作数栈（Operand-Stack）"><a href="#4-4-操作数栈（Operand-Stack）" class="headerlink" title="4.4. 操作数栈（Operand Stack）"></a>4.4. 操作数栈（Operand Stack）</h2><p>每一个独立的栈帧除了包含局部变量表以外，还包含一个后进先出（Last-In-First-Out）的 <mark>操作数栈</mark>，也可以称之为<mark>表达式栈（Expression Stack）</mark></p>
<p><mark>操作数栈，在方法执行过程中，根据字节码指令，往栈中写入数据或提取数据，即入栈（push）和 出栈（pop）</mark></p>
<ul>
<li>某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈</li>
<li>比如：执行复制、交换、求和等操作</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7f911f276f834d820fa09f31dd63a74b.png" alt="image-20200706090618332"></p>
<p>代码举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddOperation</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码指令信息</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation();</span><br><span class="line">    Code:</span><br><span class="line">    0: bipush 15</span><br><span class="line">    2: istore_1</span><br><span class="line">    3: bipush 8</span><br><span class="line">    5: istore_2</span><br><span class="line">    6:iload_1</span><br><span class="line">    7:iload_2</span><br><span class="line">    8:iadd</span><br><span class="line">    9:istore_3</span><br><span class="line">    10:return</span><br></pre></td></tr></table></figure>

<p>操作数栈，<mark>主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</mark>。</p>
<p>操作数栈就是 JVM 执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<mark>这个方法的操作数栈是空的</mark>。</p>
<p>每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的 Code 属性中，为 max_stack 的值。</p>
<p>栈中的任何一个元素都是可以任意的 Java 数据类型</p>
<ul>
<li>32bit 的类型占用一个栈单位深度</li>
<li>64bit 的类型占用两个栈单位深度</li>
</ul>
<p>操作数栈<mark>并非采用访问索引的方式来进行数据访问</mark>的，而是只能通过标准的入栈和出栈操作来完成一次数据访问</p>
<p><mark>如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中</mark>，并更新 PC 寄存器中下一条需要执行的字节码指令。</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，这由编译器在编译器期间进行验证，同时在类加载过程中的类检验阶段的数据流分析阶段要再次验证。</p>
<p>另外，我们说 Java 虚拟机的<mark>解释引擎是基于栈的执行引擎</mark>，其中的栈指的就是操作数栈。</p>
<h2 id="4-5-代码追踪"><a href="#4-5-代码追踪" class="headerlink" title="4.5. 代码追踪"></a>4.5. 代码追踪</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void testAddOperation() &#123;</span><br><span class="line">    byte i = 15;</span><br><span class="line">    int j = 8;</span><br><span class="line">    int k = i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 javap 命令反编译 class 文件：<code> javap -v 类名.class</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAddoperation</span><span class="params">()</span>; 		Code:	<span class="number">0</span>: bipush <span class="number">15</span> 	<span class="number">2</span>: istore_1 	<span class="number">3</span>: bipush <span class="number">8</span>	<span class="number">5</span>: istore_2	<span class="number">6</span>: iload_1	<span class="number">7</span>: iload_2	<span class="number">8</span>: iadd	<span class="number">9</span>: istore_3    <span class="number">10</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/da41b01ad08238a2c8065552aaa7d676.png" alt="image-20200706093131621"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6867c7a53a4faff29318783b46aef097.png" alt="image-20200706093251302"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f2d6c5d906914ebdca0a472fee33e047.png" alt="image-20200706093646406"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6ef9c2eb8ac3395133950caf8ef80da3.png" alt="image-20200706093751711"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/28113c3dc724bbffe677ea61b49e7c56.png" alt="image-20200706093859191"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f960c074fb4a6b1f35e862568ed23d04.png" alt="image-20200706093921573"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/73a07a0e10bef2537b6da97a5348fee2.png" alt="image-20200706094046782"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/17309b8150015a8b359f2cb2ef78cb60.png" alt="image-20200706094109629"></p>
<p><init>就是我们的构造器，任何类方法都会有<init><img src="/../../../images/image-20221116214709319.png" alt="image-20221116214709319"></init></init></p>
<p>就是我们定义的方法：<img src="/../../../images/image-20221116214722349.png" alt="image-20221116214722349"></p>
<p><img src="/../../../images/image-20221116220618255.png" alt="image-20221116220618255"></p>
<p>相当于8在byte范围内，一个字节能存，push之后，再istore，就是以int类型存储了</p>
<p><img src="/../../../images/image-20221116220949208.png" alt="image-20221116220949208"></p>
<p>程序员面试过程中，常见的 i++和++i 的区别，放到字节码篇章时再介绍。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 程序员面试过程中，常见的 i++ 和 ++i 的区别，放到字节码篇章时再介绍</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 第1类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i1 ++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    ++i2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第2类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> i3++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i6</span> <span class="operator">=</span> ++i5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第3类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i7</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i7 = i7 ++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">i8</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    i8 = ++i8;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第4类问题</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i9</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i10</span> <span class="operator">=</span> i9++ + ++i9;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术"><a href="#4-6-栈顶缓存技术（Top-Of-Stack-Cashing）技术" class="headerlink" title="4.6. 栈顶缓存技术（Top Of Stack Cashing）技术"></a>4.6. 栈顶缓存技术（Top Of Stack Cashing）技术</h2><p>前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读&#x2F;写次数。</p>
<p>由于<strong>操作数是存储在内存中</strong>的，因此频繁地执行内存读&#x2F;写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM 的设计者们提出了栈顶缓存（Tos，Top-of-Stack Cashing）技术，<mark>将<strong>栈顶元素</strong>全部<strong>缓存</strong>在<strong>物理 CPU 的寄存器</strong>中，以此降低对内存的读&#x2F;写次数，提升执行引擎的执行效率</mark>。</p>
<h2 id="4-7-动态链接（Dynamic-Linking）"><a href="#4-7-动态链接（Dynamic-Linking）" class="headerlink" title="4.7. 动态链接（Dynamic Linking）"></a>4.7. 动态链接（Dynamic Linking）</h2><p>动态链接、方法返回地址、附加信息 ： 有些地方被称为帧数据区</p>
<p>每一个栈帧内部都包含一个指向<mark>运行时常量池中该栈帧所属方法的引用</mark>。包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic 指令</p>
<p>在 Java 源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在 class 文件的<strong>常量池</strong>（Constant pool）里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么<mark><strong>动态链接的作用</strong>就是为了将这些符号引用转换为调用方法的直接引用</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/31f48e82748240d7694e542374e9d723.png" alt="image-20200706101251847"></p>
<p><strong>为什么需要运行时常量池呢？</strong></p>
<p>常量池的作用：就是为了提供一些符号和常量，便于指令的识别</p>
<p>比如：编译一个java代码时，所有的结构其实都需要我们加载到内存当中，但我们不能在字节码文件里面直接把这些结构都全部写出来，不然会导致字节码文件会很大。我们可以通过符号引用的方式去引用相关的结构就可以了，因此字节码文件就可以比较小，要使用时，直接用指针来指向即可</p>
<h2 id="4-8-方法的调用：解析与分配"><a href="#4-8-方法的调用：解析与分配" class="headerlink" title="4.8. 方法的调用：解析与分配"></a>4.8. 方法的调用：解析与分配</h2><p>在 JVM 中，将符号引用转换为调用方法的直接引用与方法的绑定机制相关</p>
<h3 id="4-8-1-静态链接"><a href="#4-8-1-静态链接" class="headerlink" title="4.8.1. 静态链接"></a>4.8.1. 静态链接</h3><p>当一个字节码文件被装载进 JVM 内部时，如果被调用的<mark>目标方法在编译期可知，且运行期保持不变时</mark>，这种情况下降调用方法的符号引用转换为直接引用的过程称之为静态链接</p>
<h3 id="4-8-2-动态链接"><a href="#4-8-2-动态链接" class="headerlink" title="4.8.2. 动态链接"></a>4.8.2. 动态链接</h3><p>如果<mark>被调用的方法在编译期无法被确定下来，只能够在程序运行期将调用的方法的符号转换为直接引用</mark>，由于这种引用转换过程具备动态性，因此也被称之为动态链接。</p>
<p><mark>静态链接和动态链接不是名词，而是动词，这是理解的关键。</mark></p>
<hr>
<p>对应的方法的绑定机制为：早期绑定（Early Binding）和晚期绑定（Late Binding）。<mark>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程，这仅仅发生一次。</mark></p>
<h3 id="4-8-3-早期绑定"><a href="#4-8-3-早期绑定" class="headerlink" title="4.8.3. 早期绑定"></a>4.8.3. 早期绑定</h3><p>早期绑定就是指被调用的目标方法如果在编译期可知，且运行期保持不变时，即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用静态链接的方式将符号引用转换为直接引用。</p>
<h3 id="4-8-4-晚期绑定"><a href="#4-8-4-晚期绑定" class="headerlink" title="4.8.4. 晚期绑定"></a>4.8.4. 晚期绑定</h3><p>如果被调用的方法在编译期无法被确定下来，只能够在程序运行期根据实际的类型绑定相关的方法，这种绑定方式也就被称之为晚期绑定。</p>
<hr>
<p>随着高级语言的横空出世，类似于 Java 一样的基于面向对象的编程语言如今越来越多，尽管这类编程语言在语法风格上存在一定的差别，但是它们彼此之间始终保持着一个共性，那就是都支持封装、继承和多态等面向对象特性，既然<mark>这一类的编程语言具备多态特悄，那么自然也就具备早期绑定和晚期绑定两种绑定方式。</mark></p>
<p>Java 中任何一个普通的方法其实都具备虚函数的特征，它们相当于 C++语言中的虚函数（C++中则需要使用关键字 virtual 来显式定义）。如果在 Java 程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字 final 来标记这个方法。</p>
<hr>
<h3 id="4-8-5-虚方法和非虚方法"><a href="#4-8-5-虚方法和非虚方法" class="headerlink" title="4.8.5. 虚方法和非虚方法"></a>4.8.5. 虚方法和非虚方法</h3><p><strong>非虚方法：</strong>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法。</p>
<p>静态方法、私有方法、final 方法、实例构造器、父类方法都是非虚方法。</p>
<p><strong>虚方法：</strong>在编译期间没法确定下来的。除了上面的非虚方法包含的，其他方法称为虚方法。</p>
<p>在类加载的解析阶段就可以进行解析，如下是非虚方法举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span>&#123; </span><br><span class="line">        System. out. println(<span class="string">&quot;father &quot;</span>+str);</span><br><span class="line">    &#125;    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String str)</span>&#123;      </span><br><span class="line">        System. out. println(<span class="string">&quot;father&quot;</span>+str);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VirtualMethodTest</span>&#123;   </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;   </span><br><span class="line">            Son.print(<span class="string">&quot;coder&quot;</span>);      </span><br><span class="line">            <span class="comment">//Father fa=new Father();      </span></span><br><span class="line">            <span class="comment">//fa.show(&quot;atguigu.com&quot;);      </span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虚拟机中提供了以下几条方法调用指令：</p>
<h4 id="普通调用指令："><a href="#普通调用指令：" class="headerlink" title="普通调用指令："></a>普通调用指令：</h4><ul>
<li><mark>invokestatic：调用静态方法，解析阶段确定唯一方法版本</mark></li>
<li><mark>invokespecial：调用方法、私有及父类方法，解析阶段确定唯一方法版本</mark></li>
<li>invokevirtual：调用所有虚方法</li>
<li>invokeinterface：调用接口方法</li>
</ul>
<h4 id="动态调用指令："><a href="#动态调用指令：" class="headerlink" title="动态调用指令："></a>动态调用指令：</h4><ul>
<li>invokedynamic：动态解析出需要调用的方法，然后执行</li>
</ul>
<p>前四条指令固化在虚拟机内部，方法的调用执行不可人为干预，而 invokedynamic 指令则支持由用户确定方法版本。<mark>其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</mark></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 解析调用中非虚方法、虚方法的测试</span><br><span class="line"> * 其中 invokestatic 指令和 invokespecial 指令调用的方法称为非虚方法，其余的（fina1 修饰的除外）称为虚方法。</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/17</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">class Father &#123;</span><br><span class="line">    public Father() &#123;</span><br><span class="line">        System.out.println( &quot;father 的构造器&quot; );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void showStatic(String str) &#123;</span><br><span class="line">        System.out.println(&quot;father&quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public final void showFinal() &#123;</span><br><span class="line">        System.out.println(&quot;father show final&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void showCommon() &#123;</span><br><span class="line">        System.out.println(&quot;father 普通方法&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Father &#123;</span><br><span class="line">    public Son() &#123;</span><br><span class="line">        // invokespecial #1 &lt;jvm/chapter04/Father.&lt;init&gt; : ()V&gt;</span><br><span class="line">        super();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Son(int age) &#123;</span><br><span class="line">        // invokespecial #3 &lt;jvm/chapter04/Son.&lt;init&gt; : ()V&gt;</span><br><span class="line">        this();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 不是重写的静态方法，因为静态方法不能被重写</span><br><span class="line">     */</span><br><span class="line">    public static void showStatic(String str) &#123;</span><br><span class="line">        System.out.println(&quot;son &quot; + str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void showPrivate(String str) &#123;</span><br><span class="line">        System.out.println(&quot;son private &quot; +str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void show() &#123;</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">            非虚方法：</span><br><span class="line">         */</span><br><span class="line">        // 这showStatic 和 Father.showStatic(&quot;good&quot;) 两个都是调用的静态方法，所有都是非虚方法</span><br><span class="line">        // invokestatic #13 &lt;jvm/chapter04/Son.showStatic : (Ljava/lang/String;)V&gt;</span><br><span class="line">        showStatic(&quot;qrly.com&quot;);</span><br><span class="line">        //  invokestatic #15 &lt;jvm/chapter04/Father.showStatic : (Ljava/lang/String;)V&gt;</span><br><span class="line">        Father.showStatic(&quot;good&quot;);</span><br><span class="line">        // invokespecial #17 &lt;jvm/chapter04/Son.showPrivate : (Ljava/lang/String;)V&gt;</span><br><span class="line">        showPrivate(&quot;hello&quot;);</span><br><span class="line">        // invokespecial #18 &lt;jvm/chapter04/Father.showCommon : ()V&gt;</span><br><span class="line">        super.showCommon();</span><br><span class="line"></span><br><span class="line">        // invokevirtual #19 &lt;jvm/chapter04/Son.showFinal : ()V&gt;</span><br><span class="line">        // 因为此方法声明有final，不能被子类重写，所以也认为此方法是非虚方法</span><br><span class="line">        // 虚方法是编译期间没法确定下里的才是虚方法</span><br><span class="line">        showFinal();</span><br><span class="line">        // invokespecial #20 &lt;jvm/chapter04/Father.showFinal : ()V&gt;</span><br><span class="line">        super.showFinal();</span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">          虚方法如下：</span><br><span class="line">         */</span><br><span class="line">        // invokevirtual #20 &lt;jvm/chapter04/Son.showCommon : ()V&gt;</span><br><span class="line">        // 由于没有加 super.来调用，且有可能这个方法会在子类里面重写，所以在编译期间是没法确定的，所以这个是虚方法</span><br><span class="line">        showCommon();</span><br><span class="line">        // invokevirtual #21 &lt;jvm/chapter04/Son.info : ()V&gt;</span><br><span class="line">        info();</span><br><span class="line"></span><br><span class="line">        MethodInterface in = null;</span><br><span class="line">        // invokeinterface #22 &lt;jvm/chapter04/MethodInterface.methodA : ()V&gt; count 1</span><br><span class="line">        // 要调用接口中的方法，在执行的时候肯定要被实现类里实现的</span><br><span class="line">        in.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void info() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void display(Father f) &#123;</span><br><span class="line">        f.showCommon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Son so = new Son();</span><br><span class="line">        so.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface MethodInterface &#123;</span><br><span class="line">    void methodA();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="/../../../images/image-20221117111404877.png" alt="image-20221117111404877"></p>
<p><img src="/../../../images/image-20221117112919097.png" alt="image-20221117112919097"></p>
<p><strong>关于 invokednamic 指令</strong></p>
<ul>
<li><p>JVM 字节码指令集一直比较稳定，一直到 Java7 中才增加了一个 invokedynamic 指令，这是<mark>Java 为了实现「动态类型语言」支持而做的一种改进。</mark></p>
</li>
<li><p>但是在 Java7 中并没有提供直接生成 invokedynamic 指令的方法，需要借助 ASM 这种底层字节码工具来产生 invokedynamic 指令。<mark>直到 Java8 的 Lambda 表达式的出现，invokedynamic 指令的生成，在 Java 中才有了直接的生成方式。</mark></p>
</li>
<li><p>Java7 中增加的动态语言类型支持的本质是对 Java 虚拟机规范的修改，而不是对 Java 语言规则的修改，这一块相对来讲比较复杂，增加了虚拟机中的方法调用，最直接的受益者就是运行在 Java 平台的动态语言的编译器。</p>
</li>
</ul>
<h4 id="动态类型语言和静态类型语言"><a href="#动态类型语言和静态类型语言" class="headerlink" title="动态类型语言和静态类型语言"></a>动态类型语言和静态类型语言</h4><p>动态类型语言和静态类型语言两者的区别就在于对类型的检查是在编译期还是在运行期，满足前者就是静态类型语言，反之是动态类型语言。</p>
<p>说的再直白一点就是，<mark>静态类型语言是判断<strong>变量</strong>自身的类型信息；动态类型语言是判断<strong>变量值</strong>的类型信息，变量没有类型信息，变量值才有类型信息</mark>，这是动态语言的一个重要特征。</p>
<p>java主要的还是静态类型语言的特点，而Python 和 JS 是动态类型语言</p>
<h3 id="4-8-6-方法重写的本质"><a href="#4-8-6-方法重写的本质" class="headerlink" title="4.8.6. 方法重写的本质"></a>4.8.6. 方法重写的本质</h3><p><strong>Java 语言中方法重写的本质：</strong></p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作 C。</li>
<li>如果在类型 C 中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回 java.lang.IllegalAccessError 异常。</li>
<li>否则，按照继承关系从下往上依次对 C 的各个父类进行第 2 步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出 java.1ang.AbstractMethodsrror 异常。</li>
</ol>
<p><strong>IllegalAccessError 介绍</strong></p>
<p>程序试图访问或修改一个属性或调用一个方法，这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常。这个错误如果发生在运行时，就说明一个类发生了不兼容的改变。</p>
<h3 id="4-8-7-方法的调用：虚方法表"><a href="#4-8-7-方法的调用：虚方法表" class="headerlink" title="4.8.7. 方法的调用：虚方法表"></a>4.8.7. 方法的调用：虚方法表</h3><p>在面向对象的编程中，会很频繁的使用到动态分派，如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率。<mark>因此，为了提高性能，JVM 采用在类的方法区建立一个虚方法表 （virtual method table）（非虚方法不会出现在表中）来实现。使用索引表来代替查找。</mark></p>
<p>每个类中都有一个虚方法表，表中存放着各个方法的实际入口。</p>
<p>虚方法表是什么时候被创建的呢？</p>
<p>虚方法表会在类加载的链接阶段被创建并开始初始化，类的变量初始值准备完成之后，JVM 会把该类的方法表也初始化完毕。</p>
<p>举例 1：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/79470fa420092e07a411e4e849f743b8.png" alt="image-20200706144954070"></p>
<p>举例 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Friendly</span>&#123;   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;   </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">tostring</span><span class="params">()</span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Dog&quot;</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span> &#123;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123;   </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> &#123;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CockerSpaniel</span> <span class="keyword">extends</span> <span class="title class_">Dog</span> <span class="keyword">implements</span> <span class="title class_">Friendly</span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;      </span><br><span class="line">        <span class="built_in">super</span>.sayHello();  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayGoodbye</span><span class="params">()</span> &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/2264627eaca3c5385a75101478565f5b.png" alt="image-20210509203351535"></p>
<h2 id="4-9-方法返回地址（return-address）"><a href="#4-9-方法返回地址（return-address）" class="headerlink" title="4.9. 方法返回地址（return address）"></a>4.9. 方法返回地址（return address）</h2><p>存放调用该方法的 pc 寄存器的值。一个方法的结束，有两种方式：</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，<mark>调用者的 pc 计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址</mark>。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。</p>
<p>当一个方法开始执行后，只有两种方式可以退出这个方法：</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令（return），会有返回值传递给上层的方法调用者，简称<mark>正常完成出口</mark>；<ul>
<li>一个方法在正常调用完成之后，究竟需要使用哪一个返回指令，还需要根据方法返回值的实际数据类型而定。</li>
<li>在字节码指令中，返回指令包含 ireturn（当返回值是 boolean，byte，char，short 和 int 类型时使用），lreturn（Long 类型），freturn（Float 类型），dreturn（Double 类型），areturn。另外还有一个 return 指令声明为 void 的方法，实例初始化方法，类和接口的初始化方法使用。</li>
</ul>
</li>
<li>在方法执行过程中遇到异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，简称<mark>异常完成出口</mark>。</li>
</ol>
<p>方法执行过程中，抛出异常时的异常处理，存储在一个异常处理表，方便在发生异常的时候找到处理异常的代码</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">from to   target type</span><br><span class="line">4	 16	  19   any	</span><br><span class="line">19	 21	  19   any</span><br></pre></td></tr></table></figure>

<p>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置 PC 寄存器值等，让调用者方法继续执行下去。</p>
<p><mark>正常完成出口和异常完成出口的区别在于：通过异常完成出口退出的不会给他的上层调用者产生任何的返回值。</mark></p>
<h2 id="4-10-一些附加信息"><a href="#4-10-一些附加信息" class="headerlink" title="4.10. 一些附加信息"></a>4.10. 一些附加信息</h2><p>栈帧中还允许携带与 Java 虚拟机实现相关的一些附加信息。例如：对程序调试提供支持的信息。</p>
<h2 id="4-11-栈的相关面试题"><a href="#4-11-栈的相关面试题" class="headerlink" title="4.11. 栈的相关面试题"></a>4.11. 栈的相关面试题</h2><ul>
<li><p>举例栈溢出的情况？（StackOverflowError）</p>
<ul>
<li>当栈空间不足的时候，就会导致栈溢出的情况，会报StackOverflowError</li>
<li>通过 -Xss 设置栈的大小</li>
</ul>
</li>
<li><p>调整栈大小，就能保证不出现溢出么？</p>
<ul>
<li>不能保证不溢出</li>
</ul>
</li>
<li><p>分配的栈内存越大越好么？</p>
<ul>
<li>不是，一定时间内降低了 OOM 概率，但是会挤占其它的线程空间，因为整个空间是有限的。</li>
</ul>
</li>
<li><p>垃圾回收是否涉及到虚拟机栈？</p>
<ul>
<li>不会</li>
</ul>
</li>
<li><p>方法中定义的局部变量是否线程安全？</p>
<ul>
<li>具体问题具体分析。如果对象是在内部产生，并在内部消亡，没有返回到外部，那么它就是线程安全的，反之则是线程不安全的。</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">运行时数据区</th>
<th align="left">是否存在 Error</th>
<th align="left">是否存在 GC</th>
</tr>
</thead>
<tbody><tr>
<td align="left">程序计数器</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">虚拟机栈</td>
<td align="left">是（SOE）</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">本地方法栈</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">方法区</td>
<td align="left">是（OOM）</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">堆</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/17</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 面试题：</span></span><br><span class="line"><span class="comment"> * 方法中定义的局部变量是否线程安全？具体情况具体分析</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">P62_StringBuilderTest</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的声明方式是线程安全的</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// StringBuider:线程不安全的</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sBuider的操作过程：是线程不安全的，发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(StringBuilder sBuider)</span> &#123;</span><br><span class="line">        sBuider.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        sBuider.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的操作：是线程不安全的</span></span><br><span class="line"><span class="comment">     * 因为StringBuilder被返回，发生逃逸，返回的话就可能会被其它线程拿去用，导致不安全</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * s1的操作：是线程安全的</span></span><br><span class="line"><span class="comment">     * 因为s1在方法内部生命周期就结束了。没有发生逃逸</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">method4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s1.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        s1.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> s1.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            s.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">            s.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        &#125;).run();</span><br><span class="line"></span><br><span class="line">        method2(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/4.%20%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/" data-id="cleebxr4q006mxwv66vgiaks5" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/3. 运行时数据区及程序计数器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2022-11-16T00:40:57.094Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/">3. 运行时数据区及程序计数器</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
</blockquote>
<p>[toc]</p>
<h1 id="3-运行时数据区及程序计数器"><a href="#3-运行时数据区及程序计数器" class="headerlink" title="3. 运行时数据区及程序计数器"></a>3. 运行时数据区及程序计数器</h1><h2 id="3-1-运行时数据区"><a href="#3-1-运行时数据区" class="headerlink" title="3.1. 运行时数据区"></a>3.1. 运行时数据区</h2><h3 id="3-1-1-概述"><a href="#3-1-1-概述" class="headerlink" title="3.1.1. 概述"></a>3.1.1. 概述</h3><p>本节主要讲的是运行时数据区，也就是下图这部分，它是在类加载完成后的阶段</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b5d91ce04cfef9a681bbed216732511a.png" alt="image-20200705111640511"></p>
<p>当我们通过前面的：类的加载-&gt; 验证 -&gt; 准备 -&gt; 解析 -&gt; 初始化 这几个阶段完成后，就会用到执行引擎对我们的类进行使用，同时执行引擎将会使用到我们运行时数据区</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b3cd82be688254afd263db9094e004a7.png" alt="image-20200705111843003"></p>
<p>内存是非常重要的系统资源，是硬盘和 CPU 的中间仓库及桥梁，承载着操作系统和应用程序的实时运行 JVM 内存布局规定了 Java 在运行过程中内存申请、分配、管理的策略，保证了 JVM 的高效稳定运行。不同的 JVM 对于内存的划分方式和管理机制存在着部分差异。结合 JVM 虚拟机规范，来探讨一下经典的 JVM 内存布局。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d6f0aac226ebab0c435b8fe79995eddc.png" alt="image-20210509174724223"></p>
<p>我们把大厨后面的东西（切好的菜，刀，调料），比作是运行时数据区。而厨师可以类比于执行引擎，将通过准备的东西进行制作成精美的菜品</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bbf59f2544890b06cdb69b2d7719c060.png" alt="image-20210509174543026"></p>
<p>我们通过磁盘或者网络 IO 得到的数据，都需要先加载到内存中，然后 CPU 从内存中获取数据进行读取，也就是说内存充当了 CPU 和磁盘之间的桥梁</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d9139f792f2d10eb03fb827da25b3b28.png" alt="image-20200705112416101"></p>
<p>Java 虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。</p>
<p>灰色的为单独线程私有的，红色的为多个线程共享的。即：</p>
<ul>
<li>每个线程：独立包括程序计数器、栈、本地栈。</li>
<li>线程间共享：堆、堆外内存（永久代或元空间、代码缓存）</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0f0cce71a35c12ef13e6482d0663dc21.png" alt="image-20200705112601211"></p>
<p>每个 JVM 只有一个 Runtime 实例。即为运行时环境，相当于内存结构的中间的那个框框：运行时环境。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/efc4643bdd550c6ecacb9d764e71890e.png" alt="image-20210509173410373"></p>
<h3 id><a href="#" class="headerlink" title></a></h3><hr>
<h1 id="3-1-2-线程"><a href="#3-1-2-线程" class="headerlink" title="3.1.2. 线程"></a>3.1.2. 线程</h1><p>线程是一个程序里的运行单元。JVM 允许一个应用有多个线程并行的执行。 在 Hotspot JVM 里，每个线程都与操作系统的本地线程直接映射。</p>
<p>当一个 Java 线程准备好执行以后，此时一个操作系统的本地线程也同时创建。Java 线程执行终止后，本地线程也会回收。</p>
<p>操作系统负责所有线程的安排调度到任何一个可用的 CPU 上。一旦本地线程初始化成功，它就会调用 Java 线程中的 run()方法。</p>
<p><img src="http://img10.360buyimg.com/n7/s523x355_jfs/t6595/305/70607884/742714/c76b7170/59390c8aNf12b52ac.bmp" alt="image"></p>
<p>JVM 是否要终止还要取决于当前线程是不是最后一个非守护线程（线程分为 守护线程、非守护线程）。如果们内存中都只剩下守护线程的话，JVM就可以退出了。</p>
<p>守护进程就是服务进程(例如GC进程,他们的存在不是必须的),当所有非守护进程执行结束了,守护就没有存在的意义了,自然jvm的运行就可以停止了</p>
<h3 id="3-1-3-JVM-系统线程"><a href="#3-1-3-JVM-系统线程" class="headerlink" title="3.1.3. JVM 系统线程"></a>3.1.3. JVM 系统线程</h3><p>如果你使用 console 或者是任何一个调试工具，都能看到在后台有许多线程在运行。这些后台线程不包括调用<code>public static void main(String[] args)</code>的 main 线程以及所有这个 main 线程自己创建的线程。</p>
<p>这些主要的后台系统线程在 Hotspot JVM 里主要是以下几个：</p>
<ul>
<li><mark>虚拟机线程</mark>：这种线程的操作是需要 JVM 达到安全点才会出现。这些操作必须在不同的线程中发生的原因是他们都需要 JVM 达到安全点，这样堆才不会变化。这种线程的执行类型包括”stop-the-world”的垃圾收集，线程栈收集，线程挂起以及偏向锁撤销。</li>
<li><mark>周期任务线程</mark>：这种线程是时间周期事件的体现（比如中断），他们一般用于周期性操作的调度执行。</li>
<li><mark>GC 线程</mark>：这种线程对在 JVM 里不同种类的垃圾收集行为提供了支持。</li>
<li><mark>编译线程</mark>：这种线程在运行时会将字节码编译成到本地代码。</li>
<li><mark>信号调度线程</mark>：这种线程接收信号并发送给 JVM，在它内部通过调用适当的方法进行处理。</li>
</ul>
<h2 id="3-2-程序计数器-PC-寄存器"><a href="#3-2-程序计数器-PC-寄存器" class="headerlink" title="3.2. 程序计数器(PC 寄存器)"></a>3.2. 程序计数器(PC 寄存器)</h2><p>JVM 中的程序计数寄存器（Program Counter Register）中，Register 的命名源于 CPU 的寄存器，寄存器存储指令相关的现场信息。CPU 只有把数据装载到寄存器才能够运行。这里，并非是广义上所指的物理寄存器，或许将其翻译为 PC 计数器（或指令计数器）会更加贴切（也称为程序钩子），并且也不容易引起一些不必要的误会。<mark>JVM 中的 PC 寄存器是对物理 PC 寄存器的一种抽象模拟</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6785d89d74d694f7cfe22ba74a164d9.png" alt="image-20200705155551919"></p>
<p><strong>作用</strong></p>
<p>PC 寄存器用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条指令。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/998d864c026e5d6b565d1cfaecda2bb0.png" alt="image-20200705155728557"></p>
<p>它是一块很小的内存空间，几乎可以忽略不记。也是<mark>运行速度最快的存储区域</mark>。</p>
<p>在 JVM 规范中，<mark>每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致</mark>。</p>
<p><mark>任何时间一个线程都只有一个方法在执行，也就是所谓的当前方法</mark>。程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行 native 方法，则是未指定值（undefined）。</p>
<p>它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>
<p>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。</p>
<p>它是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p>
<p>Stack Area、Native Method Stack 都没有GC垃圾回收，但是有可能发生OOM内存溢出</p>
<p>Method Area 和 Head Area都有GC垃圾回收，也会发生OOM内存溢出</p>
<p>PC寄存器既没有GC，也没有OOM (OutOfMemoryError )</p>
<p><strong>举例说明</strong></p>
<p><img src="/../../../images/image-20221116095436397.png" alt="image-20221116095436397"></p>
<p>字节码文件分析：</p>
<p><img src="/../../../images/image-20221116095326530.png" alt="image-20221116095326530"></p>
<h1 id="PC寄存器面试问题"><a href="#PC寄存器面试问题" class="headerlink" title="PC寄存器面试问题"></a>PC寄存器面试问题</h1><p><strong>使用 PC 寄存器存储字节码指令地址有什么用呢？为什么使用 PC 寄存器记录当前线程的执行地址呢？</strong></p>
<p>因为 CPU 需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。</p>
<p>JVM 的字节码解释器就需要通过改变 PC 寄存器的值来明确下一条应该执行什么样的字节码指令。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/68aa12d47725e4559e6b71489d91122e.png" alt="image-20200705161409533"></p>
<p><strong>PC 寄存器为什么被设定为私有的？</strong></p>
<p>我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU 会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？<mark>为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个 PC 寄存器</mark>，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。</p>
<p>由于 CPU 时间片轮限制，众多线程在并发执行过程中，任何一个确定的时刻，一个处理器或者多核处理器中的一个内核，只会执行某个线程中的一条指令。</p>
<p>这样必然导致经常中断或恢复，如何保证分毫无差呢？每个线程在创建后，都会产生自己的程序计数器和栈帧，程序计数器在各个线程之间互不影响。</p>
<p><strong>CPU 时间片</strong></p>
<p>CPU 时间片即 CPU 分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。</p>
<p>在宏观上：俄们可以同时打开多个应用程序，每个程序并行不悖，同时运行。</p>
<p>但在微观上：由于只有一个 CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bbab7cdab74c493af70b423f06e6ff86.png" alt="image-20200705161849557"></p>
<p>了解一下</p>
<p>并行、串行</p>
<p>并行、并发</p>
<p>的概念和区别</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/16/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/3.%20%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/" data-id="cleebxr4r006oxwv6baatcljk" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-设计模式/创建者模式/工厂模式" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="post-time" datetime="2022-11-15T14:36:07.877Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">工厂模式</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>,<a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/">创建者模式</a>,<a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">工厂模式</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p>
<p>在工厂模式中，<strong>我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</strong></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>意图：</strong>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<p><strong>主要解决：</strong>主要解决接口选择的问题。</p>
<p><strong>何时使用：</strong>我们明确地计划不同条件下创建不同实例时。</p>
<p><strong>如何解决：</strong>让其子类实现工厂接口，返回的也是一个抽象的产品。</p>
<p><strong>关键代码：</strong>创建过程在其子类执行。</p>
<p><strong>应用实例：</strong> 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>
<p><strong>优点：</strong> 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>
<p><strong>缺点：</strong>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>使用场景：</strong> 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口。</p>
<p><strong>注意事项：</strong>作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们将创建一个 <em>Shape</em> 接口和实现 <em>Shape</em> 接口的实体类。下一步是定义工厂类 <em>ShapeFactory</em>。</p>
<p><em>FactoryPatternDemo</em> 类使用 <em>ShapeFactory</em> 来获取 <em>Shape</em> 对象。它将向 <em>ShapeFactory</em> 传递信息（<em>CIRCLE &#x2F; RECTANGLE &#x2F; SQUARE</em>），以便获取它所需对象的类型。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/08/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg" alt="工厂模式的 UML 图"></p>
<h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤 1"></a>步骤 1</h3><p>创建一个接口:</p>
<h2 id="Shape-java"><a href="#Shape-java" class="headerlink" title="Shape.java"></a>Shape.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤1：创建一个接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤-2"><a href="#步骤-2" class="headerlink" title="步骤 2"></a>步骤 2</h3><p>创建实现接口的实体类。</p>
<h2 id="Rectangle-java"><a href="#Rectangle-java" class="headerlink" title="Rectangle.java"></a>Rectangle.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Rectangle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println( <span class="string">&quot;Inside Rectangle :: draw() method.&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Square-java"><a href="#Square-java" class="headerlink" title="Square.java"></a>Square.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Square::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Circle-java"><a href="#Circle-java" class="headerlink" title="Circle.java"></a>Circle.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤2：创建接口的实体类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Circle</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Inside Circle::draw() method.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="步骤-3"><a href="#步骤-3" class="headerlink" title="步骤 3"></a>步骤 3</h3><p>创建一个工厂，生成基于给定信息的实体类的对象。</p>
<h2 id="ShapeFactory-java"><a href="#ShapeFactory-java" class="headerlink" title="ShapeFactory.java"></a>ShapeFactory.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤3：创建一个工厂，生成基于给定信息的实体类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用 getShape 方法获取类型的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Shape <span class="title function_">getShape</span><span class="params">(String shapeType)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (shapeType == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;CIRCLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Circle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (shapeType.equalsIgnoreCase(<span class="string">&quot;RECTANGLE&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Rectangle</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">&quot;SQUARE&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Square</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="步骤-4"><a href="#步骤-4" class="headerlink" title="步骤 4"></a>步骤 4</h3><p>使用该工厂，通过传递类型信息来获取实体类的对象。</p>
<h2 id="FactoryPatternDemo-java"><a href="#FactoryPatternDemo-java" class="headerlink" title="FactoryPatternDemo.java"></a>FactoryPatternDemo.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 步骤4：使用该工厂，通过传递类型信息来获取实体类的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FactoryPatterDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShapeFactory</span> <span class="variable">shapeFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShapeFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape1</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;CIRCLE&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用 Circle 的 draw 方法</span></span><br><span class="line">        shape1.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape2</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;RECTANGLE&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">        shape2.draw();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape3</span> <span class="operator">=</span> shapeFactory.getShape(<span class="string">&quot;SQUARE&quot;</span>);</span><br><span class="line">        <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">        shape3.draw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="步骤-5"><a href="#步骤-5" class="headerlink" title="步骤 5"></a>步骤 5</h3><p>执行程序，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Inside Circle::draw() method.</span><br><span class="line">Inside Rectangle::draw() method.</span><br><span class="line">Inside Square::draw() method.</span><br></pre></td></tr></table></figure>

<p>截图分析</p>
<p><img src="/../../../images/image-20221115223614920.png" alt="image-20221115223614920"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" data-id="cleebxr6g00bcxwv690x52295" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%9B%E5%BB%BA%E8%80%85%E6%A8%A1%E5%BC%8F/" rel="tag">创建者模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag">设计模式</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/双亲委派机制" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/15/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/" class="article-date">
  <time class="post-time" datetime="2022-11-15T13:36:11.647Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">15</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/15/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/">(JVM)双亲委派机制</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/interview/">interview</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>,<a class="article-category-link" href="/categories/interview/">interview</a>,<a class="article-category-link" href="/categories/interview/JVM/">JVM</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h1><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>3）<strong>如果父类加载器可以完成类加载任务，就成功返回</strong>（就不会由子类加载器去加载了），倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p>
<p>举例：</p>
<p>1. </p>
<p><img src="/../../../images/image-20221115204949307.png" alt="image-20221115204949307"></p>
<p>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。一看你是java开头的，引导类加载就说了。这是归我管我来加载String（核心API里的String）。因此有父类来加载后，就不会再向下委托了，所以我们new 的这个String对象就是核心API里面的String类对象，而不是我们自定义的String，因此就没有打印出自定义String里的static静态资源里的语句</p>
<p>2. </p>
<p><img src="/../../../images/image-20221115205956137.png" alt="image-20221115205956137"></p>
<p>委托到引导类加载器，它发现你这个包是jvm开头的，不归引导类加载管，就向下委托，也不归扩展类加载器管，所以最后回到系统类加载器来加载，因此最后输出结果就是系统类加载来进行的加载</p>
<p>3. </p>
<p><img src="/../../../images/image-20221115210219781.png" alt="image-20221115210219781"></p>
<p>一直往上委托，就交给到了引导类加载器，它加载了String类以后，然后就想去执行main方法，但是核心API的String里面是没有main方法的，所以就报了 <mark>错误: 在类 java.lang.String 中找不到 main 方法</mark>. 可知，根本就没有试着想去加载我们自定义的String类，完全忽略掉你了</p>
<p>4. </p>
<p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h2><ul>
<li><strong>避免类的重复加载</strong></li>
<li><strong>保护程序安全，防止核心 API 被随意篡改</strong><ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li>
</ul>
</li>
</ul>
<p><img src="/../../../images/image-20221115212723174.png" alt="image-20221115212723174"></p>
<p>引导类加载器看到是 java.lang开头的，就表示这是归它管，于是就要去加载这个ShkStart类了，但直接直接给它报错了，相当于，要加载java.lang这个包，要想访问是要有权限的，现在报错就是阻止我们去直接用这个java.lang包来自定义这个ShkStart类。其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个类，加载成功的话，就会导致对引导类加载器本身造成影响，所以这里是直接把引导类加载器给整挂了。所以我们也禁止去用java.lang这样的包名去命名</p>
<p>其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个种自定义的类，加载成功的话，但里面可能会有一些<strong>恶意代码</strong>，就可能会会对现有的项目和程序进行破坏</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<h1 id><a href="#" class="headerlink" title></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/15/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/" data-id="cleebxr540079xwv66yhr9xq3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/redis/Redis" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/14/interview/redis/Redis/" class="article-date">
  <time class="post-time" datetime="2022-11-14T15:02:35.609Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/14/interview/redis/Redis/">Redis</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a>,<a class="article-category-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/">Redis</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/Redis/">Redis</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-说说你对Redis的了解"><a href="#1-说说你对Redis的了解" class="headerlink" title="1. 说说你对Redis的了解"></a>1. 说说你对Redis的了解</h2><p>**得分点 : **Redis概念，Redis优点及用途</p>
<p><strong>标准回答</strong> ：</p>
<p>Redis是一款基于键值对的NoSQL数据库,与其他键值对数据库不同的是,<strong>Redis中拥有string（字符串）、hash（哈希）、 list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、 HyperLogLog、GEO（地理信息定位）等多种数据结构,这给Redis带来了满足多种应用场景的能力</strong>,而且,Redis将所有数据放到内存中的做法让它的读写性能十分惊人。不仅如此,Redis的<strong>持久化机制</strong>保证了在发生类似断电,机械故障等情况时,内存中的数据不会丢失。此外Redis还提供了<strong>键过期、发布订阅、事务、流水线、Lua脚本等多个附加功能</strong>。总之,在合适的情况下使用Redis会大大增强系统的性能,减少开发人员工作量。 </p>
<p><strong>加分回答</strong> </p>
<p>适合Redis使用的场景： </p>
<ul>
<li>热点数据的缓存：redis访问速度快、支持的数据类型丰富,很适合用来存储热点数据。 </li>
<li>限时业务：redis中可以使用expire命令设置一个键的生存时间,到时间后redis会删除它。因此,Redis在限时业务中的表现很亮眼。 </li>
<li>计数器：incrby命令可以实现原子性的递增,所以可以运用于高并发的秒杀活动、分布式序列号的生成。 </li>
<li>排行榜：关系型数据库在排行榜方面查询速度普遍偏慢,所以可以借助redis的SortedSet进行热点数据的排序。 </li>
<li>分布式锁：这个主要利用redis的setnx命令进行,在后面的如何用Redis实现一个分布式锁中会进行详解。 </li>
<li>延时操作：redis自2.8.0之后版本提供Keyspace Notifications功能,允许客户订阅Pub&#x2F;Sub频道,以便以某种方式接收影响Redis数据集的事件。</li>
<li>分页查询、模糊查询：Redis的set集合中提供了一个zrangebylex方法,通过ZRANGEBYLEX zset - + LIMIT 0 10 可以进行分页数据查询,其中- +表示获取全部数据；rangebylex key min max 这个就可以返回字典区间的数据可以利用这个特性可以进行模糊查询功能。 </li>
<li>点赞,好友等相互关系的存储：Redis set对外提供的功能与list类似是一个列表的功能,特殊之处在于set是可以自动排重的,我们可以通过这一点实现类似共同好友等功能。 </li>
<li>队列：由于redis有list push和list pop这样的命令,所以能够很方便的执行队列操作。</li>
</ul>
<p>简介版回答：</p>
<p>Redis是一款基于键值对的NoSQL数据库，Redis中拥有string(字符串)，hash(哈希)、list(列表)、set（集合）等多种数据结构，redis将数据写进内存的性能很快，不仅如此，如遇到系统崩溃，内存中的数据不会丢失；redis访问速度快、支持的数据类型丰富，很适合用来储存热点数据、 而且适用业务广，如可以运用expire命令来做限时业务，设置一个键的生存时间，到时间后redis会自动删除它，如排行榜可以借住redis的SortedSet进行热点数据的排序，还有分页查询，模糊查询，点赞好友等</p>
<h2 id="2-详细的说说Redis的数据类型"><a href="#2-详细的说说Redis的数据类型" class="headerlink" title="2. 详细的说说Redis的数据类型"></a>2. 详细的说说Redis的数据类型</h2><p><strong>得分点</strong> </p>
<p>Redis5种数据结构 </p>
<p><strong>标准回答</strong> </p>
<p>Redis主要提供了5种数据结构：<strong>字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)<strong>。Redis还提供了</strong>Bitmap、HyperLogLog、Geo</strong>类型,但这些类型都是基于上述核心数据类型实现的(Bitmap基于redis的字符串实现)。5.0版本中,Redis新增加了<strong>Streams</strong>数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。 </p>
<p><mark>string</mark>可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。</p>
<p><mark>list</mark>保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素.</p>
<p><mark>hash</mark>的值本身也是一个键值对结构,最多能存储2^32-1个元素.</p>
<p><mark>set</mark>是无序不可重复的,它支持多个set求交集、并集、差集, 适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素.</p>
<p><mark>zset</mark>是<strong>有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据</strong>,一个zset最多可以存储2^32-1个元素。 </p>
<p>Bitmap:  原本的含义是用一个比特位来映射某个元素的状态。由于一个比特位只能表示 0 和 1 两种状态，所以 BitMap 能映射的状态有限，但是使用比特位的优势是能大量的节省内存空间 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/54chensongxia/p/13794391.html">Redis 中 BitMap 的使用场景 - 程序员自由之路 - 博客园 (cnblogs.com)</a></p>
<p>HyperLogLog: 用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定 的、并且是很小的。 <a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-hyperloglog.html">Redis HyperLogLog | 菜鸟教程 (runoob.com)</a></p>
<p>Geo: 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2 版本新增。[Redis GEO | 菜鸟教程 (runoob.com)](<a target="_blank" rel="noopener" href="https://www.runoob.com/redis/redis-geo.html#:~:text=Redis">https://www.runoob.com/redis/redis-geo.html#:~:text=Redis</a> GEO 主要用于存储地理位置信息，并对存储的信息进行操作，该功能在 Redis 3.2,版本新增。 geoadd：添加地理位置的坐标。 geopos：获取地理位置的坐标。 geodist：计算两个位置之间的距离。 georadius：根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。)</p>
<p><strong>加分回答</strong> </p>
<p>每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构： string：编码分为int、raw、embstr；int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。 hash：编码分为ziplist、hashtable两种,其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。 set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。</p>
<hr>
<p>主要：字符串（String），哈希（hash），列表（list），集合（set），有序集合（zset）</p>
<hr>
<h2 id="3-说说Redis的持久化策略"><a href="#3-说说Redis的持久化策略" class="headerlink" title="3. 说说Redis的持久化策略"></a>3. 说说Redis的持久化策略</h2><p><strong>得分点</strong> RDB、AOF </p>
<p>标准回答 </p>
<p>Redis4.0之后,Redis有<strong>RDB持久化（默认）、AOF持久化、RDB-AOF混合持久化</strong>这三种持久化方式。 </p>
<p><mark>RDB持久化</mark>是将当前进程数据以生成快照的方式保存到硬盘的过程,也是Redis<strong>默认</strong>的持久化机制。RDB会创建一个经过压缩的二进制文件,这个文件以’**.rdb<strong>‘结尾,内部存储了各个数据库的键值对等信息。RDB持久化过程有</strong>手动触发<strong>和</strong>自动触发<strong>两种方式。手动触发是指通过SAVE或BGSAVE命令触发RDB持久化操作,创建“.rdb”文件；</strong>自动触发是指通过配置选项,让服务器在满足指定条件时自动执行BGSAVE命令<strong>。RDB持久化的</strong>优点<strong>是其生成的紧凑压缩的二进制文件体积小,使用该文件恢复数据的速度非常快；</strong>缺点**则是BGSAVE每次运行都要执行fork操作创建子进程,这属于重量级操作,不宜频繁执行,因此,RBD没法做到实时的持久化;RDB执行时间长，两次RDB之间写入数据有丢失的风险</p>
<p><img src="/../../../images/image-20230216113518076.png" alt="image-20230216113518076"></p>
<p><mark>AOF</mark>（Append Only File）以独立日志的方式记录了每次写入的命令,重启时再重新执行AOF文件中的命令来恢复数据。AOF持久化的<strong>优点</strong>是与RDB持久化可能丢失大量的数据相比,AOF持久化的安全性要高很多。通过使用<strong>everysec</strong>（每秒刷盘）选项,用户可以将数据丢失的时间窗口限制在1秒之内。其<strong>缺点</strong>则是,AOF文件存储的是协议文本,它的体积要比二进制格式的”.rdb”文件大很多。AOF需要通过执行AOF文件中的命令来恢复数据库,其恢复速度比RDB慢很多。AOF在进行重写时也需要创建子进程,在数据库体积较大时将占用大量资源,会导致服务器的短暂阻塞。AOF解决了数据持久化的实时性,是目前Redis主流的持久化方式。 </p>
<p><mark>RDB-AOF混合持久化模式</mark>是Redis4.0开始引入的,这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时,会像执行BGSAVE命令一样,根据数据库当前的状态生成相应的RDB数据,并将其写入AOF文件中；对于重写之后执行的Redis命令,则以协议文本的方式追加到AOF文件的末尾,即RDB数据之后。 通过使用RDB-AOF混合持久化,用户可以同时获得RDB持久化和AOF持久化的优点,服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作,又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内 </p>
<p><strong>加分回答</strong><br>RDB手动触发分别对应save和bgsave命令： - save 命令会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。 - bgsave命令会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。 除了执行命令手动触发之外,Redis内部还存在自动触发RDB的持久化机制,例如以下场景： 1. 使用save相关配置,如“save m n”。表示m秒内数据集存在n次修改 时,自动触发bgsave。 2. 如果从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件并发送给从节点。 3. 执行debug reload命令重新加载Redis时,也会自动触发save操作。 4. 默认情况下执行shutdown命令时,如果没有开启AOF持久化功能则 自动执行bgsave。 AOF默认不开启,需要修改配置项来启用它： appendonly yes # 启用AOF appendfilename “appendonly.aof” # 设置文件名 AOF以文本协议格式写入命令,如： *3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n 文本协议格式具有如下的优点： 1. 文本协议具有很好的兼容性； 2. 直接采用文本协议格式,可以避免二次处理的开销； 3. 文本协议具有可读性,方便直接修改和处理。 AOF持久化的文件同步机制： 为了提高程序的写入性能,现代操作系统会把针对硬盘的多次写操作优化为一次写操作。 1. 当程序调用write对文件写入时,系统不会直接把书记写入硬盘,而是先将数据写入内存的缓冲区中； 2. 当达到特定的时间周期或缓冲区写满时,系统才会执行flush操作,将缓冲区中的数据冲洗至硬盘中； 这种优化机制虽然提高了性能,但也给程序的写入操作带来了不确定性。 1. 对于AOF这样的持久化功能来说,冲洗机制将直接影响AOF持久化的安全性； 2. 为了消除上述机制的不确定性,Redis向用户提供了appendfsync选项,来控制系统冲洗AOF的频率； 3. Linux的glibc提供了fsync函数,可以将指定文件强制从缓冲区刷到硬盘,上述选项正是基于此函数。</p>
<h2 id="4-如何利用Redis实现一个分布式锁？"><a href="#4-如何利用Redis实现一个分布式锁？" class="headerlink" title="4. 如何利用Redis实现一个分布式锁？"></a>4. 如何利用Redis实现一个分布式锁？</h2><p>得分点： 为什么要实现分布式锁、实现分布式锁的方式 </p>
<p><strong>标准回答</strong></p>
<p><strong>在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境, 而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁</strong>。 </p>
<p>采用Redis实现分布式锁,我们可以在Redis中存一份代表锁的数据,数据格式通常使用字符串即可。 首先加锁的逻辑可以通过<code>setnx key value</code>来实现,但如果客户端忘记解锁,那么这种情况就很有可能造成死锁,但如果直接给锁增加过期时间即新增<code>expire key seconds</code>又会发生其他问题,即这两个命令并不是原子性的,那么如果第二步失败,依然无法避免死锁问题。考虑到如上问题,我们最终可以通过<code>set...nx...</code>命令,将加锁、过期命令编排到一起,把他们变成原子操作,这样就可以避免死锁。写法为<code>set key value nx ex seconds</code> 。 解锁就是将代表锁的那份数据删除,但不能用简单的<code>del key</code>,因为会出现一些问题。比如此时有进程A,如果进程A在任务没有执行完毕时,锁被到期释放了。这种情况下进程A在任务完成后依然会尝试释放锁,因为它的代码逻辑规定它在任务结束后释放锁,但是它的锁早已经被释放过了,那这种情况它释放的就可能是其他线程的锁。为解决这种情况,我们可以在加锁时为key赋一个随机值,来充当进程的标识,进程要记住这个标识。当进程解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。另外判断,释放这两步需要保持原子性,否则如果第二步失败,就会造成死锁。而获取和删除命令不是原子的,这就需要采用Lua脚本,通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的。综上所述,优化后的实现分布式锁命令如下： # 加锁 set key random-value nx ex seconds # 解锁 if redis.call(“get”,KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(“del”,KEYS[1]) else return 0 end 加分回答 上述的分布式锁实现方式是建立在单节点之上的,它可能存在一些问题,比如有一种情况,进程A在主节点加锁成功,但主节点宕机了,那么从节点就会晋升为主节点。那如果此时另一个进程B在新的主节点上加锁成功而原主节点重启了,成为了从节点,系统中就会出现两把锁,这违背了锁的唯一性原则。 总之,就是在单个主节点的架构上实现分布式锁,是无法保证高可用的。若要保证分布式锁的高可用,则可以采用多个节点的实现方案。这种方案有很多,而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点,它的基本逻辑如下： - 这些节点相互独立,不存在主从复制或者集群协调机制； - 加锁：以相同的KEY向N个实例加锁,只要超过一半节点成功,则认定加锁成功； - 解锁：向所有的实例发送DEL命令,进行解锁； 我们可以自己实现该算法,也可以直接使用Redisson框架。</p>
<h2 id="5-说说缓存穿透、击穿、雪崩的区别"><a href="#5-说说缓存穿透、击穿、雪崩的区别" class="headerlink" title="5. 说说缓存穿透、击穿、雪崩的区别"></a>5. 说说缓存穿透、击穿、雪崩的区别</h2><p>得分点： 三种问题的发生原因以及解决方式 </p>
<p><strong>标准回答</strong> </p>
<p><mark>缓存穿透</mark>：<strong>是指客户端查询了根本<font color="red">不存在的数据</font>,使得这个请求直达存储层,导致其负载过大甚至造成宕机</strong>。这种情况可能是由于业务层误将缓存和库中的数据删除造成的,当然也不排除有人恶意攻击,专门访问库中不存在的数据导致缓存穿透。 我们可以通过缓存空对象的方式和布隆过滤器两种方式来解决这一问题。<strong>缓存空对象</strong>是指当存储层未命中后,仍然将空值存入缓存层 ,当客户端再次访问数据时,缓存层直接返回空值。还可以将数据存入<strong>布隆过滤器</strong>,访问缓存之前以过滤器拦截,若请求的数据不存在则直接返回空值。 </p>
<p><mark>缓存击穿</mark>：<strong>当一份访问量非常大的<font color="red">热点数据缓存失效的瞬间</font>,大量的请求直达存储层,导致服务崩溃</strong>。 缓存击穿可以通过<strong>热点数据不设置过期时间</strong>来解决,这样就不会出现上述的问题,这是“物理”上的永不过期。或者为每个数据<strong>设置逻辑过期时间</strong>,当发现该数据逻辑过期时,使用单独的线程重建缓存。除了永不过期的方式,我们也可以通过<strong>加互斥锁</strong>的方式来解决缓存击穿,即对数据的访问加互斥锁,当一个线程访问该数据时,其他线程只能等待。这个线程访问过后,缓存中的数据将被重建,届时其他线程就可以直接从缓存中取值。 </p>
<p><mark>缓存雪崩</mark>：<strong>是指当某一时刻<font color="red">缓存层无法继续提供服务</font>,导致所有的请求直达存储层,造成数据库宕机</strong>。可能是缓存中有大量数据同时过期,也可能是Redis节点发生故障,导致大量请求无法得到处理。 缓存雪崩的解决方式有三种；<strong>第一种</strong>是在设置过期时间时,附加一个随机数,避免大量的key同时过期。<strong>第二种</strong>是启用降级和熔断措施,即发生雪崩时,若应用访问的不是核心数据,则直接返回预定义信息&#x2F;空值&#x2F;错误信息。或者在发生雪崩时,对于访问缓存接口的请求,客户端并不会把请求发给Redis,而是直接返回。<strong>第三种</strong>是构建高可用的Redis服务,也就是采用哨兵或集群模式,部署多个Redis实例,这样即使个别节点宕机,依然可以保持服务的整体可用。</p>
<h2 id="6-Redis如何与数据库保持双写一致性"><a href="#6-Redis如何与数据库保持双写一致性" class="headerlink" title="6. Redis如何与数据库保持双写一致性"></a>6. Redis如何与数据库保持双写一致性</h2><p>得分点: 四种同步策略及其可能出现的问题,重试机制 </p>
<p><strong>标准回答 :</strong> </p>
<p>保证缓存和数据库的双写一致性,共有四种同步策略,即<strong>先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再删除缓存</strong>。 <strong>先更新缓存的优点</strong>是每次数据变化时都能及时地更新缓存,这样不容易出现查询未命中的情况,但这种操作的消耗很大,如果数据需要经过复杂的计算再写入缓存的话,频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景,可能会导致频繁的更新缓存却没有业务来读取该数据。 <strong>删除缓存的优点</strong>是操作简单,无论更新的操作复杂与否,都是直接删除缓存中的数据。这种做法的缺点则是,当删除了缓存之后,下一次查询容易出现未命中的情况,那么这时就需要再次读取数据库。 那么对比而言,<strong>删除缓存无疑是更好的选择</strong>。 那么我们再来看一下先操作数据库和后操作数据库的区别；先删除缓存再操作数据库的话,如果第二步骤失败可能导致缓存和数据库得到相同的旧数据。先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致。出现上述问题的时候,我们一般采用重试机制解决,而为了避免重试机制影响主要业务的执行,一般建议重试机制采用异步的方式执行。当我们采用重试机制之后由于存在并发,先删除缓存依然可能存在缓存中存储了旧的数据,而数据库中存储了新的数据,二者数据不一致的情况。 所以我们得到结论：<strong>先更新数据库、再删除缓存是影响更小的方案</strong>。如果第二步出现失败的情况,则可以采用重试机制解决问题。</p>
<h2 id="7-请你说说Redis数据类型中的zset-它和set有什么区别？底层是怎么实现的？"><a href="#7-请你说说Redis数据类型中的zset-它和set有什么区别？底层是怎么实现的？" class="headerlink" title="7. 请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？"></a>7. 请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？</h2><p>得分点: 有序无序、底层结构 </p>
<p><strong>标准回答</strong> </p>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数, Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数 ( score ) 却可以重复。</p>
<p>集合是通过哈希表实现的,所以添加,删除,查找的复杂度都是 O(1)。集合中最大的成员数为 232 – 1 ( 4294967295 ) , 每个集合可存储 40 多亿个成员。 </p>
<p>zset底层的存储结构包括ziplist或skiplist,在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist,其他时候使用skiplist。 当ziplist作为zset的底层存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值。 当skiplist作为zset的底层存储结构的时候,使用skiplist按序保存元素及分值,使用dict来保存元素和分值的映射关系。 </p>
<p><strong>加分回答</strong> </p>
<p>实际上单独使用Hashmap或skiplist也可以实现有序集合,Redis使用两种数据结构组合的原因是如果我们单独使用Hashmap,虽然能以O</p>
<p>(1) 的时间复杂度查找成员的分值,但是因为Hashmap是以无序的方式来保存集合元素,所以每次进行范围操作的时候都要进行排序；而如果单独使用skiplist,虽然能执行范围操作,但查找操作的复杂度却由 O(1)变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。</p>
<h2 id="8-说说Redis的单线程架构"><a href="#8-说说Redis的单线程架构" class="headerlink" title="8. 说说Redis的单线程架构"></a>8. 说说Redis的单线程架构</h2><p>得分点:  单线程的前提,单线程的优劣,简单的io模型 </p>
<p><strong>标准回答</strong> </p>
<p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行。单线程可以简化数据结构和算法的实现,并且可以避免线程切换和竞争造成的消耗。但要注意如果某个命令执行时间过长,会造成其他命令的阻塞。Redis采用了io多路复用机制,这带给了Redis并发处理大量客户端请求的能力。 </p>
<p>Redis单线程实现为什么这么快呢？因为对服务端程序来说,线程切换和锁通常是性能杀手,而单线程避免了线程切换和竞争所产生的消耗。另外Redis的大部分操作是在内存上完成的,这是它实现高性能的一个重要原因；Redis还采用了IO多路复用机制,使其在网络IO操作中能并发处理大量的客户端请求,实现高吞吐率。 </p>
<p><strong>加分回答</strong> </p>
<p>Redis的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能,如持久化、异步删除、集群数据同步等,则是依赖其他线程来执行的。所以,说Redis是单线程的只是一种习惯的说法,事实上它的底层不是单线程的。</p>
<h2 id="9-如何实现Redis高可用"><a href="#9-如何实现Redis高可用" class="headerlink" title="9. 如何实现Redis高可用"></a>9. 如何实现Redis高可用</h2><p>得分点： 哨兵模式、集群模式 </p>
<p><strong>标准回答</strong> </p>
<p>主要有哨兵和集群两种方式可以实现Redis高可用。</p>
<p> <strong>哨兵</strong>： 哨兵模式是Redis的高可用的解决方案,它由一个或多个Sentinel实例组成Sentinel系统,可以监视任意多个主服务器以及这些主服务器属下的所有从服务器。当哨兵节点发现有节点不可达时,会对该节点做下线标识。如果是主节点下线,它还会和其他Sentinel节点进行“协商”,当大多数Sentinel节点都认为主节点不可达时,它们会选举出一个Sentinel节点来完成自动故障转移的工作,同时会将这个变化实时通知给Redis应用方。 哨兵节点包含如下的特征：</p>
<ol>
<li><p>哨兵节点会定期监控数据节点,其他哨兵节点是否可达；</p>
</li>
<li><p>哨兵节点会将故障转移的结果通知给应用方；</p>
</li>
<li><p>哨兵节点可以将从节点晋升为主节点,并维护后续正确的主从关系；</p>
</li>
<li><p>哨兵模式下,客户端连接的是哨兵节点集合,从中获取主节点信息；</p>
</li>
<li><p>节点的故障判断是由多个哨兵节点共同完成的,可有效地防止误判；</p>
</li>
<li><p>哨兵节点集合是由多个哨兵节点组成的,即使个别哨兵节点不可用,整个集合依然是健壮的；</p>
</li>
<li><p>哨兵节点也是独立的Redis节点,是特殊的Redis节点,它们不存储数据,只支持部分命令。</p>
</li>
</ol>
<p><strong>集群：</strong> Redis集群采用虚拟槽分区来实现数据分片,它把所有的键根据哈希函数映射到<code>0-16383</code>整数槽内,计算公式为<code>slot=CRC16(key)&amp;16383</code>,每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：。</p>
<ol>
<li><p>解耦数据和节点之间的关系,简化了节点扩容和收缩的难度；</p>
</li>
<li><p>节点自身维护槽的映射关系,不需要客户端或者代理服务维护槽分区元数据；</p>
</li>
<li><p>支持节点、槽、键之间的映射查询,用于数据路由,在线伸缩等场景。</p>
</li>
</ol>
<h3 id="哨兵的作用和原理"><a href="#哨兵的作用和原理" class="headerlink" title="哨兵的作用和原理"></a>哨兵的作用和原理</h3><p><img src="https://img-blog.csdnimg.cn/2b52c12b7a1b4d368a2b605873b82930.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/d06a5ac4f10e4b1496d454ebc1f57250.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/b76d7ce8f8314194a996d3d6f680cc6e.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/b42e0e3f92ad46efb231bcb628532d55.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/adbee544452f4d6badc1b7790bb4b2ae.png" alt="img"></p>
<h2 id="10-说说Redis的主从同步机制"><a href="#10-说说Redis的主从同步机制" class="headerlink" title="10. 说说Redis的主从同步机制"></a>10. 说说Redis的主从同步机制</h2><p>得分点 ： psync,全量复制、部分复制 </p>
<p><strong>标准回答</strong> </p>
<p><strong>Redis主从同步</strong>是指任意数量的从节点（slave node）都可以从主节点上（master node）同步数据。而除了多个 slave 可以连接到同一个 master 之外,slave 还可以接受其他 slave 的连接,这就形成一个树形结构,使得Redis可执行单层树复制。 从2.8版本开始,当启动一个 slave node 的时候,它会发送一个 <code>PSYNC</code> 命令给 master node。如果slave node 是第一次连接到 master node,那么会触发一次<strong>全量复制</strong>。此时 master 会启动一个后台线程,开始生成一份 <code>RDB</code> 快照文件,同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后, master 会将这个 <code>RDB</code> 发送给 slave,slave 会先写入本地磁盘,然后再从本地磁盘加载到内存中,接着 master 会将内存中缓存的写命令发送到 slave,slave 也会同步这些数据。slave node 如果跟 master node 有网络故障,断开了连接,会自动重连,连接之后 master node 仅会复制给 slave 部分缺少的数据。</p>
<p><strong>开启主从关系</strong><br>要配置主从可以使用replicaof 或者slaveof（5.0以前）命令。有临时和永久两种模式：</p>
<ul>
<li><p>修改配置文件（永久生效）</p>
<ul>
<li>在redis.conf中添加一行配置：<strong>slaveof <masterip> <masterport></masterport></masterip></strong></li>
</ul>
</li>
<li><p>使用redis-cli客户端连接到redis服务，执行slaveof命令（重启后失效）：</p>
<ul>
<li><strong>slaveof <masterip> <masterport></masterport></masterip></strong></li>
</ul>
</li>
</ul>
<p><img src="/../../../images/image-20230216211538641.png" alt="image-20230216211538641"></p>
<h3 id="数据同步原理"><a href="#数据同步原理" class="headerlink" title="数据同步原理"></a>数据同步原理</h3><p><img src="https://img-blog.csdnimg.cn/566d2c905de44bd3a908d3ef2a221eb3.png" alt="img"></p>
<p> <img src="https://img-blog.csdnimg.cn/e07861738258498a80882dd99d5f65e6.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/c519a72fdc2140268b2b18c3e82df57e.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/32c36304a2ce450eaa3ecee4e3203ccd.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/5cb9aa1893bb409c8a65259d8dd094da.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/435c034f44794a3fbc0d6f15efe1e77c.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/1d1d8ba89683446eb5d4053a7f3c0eca.png" alt="img"> </p>
<p> <img src="https://img-blog.csdnimg.cn/4e540323ef0443eb915595fe8d975817.png" alt="img"></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/QRLYLETITBE/article/details/126649510?spm=1001.2014.3001.5501">(9条消息) （分布式缓存）Redis主从_其然乐衣的博客-CSDN博客</a></p>
<h2 id="11-说说Redis的缓存淘汰策略-Redis的回收策略"><a href="#11-说说Redis的缓存淘汰策略-Redis的回收策略" class="headerlink" title="11. 说说Redis的缓存淘汰策略(Redis的回收策略)"></a>11. 说说Redis的缓存淘汰策略(Redis的回收策略)</h2><p>得分点 : 惰性删除、定期删除,maxmemory-policy </p>
<p><strong>标准回答</strong> </p>
<p>Redis有如下两种过期策略： </p>
<p><strong>惰性删除：</strong>客户端访问一个key的时候,Redis会先检查它的过期时间,如果发现过期就立刻删除这个key。 </p>
<p><strong>定期删除：</strong>Redis会将设置了过期时间的key放到一个独立的字典中,并对该字典进行每秒10次的过期扫描, 过期扫描不会遍历字典中所有的key,而是采用了一种简单的贪心策略。该策略的删除逻辑如下： 1. 从过期字典中随机选择20个key； 2. 删除这20个key中已过期的key； 3. 如果已过期key的比例超过25%,则重复步骤1。 当写入数据将导致超出maxmemory限制时,Redis会采用maxmemory-policy所指定的策略进行数据淘汰,该策略一共包含8种选项,其中除了noeviction直接返回错误之外,筛选键的方式分为volatile和allkeys两种,volatile前缀代表从设置了过期时间的键中淘汰数据,allkeys前缀代表从所有的键中淘汰数据关于后缀,ttl代表选择过期时间最小的键,random代表随机选择键,需要我们额外关注的是lru和lfu后缀,它们分别代表采用lru算法和lfu算法来淘汰数据。因为allkeys是筛选所有的键,所以不存在ttl,余下三个后缀二者都有,lfu算法是再Redis4版本才提出来的。 </p>
<p><strong>加分回答</strong> </p>
<p><strong>LRU</strong>（Least Recently Used）是按照最近最少使用原则来筛选数据,即最不常用的数据会被筛选出来 - 标准LRU：把所有的数据组成一个链表,表头和表尾分别表示MRU和LRU端,即最常使用端和最少使用端。刚被访问的数据会被移动到MRU端,而新增的数据也是刚被访问的数据,也会被移动到MRU端。当链表的空间被占满时,它会删除LRU端的数据。 - 近似LRU：Redis会记录每个数据的最近一次访问的时间戳（LRU）。Redis执行写入操作时,若发现内存超出maxmemory,就会执行一次近似LRU淘汰算法。近似LRU会随机采样N个key,然后淘汰掉最旧的key,若淘汰后内存依然超出限制,则继续采样淘汰。可以通过maxmemory_samples配置项,设置近似LRU每次采样的数据个数,该配置项的默认值为5。 LRU算法的不足之处在于,若一个key很少被访问,只是刚刚偶尔被访问了一次,则它就被认为是热点数据,短时间内不会被淘汰。 <strong>LFU</strong>算法正式用于解决上述问题,LFU（Least Frequently Used）是Redis4新增的淘汰策略,它根据key的最近访问频率进行淘汰。LFU在LRU的基础上,为每个数据增加了一个计数器,来统计这个数据的访问次数。当使用LFU策略淘汰数据时,首先会根据数据的访问次数进行筛选,把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同,LFU再比较这两个数据的访问时间,把访问时间更早的数据淘汰出内存。</p>
<h3 id="Redis的回收策略"><a href="#Redis的回收策略" class="headerlink" title="Redis的回收策略"></a><strong>Redis的回收策略</strong></h3><blockquote>
<p>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰<br>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰<br>no-enviction（驱逐）：禁止驱逐数据<br>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。<br>使用策略规则：<br>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru<br>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p>
</blockquote>
<h2 id="12-使用Redis有哪些好处？"><a href="#12-使用Redis有哪些好处？" class="headerlink" title="12. 使用Redis有哪些好处？"></a>12. 使用Redis有哪些好处？</h2><p>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>(2) 支持丰富数据类型，支持string，list，set，zset，hash<br>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行<br>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</p>
<h2 id="13-Redis的缺点"><a href="#13-Redis的缺点" class="headerlink" title="13. Redis的缺点"></a>13. Redis的缺点</h2><ol>
<li>不保证数据的可靠性,数据有可能在宕机情况会丢失少部分数据.不能保持数据库和缓存的一致性,如果需要保持一致性,需要付出一定性能代价(加锁串行)</li>
<li>单线程操作，无法利用多核CPU的优势</li>
<li>如果进行完整重同步，由于需要生成rdb文件，并进行传输，会占用主机的CPU，并会消耗现网的带宽。不过redis2.8版本以后，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的从库。</li>
</ol>
<h2 id="14-Redis相比memcached有哪些优势？"><a href="#14-Redis相比memcached有哪些优势？" class="headerlink" title="14. Redis相比memcached有哪些优势？"></a>14. Redis相比memcached有哪些优势？</h2><p>(1) memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型<br>(2) redis的速度比memcached快很多<br>(3) redis可以持久化其数据<br>(4) redis支持数据的备份，即master-slave模式的数据备份。<br>(5) 使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。<br>(6）value大小：redis最大可以达到1GB，而memcache只有1MB</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/14/interview/redis/Redis/" data-id="cleebxr6000a3xwv6dzttdmh3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Redis/" rel="tag">Redis</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" rel="tag">中间件</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/waitingSee" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/14/interview/waitingSee/" class="article-date">
  <time class="post-time" datetime="2022-11-14T08:09:57.938Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">14</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>八股文</p>
<p>netty</p>
<p>io</p>
<p>设计模式</p>
<table>
<thead>
<tr>
<th>ID</th>
<th>标题</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>设计模式面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125721772039">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>2</td>
<td>Java基础知识面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059738631">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>3</td>
<td>Java集合面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125939843079">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>4</td>
<td>JavaIO、BIO、NIO、AIO、Netty面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125700784136">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>5</td>
<td>Java并发编程面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125755293710">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>6</td>
<td>Java异常面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904128959741965">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>7</td>
<td>Java虚拟机（JVM）面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125696573448">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>8</td>
<td>Spring面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127051513864">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>9</td>
<td>Spring MVC面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059722253">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>10</td>
<td>Spring Boot面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125709156359">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>11</td>
<td>Spring Cloud面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125717544973">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>12</td>
<td>Redis面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127055527950">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>13</td>
<td>MyBatis面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125935648776">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>14</td>
<td>MySQL面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127047139335">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>15</td>
<td>TCP、UDP、Socket、HTTP面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125692379143">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>16</td>
<td>Nginx面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125784653837">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>17</td>
<td>ElasticSearch面试题</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>kafka面试题</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>RabbitMQ面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125935665160">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>20</td>
<td>Dubbo面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127076499463">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>21</td>
<td>ZooKeeper面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127076499464">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>22</td>
<td>Netty面试题（总结最全面的面试题）</td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>Tomcat面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059722247">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>24</td>
<td>Linux面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059738637">juejin.cn&#x2F;post&#x2F;684490…</a></td>
</tr>
<tr>
<td>25</td>
<td>互联网相关面试题（总结最全面的面试题）</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>互联网安全面试题（总结最全面的面试题）</td>
<td></td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/14/interview/waitingSee/" data-id="cleebxr3g002txwv67apy7mp6" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/jvm零碎笔记" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="post-time" datetime="2022-11-12T13:04:00.571Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/">1. 零碎笔记</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/.com//Typora\RunningYuBlog\source\images\image-20221112210028078.png" alt="image-20221112210028078"></p>
<p><img src="/.com//Typora\RunningYuBlog\source\images\image-20221112210242978.png" alt="image-20221112210242978"></p>
<p><img src="/.com//Typora\RunningYuBlog\source\images\image-20221112210338812.png" alt="image-20221112210338812"></p>
<p><img src="/../../../images/image-20221112212347371.png" alt="image-20221112212347371"></p>
<p>Java虚拟机不只是适用于java语言，也适用于其它语言，只要其它语言通过编译器生成的字节码文件遵循java虚拟机的规则，java虚拟机就可以运行</p>
<p><img src="/../../../images/image-20221112212742280.png" alt="image-20221112212742280"></p>
<p><strong>虚拟机</strong></p>
<p>所谓虚拟机（Virtual Machine），就是一台虚拟的计算机。它是一款软件，用来执行一系列虚拟计算机指令。大体上，虚拟机可以分为<strong>系统虚拟机</strong>和<strong>程序虚拟机</strong>。</p>
<ul>
<li>大名鼎鼎的 Visual Box，Mware 就属于系统虚拟机，它们<mark>完全是对物理计算机的仿真</mark>，提供了一个可运行完整操作系统的软件平台。</li>
<li>程序虚拟机的典型代表就是 Java 虚拟机，它<mark>专门为执行单个计算机程序而设计</mark>，在 Java 虚拟机中执行的指令我们称为 Java 字节码指令。</li>
</ul>
<p>无论是系统虚拟机还是程序虚拟机，在上面运行的软件都被限制于虚拟机提供的资源中。</p>
<p><strong>Java 虚拟机</strong></p>
<ul>
<li>Java 虚拟机是一台执行 Java 字节码的虚拟计算机，它拥有独立的运行机制，其运行的 Java 字节码也未必由 Java 语言编译而成。</li>
<li>JVM 平台的各种语言可以共享 Java 虚拟机带来的跨平台性、优秀的垃圾回器，以及可靠的即时编译器。</li>
<li><mark>Java 技术的核心就是 Java 虚拟机</mark>（JVM，Java Virtual Machine），因为所有的 Java 程序都运行在 Java 虚拟机内部。</li>
</ul>
<p>作用</p>
<ul>
<li>Java 虚拟机就是二进制字节码的运行环境，负责装载字节码到其内部，解释&#x2F;编译为对应平台上的机器指令执行。每一条 Java 指令，Java 虚拟机规范中都有详细定义，如怎么取操作数，怎么处理操作数，处理结果放在哪里。</li>
</ul>
<p>特点</p>
<ul>
<li>一次编译，到处运行</li>
<li>自动内存管理</li>
<li>自动垃圾回收功能</li>
</ul>
<hr>
<p><strong>编译器前端</strong>（将源文件编译生成字节码文件），<strong>编译器后端</strong>（将字节码指令编译成机器指令）</p>
<p>因为机器指令是反复执行的<strong>热点代码</strong>，所以缓存起来，下次可以直接调用</p>
<hr>
<p><img src="/../../../images/image-20221112225810473.png" alt="image-20221112225810473"></p>
<p>栈式架构采用的是8位作为一个基本单位的，所以栈的指令集更小，但是指令数多</p>
<p>寄存器架构采用的是16位的双字节的进行设计的，所以指令集大，但指令数更少</p>
<p>比如：</p>
<p><img src="/../../../images/image-20221112225721970.png" alt="image-20221112225721970"></p>
<p><strong>总结</strong></p>
<p><mark>由于跨平台性的设计，Java 的指令都是根据栈来设计的。</mark>不同平台 CPU 架构不同，所以不能设计为基于寄存器的。</p>
<p>优点：是跨平台，指令集小，编译器容易实现。</p>
<p>缺点：是性能下降，实现同样的功能需要更多的指令。</p>
<p>栈：</p>
<p>跨平台、指令集小、指令多，执行性能比寄存器差</p>
<hr>
<h1 id="虚拟机的生命周期"><a href="#虚拟机的生命周期" class="headerlink" title="虚拟机的生命周期"></a>虚拟机的生命周期</h1><h2 id="虚拟机的启动"><a href="#虚拟机的启动" class="headerlink" title="虚拟机的启动"></a><strong>虚拟机的启动</strong></h2><p>Java 虚拟机的启动是通过引导类加载器（bootstrap class loader）创建一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。</p>
<p><img src="/../../../images/image-20221113093105220.png" alt="image-20221113093105220"></p>
<p>像上面我们自定义的类，是由系统类加载器来加载的</p>
<p>但（如果）没有明确指定的父类，它的父类就是Object，Object作为核心api，由引导类加载器（bootstrap class loader）加载的</p>
<p>我们要启动一个类，而父类是要早于子类先加载的，但是父类还没加载而它的子类要用，所以我们就需要先启动Java虚拟机</p>
<h2 id="虚拟机的执行"><a href="#虚拟机的执行" class="headerlink" title="虚拟机的执行"></a><strong>虚拟机的执行</strong></h2><ul>
<li><p>一个运行中的 Java 虚拟机有着一个清晰的任务：执行 Java 程序。</p>
</li>
<li><p>程序开始执行时他才运行，程序结束时他就停止。</p>
</li>
<li><p><mark>执行一个所谓的 Java 程序的时候，真真正正在执行的是一个叫做 Java 虚拟机的进程。</mark></p>
</li>
</ul>
<h2 id="虚拟机的退出"><a href="#虚拟机的退出" class="headerlink" title="虚拟机的退出"></a><strong>虚拟机的退出</strong></h2><p>有如下的几种情况：</p>
<ul>
<li>程序正常执行结束</li>
<li>程序在执行过程中遇到了异常或错误而异常终止</li>
<li>由于操作系统用现错误而导致 Java 虚拟机进程终止</li>
<li>某线程调用 Runtime 类或 system 类的 exit 方法，或 Runtime 类的 halt 方法，并且 Java 安全管理器也允许这次 exit 或 halt 操作。</li>
<li>除此之外，JNI（Java Native Interface）规范描述了用 JNI Invocation API 来加载或卸载 Java 虚拟机时，Java 虚拟机的退出情况。</li>
</ul>
<hr>
<p><img src="/../../../images/image-20221113101445106.png" alt="image-20221113101445106"></p>
<p><img src="/../../../images/image-20221113101718312.png" alt="image-20221113101718312"></p>
<hr>
<h3 id="HotSpot-VM"><a href="#HotSpot-VM" class="headerlink" title="HotSpot VM"></a>HotSpot VM</h3><ul>
<li>HotSpot 历史<ul>
<li>最初由一家名为“Longview Technologies”的小公司设计</li>
<li>1997 年，此公司被 sun 收购；2009 年，Sun 公司被甲骨文收购。</li>
<li>JDK1.3 时，HotSpot VM 成为默认虚拟机</li>
</ul>
</li>
<li><mark>目前 Hotspot 占有绝对的市场地位，称霸武林。</mark><ul>
<li>不管是现在仍在广泛使用的 JDK6，还是使用比例较多的 JDK8 中，默认的虚拟机都是 HotSpot</li>
<li>Sun &#x2F; Oracle JDK 和 OpenJDK 的默认虚拟机</li>
<li>因此本课程中默认介绍的虚拟机都是 HotSpot，相关机制也主要是指 HotSpot 的 Gc 机制。（比如其他两个商用虚机都没有方法区的概念）</li>
</ul>
</li>
<li>从服务器、桌面到移动端、嵌入式都有应用。</li>
<li>名称中的 HotSpot 指的就是它的<strong>热点代码探测技术</strong>。<ul>
<li>通过计数器找到最具编译价值代码，触发即时编译或栈上替换</li>
<li>通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡</li>
</ul>
</li>
</ul>
<h3 id="JRockit"><a href="#JRockit" class="headerlink" title="JRockit"></a>JRockit</h3><ul>
<li><p><mark>专注于服务器端应用</mark></p>
<ul>
<li>它可以不太关注程序启动速度，因此 JRockit 内部不包含解析器实现，全部代码都靠即时编译器编译后执行。</li>
</ul>
</li>
<li><p>大量的行业基准测试显示，<mark>JRockit JVM 是世界上最快的 JVM。</mark></p>
<ul>
<li>使用 JRockit 产品，客户已经体验到了显著的性能提高（一些超过了 70%）和硬件成本的减少（达 50%）。</li>
</ul>
</li>
<li><p>优势：全面的 Java 运行时解决方案组合</p>
<ul>
<li>JRockit 面向延迟敏感型应用的解决方案 JRockit Real Time 提供以毫秒或微秒级的 JVM 响应时间，适合财务、军事指挥、电信网络的需要</li>
<li>MissionControl 服务套件，它是一组以极低的开销来监控、管理和分析生产环境中的应用程序的工具。</li>
</ul>
</li>
<li><p>2008 年，JRockit 被 oracle 收购。</p>
</li>
<li><p>Oracle 表达了整合两大优秀虚拟机的工作，大致在 JDK8 中完成。整合的方式是在 HotSpot 的基础上，移植 JRockit 的优秀特性。</p>
</li>
<li><p>高斯林：目前就职于谷歌，研究人工智能和水下机器人</p>
</li>
</ul>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="IBM-的-J9"><a href="#IBM-的-J9" class="headerlink" title="IBM 的 J9"></a>IBM 的 J9</h3><ul>
<li>全称：IBM Technology for Java Virtual Machine，简称 IT4J，内部代号：J9</li>
<li>市场定位与 HotSpot 接近，服务器端、桌面应用、嵌入式等多用途 VM</li>
<li>广泛用于 IBM 的各种 Java 产品（一般用于自己的产品）。</li>
<li>目前，有影响力的三大商用虚拟机之一，也号称是世界上最快的 Java 虚拟机（但J9只是在自己的产品上使用时比较快，而通用性的话，还是JRockit好点）。</li>
<li>2017 年左右，IBM 发布了开源 J9VM，命名为 openJ9，交给 EClipse 基金会管理，也称为 Eclipse OpenJ9</li>
</ul>
<h3 id="…"><a href="#…" class="headerlink" title="…."></a>….</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​		具体 JVM 的内存结构，其实取决于其实现，不同厂商的 JVM，或者同一厂商发布的不同版本，都有可能存在一定差异。主要以 Oracle HotSpot VM 为默认虚拟机。</p>
<hr>
<h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2. 类加载子系统"></a>2. 类加载子系统</h1><p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<p><strong>类加载器子系统：</strong>获取字节码文件的信息（常量信息，变量信息，方法，指令等），然后有组织第分配到内存当中（<strong>运行时数据区</strong>）</p>
<p><strong>执行引擎:</strong>  需要去解释这些指令</p>
<hr>
<p>如果不是一个合法的字节码文件，就会在加载的过程中抛出异常。如果有些恶意攻击的话，就会对这个字节码文件进行修改，就不合法了</p>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul>
<li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态代码块中的语句</strong>合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li>
<li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</li>
</ul>
<p><img src="/../../../images/image-20221114203139057.png" alt="image-20221114203139057"></p>
<p>当要只能main方法时，先把这个ClinitTest1类加载到内存当中（当然在加载这个类之前先把它的父类加载），加载完后，调用main静态方法，里面要加载Son这个类，要把Son这个类加载进来，但在加载Son类之前要先加载Son的父类Father，加载完父类后，在加载Son的时候，在初始化这个环节，把A的值赋过来，这时A已经等于2，所以main中打印出来的结果就是2</p>
<p><strong>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被同步加锁。</strong></p>
<p>线程2进来了，但是线程2出不来，它还在初始化这个DeadThread类，线程1也进不去，因为线程正在处于一个加锁的状态</p>
<p><img src="/../../../images/image-20221114213537778.png" alt="image-20221114213537778"></p>
<p><img src="/../../../images/image-20221114210548293.png" alt="image-20221114210548293"></p>
<p>static代码块只执行一次原因：</p>
<p>​		static代码块只在类加载时执行，类是用类加载器来读取的，类加载器是带有一个缓存区的，它会把读取到的类缓存起来，所以在一次虚拟机运行期间，一个类只会被加载一次，这样的话静态代码块只会运行一次</p>
<hr>
<h1 id="2-3-1-虚拟机自带的加载器"><a href="#2-3-1-虚拟机自带的加载器" class="headerlink" title="2.3.1. 虚拟机自带的加载器"></a>2.3.1. 虚拟机自带的加载器</h1><p><strong>启动类加载器（引导类加载器，Boostrap ClassLoader）</strong>,我们获取不到，它是由C&#x2F;C++语言编写的</p>
<p><strong>扩展类加载器（Extension ClassLoader）</strong>和 <strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong>都是由java语言编写的</p>
<p>还要记住什么样的类加载器加载什么样的类文件</p>
<hr>
<p> <strong>为什么要自定义类加载器？</strong></p>
<ul>
<li>隔离加载类 (避免类的冲突)<ul>
<li>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</li>
</ul>
</li>
<li>修改类加载的方式 （可以实现动态的加载）<ul>
<li>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行<strong>动态加载</strong>。</li>
</ul>
</li>
<li>扩展加载源<ul>
<li>比如从数据库、网络、甚至是电视机机顶盒进行加载。</li>
</ul>
</li>
<li>防止源码泄漏<ul>
<li>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>获取 ClassLoader 的途径</strong></p>
<ul>
<li><p>方式一：获取当前 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式二：获取当前线程上下文的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式三：获取系统的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></table></figure>
</li>
<li><p>方式四：获取调用者的 ClassLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="-1"><a href="#-1" class="headerlink" title></a></h2><h1 id="2-5-双亲委派机制"><a href="#2-5-双亲委派机制" class="headerlink" title="2.5. 双亲委派机制"></a>2.5. 双亲委派机制</h1><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a><strong>工作原理</strong></h2><ul>
<li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>3）<strong>如果父类加载器可以完成类加载任务，就成功返回</strong>（就不会由子类加载器去加载了），倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p>
<p>举例：</p>
<p>1. </p>
<p><img src="/../../../images/image-20221115204949307.png" alt="image-20221115204949307"></p>
<p>出于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类。一看你是java开头的，引导类加载就说了。这是归我管我来加载String（核心API里的String）。因此有父类来加载后，就不会再向下委托了，所以我们new 的这个String对象就是核心API里面的String类对象，而不是我们自定义的String，因此就没有打印出自定义String里的static静态资源里的语句</p>
<p>2. </p>
<p><img src="/../../../images/image-20221115205956137.png" alt="image-20221115205956137"></p>
<p>委托到引导类加载器，它发现你这个包是jvm开头的，不归引导类加载管，就向下委托，也不归扩展类加载器管，所以最后回到系统类加载器来加载，因此最后输出结果就是系统类加载来进行的加载</p>
<p>3. </p>
<p><img src="/../../../images/image-20221115210219781.png" alt="image-20221115210219781"></p>
<p>一直往上委托，就交给到了引导类加载器，它加载了String类以后，然后就想去执行main方法，但是核心API的String里面是没有main方法的，所以就报了 <mark>错误: 在类 java.lang.String 中找不到 main 方法</mark>. 可知，根本就没有试着想去加载我们自定义的String类，完全忽略掉你了</p>
<p>4. </p>
<p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p>
<h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a><strong>优势</strong></h2><ul>
<li><strong>避免类的重复加载</strong></li>
<li><strong>保护程序安全，防止核心 API 被随意篡改</strong><ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li>
</ul>
</li>
</ul>
<p><img src="/../../../images/image-20221115212723174.png" alt="image-20221115212723174"></p>
<p>引导类加载器看到是 java.lang开头的，就表示这是归它管，于是就要去加载这个ShkStart类了，但直接直接给它报错了，相当于，要加载java.lang这个包，要想访问是要有权限的，现在报错就是阻止我们去直接用这个java.lang包来自定义这个ShkStart类。其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个类，加载成功的话，就会导致对引导类加载器本身造成影响，所以这里是直接把引导类加载器给整挂了。所以我们也禁止去用java.lang这样的包名去命名</p>
<p>其实这也是起到了保护作用和出于安全的考虑，如果允许去加载这个种自定义的类，加载成功的话，但里面可能会有一些<strong>恶意代码</strong>，就可能会会对现有的项目和程序进行破坏</p>
<h2 id="沙箱安全机制"><a href="#沙箱安全机制" class="headerlink" title="沙箱安全机制"></a><strong>沙箱安全机制</strong></h2><p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<hr>
<h2 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6. 其他"></a>2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p>
<p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li>
</ul>
<p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/12/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/jvm%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/" data-id="cleebxr4w0071xwv6dhmmc4sj" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-SpringSecurity/UserDetailsServiceImpl" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/12/SpringSecurity/UserDetailsServiceImpl/" class="article-date">
  <time class="post-time" datetime="2022-11-12T10:24:46.189Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/12/SpringSecurity/UserDetailsServiceImpl/">自定义UserDetailsServiceImpl</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/SpringSecurity/">SpringSecurity</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。</p>
<p>如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</p>
<h3 id="UserDetailsServiceImpl"><a href="#UserDetailsServiceImpl" class="headerlink" title="UserDetailsServiceImpl"></a>UserDetailsServiceImpl</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.aclservice.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.entity.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.service.PermissionService;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.aclservice.service.UserService;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.SecurityUser;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.BeanUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UsernameNotFoundException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以</span></span><br><span class="line"><span class="comment"> * 我们要通过自定义逻辑控制认证逻辑。</span></span><br><span class="line"><span class="comment"> * 如果需要自定义逻辑时，只需要实现UserDetailsService接口即可。接口定义如下：</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDetailsServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PermissionService permissionService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="comment">// 根据用户名查询数据</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.selectByUsername(username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断</span></span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 抛出用户名没有发现异常，系统就知道用户名没有查询到</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UsernameNotFoundException</span>(<span class="string">&quot;用户不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        com.atguigu.security.entity.<span class="type">User</span> <span class="variable">curUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.atguigu.security.entity.User();</span><br><span class="line">        BeanUtils.copyProperties(user, curUser);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据用户查询用户权限列表</span></span><br><span class="line">        List&lt;String&gt; permissionValueList = permissionService.selectPermissionValueByUserId(user.getId());</span><br><span class="line">        <span class="type">SecurityUser</span> <span class="variable">securityUser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityUser</span>();</span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecurityUser</span>();</span><br><span class="line">        securityUser.setPermissionValueList(permissionValueList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> securityUser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="SecurityUser"><a href="#SecurityUser" class="headerlink" title="SecurityUser"></a>SecurityUser</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.security.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.GrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.core.userdetails.UserDetails;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityUser</span> <span class="keyword">implements</span> <span class="title class_">UserDetails</span> &#123;</span><br><span class="line">    <span class="comment">//当前登录用户</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> User currentUserInfo;</span><br><span class="line">    <span class="comment">//当前权限</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; permissionValueList;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SecurityUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.currentUserInfo = user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;? <span class="keyword">extends</span> <span class="title class_">GrantedAuthority</span>&gt; getAuthorities() &#123;</span><br><span class="line">        Collection&lt;GrantedAuthority&gt; authorities = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String permissionValue : permissionValueList) &#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isEmpty(permissionValue)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">SimpleGrantedAuthority</span> <span class="variable">authority</span> <span class="operator">=</span> <span class="keyword">new</span></span><br><span class="line">                    <span class="title class_">SimpleGrantedAuthority</span>(permissionValue);</span><br><span class="line">            authorities.add(authority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> authorities;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPassword</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getPassword();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getUsername</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUserInfo.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAccountNonLocked</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCredentialsNonExpired</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnabled</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>User</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModel;</span><br><span class="line"><span class="keyword">import</span> io.swagger.annotations.ApiModelProperty;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ApiModel(description = &quot;用户实体类&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@ApiModelProperty</span>用于swapper测试的</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;微信openid&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;密码&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;昵称&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户头像&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String salt;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty(value = &quot;用户签名&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/12/SpringSecurity/UserDetailsServiceImpl/" data-id="cleebxr3c002gxwv6ayuy4iof" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringSecurity/" rel="tag">SpringSecurity</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-SpringSecurity/总结分析" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/12/SpringSecurity/%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/" class="article-date">
  <time class="post-time" datetime="2022-11-12T09:40:41.206Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RequestInterceptor  implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    private List&lt;String&gt; patterns = new ArrayList&lt;String&gt;();  //不用过滤的url</span><br><span class="line"></span><br><span class="line">    public void addInterceptor(InterceptorRegistry registry)&#123;</span><br><span class="line"></span><br><span class="line">        //写一个拦截器</span><br><span class="line">        registry.addInterceptor(new HandlerInterceptor() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                //从请求头中获取token</span><br><span class="line">                String token = request.getHeader(&quot;Authorization&quot;);</span><br><span class="line">//                                      从redis中获取token</span><br><span class="line">                if(token != null &amp;&amp; redisTemplate.opsForValue().get(token) != null)&#123;</span><br><span class="line">                    //每次认证后就充值为30天                      时间单位：天</span><br><span class="line">                    redisTemplate.expire(token,30, TimeUnit.DAYS);</span><br><span class="line">                    return true;   //取到就返回true</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //设置响应状态为401</span><br><span class="line">                response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).excludePathPatterns(patterns);  //不用过滤的url</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/12/SpringSecurity/%E6%80%BB%E7%BB%93%E5%88%86%E6%9E%90/" data-id="cleebxr3d002lxwv6bunc8vkh" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-权限认证/JWT 生成Token、解析Token的简单工具类" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/12/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/JWT%20%E7%94%9F%E6%88%90Token%E3%80%81%E8%A7%A3%E6%9E%90Token%E7%9A%84%E7%AE%80%E5%8D%95%E5%B7%A5%E5%85%B7%E7%B1%BB/" class="article-date">
  <time class="post-time" datetime="2022-11-12T08:55:13.197Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/12/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/JWT%20%E7%94%9F%E6%88%90Token%E3%80%81%E8%A7%A3%E6%9E%90Token%E7%9A%84%E7%AE%80%E5%8D%95%E5%B7%A5%E5%85%B7%E7%B1%BB/">JWT 生成Token、解析Token的简单工具类</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/token/">token</a>,<a class="article-category-link" href="/categories/token/JWT/">JWT</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="pom-xml导入依赖："><a href="#pom-xml导入依赖：" class="headerlink" title="pom.xml导入依赖："></a>pom.xml导入依赖：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jjwt&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;<span class="number">0.9</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h1 id="JwtTokenManager工具类"><a href="#JwtTokenManager工具类" class="headerlink" title="JwtTokenManager工具类"></a>JwtTokenManager工具类</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.atguigu.security.entity.User;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.CompressionCodecs;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jwts;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtTokenManager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于签名的私钥</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PRIVATE_KEY</span> <span class="operator">=</span> <span class="string">&quot;516Letitbe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 签发者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ISSUER</span> <span class="operator">=</span> <span class="string">&quot;Letitbe&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间 1 小时</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_ONE_HOUR</span> <span class="operator">=</span> <span class="number">3600L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 过期时间 1 天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">EXPIRATION_ONE_DAY</span> <span class="operator">=</span> <span class="number">3600</span> * <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成Token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user         token存储的 实体类 信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireTime   token的过期时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">createToken</span><span class="params">(User user, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 过期时间</span></span><br><span class="line">        <span class="keyword">if</span> ( expireTime == <span class="number">0</span> ) &#123;</span><br><span class="line">            <span class="comment">// 如果是0，就设置默认 1天 的过期时间</span></span><br><span class="line">            expireTime = EXPIRATION_ONE_DAY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; claims = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 自定义有效载荷部分, 将User实体类用户名和密码存储</span></span><br><span class="line">        claims.put(<span class="string">&quot;id&quot;</span>, user.getId());</span><br><span class="line">        claims.put(<span class="string">&quot;username&quot;</span>, user.getUsername());</span><br><span class="line">        claims.put(<span class="string">&quot;password&quot;</span>, user.getPassword());</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> Jwts.builder()</span><br><span class="line">                <span class="comment">// 发证人</span></span><br><span class="line">                .setIssuer(ISSUER)</span><br><span class="line">                <span class="comment">// 有效载荷</span></span><br><span class="line">                .setClaims(claims)</span><br><span class="line">                <span class="comment">// 设定签发时间</span></span><br><span class="line">                .setIssuedAt(<span class="keyword">new</span> <span class="title class_">Date</span>())</span><br><span class="line">                <span class="comment">// 设置有效时长</span></span><br><span class="line">                .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + expireTime))</span><br><span class="line">                <span class="comment">// 使用HS512算法签名，PRIVATE_KEY为签名密钥</span></span><br><span class="line">                .signWith(SignatureAlgorithm.HS512, PRIVATE_KEY)</span><br><span class="line">                <span class="comment">// compressWith() 压缩方法，当载荷过长时可对其进行压缩</span></span><br><span class="line">                <span class="comment">// 可采用jjwt实现的两种压缩方法CompressionCodecs.GZIP和CompressionCodecs.DEFLATE</span></span><br><span class="line">                .compressWith(CompressionCodecs.GZIP)</span><br><span class="line">                <span class="comment">// 生成JWT</span></span><br><span class="line">                .compact();</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的User实体类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserFromToken</span><span class="params">(String token)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取有效载荷</span></span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> getClaimsFromToken(token);</span><br><span class="line">        <span class="comment">// 解析token后，从有效载荷取出值</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;username&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> (String) claims.get(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">        <span class="comment">// 封装成User实体类</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId( id );</span><br><span class="line">        user.setUsername( username );</span><br><span class="line">        user.setPassword( password );</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取有效载荷</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Claims <span class="title function_">getClaimsFromToken</span><span class="params">(String token)</span>&#123;</span><br><span class="line">        <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            claims = Jwts.parser()</span><br><span class="line">                    <span class="comment">//设定解密私钥</span></span><br><span class="line">                    .setSigningKey(PRIVATE_KEY)</span><br><span class="line">                    <span class="comment">//传入Token</span></span><br><span class="line">                    .parseClaimsJws(token)</span><br><span class="line">                    <span class="comment">//获取载荷类</span></span><br><span class="line">                    .getBody();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> claims;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="测试："><a href="#测试：" class="headerlink" title="测试："></a>测试：</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">czyTokenTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setId(<span class="string">&quot;1arg232t3tg231235&quot;</span>);</span><br><span class="line">        user.setUsername(<span class="string">&quot;其然乐衣&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;2000516&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> jwtTokenManager.createToken(user, <span class="number">0L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;生成的token: &quot;</span>);</span><br><span class="line">        System.out.println(token);</span><br><span class="line">        <span class="type">User</span> <span class="variable">userFromToken</span> <span class="operator">=</span> jwtTokenManager.getUserFromToken(token);</span><br><span class="line">        System.out.println(<span class="string">&quot;userFromToken:&quot;</span>);</span><br><span class="line">        System.out.println(userFromToken);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../../images/image-20221112165845740.png" alt="image-20221112165845740"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/12/%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/JWT%20%E7%94%9F%E6%88%90Token%E3%80%81%E8%A7%A3%E6%9E%90Token%E7%9A%84%E7%AE%80%E5%8D%95%E5%B7%A5%E5%85%B7%E7%B1%BB/" data-id="cleebxr4h005uxwv6c1bz8fz0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/token/" rel="tag">token</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/16/">16</a><a class="extend next" rel="next" href="/page/9/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>152</strong><br>文章</div></a>
      <a href="/categories"><div><strong>83</strong><br>分类</div></a>
      <a href="/tags"><div><strong>55</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>