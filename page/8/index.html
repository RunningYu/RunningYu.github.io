<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/8/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-Quartz/Quartz学习笔记" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="post-time" datetime="2022-11-27T12:50:56.294Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Quartz学习笔记</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">定时任务</a>,<a class="article-category-link" href="/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/">Quartz</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="/../../images/image-20221127205106372.png" alt="image-20221127205106372"></p>
<p><img src="/../../images/image-20221127213810488.png" alt="image-20221127213810488"></p>
<p><img src="/../../images/image-20221128143023074.png" alt="image-20221128143023074"></p>
<p><img src="/../../images/image-20221128130326946.png" alt="image-20221128130326946"></p>
<p><img src="/../../images/image-20221128142414350.png" alt="image-20221128142414350"></p>
<p><img src="/../../images/image-20221128142313901.png" alt="image-20221128142313901"></p>
<p>quartz 总体架构</p>
<p><img src="/../../images/image-20221127223745383.png" alt="image-20221127223745383"></p>
<h2 id="Quartz的使用"><a href="#Quartz的使用" class="headerlink" title="Quartz的使用"></a>Quartz的使用</h2><p>导包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        System.out.println(<span class="string">"MyJob execute:"</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>测试类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果图</p>
<p><img src="/../../images/image-20221127225021946.png" alt="image-20221127225021946"></p>
<hr>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobDataMap;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class MyJop implements Job {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span><br><span class="line">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException {</span><br><span class="line">//        System.out.println("MyJob execute:" + new Date());</span><br><span class="line"></span><br><span class="line">        JobDataMap jobDetailMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">        JobDataMap triggerMap = context.getTrigger().getJobDataMap();</span><br><span class="line">        // 获取 JobDetail 和 Trigger 合并，但如果存在相同的键值key,Trigger的会覆盖JobDetail的</span><br><span class="line">        JobDataMap mergeMap = context.getMergedJobDataMap();</span><br><span class="line"></span><br><span class="line">        System.out.println("jobDetailMap:" + jobDetailMap.getString("job"));</span><br><span class="line">        System.out.println("triggerMap:" + triggerMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("job"));</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println( "name : " + name );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package quartz.quartz;</span><br><span class="line"></span><br><span class="line">import org.quartz.*;</span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class TestJob {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJop.class)</span><br><span class="line">                // name: 任务名称（在调度器里不能重复，唯一的） group : 组</span><br><span class="line">                .withIdentity("jop1", "group1")</span><br><span class="line">                .usingJobData("job", "jobDetail1")</span><br><span class="line">                .usingJobData("name", "jobDetail2")</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 触发器</span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity("trigger1", "trigger1")</span><br><span class="line">                .usingJobData("trigger", "trigger")</span><br><span class="line">                // 会覆盖上面JobDetail中的name的值</span><br><span class="line">                .usingJobData("name", "trigger2")</span><br><span class="line">                .startNow()</span><br><span class="line">                //                                                            时间间隔           永久重复执行</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 调度器</span><br><span class="line">        try {</span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            // 启动</span><br><span class="line">            scheduler.start();</span><br><span class="line">        } catch (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结果</p>
<p><img src="/../../images/image-20221128103703359.png" alt="image-20221128103703359"></p>
<hr>
<h2 id="Job-封装成JobDetail设置属性"><a href="#Job-封装成JobDetail设置属性" class="headerlink" title="Job : 封装成JobDetail设置属性"></a>Job : 封装成JobDetail设置属性</h2><p><img src="/../../images/image-20221128132915669.png" alt="image-20221128132915669"></p>
<p><img src="/../../images/image-20221128104234972.png" alt="image-20221128104234972"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span></span><br><span class="line"><span class="comment">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会发现，不加注解的情况下（@DisallowConcurrentExecution）</span></span><br><span class="line">        <span class="comment">// 下面的输出都是不一样的，证明不是同一个 Job 实例</span></span><br><span class="line">        System.out.println( <span class="string">"jobDetail : "</span> + System.identityHashCode(context.getJobDetail()) );</span><br><span class="line">        System.out.println( <span class="string">"job : "</span> + System.identityHashCode(context.getJobInstance()) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不加上注解的话（@DisallowConcurrentExecution），</span></span><br><span class="line">        <span class="comment">// 我们想着是每隔次启动 job 实例之后等待sleep 3秒 之后再重复启动的</span></span><br><span class="line">        <span class="comment">// 但是实际发现，每隔一秒就又有启动了，证明不是同一个job实例，所以它们之间的启动不需要等待sleep的时间</span></span><br><span class="line">        System.out.println(<span class="string">"execute : "</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>结果：</p>
<p><img src="/../../images/image-20221128110013728.png" alt="image-20221128110013728"></p>
<hr>
<p>测试count++</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">triggerMap</span> <span class="operator">=</span> context.getTrigger().getJobDataMap();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDetailMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();</span><br><span class="line">        triggerMap.put(<span class="string">"count"</span>, triggerMap.getInt(<span class="string">"count"</span>) + <span class="number">1</span>);</span><br><span class="line">        jobDetailMap.put(<span class="string">"count1"</span>, jobDetailMap.getInt(<span class="string">"count1"</span>) + <span class="number">1</span>);</span><br><span class="line">        System.out.println( <span class="string">"triggerMap count : "</span> + triggerMap.getInt(<span class="string">"count"</span>) );</span><br><span class="line">        System.out.println( <span class="string">"jobDetailMap count : "</span> + jobDetailMap.getInt(<span class="string">"count1"</span>) );</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"job"</span>, <span class="string">"jobDetail1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"jobDetail2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count1"</span>, <span class="number">0</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"trigger"</span>, <span class="string">"trigger"</span>)</span><br><span class="line">                <span class="comment">// 会覆盖上面JobDetail中的name的值</span></span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"trigger2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count"</span>, count)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>结果图：</p>
<p><img src="/../../images/image-20221128132552340.png" alt="image-20221128132552340"></p>
<p>Springboot整合Quartz</p>
<p><img src="/../../images/image-20221128143743504.png" alt="image-20221128143743504"></p>
<p>Springboot整合Quartz</p>
<p>使用Springboot里面的监听器，让项目在启动后也启动了调度器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(context.getScheduler().getSchedulerInstanceId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"taskname : "</span> + context.getJobDetail().getKey().getName() );</span><br><span class="line">            System.out.println(<span class="string">"执行时间 ："</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            scheduler1 = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> scheduler1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> quartz.bootquartz.QuartzJob;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="type">TriggerKey</span> <span class="variable">triggerKey</span> <span class="operator">=</span> TriggerKey.triggerKey(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> scheduler.getTrigger(triggerKey);</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="literal">null</span>) {</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(triggerKey)</span><br><span class="line">                        .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ?"</span>))</span><br><span class="line">                        .startNow()</span><br><span class="line">                        .build();</span><br><span class="line">                <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(QuartzJob.class)</span><br><span class="line">                        .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">                scheduler.start();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>结果：</p>
<p><img src="/../../images/image-20221128152834236.png" alt="image-20221128152834236"></p>
<p><img src="/../../images/image-20221217151142631.png" alt="image-20221217151142631"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cliiv9kjp001e3kv6gw8d7k2h" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Quartz/" rel="tag">Quartz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/13. 垃圾回收器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2022-11-24T09:06:54.329Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">13. 垃圾回收器</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="13-垃圾回收器"><a href="#13-垃圾回收器" class="headerlink" title="13. 垃圾回收器"></a>13. 垃圾回收器</h1><h2 id="13-1-GC-分类与性能指标"><a href="#13-1-GC-分类与性能指标" class="headerlink" title="13.1. GC 分类与性能指标"></a>13.1. GC 分类与性能指标</h2><h3 id="13-1-1-垃圾回收器概述"><a href="#13-1-1-垃圾回收器概述" class="headerlink" title="13.1.1. 垃圾回收器概述"></a>13.1.1. 垃圾回收器概述</h3><p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p>
<p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p>
<p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p>
<h3 id="13-1-2-垃圾收集器分类"><a href="#13-1-2-垃圾收集器分类" class="headerlink" title="13.1.2. 垃圾收集器分类"></a>13.1.2. 垃圾收集器分类</h3><p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab10d1899d353ea14797f9ce1778503c.png" alt="image-20210512144253383"></p>
<p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li>
<li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
<p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6e2c2869a4450dc405bda0ea8a8e7c31.png" alt="image-20200713083443486"></p>
<p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p>
<h3 id="13-1-3-评估-GC-的性能指标"><a href="#13-1-3-评估-GC-的性能指标" class="headerlink" title="13.1.3. 评估 GC 的性能指标"></a>13.1.3. 评估 GC 的性能指标</h3><p>（加粗的是比较重要的）</p>
<ul>
<li><strong><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</strong></li>
<li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li>
<li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong><mark>内存占用</mark>：Java 堆区所占的内存大小。</strong></li>
<li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p><strong>吞吐量、暂停时间、内存占用</strong> 这三者共同构成一个“<strong>不可能三角</strong>”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：吞吐量、暂停时间</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a05d48c1926a03c3acdebf74d10bf522.png" alt="image-20200713084726176"></p>
<h4 id="暂停时间"><a href="#暂停时间" class="headerlink" title="暂停时间"></a>暂停时间</h4><p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p>
<p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p>
<p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de90092e21cbff31926f7cc7dceebf25.png" alt="image-20200713085306400"></p>
<h4 id="吞吐量-vs-暂停时间"><a href="#吞吐量-vs-暂停时间" class="headerlink" title="吞吐量 vs 暂停时间"></a>吞吐量 vs 暂停时间</h4><p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p><strong>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></strong></p>
<h2 id="13-2-不同的垃圾回收器概述"><a href="#13-2-不同的垃圾回收器概述" class="headerlink" title="13.2. 不同的垃圾回收器概述"></a>13.2. 不同的垃圾回收器概述</h2><p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<h3 id="13-2-1-垃圾回收器发展史"><a href="#13-2-1-垃圾回收器发展史" class="headerlink" title="13.2.1. 垃圾回收器发展史"></a>13.2.1. 垃圾回收器发展史</h3><p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<ul>
<li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li>
<li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li>
<li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li>
<li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li>
<li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li>
<li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 “No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li>
<li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li>
</ul>
<h3 id="13-2-2-7-种经典的垃圾收集器"><a href="#13-2-2-7-种经典的垃圾收集器" class="headerlink" title="13.2.2. 7 种经典的垃圾收集器"></a>13.2.2. 7 种经典的垃圾收集器</h3><ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/90c3bcdc22cd0b49e10d702c608c4fc6.png" alt="image-20200713093551365"></p>
<p>官方手册：<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c529d76b22212c44275b94675cc56760.png" alt="image-20210512145950897"></p>
<h3 id="13-2-3-7-款经典收集器与垃圾分代之间的关系"><a href="#13-2-3-7-款经典收集器与垃圾分代之间的关系" class="headerlink" title="13.2.3. 7 款经典收集器与垃圾分代之间的关系"></a>13.2.3. 7 款经典收集器与垃圾分代之间的关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/fd16701d3e150d5e58d52b7306473a42.png" alt="image-20200713093757644"></p>
<ul>
<li><p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
</li>
<li><p>老年代收集器：Serial Old、Parallel Old、CMS；</p>
</li>
<li><p>整堆收集器：G1；</p>
</li>
</ul>
<h3 id="13-2-4-垃圾收集器的组合关系"><a href="#13-2-4-垃圾收集器的组合关系" class="headerlink" title="13.2.4. 垃圾收集器的组合关系"></a>13.2.4. 垃圾收集器的组合关系</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/b92c2212bea2907cb75ff9ef26f346fe.png" alt="image-20200713094745366"></p>
<ol>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>
<li>其中 Serial Old 作为 CMS 出现”<code>Concurrent Mode Failure</code>“失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li>
<li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li>
</ol>
<h3 id="13-2-5-不同的垃圾收集器概述"><a href="#13-2-5-不同的垃圾收集器概述" class="headerlink" title="13.2.5. 不同的垃圾收集器概述"></a>13.2.5. 不同的垃圾收集器概述</h3><p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p>
<h3 id="13-2-6-如何查看默认垃圾收集器"><a href="#13-2-6-如何查看默认垃圾收集器" class="headerlink" title="13.2.6. 如何查看默认垃圾收集器"></a>13.2.6. 如何查看默认垃圾收集器</h3><p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p>
<h2 id="13-3-Serial-回收器：串行回收"><a href="#13-3-Serial-回收器：串行回收" class="headerlink" title="13.3. Serial 回收器：串行回收"></a>13.3. Serial 回收器：串行回收</h2><p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p>
<p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p>
<p><mark>Serial 收集器采用复制算法、串行回收和”stop-the-World”机制的方式执行内存回收。</mark></p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和”Stop the World”机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p>
<ul>
<li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d66b612e68381df2101c3e829a18b4f0.png" alt="image-20200713100703799"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p>
<p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的（因为它是串行的，导致用户完全停止了，容易影响用户交互）。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="13-4-ParNew-回收器：并行回收"><a href="#13-4-ParNew-回收器：并行回收" class="headerlink" title="13.4. ParNew 回收器：并行回收"></a>13.4. ParNew 回收器：并行回收</h2><p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p>
<p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、”Stop-the-World”机制</mark>。</p>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/187fdcd46a1cb35be6d88a01a433c0f3.png" alt="image-20200713102030127"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p>
<ul>
<li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p>
<p>在程序中，开发人员可以通过选项”<code>-XX:+UseParNewGC</code>“手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h2 id="13-5-Parallel-回收器：吞吐量优先"><a href="#13-5-Parallel-回收器：吞吐量优先" class="headerlink" title="13.5. Parallel 回收器：吞吐量优先"></a>13.5. Parallel 回收器：吞吐量优先</h2><p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和”Stop the World”机制</mark>。</p>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
<p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和”Stop-the-World”机制</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8a4b655ee277aaf0f9a46754248ce05a.png" alt="image-20200713110359441"></p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p>
<p><strong>参数配置</strong></p>
<ul>
<li><p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p>
</li>
<li><p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
</li>
<li><p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p>$$ ParallelGCThreads = \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;= 8) \ 3 + (5 * CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8) \end{cases} $$</p>
</li>
<li><p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li>
<li><mark>该参数使用需谨慎</mark>。</li>
</ul>
</li>
<li><p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>
<ul>
<li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li>
</ul>
</li>
<li><p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p>
<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
<h2 id="13-6-CMS-回收器：低延迟"><a href="#13-6-CMS-回收器：低延迟" class="headerlink" title="13.6. CMS 回收器：低延迟"></a>13.6. CMS 回收器：低延迟</h2><p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会”Stop-the-World”</p>
<p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
<p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f84a132db8c56a488e14f51e2c4d7fa7.png" alt="image-20200713205154007"></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<mark>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</mark>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/052d6ef7655e46e040729082ac36da30.png" alt="image-20200713212230352"></p>
<p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p>
<p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p>
<h3 id="13-6-1-CMS-的优点"><a href="#13-6-1-CMS-的优点" class="headerlink" title="13.6.1. CMS 的优点"></a>13.6.1. CMS 的优点</h3><ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="13-6-2-CMS-的弊端"><a href="#13-6-2-CMS-的弊端" class="headerlink" title="13.6.2. CMS 的弊端"></a>13.6.2. CMS 的弊端</h3><ul>
<li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC（如果来一次业务高峰，导致提前触发Full GC，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，而单线程的垃圾回收器Serial OId，是性能最差的一个，停顿可能是几秒钟甚至十几秒钟，业务高峰时，停顿时间就很长了，给用户的体验就是很卡）。</li>
<li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>“失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li>
</ul>
<h3 id="13-6-3-设置的参数"><a href="#13-6-3-设置的参数" class="headerlink" title="13.6.3. 设置的参数"></a>13.6.3. 设置的参数</h3><ul>
<li><p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p>
<p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p>
</li>
<li><p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li>
</ul>
</li>
<li><p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li><p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
</li>
<li><p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p>
<ul>
<li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地 使用内存和并行开销，请选 Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li>
<li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li>
</ul>
<h3 id="13-6-4-JDK-后续版本中-CMS-的变化"><a href="#13-6-4-JDK-后续版本中-CMS-的变化" class="headerlink" title="13.6.4. JDK 后续版本中 CMS 的变化"></a>13.6.4. JDK 后续版本中 CMS 的变化</h3><p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p>
<ul>
<li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
<p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p>
<ul>
<li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li>
</ul>
<h2 id="13-7-G1-回收器：区域化分代式"><a href="#13-7-G1-回收器：区域化分代式" class="headerlink" title="13.7. G1 回收器：区域化分代式"></a>13.7. G1 回收器：区域化分代式</h2><p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p>
<p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而<strong>经常造成 STW 的 GC 又跟不上实际的需求</strong>，所以才会<strong>不断地尝试对 GC 进行优化</strong>。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p>
<p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p>
<p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p>
<p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在 JDK1.7 版本正式启用，移除了 Experimental 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p>
<p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
<h3 id="13-7-1-G1-回收器的特点（优势）"><a href="#13-7-1-G1-回收器的特点（优势）" class="headerlink" title="13.7.1. G1 回收器的特点（优势）"></a>13.7.1. G1 回收器的特点（优势）</h3><p>与其他 GC 收集器相比，G1 使用了全新的<strong>分区算法</strong>，其特点如下所示：</p>
<h4 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h4><ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序<strong>交替执行</strong>的能力（就不用考虑STW了），部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><ul>
<li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li>
<li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a71df3a4013da274aa3b28cd95e7d37.png" alt="image-20200713215105293"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8bcd36541731eb308043eba968b7a828.png" alt="image-20200713215133839"></p>
<h4 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h4><ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li>
<li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
<h4 id="可预测的停顿时间模型（即：软实时-soft-real-time）"><a href="#可预测的停顿时间模型（即：软实时-soft-real-time）" class="headerlink" title="可预测的停顿时间模型（即：软实时 soft real-time）"></a>可预测的停顿时间模型（即：软实时 soft real-time）</h4><p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h3 id="13-7-2-G1-垃圾收集器的缺点"><a href="#13-7-2-G1-垃圾收集器的缺点" class="headerlink" title="13.7.2. G1 垃圾收集器的缺点"></a>13.7.2. G1 垃圾收集器的缺点</h3><p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p>
<h3 id="13-7-3-G1-回收器的参数设置"><a href="#13-7-3-G1-回收器的参数设置" class="headerlink" title="13.7.3. G1 回收器的参数设置"></a>13.7.3. G1 回收器的参数设置</h3><ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li>
<li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了）</li>
<li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li>
<li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h3 id="13-7-4-G1-收集器的常见操作步骤"><a href="#13-7-4-G1-收集器的常见操作步骤" class="headerlink" title="13.7.4. G1 收集器的常见操作步骤"></a>13.7.4. G1 收集器的常见操作步骤</h3><p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启 G1 垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h3 id="13-7-5-G1-收集器的适用场景"><a href="#13-7-5-G1-收集器的适用场景" class="headerlink" title="13.7.5. G1 收集器的适用场景"></a>13.7.5. G1 收集器的适用场景</h3><p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p>
<p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p>
<ul>
<li>超过 50%的 Java 堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
<p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="13-7-6-分区-Region：化整为零"><a href="#13-7-6-分区-Region：化整为零" class="headerlink" title="13.7.6. 分区 Region：化整为零"></a>13.7.6. 分区 Region：化整为零</h3><p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark><strong>所有的 Region 大小相同</strong>，且在 JVM 生命周期内不会被改变。</mark></p>
<p>（之所以要分代，就是要对堆内存进行局部清理，缩短停留提升回收效率。尽管分了代，对于新生代和老年代而言内存空间占用还是比较大，所以G1就使用了分区，通过更细的粒度来回收内存，以控制回收停留时间）</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/74c611464ae6cdae3cbfffaef213cfd5.png" alt="image-20200713223244886"></p>
<p>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p>
<p>（region在整个jvm生命周期里的角色是可以转变的，比如说，当Eden区满的时候，触发YGC，YGC评判它价值比较高，就优先回收它了，回收完后，就一整个空白了，因为数据就会被提升复制到S幸存区了，就把Eden这区清空，那么这块空白的region就会被放到一个空闲列表中（专门用来记录这些空闲的region的），空闲之后，那么下一刻可能就会从这个空闲列表中将它选出来充当Old区了）</p>
<p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p>
<p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
<p>每个 Region 都是通过指针碰撞来分配空间</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/049520c5a004b63f750e04d5362a2992.png" alt="image-20200713223509993"></p>
<h3 id="13-7-7-G1-垃圾回收器的回收过程"><a href="#13-7-7-G1-垃圾回收器的回收过程" class="headerlink" title="13.7.7. G1 垃圾回收器的回收过程"></a>13.7.7. G1 垃圾回收器的回收过程</h3><p>G1GC 的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li><p>年轻代 GC（Young GC）</p>
</li>
<li><p>老年代并发标记过程（Concurrent Marking）</p>
</li>
<li><p>混合回收（Mixed GC）（涉及到新生代和老年代混合回收）</p>
<p>可能第四种情况：（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。情况如：（  <code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了））</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8f79c3cdeb0969981703f7a026cf581.png" alt="image-20200713224113996"></p>
<p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p>
<p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p>
<p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p>
<p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="13-7-8-Remembered-Set"><a href="#13-7-8-Remembered-Set" class="headerlink" title="13.7.8. Remembered Set"></a>13.7.8. Remembered Set</h3><ul>
<li><p>一个对象被不同区域引用的问题</p>
</li>
<li><p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p>
</li>
<li><p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</p>
</li>
<li><p>这样的话会降低 MinorGC 的效率；</p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li><p>无论 G1 还是其他分代收集器，<strong>JVM 都是使用 Remembered Set 来避免全局扫描：</strong></p>
</li>
<li><p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p>
</li>
<li><p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier （写屏障）暂时中断操作；</p>
</li>
<li><p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li><p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p>
</li>
<li><p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c97de4bdada1da5a9fdd344692ed0957.png" alt="image-20200713224716715"></p>
<h3 id="13-7-9-G1-回收过程一：年轻代-GC"><a href="#13-7-9-G1-回收过程一：年轻代-GC" class="headerlink" title="13.7.9. G1 回收过程一：年轻代 GC"></a>13.7.9. G1 回收过程一：年轻代 GC</h3><p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p>
<p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f29fa4dfe3abf4a77be06fdf3378aecf.png" alt="image-20200713225100632"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li>
<li><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</li>
<li><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
<li><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li>
<li><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ol>
<h3 id="13-7-10-G1-回收过程二：并发标记过程"><a href="#13-7-10-G1-回收过程二：并发标记过程" class="headerlink" title="13.7.10. G1 回收过程二：并发标记过程"></a>13.7.10. G1 回收过程二：并发标记过程</h3><ol>
<li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li>
<li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成 。</li>
<li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li>
<li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li>
</ol>
<h3 id="13-7-11-G1-回收过程三：混合回收"><a href="#13-7-11-G1-回收过程三：混合回收" class="headerlink" title="13.7.11. G1 回收过程三：混合回收"></a>13.7.11. G1 回收过程三：混合回收</h3><p>当越来越多的对象晋升到老年代 old region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/766b882cba7e709202005a3baeb596d0.png" alt="image-20200713225810871"></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。<font color="blue">垃圾占内存分段比例越高的，越会被先回收</font>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="13-7-12-G1-回收可选的过程四：Full-GC"><a href="#13-7-12-G1-回收可选的过程四：Full-GC" class="headerlink" title="13.7.12. G1 回收可选的过程四：Full GC"></a>13.7.12. G1 回收可选的过程四：Full GC</h3><p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p>
<p>导致 G1 Full GC 的原因可能有两个：</p>
<ul>
<li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="13-7-13-补充"><a href="#13-7-13-补充" class="headerlink" title="13.7.13. 补充"></a>13.7.13. 补充</h3><p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h3 id="13-7-14-G1-回收器优化建议"><a href="#13-7-14-G1-回收器优化建议" class="headerlink" title="13.7.14. G1 回收器优化建议"></a>13.7.14. G1 回收器优化建议</h3><p>年轻代大小</p>
<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
<p>暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h2 id="13-8-垃圾回收器总结"><a href="#13-8-垃圾回收器总结" class="headerlink" title="13.8. 垃圾回收器总结"></a>13.8. 垃圾回收器总结</h2><h3 id="13-8-1-7-种经典垃圾回收器总结"><a href="#13-8-1-7-种经典垃圾回收器总结" class="headerlink" title="13.8.1. 7 种经典垃圾回收器总结"></a>13.8.1. 7 种经典垃圾回收器总结</h3><p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th align="left">垃圾收集器</th>
<th align="left">分类</th>
<th align="left">作用位置</th>
<th align="left">使用算法</th>
<th align="left">特点</th>
<th align="left">适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Serial</td>
<td align="left">串行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于单 CPU 环境下的 client 模式</td>
</tr>
<tr>
<td align="left">ParNew</td>
<td align="left">并行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">多 CPU 环境 Server 模式下与 CMS 配合使用</td>
</tr>
<tr>
<td align="left">Parallel</td>
<td align="left">并行运行</td>
<td align="left">作用于新生代</td>
<td align="left">复制算法</td>
<td align="left">吞吐量优先</td>
<td align="left">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="left">Serial Old</td>
<td align="left">串行运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-压缩算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td align="left">Parallel Old</td>
<td align="left">并行运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-压缩算法</td>
<td align="left">吞吐量优先</td>
<td align="left">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td align="left">CMS</td>
<td align="left">并发运行</td>
<td align="left">作用于老年代</td>
<td align="left">标记-清除算法</td>
<td align="left">响应速度优先</td>
<td align="left">适用于互联网或 B／S 业务</td>
</tr>
<tr>
<td align="left">G1</td>
<td align="left">并发、并行运行</td>
<td align="left">作用于新生代、老年代</td>
<td align="left">标记-压缩算法、复制算法</td>
<td align="left">响应速度优先</td>
<td align="left">面向服务端应用</td>
</tr>
</tbody></table>
<p>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<h3 id="13-8-2-垃圾回收器组合"><a href="#13-8-2-垃圾回收器组合" class="headerlink" title="13.8.2. 垃圾回收器组合"></a>13.8.2. 垃圾回收器组合</h3><p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e57edaa3ec7295424480c67daee499e.png" alt="image-20200714080151020"></p>
<ol>
<li><p>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li><p>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</p>
</li>
<li><p>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中</p>
</li>
</ol>
<p>完全取消了这些组合的支持（JEP214），即：移除。</p>
<ol start="4">
<li><p>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</p>
</li>
<li><p>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</p>
</li>
</ol>
<h3 id="13-8-3-怎么选择垃圾回收器"><a href="#13-8-3-怎么选择垃圾回收器" class="headerlink" title="13.8.3. 怎么选择垃圾回收器"></a>13.8.3. 怎么选择垃圾回收器</h3><p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p>
<p>怎么选择垃圾收集器？</p>
<ol>
<li><p>优先调整堆的大小让 JVM 自适应完成。</p>
</li>
<li><p>如果内存小于 100M，使用串行收集器</p>
</li>
<li><p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
</li>
<li><p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</p>
</li>
<li><p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</p>
<p>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</p>
</li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<p><strong>面试</strong></p>
<p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>
<ul>
<li><p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>
</li>
<li><p>垃圾收集器工作的基本流程。</p>
</li>
</ul>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id="13-9-GC-日志分析"><a href="#13-9-GC-日志分析" class="headerlink" title="13.9. GC 日志分析"></a>13.9. GC 日志分析</h2><p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li>
<li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li>
<li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li>
</ul>
<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></tbody></table></figure>

<p>这个只会显示总的 GC 堆的变化，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),<span class="number">0.0084018</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="number">0.0184066</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> 21465K-&gt;16716K(201728K),<span class="number">0.0619261</span> secs]</span><br></pre></td></tr></tbody></table></figure>

<p>参数解析</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。</span><br><span class="line">Allocation Failure：GC发生的原因。</span><br><span class="line">80832K-&gt;19298K：堆在GC前的大小和GC后的大小。</span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line"><span class="number">0.0084018</span> secs：GC持续的时间。</span><br></pre></td></tr></tbody></table></figure>

<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure>

<p>输入信息如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="number">0.0172573</span> secs] [Times:user=<span class="number">0.03</span> sys=<span class="number">0.00</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="number">0.0151573</span> secs] [Times:user=<span class="number">0.00</span> sys=<span class="number">0.01</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0K(142336K)]</span><br><span class="line">[ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],<span class="number">0.0639732</span> secs]</span><br><span class="line">[Times:user=<span class="number">0.14</span> sys=<span class="number">0.00</span>,real=<span class="number">0.06</span> secs]</span><br></pre></td></tr></tbody></table></figure>

<p>参数解析</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GC，Full FC：同样是GC的类型</span><br><span class="line">Allocation Failure：GC原因</span><br><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代</span><br><span class="line">xxx secs：指GC花费的时间</span><br><span class="line">Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></tbody></table></figure>

<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</span><br></pre></td></tr></tbody></table></figure>

<p>输入信息如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">24.518</span>+0800: <span class="number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="number">0.0248249</span> secs] [Times:user=<span class="number">0.05</span> sys=<span class="number">0.00</span>,real=<span class="number">0.03</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.559</span>+0800: <span class="number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="number">0.0094071</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>,real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.569</span>+0800: <span class="number">4.338</span>: [Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],<span class="number">0.0494875</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>,real=<span class="number">0.05</span> secs]</span><br></pre></td></tr></tbody></table></figure>

<p>说明：带上了日期和实践</p>
<p>如果想把 GC 日志存到文件的话，是下面的参数：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log</span><br></pre></td></tr></tbody></table></figure>

<p><strong>日志补充说明</strong></p>
<ul>
<li><p>“<code>[GC</code>“和”<code>[Full GC</code>“说明了这次垃圾收集的停顿类型，如果有”Full”则说明 GC 发生了”Stop The World”</p>
</li>
<li><p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是”<code>[DefNew</code>“</p>
</li>
<li><p>使用 ParNew 收集器在新生代的名字会变成”<code>[ParNew</code>“，意思是”Parallel New Generation”</p>
</li>
<li><p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>“</p>
</li>
<li><p>老年代的收集和新生代道理一样，名字也是收集器决定的</p>
</li>
<li><p>使用 G1 收集器的话，会显示为”garbage-first heap”</p>
</li>
<li><p><mark>Allocation Failure</mark></p>
<p>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
</li>
<li><p><mark>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</mark></p>
<p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p>
<p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
</li>
<li><p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heap（堆）</span><br><span class="line">PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"></span><br><span class="line">ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"></span><br><span class="line">PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line">object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Minor-GC-日志"><a href="#Minor-GC-日志" class="headerlink" title="Minor GC 日志"></a>Minor GC 日志</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/9364561fbb81a0e2f9aedc45a383972f.png" alt="image-20200714082555688"></p>
<h3 id="Full-GC-日志"><a href="#Full-GC-日志" class="headerlink" title="Full GC 日志"></a>Full GC 日志</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/502793e725122b958f2861932e5ef9c1.png" alt="image-20210512194815354"></p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> { </span><br><span class="line">    <span class="type">byte</span> [] allocation1, allocation2, allocation3, allocation4;  </span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {    </span><br><span class="line">    testAllocation();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>设置 JVM 参数</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure>

<p><strong>图示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8dada6b73786eb693975593db10ce825.png" alt="image-20200714083332238"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/78f6489bd1a3b74e14ee4a95392df8c2.png" alt="image-20200714083526790"></p>
<p>（ jdk7是如上图分析所示。但是JDK8和JDK7不一样，大对象来的时候，发现新生代装不下，直接进入老年代 ）</p>
<p>可以用一些工具去分析这些 GC 日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p>
<h2 id="13-X-垃圾回收器的新发展"><a href="#13-X-垃圾回收器的新发展" class="headerlink" title="13.X. 垃圾回收器的新发展"></a>13.X. 垃圾回收器的新发展</h2><p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p>
<p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p>
<h3 id="13-X-1-JDK11-新特性"><a href="#13-X-1-JDK11-新特性" class="headerlink" title="13.X.1. JDK11 新特性"></a>13.X.1. JDK11 新特性</h3><p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，”No-Op（无操作）”回收器）<a target="_blank" rel="noopener" href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a target="_blank" rel="noopener" href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4aaef244379d75ba838e10d4178b2960.png" alt="image-20210512195426194"></p>
<p>现在 G1 回收器已成为默认回收器好几年了。</p>
<p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00920e4ae2b2c80a8016e6d8f4632545.png" alt="image-20210512195528695"></p>
<h3 id="13-X-2-Open-JDK12-的-Shenandoash-GC"><a href="#13-X-2-Open-JDK12-的-Shenandoash-GC" class="headerlink" title="13.X.2. Open JDK12 的 Shenandoash GC"></a>13.X.2. Open JDK12 的 Shenandoash GC</h3><p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p>
<p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p>
<p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01f566c0db04f0e475db05addd94259f.png" alt="image-20200714090608807"></p>
<p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
<p>总结</p>
<ul>
<li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC 的强项：低延迟时间。</li>
<li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li>
</ul>
<p>【Java12 新特性地址】</p>
<p><a target="_blank" rel="noopener" href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a></p>
<p>或</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p>
<h3 id="13-X-3-令人震惊、革命性的-ZGC"><a href="#13-X-3-令人震惊、革命性的-ZGC" class="headerlink" title="13.X.3. 令人震惊、革命性的 ZGC"></a>13.X.3. 令人震惊、革命性的 ZGC</h3><p>官方地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f78eebadbabf7450ded984f0f1e3a405.png" alt="image-20210512200236647"></p>
<p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p>
<p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p>
<p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p>
<p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p>测试数据：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b08828b548a255493e934c6fe3308e50.png" alt="image-20200714091201073"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e648c4e37d84f5d83d965b55f6bc5f9.png" alt="image-20200714091401511"></p>
<p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p>
<p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/59b014ca2eeda5332fd40a4a2356f883.png" alt="image-20200714093243028"></p>
<p><mark>JEP 364：ZGC 应用在 macos 上</mark></p>
<p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p>
<p>JDK14 之前，ZGC 仅 Linux 才支持。</p>
<p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p>
<p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></tbody></table></figure>

<h3 id="13-X-4-其他垃圾回收器：AliGC"><a href="#13-X-4-其他垃圾回收器：AliGC" class="headerlink" title="13.X.4. 其他垃圾回收器：AliGC"></a>13.X.4. 其他垃圾回收器：AliGC</h3><p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/835fff5c3a7884de2a1d564b7f332900.png" alt="image-20200714093604012"></p>
<p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" data-id="cliiv9kva00803kv66gtpcg14" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/12. 垃圾回收相关概念" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/23/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="post-time" datetime="2022-11-23T09:44:11.240Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">23</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/23/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/">12. 垃圾回收相关概念</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="12-垃圾回收相关概念"><a href="#12-垃圾回收相关概念" class="headerlink" title="12. 垃圾回收相关概念"></a>12. 垃圾回收相关概念</h1><h2 id="12-1-System-gc-的理解"><a href="#12-1-System-gc-的理解" class="headerlink" title="12.1. System.gc()的理解"></a>12.1. System.gc()的理解</h2><p>在默认情况下，通过 system.gc()或者 Runtime.getRuntime().gc() 的调用，<mark>会显式触发 Full GC</mark>，同时对老年代和新生代进行回收，尝试释放被丢弃对象占用的内存。</p>
<p>然而 System.gc() 调用附带一个免责声明，无法保证对垃圾收集器的调用。(不能确保立即生效)</p>
<p>JVM 实现者可以通过 System.gc() 调用来决定 JVM 的 GC 行为。而一般情况下，垃圾回收应该是自动进行的，<mark>无须手动触发，否则就太过于麻烦了</mark>。在一些特殊情况下，如我们正在编写一个性能基准，我们可以在运行之间调用 System.gc()</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SystemGCTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">SystemGCTest</span>();</span><br><span class="line">        System.gc();<span class="comment">// 提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</span></span><br><span class="line">        <span class="comment">// 与Runtime.getRuntime().gc();的作用一样，因为System.gc()底层就是它</span></span><br><span class="line"></span><br><span class="line">        System.runFinalization(); <span class="comment">// 强制执行使用引用的对象的finalize()方法</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"SystemGCTest 重写了finalize()"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上面的代码例子，</p>
<p>不加上System.runFinalization();，运行时，不是每次都会输出”SystemGCTest 重写了finalize()”，证明System.gc()只是提醒JVM的垃圾回收器执行gc，但是不确定是否马上执行gc</p>
<p>加上<strong>System.runFinalization()</strong>;，就会每次都输出”SystemGCTest 重写了finalize()”，因为它<strong>强制执行</strong>使用引用的对象的finalize()方法</p>
<h2 id="12-2-内存溢出与内存泄露"><a href="#12-2-内存溢出与内存泄露" class="headerlink" title="12.2. 内存溢出与内存泄露"></a>12.2. 内存溢出与内存泄露</h2><h3 id="内存溢出（OOM）"><a href="#内存溢出（OOM）" class="headerlink" title="内存溢出（OOM）"></a>内存溢出（OOM）</h3><ul>
<li><p>内存溢出相对于内存泄漏来说，尽管更容易被理解，但是同样的，内存溢出也是引发程序崩溃的罪魁祸首之一。</p>
</li>
<li><p>由于 GC 一直在发展，所有一般情况下，除非应用程序占用的内存增长速度非常快，造成垃圾回收已经跟不上内存消耗的速度，否则不太容易出现 ooM 的情况。</p>
</li>
<li><p>大多数情况下，GC 会进行各种年龄段的垃圾回收，实在不行了就放大招，来一次独占式的 Full GC 操作，这时候会回收大量的内存，供应用程序继续使用。</p>
</li>
<li><p>javadoc 中对 OutOfMemoryError 的解释是，<mark>没有空闲内存，并且垃圾收集器也无法提供更多内存</mark>。</p>
</li>
</ul>
<p>首先说没有空闲内存的情况：说明 Java 虚拟机的堆内存不够。原因有二：</p>
<ol>
<li><p><mark>Java 虚拟机的堆内存设置不够。</mark></p>
<p>比如：可能存在内存泄漏问题；也很有可能就是堆的大小不合理，比如我们要处理比较可观的数据量，但是没有显式指定 JVM 堆大小或者指定数值偏小。我们可以通过参数<code>-Xms</code> 、<code>-Xmx</code>来调整。</p>
</li>
<li><p><mark>代码中创建了大量大对象，并且长时间不能被垃圾收集器收集（存在被引用）</mark></p>
<p>对于老版本的 Oracle JDK，因为永久代的大小是有限的，并且 JVM 对永久代垃圾回收（如，常量池回收、卸载不再需要的类型）非常不积极，所以当我们不断添加新类型的时候，永久代出现 OutOfMemoryError 也非常多见，尤其是在运行时存在大量动态类型生成的场合；类似 intern 字符串缓存占用太多空间，也会导致 OOM 问题。对应的异常信息，会标记出来和永久代相关：“<code>java.lang.OutOfMemoryError: PermGen space</code>“。</p>
<p>随着元数据区的引入，方法区内存已经不再那么窘迫，所以相应的 ooM 有所改观，出现 OOM，异常信息则变成了：“<code>java.lang.OutofMemoryError:Metaspace</code>“。直接内存不足，也会导致 OOM。</p>
</li>
</ol>
<p>这里面隐含着一层意思是，在抛出 OutOfMemoryError 之前，通常垃圾收集器会被触发，尽其所能去清理出空间。</p>
<ul>
<li>例如：在引用机制分析中，涉及到 JVM 会去尝试回收软引用指向的对象等。</li>
<li>在<code>java.nio.BIts.reserveMemory()</code>方法中，我们能清楚的看到，<code>System.gc()</code>会被调用，以清理空间。</li>
</ul>
<p>当然，也不是在任何情况下垃圾收集器都会被触发的</p>
<ul>
<li>比如，我们去分配一个超大对象，类似一个超大数组超过堆的最大值，JVM 可以判断出垃圾收集并不能解决这个问题，所以直接抛出 OutOfMemoryError。</li>
</ul>
<h3 id="内存泄漏（Memory-Leak）"><a href="#内存泄漏（Memory-Leak）" class="headerlink" title="内存泄漏（Memory Leak）"></a>内存泄漏（Memory Leak）</h3><p>也称作“存储渗漏”。严格来说，<mark><strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏</strong></mark>。</p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的生命周期变得很长甚至导致 OOM，也可以叫做<mark>宽泛意义上的“内存泄漏”</mark>。详说如下：</p>
<p>（一个类里面的方法，把一个变量定义到方法内，作为一个局部变量，那么这个变量出了这个方法它就被回收了。但是你把它定义成成员变量了，生命周期就会长一些，甚至还把这个成员变量定义成了 static ，那么这个静态变量的变量或是类变量就会随着类的加载而加载，随着类的消亡而消亡，这个变量的生命周期就会非常长。如果程序当中出现大量的生命周期很长的对象的时候，加上那些没办法回收的数据的存在，最后导致 OOM 。所以我们把那些生命周期本很长的对象，本来没必要那么长而我们又申明了那么长的对象，也可以理解为<strong>宽泛意义的“内存泄露”</strong>）</p>
<p>尽管内存泄漏并不会立刻引起程序崩溃，但是一旦发生内存泄漏，程序中的可用内存就会被逐步蚕食，直至耗尽所有内存，最终出现 OutOfMemory 异常，导致程序崩溃。</p>
<p>注意，这里的存储空间并不是指物理内存，而是指虚拟内存大小，这个虚拟内存大小取决于磁盘交换区设定的大小。</p>
<p><img src="/../../../images/image-20221123174631209.png" alt="image-20221123174631209"></p>
<p><strong>举例</strong></p>
<ol>
<li><p>单例模式</p>
<p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内存泄漏的产生。</p>
</li>
<li><p>一些提供 close 的资源未关闭导致内存泄漏</p>
<p>数据库连接（dataSourse.getConnection() ），网络连接（socket）和 io 连接必须手动 close，否则是不能被回收的。</p>
</li>
</ol>
<h2 id="12-3-Stop-The-World"><a href="#12-3-Stop-The-World" class="headerlink" title="12.3. Stop The World"></a>12.3. Stop The World</h2><p>Stop-the-World，简称 STW，指的是 GC 事件发生过程中，会产生应用程序的停顿。<mark>停顿产生时整个应用程序线程都会被暂停，没有任何响应</mark>，有点像卡死的感觉，这个停顿称为 STW。</p>
<p>可达性分析算法中枚举根节点（GC Roots）会导致所有 Java 执行线程停顿。</p>
<ul>
<li>分析工作必须在一个能确保一致性的快照中进行</li>
<li><strong>一致性</strong>指整个分析期间整个执行系统看起来像被冻结在某个时间点上</li>
<li><mark>如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证</mark></li>
</ul>
<p>被 STW 中断的应用程序线程会在完成 GC 之后恢复，频繁中断会让用户感觉像是网速不快造成电影卡带一样，所以我们需要减少 STW 的发生。</p>
<p>STW 事件和采用哪款 GC 无关，所有的 GC 都有这个事件。</p>
<p>哪怕是 G1 也不能完全避免 Stop-the-World 情况发生，只能说垃圾回收器越来越优秀，回收效率越来越高，尽可能地缩短了暂停时间。</p>
<p>STW 是 JVM 在<mark>后台自动发起和自动完成</mark>的。在用户不可见的情况下，把用户正常的工作线程全部停掉。</p>
<p>开发中不要用 System.gc()，否则 会导致 Stop-the-World 的发生。</p>
<h2 id="12-4-垃圾回收的并行与并发"><a href="#12-4-垃圾回收的并行与并发" class="headerlink" title="12.4. 垃圾回收的并行与并发"></a>12.4. 垃圾回收的并行与并发</h2><h3 id="并发（Concurrent）"><a href="#并发（Concurrent）" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h3><p>在操作系统中，是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理器上运行。</p>
<p>并发不是真正意义上的“同时进行”，只是 CPU 把一个时间段划分成几个时间片段（时间区间），然后在这几个时间区间之间来回切换，由于 CPU 处理的速度非常快，只要时间间隔处理得当，即可让用户感觉是多个应用程序同时在进行。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e4a10263a26cb7aa87f1a6615b5b833.png" alt="image-20200712202522051"></p>
<h3 id="并行（Parallel）"><a href="#并行（Parallel）" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h3><p>当系统有一个以上 CPU 时，当一个 CPU 执行一个进程时，另一个 CPU 可以执行另一个进程，两个进程互不抢占 CPU 资源，可以同时进行，我们称之为并行（Parallel）。</p>
<p>其实决定并行的因素不是 CPU 的数量，而是 CPU 的核心数量，比如一个 CPU 多个核也可以并行。</p>
<p>适合科学计算，后台处理等弱交互场景</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ea1ebdd0fd0bc3a27c0d745c9bcdff7.png" alt="image-20200712202822129"></p>
<h3 id="并发-vs-并行"><a href="#并发-vs-并行" class="headerlink" title="并发 vs 并行"></a>并发 vs 并行</h3><ul>
<li><p>并发，指的是多个事情，在<mark>同一时间段内</mark>同时发生了。</p>
</li>
<li><p>并行，指的是多个事情，在<mark>同一时间点上</mark>同时发生了。</p>
</li>
<li><p>并发的多个任务之间是互相抢占资源的。</p>
</li>
<li><p>并行的多个任务之间是不互相抢占资源的。</p>
</li>
<li><p>只有在多 CPU 或者一个 CPU 多核的情况中，才会发生并行。</p>
</li>
<li><p>否则，看似同时发生的事情，其实都是并发执行的。</p>
</li>
</ul>
<h3 id="垃圾回收的并发与并行"><a href="#垃圾回收的并发与并行" class="headerlink" title="垃圾回收的并发与并行"></a>垃圾回收的并发与并行</h3><p>并发和并行，在谈论垃圾收集器的上下文语境中，它们可以解释如下：</p>
<h4 id="并行（Parallel）-1"><a href="#并行（Parallel）-1" class="headerlink" title="并行（Parallel）"></a>并行（Parallel）</h4><p>指<strong>多条垃圾收集线程</strong>并行工作，但此时用户线程仍处于等待状态。如 ParNew、Parallel Scavenge、Parallel Old；</p>
<h4 id="串行（Serial）"><a href="#串行（Serial）" class="headerlink" title="串行（Serial）"></a>串行（Serial）</h4><p>相较于并行的概念，单线程执行。如果内存不够，则程序暂停，启动 JM 垃圾回收器进行垃圾回收。回收完，再启动程序的线程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fd2b4f4ece3976fbd73c1039666cf7d7.png" alt="image-20210512112822896"></p>
<h4 id="并发（Concurrent）-1"><a href="#并发（Concurrent）-1" class="headerlink" title="并发（Concurrent）"></a>并发（Concurrent）</h4><p>指<mark>用户线程与垃圾收集线程同时执行</mark>（但不一定是并行的，可能会交替执行），<mark>垃圾回收线程在执行时不会停顿用户程序的运行</mark>。用户程序在继续运行，而垃圾收集程序线程运行于<strong>另一个 CPU 上</strong>；如：CMS、G1</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/48a4190f4d2ff4b7c8963a75ba2e6182.png" alt="image-20200712203815517"></p>
<h2 id="12-5-安全点与安全区域"><a href="#12-5-安全点与安全区域" class="headerlink" title="12.5. 安全点与安全区域"></a>12.5. 安全点与安全区域</h2><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>程序执行时并非在所有地方都能停顿下来开始 GC，只有在特定的位置才能停顿下来开始 GC，这些位置称为“安全点（Safepoint）”。</p>
<p>Safe Point 的选择很重要，<mark>如果太少可能导致 GC 等待的时间太长，如果太频繁可能导致运行时的性能问题</mark>。大部分指令的执行时间都非常短暂，通常会根据“<mark>是否具有让程序长时间执行的特征</mark>”为标准。比如：选择一些<strong>执行时间较长</strong>的指令作为 Safe Point，如<mark>方法调用、循环跳转和异常跳转等</mark>。</p>
<p>如何在 GC 发生时，检查所有线程都跑到最近的安全点停顿下来呢？</p>
<h4 id="抢先式中断：（目前没有虚拟机采用了）"><a href="#抢先式中断：（目前没有虚拟机采用了）" class="headerlink" title="抢先式中断：（目前没有虚拟机采用了）"></a>抢先式中断：（目前没有虚拟机采用了）</h4><ul>
<li>首先中断所有线程。如果还有线程不在安全点，就恢复线程，让线程跑到安全点。\</li>
</ul>
<h4 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h4><p>设置一个中断标志，各个线程运行到 Safe Point 的时候主动轮询这个标志，如果中断标志为真，则将自己进行中断挂起。（有轮询的机制）</p>
<h3 id="安全区域（Safe-Resion）"><a href="#安全区域（Safe-Resion）" class="headerlink" title="安全区域（Safe Resion）"></a>安全区域（Safe Resion）</h3><p>Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint。但是，程序“不执行”的时候呢？例如线程处于 Sleep 状态或 Blocked 状态，这时候线程无法响应 JVM 的中断请求，“走”到安全点去中断挂起，JVM 也不太可能等待线程被唤醒。对于这种情况，就需要安全区域（Safe Region）来解决。</p>
<p><mark>安全区域是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始 Gc 都是安全的。</mark>我们也可以把 Safe Region 看做是被扩展了的 Safepoint。</p>
<h3 id="实际执行时："><a href="#实际执行时：" class="headerlink" title="实际执行时："></a>实际执行时：</h3><ol>
<li>当线程运行到 Safe Region 的代码时，首先标识已经进入了 Safe Relgion，如果这段时间内发生 GC，JVM 会忽略标识为 Safe Region 状态的线程</li>
<li>当线程即将离开 Safe Region 时，会检查 JVM 是否已经完成 GC，如果完成了，则继续运行，否则线程必须等待直到收到可以安全离开 Safe Region 的信号为止；</li>
</ol>
<h2 id="12-6-再谈引用：强引用"><a href="#12-6-再谈引用：强引用" class="headerlink" title="12.6. 再谈引用：强引用"></a>12.6. 再谈引用：强引用</h2><p>我们希望能描述这样一类对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是很紧张，则可以抛弃这些对象。</p>
<p>【既<mark>偏门</mark>又非常<mark>高频</mark>的面试题】强引用、软引用、弱引用、虚引用有什么区别？具体使用场景是什么？</p>
<p>在 JDK1.2 版之后，Java 对引用的概念进行了扩充，将引用分为：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）这 4 种引用强度依次逐渐减弱。</p>
<p>除强引用外，其他 3 种引用均可以在 java.lang.ref 包中找到它们的身影。如下图，显示了这 3 种引用类型对应的类，开发人员可以在应用程序中直接使用它们。</p>
<p>.<img src="https://img-blog.csdnimg.cn/img_convert/1ef8adfbf9082acacc9db47ae48f5b47.png" alt="image-20200712205813321"></p>
<p>Reference 子类中只有终结器引用是包内可见的，其他 3 种引用类型均为 public，可以在应用程序中直接使用</p>
<ul>
<li><mark>强引用（StrongReference）</mark>：最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“<code>Object obj = new Object()</code>”这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><mark>软引用（SoftReference）</mark>：在系统将要发生内存溢出之前，将会把这些对象列入回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存流出异常。</li>
<li><mark>弱引用（WeakReference）</mark>：被弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论内存空间是否足够，都会回收掉被弱引用关联的对象。</li>
<li><mark>虚引用（PhantomReference）</mark>：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来获得一个对象的实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
</ul>
<h3 id="强引用（Strong-Reference）——不回收"><a href="#强引用（Strong-Reference）——不回收" class="headerlink" title="强引用（Strong Reference）——不回收"></a>强引用（Strong Reference）——不回收</h3><p>在 Java 程序中，最常见的引用类型是强引用（<mark>普通系统 99%以上都是强引用</mark>），也就是我们最常见的普通对象引用，<mark>也是默认的引用类型</mark>。</p>
<p>当在 Java 语言中使用 new 操作符创建一个新的对象，并将其赋值给一个变量的时候，这个变量就成为指向该对象的一个强引用。</p>
<p><mark>强引用的对象是可触及的，垃圾收集器就永远不会回收掉被引用的对象。</mark></p>
<p>对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 nu11，就是可以当做垃圾被收集了，当然具体回收时机还是要看垃圾收集策略。</p>
<p>相对的，软引用、弱引用和虚引用的对象是软可触及、弱可触及和虚可触及的，在一定条件下，都是可以被回收的。所以，<mark>强引用是造成 Java 内存泄漏的主要原因之一</mark>。</p>
<p><strong>强引用例子</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">"hello mogublog"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>局部变量 str 指向 StringBuffer 实例所在堆空间，通过 str 可以操作该实例，那么 str 就是 StringBuffer 实例的强引用</p>
<p><strong>对应内存结构</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34ad0a72d2fce1fd6c06b5965c354712.png" alt="image-20200712211501377"></p>
<p>此时，如果再运行一个赋值语句</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">str1</span> <span class="operator">=</span> str;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>对应的内存结构</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/baf5d789fc28868dfb983adc7265461c.png" alt="image-20200712211732976"></p>
<p>本例中的两个引用，都是强引用，强引用具备以下特点：</p>
<ul>
<li>强引用可以直接访问目标对象。</li>
<li>强引用所指向的对象在任何时候都不会被系统回收，虚拟机宁愿抛出 OOM 异常，也不会回收强引用所指向对象。</li>
<li>强引用可能导致内存泄漏。</li>
</ul>
<h2 id="12-8-再谈引用：-软引用"><a href="#12-8-再谈引用：-软引用" class="headerlink" title="12.8. 再谈引用： 软引用"></a>12.8. 再谈引用： 软引用</h2><h3 id="软引用（Soft-Reference）——内存不足即回收"><a href="#软引用（Soft-Reference）——内存不足即回收" class="headerlink" title="软引用（Soft Reference）——内存不足即回收"></a>软引用（Soft Reference）——内存不足即回收</h3><p>（内存足够 –&gt; 不会回收软引用的可达对象； 内存不够 –&gt; 会回收软引用的可达对象）</p>
<p>软引用是用来描述一些还有用，但非必需的对象（必须对象由强引用描述）。<mark>只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收</mark>（一次回收是不可达对象），如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p>
<p>软引用通常用来实现内存敏感的<strong>缓存</strong>。比如：<mark>高速缓存</mark>就有用到软引用。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<p>垃圾回收器在某个时刻决定回收软可达的对象的时候，会清理软引用，并可选地把引用存放到一个引用队列（Reference Queue）。</p>
<p>类似弱引用，只不过 Java 虚拟机会尽量让软引用的存活时间长一些，迫不得已才清理。</p>
<p>在 JDK1.2 版之后提供了 java.lang.ref.SoftReference 类来实现软引用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">SoftReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20221124152020225.png" alt="image-20221124152020225"></p>
<h2 id="12-9-再谈引用：弱引用"><a href="#12-9-再谈引用：弱引用" class="headerlink" title="12.9. 再谈引用：弱引用"></a>12.9. 再谈引用：弱引用</h2><h3 id="弱引用（Weak-Reference）——发现即回收"><a href="#弱引用（Weak-Reference）——发现即回收" class="headerlink" title="弱引用（Weak Reference）——发现即回收"></a>弱引用（Weak Reference）——发现即回收</h3><p>弱引用也是用来描述那些非必需对象，<mark>只被弱引用关联的对象只能生存到下一次垃圾收集发生为止</mark>。在系统 GC 时，只要发现弱引用，不管系统堆空间使用是否充足，都会回收掉只被弱引用关联的对象。</p>
<p>但是，由于垃圾回收器的线程通常优先级很低，因此，并不一定能很快地发现持有弱引用的对象。在这种情况下，<mark>弱引用对象可以存在较长的时间</mark>。</p>
<p>弱引用和软引用一样，在构造弱引用时，也可以指定一个引用队列，当弱引用对象被回收时，就会加入指定的引用队列，通过这个队列可以跟踪对象的回收情况。</p>
<p><mark>软引用、弱引用都非常适合来保存那些可有可无的缓存数据</mark>。如果这么做，当系统内存不足时，这些缓存数据会被回收，不会导致内存溢出。<strong>而当内存资源充足时，这些缓存数据又可以存在相当长的时间，从而起到加速系统的作用。</strong></p>
<p>在 JDK1.2 版之后提供了 WeakReference 类来实现弱引用</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line">WeakReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(obj);</span><br><span class="line">obj = <span class="literal">null</span>; <span class="comment">//销毁强引用</span></span><br></pre></td></tr></tbody></table></figure>

<p><mark>弱引用对象与软引用对象的最大不同</mark>就在于，当 GC 在进行回收时，需要通过算法检查是否回收软引用对象，而对于弱引用对象，GC 总是进行回收。<mark>弱引用对象更容易、更快被 GC 回收</mark>。</p>
<p><img src="/../../../images/image-20221124153725910.png" alt="image-20221124153725910"></p>
<p><strong>面试题：你开发中使用过 WeakHashMap 吗？</strong></p>
<p>WeakHashMap 用来存储图片信息，可以在内存不足的时候，及时回收，避免了 OOM</p>
<h2 id="12-X-再谈引用：虚引用"><a href="#12-X-再谈引用：虚引用" class="headerlink" title="12.X. 再谈引用：虚引用"></a>12.X. 再谈引用：虚引用</h2><h3 id="虚引用（Phantom-Reference）——对象回收跟踪"><a href="#虚引用（Phantom-Reference）——对象回收跟踪" class="headerlink" title="虚引用（Phantom Reference）——对象回收跟踪"></a>虚引用（Phantom Reference）——对象回收跟踪</h3><p>也称为“幽灵引用”或者“幻影引用”，是所有引用类型中最弱的一个。</p>
<p>一个对象是否有虚引用的存在，完全不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它和没有引用几乎是一样的，随时都可能被垃圾回收器回收。</p>
<p>它不能单独使用，也无法通过虚引用来获取被引用的对象。当试图通过虚引用的 get()方法取得对象时，总是 null</p>
<p><mark>为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如：能在这个对象被收集器回收时收到一个系统通知。</mark></p>
<p>虚引用必须和引用队列一起使用。虚引用在创建时必须提供一个引用队列作为参数。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象后，将这个虚引用加入引用队列，以通知应用程序对象的回收情况。</p>
<p><mark>由于虚引用可以跟踪对象的回收时间，因此，也可以将一些资源释放操作放置在虚引用中执行和记录。</mark></p>
<p>在 JDK1.2 版之后提供了 PhantomReference 类来实现虚引用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>(); <span class="comment">// 声明强引用</span></span><br><span class="line"><span class="type">ReferenceQueue</span> <span class="variable">phantomQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>();</span><br><span class="line">PhantomReference&lt;Object&gt; sf = <span class="keyword">new</span> <span class="title class_">PhantomReference</span>&lt;&gt;(obj, phantomQueue);</span><br><span class="line">obj = <span class="literal">null</span>;</span><br></pre></td></tr></tbody></table></figure>

<h2 id="12-11-终结器引用"><a href="#12-11-终结器引用" class="headerlink" title="12.11. 终结器引用"></a>12.11. 终结器引用</h2><p>它用于实现对象的 finalize() 方法，也可以称为终结器引用。无需手动编码，其内部配合引用队列使用。</p>
<p>在 GC 时，终结器引用入队。由 Finalizer 线程通过终结器引用找到被引用对象调用它的 finalize()方法，第二次 GC 时才回收被引用的对象</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/23/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/12.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/" data-id="cliiv9kv4007v3kv634ke05ya" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-设计模式/结构型模式/适配器模式" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" class="article-date">
  <time class="post-time" datetime="2022-11-21T14:08:21.872Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>,<a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/">结构型模式</a>,<a class="article-category-link" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>
<p><img src="https://bright-boy.gitee.io/technical-notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/%E8%BD%AC%E6%8E%A5%E5%A4%B4.png" alt="img"></p>
<p><strong>定义：</strong></p>
<p> 将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p> 适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2 结构"></a>5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h3 id="5-2-3-类适配器模式"><a href="#5-2-3-类适配器模式" class="headerlink" title="5.2.3 类适配器模式"></a>5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<p><img src="/../../../images/image-20221121221506653.png" alt="image-20221121221506653"></p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SD卡的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="comment">//读取SD卡方法</span></span><br><span class="line">    String <span class="title function_">readSD</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入SD卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//SD卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="string">"sd card read a msg :hello word SD"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"sd card write msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Computer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">(SDCard sdCard)</span> {</span><br><span class="line">        <span class="keyword">if</span>(sdCard == <span class="literal">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">"sd card null"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sdCard.readSD();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TFCard</span> {</span><br><span class="line">    <span class="comment">//读取TF卡方法</span></span><br><span class="line">    String <span class="title function_">readTF</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">//写入TF卡功能</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//TF卡实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">TFCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readTF</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span><span class="string">"tf card read msg : hello word tf card"</span>;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeTF</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"tf card write a msg : "</span> + msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义适配器类（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span> <span class="keyword">extends</span> <span class="title class_">TFCardImpl</span> <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>();</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure>

<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h3 id="5-2-4-对象适配器模式"><a href="#5-2-4-对象适配器模式" class="headerlink" title="5.2.4 对象适配器模式"></a><a target="_blank" rel="noopener" href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_524-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F">5.2.4 对象适配器模式</a></h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<p><img src="https://bright-boy.gitee.io/technical-notes/img/%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="img"></p>
<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建适配器对象（SD兼容TF）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SDAdapterTF</span>  <span class="keyword">implements</span> <span class="title class_">SDCard</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TFCard tfCard;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SDAdapterTF</span><span class="params">(TFCard tfCard)</span> {</span><br><span class="line">        <span class="built_in">this</span>.tfCard = tfCard;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">readSD</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter read tf card "</span>);</span><br><span class="line">        <span class="keyword">return</span> tfCard.readTF();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">writeSD</span><span class="params">(String msg)</span> {</span><br><span class="line">        System.out.println(<span class="string">"adapter write tf card"</span>);</span><br><span class="line">        tfCard.writeTF(msg);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">Computer</span> <span class="variable">computer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Computer</span>();</span><br><span class="line">        <span class="type">SDCard</span> <span class="variable">sdCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDCardImpl</span>();</span><br><span class="line">        System.out.println(computer.readSD(sdCard));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">TFCard</span> <span class="variable">tfCard</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TFCardImpl</span>();</span><br><span class="line">        <span class="type">SDAdapterTF</span> <span class="variable">adapter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SDAdapterTF</span>(tfCard);</span><br><span class="line">        System.out.println(computer.readSD(adapter));</span><br><span class="line">    }</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意：还有一个适配器模式是接口适配器模式。当不希望实现一个接口中所有的方法时，可以创建一个抽象类Adapter ，实现所有方法。而此时我们只需要继承该抽象类即可。</p>
</blockquote>
<h3 id="5-2-5-应用场景"><a href="#5-2-5-应用场景" class="headerlink" title="5.2.5 应用场景"></a><a target="_blank" rel="noopener" href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_525-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">5.2.5 应用场景</a></h3><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h3 id="5-2-6-JDK源码解析"><a href="#5-2-6-JDK源码解析" class="headerlink" title="5.2.6 JDK源码解析"></a><a target="_blank" rel="noopener" href="https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index?id=_526-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">5.2.6 JDK源码解析</a></h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p>
<p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">return</span> sd.read();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">char</span> cbuf[], <span class="type">int</span> offset, <span class="type">int</span> length)</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="keyword">return</span> sd.read(cbuf, offset, length);</span><br><span class="line">}Copy to clipboardErrorCopied</span><br></pre></td></tr></tbody></table></figure>

<p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p>
<p><img src="https://bright-boy.gitee.io/technical-notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/img/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png" alt="img"></p>
<p>从上图可以看出：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li>
</ul>
<p>结论：</p>
<p> 从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" data-id="cliiv9ler00xi3kv6e27ca0cb" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/" rel="tag">结构型模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/" rel="tag">适配器模式</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/11. 垃圾回收概述及算法" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="post-time" datetime="2022-11-21T12:37:10.393Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/">11. 垃圾回收概述及算法</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="11-垃圾回收概述及算法"><a href="#11-垃圾回收概述及算法" class="headerlink" title="11. 垃圾回收概述及算法"></a>11. 垃圾回收概述及算法</h1><h2 id="11-1-垃圾回收概述"><a href="#11-1-垃圾回收概述" class="headerlink" title="11.1. 垃圾回收概述"></a>11.1. 垃圾回收概述</h2><h3 id="11-1-1-什么是垃圾？"><a href="#11-1-1-什么是垃圾？" class="headerlink" title="11.1.1. 什么是垃圾？"></a>11.1.1. 什么是垃圾？</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/7d77b6d955e70ac268b08593078fbbdd.png" alt="image-20200712085456113"></p>
<p>垃圾收集，不是 Java 语言的伴生产物。早在 1960 年，第一门开始使用内存动态分配和垃圾收集技术的 Lisp 语言诞生。</p>
<p>关于垃圾收集有三个经典问题：</p>
<ul>
<li>哪些内存需要回收？</li>
<li>什么时候回收？</li>
<li>如何回收？</li>
</ul>
<p>垃圾收集机制是 Java 的招牌能力，<mark>极大地提高了开发效率</mark>。如今，垃圾收集几乎成为现代语言的标配，即使经过如此长时间的发展，Java 的垃圾收集机制仍然在不断的演进中，不同大小的设备、不同特征的应用场景，对垃圾收集提出了新的挑战，这当然也是面试的热点。</p>
<p><strong>大厂面试题</strong></p>
<p>CMS的全称是<strong>Mostly Concurrent Mark and Sweep Garbage Collector</strong>（主要并发标记清除垃圾回收器），它在年轻代使用复制算法，在老年代使用标记-清除算法，在老年代比起Mark-Sweep，多了一个并发设计。</p>
<blockquote>
<p><mark>蚂蚁金服</mark></p>
<ul>
<li><p>你知道哪几种垃圾回收器，各自的优缺点，重点讲一下 cms 和 G1？</p>
</li>
<li><p>JVM GC 算法有哪些，目前的 JDK 版本采用什么回收算法？</p>
</li>
<li><p>G1 回收器讲下回收过程 GC 是什么？为什么要有 GC？</p>
</li>
<li><p>GC 的两种判定方法？CMS 收集器与 G1 收集器的特点</p>
</li>
</ul>
<p><mark>百度</mark></p>
<ul>
<li><p>说一下 GC 算法，分代回收说下</p>
</li>
<li><p>垃圾收集策略和算法</p>
</li>
</ul>
<p><mark>天猫</mark></p>
<ul>
<li><p>JVM GC 原理，JVM 怎么回收内存</p>
</li>
<li><p>CMS 特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？</p>
</li>
</ul>
<p><mark>滴滴</mark></p>
<ul>
<li>Java 的垃圾回收器都有哪些，说下 g1 的应用场景，平时你是如何搭配使用垃圾回收器的</li>
</ul>
<p><mark>京东</mark></p>
<ul>
<li><p>你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms 和 G1，</p>
</li>
<li><p>包括原理，流程，优缺点。垃圾回收算法的实现原理</p>
</li>
</ul>
<p><mark>阿里</mark></p>
<ul>
<li><p>讲一讲垃圾回收算法。</p>
</li>
<li><p>什么情况下触发垃圾回收？</p>
</li>
<li><p>如何选择合适的垃圾收集算法？</p>
</li>
<li><p>JVM 有哪三种垃圾回收器？</p>
</li>
</ul>
<p><mark>字节跳动</mark></p>
<ul>
<li>常见的垃圾回收器算法有哪些，各有什么优劣？</li>
<li>System.gc（）和 Runtime.gc（）会做什么事情？</li>
<li>Java GC 机制？GC Roots 有哪些？</li>
<li>Java 对象的回收方式，回收算法。</li>
<li>CMS 和 G1 了解么，CMS 解决什么问题，说一下回收的过程。</li>
<li>CMS 回收停顿了几次，为什么要停顿两次?</li>
</ul>
</blockquote>
<h4 id="什么是垃圾？"><a href="#什么是垃圾？" class="headerlink" title="什么是垃圾？"></a>什么是垃圾？</h4><blockquote>
<p>An object is considered garbage when it can no longer be reached from any pointer in the running program</p>
</blockquote>
<p><strong>垃圾</strong>是指在<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾 。</p>
<p>如果不及时对内存中的垃圾进行清理，那么，这些垃圾对象所占的内存空间会一直保留到应用程序的结束，被保留的空间无法被其它对象使用，甚至可能导致内存溢出。</p>
<p><strong>磁盘碎片整理的日子</strong></p>
<p>机械硬盘需要进行磁盘整理，同时还有坏道</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/309e92079f207b99ecb61e0e61f59933.png" alt="image-20200712090848669"></p>
<h2 id="11-1-2-为什么需要-GC"><a href="#11-1-2-为什么需要-GC" class="headerlink" title="11.1.2. 为什么需要 GC"></a>11.1.2. 为什么需要 GC</h2><p><strong>想要学习 GC，首先需要理解为什么需要 GC？</strong></p>
<p>对于高级语言来说，一个基本认知是如果不进行垃圾回收，<mark>内存迟早都会被消耗完</mark>，因为不断地分配内存空间而不进行回收，就好像不停地生产生活垃圾而从来不打扫一样。</p>
<p>除了释放没用的对象，垃圾回收也可以清除内存里的记录碎片。碎片整理将所占用的堆内存移到堆的一端，以便<mark>JVM 将整理出的内存分配给新的对象</mark>。</p>
<p>随着应用程序所应付的业务越来越庞大、复杂，用户越来越多，<mark>没有 GC 就不能保证应用程序的正常进行</mark>。而经常造成 STW 的 GC 又跟不上实际的需求，所以才会不断地尝试对 GC 进行优化。</p>
<h2 id="11-1-3-早期垃圾回收"><a href="#11-1-3-早期垃圾回收" class="headerlink" title="11.1.3. 早期垃圾回收"></a>11.1.3. 早期垃圾回收</h2><p>在早期的 C/C++时代，垃圾回收基本上是手工进行的。开发人员可以使用 new 关键字进行内存申请，并使用 delete 关键字进行内存释放。比如以下代码：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge= <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line"><span class="comment">//如果注册失败，使用Delete释放该对象所占内存区域</span></span><br><span class="line"><span class="keyword">if</span> (pBridge-&gt;<span class="built_in">Register</span>(kDestroy) != NO ERROR）</span><br><span class="line">	<span class="keyword">delete</span> pBridge;</span><br></pre></td></tr></tbody></table></figure>

<p>这种方式可以灵活控制内存释放的时间，但是会给开发人员带来<mark>频繁申请和释放内存的管理负担</mark>。倘若有一处内存区间由于程序员编码的问题忘记被回收，那么就会产生<mark>内存泄漏</mark>，垃圾对象永远无法被清除，随着系统运行时间的不断增长，垃圾对象所耗内存可能持续上升，直到出现内存溢出并造成<mark>应用程序崩溃</mark>。</p>
<p>在有了垃圾回收机制后，上述代码极有可能变成这样</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MibBridge *pBridge = <span class="keyword">new</span> <span class="built_in">cmBaseGroupBridge</span>();</span><br><span class="line">pBridge-&gt;<span class="built_in">Register</span>(kDestroy);</span><br></pre></td></tr></tbody></table></figure>

<p>现在，除了 Java 以外，C#、Python、Ruby 等语言都使用了自动垃圾回收的思想，也是未来发展趋势，可以说这种自动化的内存分配和来及回收方式已经成为了现代开发语言必备的标准。</p>
<h2 id="11-1-4-Java-垃圾回收机制"><a href="#11-1-4-Java-垃圾回收机制" class="headerlink" title="11.1.4. Java 垃圾回收机制"></a>11.1.4. Java 垃圾回收机制</h2><p>自动内存管理，无需开发人员手动参与内存的分配与回收，这样<mark>降低内存泄漏和内存溢出的风险</mark></p>
<ul>
<li>没有垃圾回收器，java 也会和 cpp 一样，各种悬垂指针，野指针，泄露问题让你头疼不已。</li>
</ul>
<p>自动内存管理机制，将程序员从繁重的内存管理中释放出来，可以更专心地<mark>专注于业务开发</mark></p>
<p>oracle 官网关于垃圾回收的介绍 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html">https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/toc.html</a></p>
<h4 id="担忧"><a href="#担忧" class="headerlink" title="担忧"></a>担忧</h4><p>对于 Java 开发人员而言，自动内存管理就像是一个黑匣子，如果过度依赖于“自动”，那么这将会是一场灾难，最严重的就会<mark>弱化 Java 开发人员在程序出现内存溢出时定位问题和解决问题的能力</mark>。</p>
<p>此时，了解 JVM 的自动内存分配和内存回收原理就显得非常重要，只有在真正了解 JVM 是如何管理内存后，我们才能够在遇见 outofMemoryError 时，快速地根据错误异常日志定位问题和解决问题。</p>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些“自动化”的技术<mark>实施必要的监控和调节</mark>。</p>
<h4 id="GC-主要关注的区域"><a href="#GC-主要关注的区域" class="headerlink" title="GC 主要关注的区域"></a>GC 主要关注的区域</h4><p>GC 主要关注于 方法区 和堆中的垃圾收集</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c3e4606c5878ad5ae19f878e2585ee9f.png" alt="image-20200712092427246"></p>
<p>垃圾收集器可以对年轻代回收，也可以对老年代回收，甚至是全栈和方法区的回收。其中，<mark>Java 堆是垃圾收集器的工作重点</mark></p>
<p>从次数上讲：</p>
<ul>
<li><mark>频繁收集 Young 区</mark></li>
<li><mark>较少收集 Old 区</mark></li>
<li><mark>基本不收集 Perm 区（元空间）</mark></li>
</ul>
<h2 id="11-2-垃圾回收相关算法（面试的概率比较高）"><a href="#11-2-垃圾回收相关算法（面试的概率比较高）" class="headerlink" title="11.2. 垃圾回收相关算法（面试的概率比较高）"></a>11.2. 垃圾回收相关算法（面试的概率比较高）</h2><p><strong>对象存活判断</strong></p>
<p>在堆里存放着几乎所有的 Java 对象实例，在 GC 执行垃圾回收之前，首先<mark>需要区分出内存中哪些是存活对象，哪些是已经死亡的对象</mark>。<strong>只有被标记为己经死亡的对象，GC 才会在执行垃圾回收</strong>时，释放掉其所占用的内存空间，因此这个过程我们可以称为<mark>垃圾标记阶段</mark>。</p>
<p>那么在 JVM 中究竟是如何标记一个死亡对象呢？简单来说，当<strong>一个对象已经不再被任何的存活对象继续引用时，就可以宣判为已经死亡。</strong></p>
<p>判断对象存活一般有两种方式：<mark><strong>引用计数算法</strong></mark>和<mark><strong>可达性分析算法</strong></mark>。</p>
<h3 id="11-2-1-标记阶段：引用计数算法"><a href="#11-2-1-标记阶段：引用计数算法" class="headerlink" title="11.2.1. 标记阶段：引用计数算法"></a>11.2.1. 标记阶段：引用计数算法</h3><h4 id="方式一：引用计数算法"><a href="#方式一：引用计数算法" class="headerlink" title="方式一：引用计数算法"></a>方式一：引用计数算法</h4><p>引用计数算法（Reference Counting）比较简单，对每个对象保存一个整型的<mark>引用计数器属性。用于记录对象被引用的情况。</mark></p>
<p><strong>对于一个对象 A，只要有任何一个对象引用了 A，则 A 的引用计数器就加 1；当引用失效时，引用计数器就减 1。只要对象 A 的引用计数器的值为 0，即表示对象 A 不可能再被使用，可进行回收。</strong></p>
<p>优点：<mark>实现简单，垃圾对象便于辨识；判定效率高，回收没有延迟性。</mark></p>
<p>缺点：</p>
<ul>
<li>它需要单独的字段存储计数器，这样的做法增加了<mark>存储空间的开销</mark>。</li>
<li>每次赋值都需要更新计数器，伴随着加法和减法操作，这增加了<mark>时间开销</mark>。</li>
<li>引用计数器有一个严重的问题，即<mark>无法处理循环引用</mark>的情况。这是一条致命缺陷，导致在 Java 的垃圾回收器中<strong>没有</strong>使用这类算法。</li>
</ul>
<h4 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h4><p>当 p 的指针断开的时候，内部的引用形成一个循环，这就是循环引用</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1367a58058e6653d53afdea83b937af3.png" alt="image-20200712102205795"></p>
<p><strong>举例</strong></p>
<p>测试 Java 中是否采用的是引用计数算法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RefCountGC</span> {</span><br><span class="line">    <span class="comment">// 这个成员属性的唯一作用就是占用一点内存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] bigSize = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>*<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 引用</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">reference</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line">        <span class="type">RefCountGC</span> <span class="variable">obj2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RefCountGC</span>();</span><br><span class="line"></span><br><span class="line">        obj1.reference = obj2;</span><br><span class="line">        obj2.reference = obj1;</span><br><span class="line"></span><br><span class="line">        obj1 = <span class="literal">null</span>;</span><br><span class="line">        obj2 = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 显示的执行垃圾收集行为</span></span><br><span class="line">        <span class="comment">// 这里发生GC，obj1和obj2是否被回收？</span></span><br><span class="line">        System.gc();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">PSYoungGen: 15490K-&gt;808K(76288K)] 15490K-&gt;816K(251392K)</span><br></pre></td></tr></tbody></table></figure>

<p>上述进行了 GC 收集的行为，所以可以证明 JVM 中采用的不是引用计数器的算法</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/010896600bb4483f35d004dce60cc58b.png" alt="image-20200712103230349"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>引用计数算法，是很多语言的资源回收选择，例如因人工智能而更加火热的 Python，它更是同时支持引用计数和垃圾收集机制。</p>
<p>具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。</p>
<p>Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很<font color="red">难处理循环引用关系</font>。</p>
<p>Python 如何解决循环引用？</p>
<ul>
<li>手动解除：很好理解，就是在合适的时机，解除引用关系。 使用弱引用 weakref，weakref 是 Python 提供的标准库，旨在解决循环引用。</li>
</ul>
<h3 id="11-2-2-标记阶段：可达性分析算法"><a href="#11-2-2-标记阶段：可达性分析算法" class="headerlink" title="11.2.2. 标记阶段：可达性分析算法"></a>11.2.2. 标记阶段：可达性分析算法</h3><h4 id="方式二：可达性分析算法（根搜索算法、追踪性垃圾收集）"><a href="#方式二：可达性分析算法（根搜索算法、追踪性垃圾收集）" class="headerlink" title="方式二：可达性分析算法（根搜索算法、追踪性垃圾收集）"></a>方式二：可达性分析算法（根搜索算法、追踪性垃圾收集）</h4><p>相对于引用计数算法而言，可达性分析算法不仅同样具备实现简单和执行高效等特点，更重要的是该算法可以有效地<mark>解决在引用计数算法中循环引用的问题，防止内存泄漏的发生</mark>。</p>
<p>相较于引用计数算法，这里的可达性分析就是 Java、C#选择的。这种类型的垃圾收集通常也叫作<mark>追踪性垃圾收集（Tracing Garbage Collection）</mark></p>
<p>所谓”GCRoots”根集合就是一组必须活跃的引用。</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><ul>
<li>可达性分析算法是以根对象集合（GCRoots）为起始点，按照从上至下的方式<mark>搜索被根对象集合所连接的目标对象是否可达</mark>。</li>
<li>使用可达性分析算法后，内存中的存活对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<mark>引用链（Reference Chain）</mark></li>
<li>如果目标对象没有任何引用链相连，则是不可达的，就意味着该对象己经死亡，可以标记为垃圾对象。</li>
<li>在可达性分析算法中，只有能够被根对象集合直接或者间接连接的对象才是存活对象。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/071039dcf30672f55dfe8e5dab5e8081.png" alt="image-20210511195540451"></p>
<p><strong>在 Java 语言中，GC Roots 包括以下几类元素：</strong></p>
<ul>
<li>虚拟机栈中引用的对象<ul>
<li>比如：各个线程被调用的方法中使用到的参数、局部变量等。</li>
</ul>
</li>
<li>本地方法栈内 JNI（通常说的本地方法）引用的对象</li>
<li>方法区中类静态属性引用的对象<ul>
<li>比如：Java 类的引用类型静态变量</li>
</ul>
</li>
<li>方法区中常量引用的对象<ul>
<li>比如：字符串常量池（String Table）里的引用</li>
</ul>
</li>
<li>所有被同步锁 synchronized 持有的对象</li>
<li>Java 虚拟机内部的引用。<ul>
<li>基本数据类型对应的 Class 对象，一些常驻的异常对象（如：NullPointerException、OutOfMemoryError），系统类加载器。</li>
</ul>
</li>
<li>反映 java 虚拟机内部情况的 JMXBean、JVMTI 中注册的回调、本地代码缓存等。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d1ce4b570439851d57973a00684c6410.png" alt="image-20200712104622677"></p>
<p>( 栈，方法区，常量池，如果有引用堆空间里面的实体的话，比如里面那些蓝色的，就都是可达的对象，就不是垃圾。红色的那些就不可达的，就是垃圾 )</p>
<ul>
<li><p>除了这些固定的 GC Roots 集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象“临时性”地加入，共同构成完整 GC Roots 集合。比如：分代收集和局部回收（PartialGC）。</p>
<ul>
<li>如果只针对 Java 堆中的某一块区域进行垃圾回收（比如：典型的只针对新生代），必须考虑到内存区域是虚拟机自己的实现细节，更不是孤立封闭的，这个区域的对象完全有可能被其他区域的对象所引用，这时候就需要一并将关联的区域对象也加入 GCRoots 集合中去考虑，才能保证可达性分析的准确性。</li>
<li>比如: 非新生代的，比如说老年代，也会考虑作为GC Roots的一部分，因为单独看新生代的话，也有可能会被老年代的一些引用所指向了</li>
</ul>
</li>
<li><p>小技巧：  由于 Root 采用<strong>栈方式</strong>存放变量和指针，所以如果一个指针，它保存了堆内存里面的对象，但是自己又不存放在堆内存里面，那它就是一个 Root。</p>
</li>
</ul>
<p><strong>注意</strong></p>
<p>如果要使用可达性分析算法来判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行（比如，一个对象刚被引用完和表示可达的，就被标记上是垃圾了，这就不是一致性了，那肯定不行不符合的）。这点不满足的话分析结果的准确性就无法保证。</p>
<p>这点也是导致 GC 进行时必须“stop The World”的一个重要原因。</p>
<ul>
<li>即使是号称（几乎）不会发生停顿的 CMS 收集器中，枚举根节点时也是必须要停顿的。</li>
</ul>
<h3 id="11-2-3-对象的-finalization-机制"><a href="#11-2-3-对象的-finalization-机制" class="headerlink" title="11.2.3. 对象的 finalization 机制"></a>11.2.3. 对象的 finalization 机制</h3><p>Java 语言提供了对象终止（finalization）机制来允许开发人员提供<mark>对象被销毁之前的自定义处理逻辑</mark>（就是对象被销毁前加一些逻辑代码进行处理）。</p>
<p>当垃圾回收器发现没有引用指向一个对象，即：垃圾回收此对象之前，总会先调用这个对象的 finalize()方法。</p>
<p><img src="/../../../images/image-20221122223605544.png" alt="image-20221122223605544"></p>
<p><strong>finalize() 方法允许在子类中被重写，<mark>用于在对象被回收时进行资源释放</mark>。通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等。</strong></p>
<p>finalize() 方法本来是空的，没有重写finalize方法的话，调用了也没有什么意义，但即便是重写了，也不建议主动去调用，如下说明：</p>
<p>永远<strong>不要主动调用</strong>某个对象的 finalize()方法 ， 应该<strong>交给垃圾回收机制调用</strong>。理由包括下面三点：</p>
<ul>
<li>在 finalize()时可能会导致对象复活。</li>
<li>finalize()方法的执行时间是没有保障的（你调用它，它也不能保证马上执行），它完全由 GC 线程决定，极端情况下，若不发生 GC，则 finalize()方法将没有执行机会。</li>
<li>一个糟糕的 finalize()会严重影响 GC的性能。（比如，自己重写时写了个死循环在里面或是执行速度很慢，调用，那么GC的性能就会验证受影响）</li>
<li>它本来是空的，没有重写finalize方法的话，调用了也没有什么意义</li>
</ul>
<p>从功能上来说，finalize()方法与 C++中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize()方法在本质上不同于 C++中的析构函数。 </p>
<p>由于 finalize()方法的存在，<mark>虚拟机中的对象一般处于三种可能的状态</mark>（可触及的，可复活的，不可触及的）。</p>
<h4 id="生存还是死亡？"><a href="#生存还是死亡？" class="headerlink" title="生存还是死亡？"></a>生存还是死亡？</h4><p>如果从所有的根节点都无法访问到某个对象，说明对象己经不再使用了。一般来说，此对象需要被回收。但事实上，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段。<mark>一个无法触及的对象有可能在某一个条件下“复活”自己</mark>，如果这样，那么对它的回收就是不合理的，为此，定义虚拟机中的对象可能的三种状态。如下：</p>
<ul>
<li><mark>可触及的</mark>：从根节点开始，可以到达这个对象。</li>
<li><mark>可复活的</mark>：对象的所有引用都被释放，但是对象有可能在 finalize()中复活。</li>
<li><mark>不可触及的</mark>：对象的 finalize()被调用，并且没有复活，那么就会进入不可触及状态。不可触及的对象不可能被复活，因为<mark>finalize()只会被调用一次</mark>。</li>
</ul>
<p>以上 3 种状态中，是由于 inalize()方法的存在，进行的区分。只有在对象不可触及时才可以被回收。</p>
<h4 id="具体过程"><a href="#具体过程" class="headerlink" title="具体过程"></a>具体过程</h4><p>判定一个对象 objA 是否可回收，至少要经历<strong>两次标记</strong>过程：</p>
<ol>
<li>如果对象 objA 到 GC Roots 没有引用链，则进行<strong>第一次标记</strong>。</li>
<li>进行筛选，判断此对象是否有必要执行 finalize()方法</li>
<li>如果对象 objA 没有重写 finalize()方法，或者 finalize()方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li>
<li>如果对象 objA 重写了 finalize()方法，且还未执行过，那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize()方法执行。</li>
<li><mark>finalize()方法是对象逃脱死亡的最后机会</mark>，稍后 GC 会对 F-Queue 队列中的对象进行<strong>第二次标记</strong>。如果 objA 在 finalize()方法中与引用链上的任何一个对象建立了联系，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的 finalize 方法只会被调用一次</strong>。</li>
</ol>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanReliveObj</span> {</span><br><span class="line">    <span class="comment">// 类变量，属于GC Roots的一部分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> CanReliveObj canReliveObj;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable {</span><br><span class="line">        <span class="built_in">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"调用当前类重写的finalize()方法"</span>);</span><br><span class="line">        canReliveObj = <span class="built_in">this</span>;   <span class="comment">// 当前待回收的对象在 finalize() 方法中与引用链上的一个对象canReliveObj建立联系</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException {</span><br><span class="line">        canReliveObj = <span class="keyword">new</span> <span class="title class_">CanReliveObj</span>();</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"-----------------第一次gc操作------------"</span>);</span><br><span class="line">        <span class="comment">// 因为Finalizer线程的优先级比较低，暂停2秒，以等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------第二次gc操作------------"</span>);</span><br><span class="line">        canReliveObj = <span class="literal">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 下面代码和上面代码是一样的，但是 canReliveObj却自救失败了</span></span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">if</span> (canReliveObj == <span class="literal">null</span>) {</span><br><span class="line">            System.out.println(<span class="string">"obj is dead"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            System.out.println(<span class="string">"obj is still alive"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-----------------第一次gc操作------------</span><br><span class="line">调用当前类重写的finalize()方法</span><br><span class="line">obj is still alive</span><br><span class="line">-----------------第二次gc操作------------</span><br><span class="line">obj is dead</span><br></pre></td></tr></tbody></table></figure>

<p>在第一次 GC 时，执行了 finalize 方法，但 finalize()方法只会被调用一次，所以第二次该对象被 GC 标记并清除了。</p>
<h3 id="11-2-4-MAT-与-JProfiler-的-GC-Roots-溯源"><a href="#11-2-4-MAT-与-JProfiler-的-GC-Roots-溯源" class="headerlink" title="11.2.4. MAT 与 JProfiler 的 GC Roots 溯源"></a>11.2.4. MAT 与 JProfiler 的 GC Roots 溯源</h3><h4 id="MAT-是什么？"><a href="#MAT-是什么？" class="headerlink" title="MAT 是什么？"></a>MAT 是什么？</h4><p>MAT 是 Memory Analyzer 的简称，它是一款功能强大的 Java 堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。</p>
<p>MAT 是基于 Eclipse 开发的，是一款免费的性能分析工具。</p>
<p>大家可以在 <a target="_blank" rel="noopener" href="http://www.eclipse.org/mat/">http://www.eclipse.org/mat/</a> 下载并使用 MAT</p>
<h4 id="获取-dump-文件"><a href="#获取-dump-文件" class="headerlink" title="获取 dump 文件"></a>获取 dump 文件</h4><h5 id="方式一：命令行使用-jmap"><a href="#方式一：命令行使用-jmap" class="headerlink" title="方式一：命令行使用 jmap"></a>方式一：命令行使用 jmap</h5><p><img src="https://img-blog.csdnimg.cn/img_convert/f8cc8bd3ef9526b497bcc4335e84e639.png" alt="image-20210512105418987"></p>
<h5 id="方式二：使用-JVisualVM-导出"><a href="#方式二：使用-JVisualVM-导出" class="headerlink" title="方式二：使用 JVisualVM 导出"></a>方式二：使用 JVisualVM 导出</h5><p>捕获的 heap dump 文件是一个临时文件，关闭 JVisualVM 后自动删除，若要保留，需要将其另存为文件。</p>
<p>可通过以下方法捕获 heap dump：</p>
<ul>
<li><p>在左侧“Application”（应用程序）子窗口中右击相应的应用程序，选择 Heap Dump（堆 Dump）。</p>
</li>
<li><p>在 Monitor（监视）子标签页中点击 Heap Dump（堆 Dump）按钮。</p>
</li>
</ul>
<p>本地应用程序的 Heap dumps 作为应用程序标签页的一个子标签页打开。同时，heap dump 在左侧的 Application（应用程序）栏中对应一个含有时间戳的节点。</p>
<p>右击这个节点选择 save as（另存为）即可将 heap dump 保存到本地。</p>
<h5 id="方式三：使用-MAT-打开-Dump-文件"><a href="#方式三：使用-MAT-打开-Dump-文件" class="headerlink" title="方式三：使用 MAT 打开 Dump 文件"></a>方式三：使用 MAT 打开 Dump 文件</h5><p><img src="/../../../images/image-20221123091417318.png" alt="image-20221123091417318"></p>
<h4 id="JProfiler-的-GC-Roots-溯源"><a href="#JProfiler-的-GC-Roots-溯源" class="headerlink" title="JProfiler 的 GC Roots 溯源"></a>JProfiler 的 GC Roots 溯源</h4><p>（本身这个对象我已经不想用它了，它已经不再会被使用了，它就是垃圾，但是当我们用Class分析算法时，会发现，它直接或间接地还被GC Roots关联着，导致还没办法将它GC，这就是java真正的内存泄露。那出现内存泄漏， 我们可以溯源，发现它确实和GC Roots连上了，那可以在适当的位置给它断开。所以我们在开发中，一般都会看某个对象上的GC Roots是什么，这就是<strong>GC Roots溯源</strong>）</p>
<p>我们在实际的开发中，一般不会查找全部的 GC Roots，可能只是查找某个对象的整个链路，或者称为 GC Roots 溯源，这个时候，我们就可以使用 JProfiler</p>
<p><img src="/../../../images/image-20221123093811032.png" alt="image-20221123093811032"></p>
<p>view –&gt; Mark Current Values</p>
<p><img src="/../../../images/image-20221123093839170.png" alt="image-20221123093839170"></p>
<p><img src="/../../../images/image-20221123094354023.png" alt="image-20221123094354023"></p>
<p>可以将当前对象基于当前节点后的个数的变化的值展现出来，便可以看到有哪些对象变化比较大，变化比较大的就是我们要关注的一些对象了。</p>
<p>对象个数比较大或是说占用空间比较大，当我们GC（点击Run GC）的时候，我们还始终回收不了它们</p>
<p><img src="/../../../images/image-20221123094522918.png" alt="image-20221123094522918"></p>
<p>我们发现char数组对象比较多，我们可以鼠标指着–&gt;点右键–&gt;Show Selection In Heap Walker–&gt;ok</p>
<p><img src="/../../../images/image-20221123094721985.png" alt="image-20221123094721985"></p>
<p>分配，大对象，相关引用。我们更关注的是引用，引用用得比较多</p>
<p><img src="/../../../images/image-20221123095009723.png" alt="image-20221123095009723"></p>
<p>点击References之后，就可以看到所有的参数。想知道有哪些有内存泄漏问题，就可以做GC Roots溯源</p>
<p><img src="/../../../images/image-20221123095352781.png" alt="image-20221123095352781"></p>
<p><img src="/../../../images/image-20221123092829645.png" alt="image-20221123092829645"></p>
<p>Outgoing references：定位代码的大概位置</p>
<p>Incoming references：判断和哪个GC Roots是相关联的</p>
<p><img src="/../../../images/image-20221123093245549.png" alt="image-20221123093245549"></p>
<h3 id="11-2-5-清除阶段：标记-清除算法"><a href="#11-2-5-清除阶段：标记-清除算法" class="headerlink" title="11.2.5. 清除阶段：标记-清除算法"></a>11.2.5. 清除阶段：标记-清除算法</h3><p>当成功区分出内存中存活对象和死亡对象后，GC 接下来的任务就是执行垃圾回收，释放掉无用对象所占用的内存空间，以便有足够的可用内存空间为新对象分配内存。</p>
<p>目前在 JVM 中比较常见的三种<font color="red">垃圾收集算法</font>是<mark>标记一清除算法（Mark-Sweep）、复制算法（copying）、标记-压缩算法（Mark-Compact）</mark></p>
<h4 id="标记-清除（Mark-Sweep）算法"><a href="#标记-清除（Mark-Sweep）算法" class="headerlink" title="标记-清除（Mark-Sweep）算法"></a>标记-清除（Mark-Sweep）算法</h4><p>标记-清除算法（Mark-Sweep）是一种非常基础和常见的垃圾收集算法，该算法被 J.McCarthy 等人在 1960 年提出并并应用于 Lisp 语言。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>当堆中的有效内存空间（available memory）被耗尽的时候，就会停止整个程序（也被称为 stop the world），然后进行两项工作，第一项则是标记，第二项则是清除</p>
<ul>
<li><p><mark>标记</mark>：Collector 从引用根节点开始遍历，标记所有被引用的对象（即GC Roots可到达的对象）。一般是在对象的 Header 中记录为可达对象。</p>
</li>
<li><p><mark>清除</mark>：Collector 对堆内存从头到尾进行线性的遍历，如果发现某个对象在其 Header 中没有标记为可达对象，则将其回收</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8ea506a5c45c10410418ff0403e2b3a8.png" alt="image-20200712150935078"></p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>标记清除算法的效率不算高（全部对象都要遍历）</li>
<li>在进行 GC 的时候，需要停止整个应用程序，用户体验较差</li>
<li>这种方式清理出来的<strong>空闲内存是不连续的，产生内碎片</strong>，需要维护一个空闲列表</li>
</ul>
<h4 id="何为清除？"><a href="#何为清除？" class="headerlink" title="何为清除？"></a>何为清除？</h4><p>这里所谓的清除并<strong>不是真的置空</strong>，而是<strong>把需要清除的对象地址保存在空闲的地址列表里</strong>。下次有新对象需要加载时，判断垃圾的位置空间是否够，如果够，就存放，<strong>覆盖原有的地址</strong>。</p>
<h3 id="11-2-6-清除阶段：复制算法"><a href="#11-2-6-清除阶段：复制算法" class="headerlink" title="11.2.6. 清除阶段：复制算法"></a>11.2.6. 清除阶段：复制算法</h3><h4 id="复制（Copying）算法"><a href="#复制（Copying）算法" class="headerlink" title="复制（Copying）算法"></a>复制（Copying）算法</h4><p>为了解决标记-清除算法在垃圾收集效率方面的缺陷，M.L.Minsky 于 1963 年发表了著名的论文，“使用双存储区的 Lisp 语言垃圾收集器 CA LISP Garbage Collector Algorithm Using Serial Secondary Storage）”。M.L.Minsky 在该论文中描述的算法被人们称为复制（Copying）算法，它也被 M.L.Minsky 本人成功地引入到了 Lisp 语言的一个实现版本中。</p>
<h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h4><p>将活着的内存<strong>空间分为两块</strong>，每次只使用其中一块，在垃圾回收时将正在使用的内存中的存活对象复制到未被使用的内存块中，之后清除正在使用的内存块中的所有对象，交换两个内存的角色，最后完成垃圾回收</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b508a12ff6282839b65f8be9a683e04b.png" alt="image-20200712151916991"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>没有标记和清除过程，实现简单，运行高效</li>
<li>复制过去以后保证空间的连续性，不会出现“碎片”问题。</li>
</ul>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>此算法的缺点也是很明显的，就是需要两倍的内存空间。</li>
<li>对于 G1 这种分拆成为大量 region 的 GC，复制而不是移动，意味着 GC 需要维护 region 之间对象引用关系，不管是内存占用或者时间开销也不小</li>
</ul>
<h4 id="特别的"><a href="#特别的" class="headerlink" title="特别的"></a>特别的</h4><p>如果系统中的垃圾对象很多，复制算法不会很理想（复制太多的话，最后发现回收的不多，而且还要维护 region 之间对象引用关系还很多）。因为复制算法需要复制的存活对象数量并不会太大，或者说非常低才行</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在<strong>新生代</strong>，对常规应用的垃圾回收，一次通常可以回收 70% - 99% 的内存空间。回收性价比很高。所以现在的商业虚拟机都是用这种收集算法回收新生代。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a911b5f7d17bd00fda883623e4d831a.png" alt="image-20200712152847218"></p>
<h3 id="11-2-7-清除阶段：标记-压缩（整理）算法"><a href="#11-2-7-清除阶段：标记-压缩（整理）算法" class="headerlink" title="11.2.7. 清除阶段：标记-压缩（整理）算法"></a>11.2.7. 清除阶段：标记-压缩（整理）算法</h3><h4 id="标记-压缩（或标记-整理、Mark-Compact）算法"><a href="#标记-压缩（或标记-整理、Mark-Compact）算法" class="headerlink" title="标记-压缩（或标记-整理、Mark-Compact）算法"></a>标记-压缩（或标记-整理、Mark-Compact）算法</h4><p>复制算法的高效性是建立在存活对象少、垃圾对象多的前提下的。这种情况在新生代经常发生，但是在老年代，更常见的情况是大部分对象都是存活对象。如果依然使用复制算法，由于存活对象较多，复制的成本也将很高。因此，基于老年代垃圾回收的特性，需要使用其他的算法。</p>
<p>标记一清除算法的确可以应用在老年代中，但是该算法不仅执行效率低下，而且在执行完内存回收后还会产生内存碎片，所以 JVM 的设计者需要在此基础之上进行改进。标记-压缩（Mark-Compact）算法由此诞生。</p>
<p>1970 年前后，G.L.Steele、C.J.Chene 和 D.s.Wise 等研究者发布标记-压缩算法。在许多现代的垃圾收集器中，人们都使用了标记-压缩算法或其改进版本。</p>
<h4 id="执行过程-1"><a href="#执行过程-1" class="headerlink" title="执行过程"></a>执行过程</h4><ol>
<li><p>第一阶段和标记清除算法一样，从根节点开始标记所有被引用对象</p>
</li>
<li><p>第二阶段将所有的存活对象压缩到内存的一端，按顺序排放。</p>
</li>
<li><p>之后，清理边界外所有的空间。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/aac06de20fada1a602f1955010bd969d.png" alt="image-20200712153236508"></p>
<p>标记-压缩算法的最终效果等同于标记-清除算法执行完成后，再进行一次内存碎片整理，因此，也可以把它称为<mark>标记-清除-压缩（Mark-Sweep-Compact）算法</mark>。</p>
<p>二者的本质差异在于标记-清除算法是一种<mark>非移动式的回收算法</mark>，标记-压缩是移动式的。是否移动回收后的存活对象是一项优缺点并存的风险决策。可以看到，标记的存活对象将会被整理，按照内存地址依次排列，而未被标记的内存会被清理掉。如此一来，<strong>当我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可，这比维护一个空闲列表显然少了许多开销。</strong> </p>
<h4 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h4><p>如果内存空间以规整和有序的方式分布，即已用和未用的内存都各自一边，彼此之间维系着一个记录下一次分配起始点的标记指针，当为新对象分配内存时，只需要通过修改指针的偏移量将新对象分配在第一个空闲内存位置上，这种分配方式就叫做指针碰撞（Bump tHe Pointer）。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul>
<li>消除了标记-清除算法当中，内存区域分散的缺点，我们需要给新对象分配内存时，JVM 只需要持有一个内存的起始地址即可。</li>
<li>消除了复制算法当中，内存减半的高额代价。</li>
</ul>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>从效率上来说，标记-整理算法要低于复制算法。</li>
<li>移动对象的同时，如果对象被其他对象引用，则还需要调整引用的地址</li>
<li>移动过程中，需要全程暂停用户应用程序。即：STW</li>
</ul>
<h3 id="11-2-8-小结"><a href="#11-2-8-小结" class="headerlink" title="11.2.8. 小结"></a>11.2.8. 小结</h3><p>对比三种算法</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Mark-Sweep</th>
<th align="left">Mark-Compact</th>
<th align="left">Copying</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>速率</strong></td>
<td align="left">中等</td>
<td align="left">最慢</td>
<td align="left">最快</td>
</tr>
<tr>
<td align="left"><strong>空间开销</strong></td>
<td align="left">少（但会堆积碎片）</td>
<td align="left">少（不堆积碎片）</td>
<td align="left">通常需要活对象的 2 倍空间（不堆积碎片）</td>
</tr>
<tr>
<td align="left"><strong>移动对象</strong></td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
</tbody></table>
<p>效率上来说，复制算法是当之无愧的老大，但是却浪费了太多内存。</p>
<p>而为了尽量兼顾上面提到的三个指标，标记-整理算法相对来说更平滑一些，但是效率上不尽如人意，它比复制算法多了一个标记的阶段，比标记-清除多了一个整理内存的阶段</p>
<p>难道就没有一种最优算法吗？</p>
<p>回答：无，没有最好的算法，只有最合适的算法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cdb03d2691d80ca89da2805015ad31e9.png" alt="image-20210512104415281"></p>
<h3 id="11-2-9-分代收集算法"><a href="#11-2-9-分代收集算法" class="headerlink" title="11.2.9. 分代收集算法"></a>11.2.9. 分代收集算法</h3><p>前面所有这些算法中，并没有一种算法可以完全替代其他算法，它们都具有自己独特的优势和特点。分代收集算法应运而生。</p>
<p>分代收集算法，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，<mark>不同生命周期的对象可以采取不同的收集方式</mark>，以便提高回收效率。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点使用不同的回收算法，以提高垃圾回收的效率。</p>
<p>在 Java 程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如<mark>Http 请求中的 Session 对象、线程、Socket 连接</mark>，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：<mark>String 对象</mark>，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。</p>
<p><mark>目前几乎所有的 GC 都采用分代手机算法执行垃圾回收的。</mark></p>
<p><strong>在 HotSpot 中，基于分代的概念，GC 所使用的内存回收算法必须结合年轻代和老年代各自的特点。</strong></p>
<h4 id="年轻代（Young-Gen）"><a href="#年轻代（Young-Gen）" class="headerlink" title="年轻代（Young Gen）"></a>年轻代（Young Gen）</h4><p>年轻代特点：区域相对老年代较小，对象生命周期短、存活率低，回收频繁。</p>
<p>这种情况复制算法的回收整理，速度是最快的。复制算法的效率只和当前存活对象大小有关，因此很适用于年轻代的回收。而<strong>复制算法内存利用率不高的问题，通过 hotspot 中的两个 survivor 的设计得到缓解。</strong></p>
<h4 id="老年代（Tenured-Gen）"><a href="#老年代（Tenured-Gen）" class="headerlink" title="老年代（Tenured Gen）"></a>老年代（Tenured Gen）</h4><p><mark>老年代特点：区域较大，对象生命周期长、存活率高，回收不及年轻代频繁</mark>。</p>
<p>这种情况存在大量存活率高的对象，复制算法明显变得不合适。一般是由标记-清除或者是标记-清除与标记-整理的混合实现。</p>
<ul>
<li>Mark 阶段的开销与存活对象的数量成正比。</li>
<li>Sweep 阶段的开销与所管理区域的大小成正相关。</li>
<li>Compact 阶段的开销与存活对象的数据成正比。</li>
</ul>
<p>以 HotSpot 中的 CMS 回收器为例，CMS 是基于 Mark-Sweep 实现的，对于对象的回收效率很高。而对于碎片问题，CMS 采用基于 Mark-Compact 算法的 Serial Old 回收器作为补偿措施：当内存回收不佳（碎片导致的 Concurrent Mode Failure 时），将采用 Serial Old 执行 Full GC 以达到对老年代内存的整理。</p>
<p>分代的思想被现有的虚拟机广泛使用。几乎所有的垃圾回收器都区分新生代和老年代</p>
<h3 id="11-2-X-增量收集算法、分区算法"><a href="#11-2-X-增量收集算法、分区算法" class="headerlink" title="11.2.X. 增量收集算法、分区算法"></a>11.2.X. 增量收集算法、分区算法</h3><h4 id="增量收集算法"><a href="#增量收集算法" class="headerlink" title="增量收集算法"></a>增量收集算法</h4><p>上述现有的算法，在垃圾回收过程中，应用软件将处于一种 Stop the World 的状态。在 Stop the World 状态下，应用程序所有的线程都会挂起，暂停一切正常的工作，等待垃圾回收的完成。如果垃圾回收时间过长，应用程序会被挂起很久，将<mark>严重影响用户体验或者系统的稳定性</mark>。为了解决这个问题，即对实时垃圾收集算法的研究直接导致了增量收集（Incremental Collecting）算法的诞生。</p>
<h5 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h5><p>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替执行。每次，<mark>垃圾收集线程只收集一小片区域的内存空间，接着切换到应用程序线程。依次反复，直到垃圾收集完成</mark>。</p>
<p>总的来说，增量收集算法的基础仍是传统的标记-清除和复制算法。增量收集算法通过<mark>对线程间冲突的妥善处理，允许垃圾收集线程以分阶段的方式完成标记、清理或复制工作</mark></p>
<h5 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h5><p>使用这种方式，由于在垃圾回收过程中，间断性地还执行了应用程序代码，所以能减少系统的停顿时间。但是，因为线程切换和上下文转换的消耗，会使得垃圾回收的总体成本上升，<mark>造成系统吞吐量的下降</mark>。</p>
<h4 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h4><p>一般来说，在相同条件下，堆空间越大，一次 Gc 时所需要的时间就越长，有关 GC 产生的停顿也越长。为了更好地控制 GC 产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理地回收若干个小区间，而不是整个堆空间，从而减少一次 GC 所产生的停顿。</p>
<p>分代算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。</p>
<p>每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/34de5a2cce0c5e9c88f76652b674877d.png" alt="image-20200712165318590"></p>
<h4 id="写到最后"><a href="#写到最后" class="headerlink" title="写到最后"></a>写到最后</h4><p>注意，这些只是基本的算法思路，实际 GC 实现过程要复杂的多，目前还在发展中的前沿 GC 都是复合算法，并且并行和并发兼备。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/11.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%AE%97%E6%B3%95/" data-id="cliiv9kvn008a3kv614rccxkr" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/10. StringTable" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10.%20StringTable/" class="article-date">
  <time class="post-time" datetime="2022-11-21T01:52:16.546Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10.%20StringTable/">10. StringTable</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="10-StringTable"><a href="#10-StringTable" class="headerlink" title="10. StringTable"></a>10. StringTable</h1><h2 id="10-1-String-的基本特性"><a href="#10-1-String-的基本特性" class="headerlink" title="10.1. String 的基本特性"></a>10.1. String 的基本特性</h2><ul>
<li>String：字符串，使用一对””引起来表示</li>
<li>String 声明为 final 的，不可被继承</li>
<li>String 实现了 Serializable 接口：表示字符串是支持序列化的。</li>
<li>String 实现了 Comparable 接口：表示 string 可以比较大小</li>
<li>String 在 jdk8 及以前内部定义了 final char[] value 用于存储字符串数据。JDK9 时改为 byte[]</li>
</ul>
<h3 id="10-1-1-String-在-jdk9-中存储结构变更"><a href="#10-1-1-String-在-jdk9-中存储结构变更" class="headerlink" title="10.1.1. String 在 jdk9 中存储结构变更"></a>10.1.1. String 在 jdk9 中存储结构变更</h3><p>官网地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/254">JEP 254: Compact Strings (java.net)</a></p>
<blockquote>
<h2 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h2><p>The current implementation of the <code>String</code> class stores characters in a <code>char</code> array, using two bytes (sixteen bits) for each character. Data gathered from many different applications indicates that strings are a major component of heap usage and, moreover, that most <code>String</code> objects contain only Latin-1 characters. Such characters require only one byte of storage, hence half of the space in the internal <code>char</code> arrays of such <code>String</code> objects is going unused.</p>
<h2 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h2><p>We propose to change the internal representation of the <code>String</code> class from a UTF-16 <code>char</code> array to a <code>byte</code> array plus an encoding-flag field. The new <code>String</code> class will store characters encoded either as ISO-8859-1/Latin-1 (one byte per character), or as UTF-16 (two bytes per character), based upon the contents of the string. The encoding flag will indicate which encoding is used.</p>
<p>String-related classes such as <code>AbstractStringBuilder</code>, <code>StringBuilder</code>, and <code>StringBuffer</code> will be updated to use the same representation, as will the HotSpot VM’s intrinsic string operations.</p>
<p>This is purely an implementation change, with no changes to existing public interfaces. There are no plans to add any new public APIs or other interfaces.</p>
<p>The prototyping work done to date confirms the expected reduction in memory footprint, substantial reductions of GC activity, and minor performance regressions in some corner cases.</p>
</blockquote>
<p><strong>动机</strong></p>
<p>目前 String 类的实现将字符存储在一个 char 数组中，每个字符使用两个字节（16 位）。从许多不同的应用中收集到的数据表明，字符串是堆使用的主要组成部分，此外，大多数字符串对象只包含 Latin-1 字符。这些字符只需要一个字节的存储空间，因此这些字符串对象的内部字符数组中有一半的空间没有被使用。</p>
<p><strong>说明</strong></p>
<p>我们建议将 String 类的内部表示方法从 UTF-16 字符数组改为字节数组加编码标志域。新的 String 类将根据字符串的内容，以 ISO-8859-1/Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的方式存储字符编码。编码标志将表明使用的是哪种编码。</p>
<hr>
<p>与字符串相关的类，如<mark>AbstractStringBuilder、StringBuilder 和 StringBuffer 将被更新以使用相同的表示方法，HotSpot VM 的内在字符串操作也是如此</mark>。</p>
<p>这纯粹是一个实现上的变化，对现有的公共接口没有变化。目前没有计划增加任何新的公共 API 或其他接口。</p>
<p>迄今为止所做的原型设计工作证实了内存占用的预期减少，GC 活动的大幅减少，以及在某些角落情况下的轻微性能倒退。</p>
<p>结论：<mark><strong>String 再也不用 char[] 来存储了，改成了 byte [] 加上编码标记，节约了一些空间</strong></mark></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span> <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence {</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">byte</span>[] value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-1-2-String-的基本特性"><a href="#10-1-2-String-的基本特性" class="headerlink" title="10.1.2. String 的基本特性"></a>10.1.2. String 的基本特性</h3><p>String：代表不可变的字符序列。简称：不可变性。</p>
<ul>
<li>当对字符串<strong>重新赋值</strong>时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当对现有的字符串进行<strong>连接</strong>操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当调用 string 的 **replace()**方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
</ul>
<p>通过字面量的方式（区别于 new）给一个字符串赋值，此时的字符串值声明在字符串常量池中。</p>
<p><mark>字符串常量池是不会存储相同内容的字符串的</mark></p>
<p>String 的 String Pool 是一个固定大小的 Hashtable，默认值大小长度是 1009。如果放进 String Pool 的 String 非常多，就会造成 Hash 冲突严重，从而导致链表会很长，而<strong>链表长了后直接会造成的影响就是当调用 String.intern 时性能会大幅下降</strong>。</p>
<p>如：通过设置不同长度来测试性能：<img src="/../../../images/image-20221121105838424.png" alt="image-20221121105838424"></p>
<p>使用<code>-XX:StringTablesize</code>可设置 StringTable 的长度</p>
<ul>
<li>在 jdk6 中 StringTable 是固定的，就是 1009 的长度，所以如果常量池中的字符串过多就会导致效率下降很快。StringTablesize 设置没有要求</li>
<li>在 jdk7 中，StringTable 的长度默认值是 60013，StringTablesize 设置没有要求</li>
<li>在 JDK8 中，设置 StringTable 长度的话，1009 是可以设置的最小值<ul>
<li>如果设置小于1009的话，就会报如下错误：<img src="/../../../images/image-20221121105440727.png" alt="image-20221121105440727"></li>
</ul>
</li>
</ul>
<p>例子：（String 的基本使用，体现String的不可变性）</p>
<p><img src="/../../../images/image-20221121102353645.png" alt="image-20221121102353645"></p>
<p><img src="/../../../images/image-20221121100748082.png" alt="image-20221121100748082"></p>
<p><img src="/../../../images/image-20221121102438865.png" alt="image-20221121102438865"></p>
<p>无论你是char数组还是byte数组，字符串一旦定义好了，其实字符串底层的数组长度就定死了，要想往后面拼接的话，数组扩容本身也不能往后补，就得重新造一个。其二的话，堆空间中的字符串常量池，只要你修改，就得去重新创建，这就体现了不可变性</p>
<p><img src="/../../../images/image-20221121102458111.png" alt="image-20221121102458111"></p>
<p>面试题：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一道String的面试题</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"good"</span>);</span><br><span class="line">    <span class="type">char</span>[] ch = {<span class="string">'t'</span>, <span class="string">'e'</span>, <span class="string">'s'</span>, <span class="string">'t'</span>};</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">change</span><span class="params">(String str, <span class="type">char</span> ch[])</span> {</span><br><span class="line">        str = <span class="string">"test ok"</span>;</span><br><span class="line">        ch[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">StringExer</span> <span class="variable">ex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringExer</span>();</span><br><span class="line">        ex.change(ex.str, ex.ch);</span><br><span class="line">        System.out.println(ex.str); <span class="comment">// good</span></span><br><span class="line">        System.out.println(ex.ch);  <span class="comment">// best</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39552268/article/details/111415291">(5条消息) java 中String到底是值传递还是引用传递的问题_技术无产者的博客-CSDN博客</a></p>
<h2 id="10-2-String-的内存分配"><a href="#10-2-String-的内存分配" class="headerlink" title="10.2. String 的内存分配"></a>10.2. String 的内存分配</h2><p>在 Java 语言中有 8 种基本数据类型和一种比较特殊的类型 String。这些类型为了使它们在运行过程中速度更快、更节省内存，都提供了一种常量池的概念。</p>
<p>常量池就类似一个 Java 系统级别提供的缓存。8 种基本数据类型的常量池都是系统协调的，<mark>String 类型的常量池比较特殊。它的主要使用方法有两种。</mark></p>
<ul>
<li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。</p>
</li>
<li><p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern()方法。这个后面重点谈</p>
</li>
</ul>
<p>Java 6 及以前，字符串常量池存放在<strong>永久代</strong></p>
<p>如：字符串常量池装不下时报oom显示永久代PermGen空间：<img src="/../../../images/image-20221121111144881.png" alt="image-20221121111144881"></p>
<p>Java 7 中 Oracle 的工程师对字符串池的逻辑做了很大的改变，即将<mark>字符串常量池的位置调整到 Java <strong>堆内</strong></mark></p>
<ul>
<li>所有的字符串都保存在堆（Heap）中，和其他普通对象一样，这样可以让你在进行调优应用时仅需要调整堆大小就可以了。</li>
<li>字符串常量池概念原本使用得比较多，但是这个改动使得我们有足够的理由让我们重新考虑在 Java 7 中使用<code>String.intern()</code>。</li>
</ul>
<p>如：字符串常量池装不下时报oom显示堆空间（和jdk8一样）：<img src="/../../../images/image-20221121111122217.png" alt="image-20221121111122217"></p>
<p>Java8 元空间，字符串常量在<strong>堆</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/27b7bf706fc1724baf503eac9b49c7fc.png" alt="image-20200711093546398"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c59830deeebca85d5b2e446211e4e28d.png" alt="image-20200711093558709"></p>
<p><strong>StringTable 为什么要调整？</strong></p>
<p>官网地址：<a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/javase/jdk7-relnotes.html#jdk7changes">Java SE 7 Features and Enhancements (oracle.com)</a></p>
<blockquote>
<p><strong>Synopsis:</strong> In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the <code>String.intern()</code> method will see more significant differences.</p>
</blockquote>
<p>简介：在 JDK 7 中，内部字符串不再分配在 Java 堆的永久代中，而是分配在 Java 堆的主要部分（称为年轻代和老年代），与应用程序创建的其他对象一起。这种变化将导致更多的数据驻留在主 Java 堆中，而更少的数据在永久代中，因此可能需要调整堆的大小。大多数应用程序将看到由于这一变化而导致的堆使用的相对较小的差异，但<mark>加载许多类或大量使用 String.intern()方法的大型应用程序将看到更明显的差异</mark>。</p>
<h2 id="10-3-String-的基本操作"><a href="#10-3-String-的基本操作" class="headerlink" title="10.3. String 的基本操作"></a>10.3. String 的基本操作</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">    System.out.println();    <span class="comment">//2320</span></span><br><span class="line">    System.out.println(<span class="string">"1"</span>); <span class="comment">//2321</span></span><br><span class="line">    System.out.println(<span class="string">"2"</span>);</span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(<span class="string">"5"</span>);</span><br><span class="line">    System.out.println(<span class="string">"6"</span>);</span><br><span class="line">    System.out.println(<span class="string">"7"</span>);</span><br><span class="line">    System.out.println(<span class="string">"8"</span>);</span><br><span class="line">    System.out.println(<span class="string">"9"</span>);</span><br><span class="line">    System.out.println(<span class="string">"10"</span>); <span class="comment">//2330</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面的字符串就不会再次加载进字符串常量池了，因为上面都已经加载过了，常量池汇中都有了</span></span><br><span class="line">    System.out.println(<span class="string">"1"</span>); <span class="comment">//2321</span></span><br><span class="line">    System.out.println(<span class="string">"2"</span>); <span class="comment">//2322</span></span><br><span class="line">    System.out.println(<span class="string">"3"</span>);</span><br><span class="line">    System.out.println(<span class="string">"4"</span>);</span><br><span class="line">    System.out.println(l<span class="string">"5"</span>);</span><br><span class="line">    System.out.println(<span class="string">"6"</span>);</span><br><span class="line">    System.out.println(<span class="string">"7"</span>);</span><br><span class="line">    System.out.println(<span class="string">"8"</span>);</span><br><span class="line">    System.out.println(<span class="string">"9"</span>);</span><br><span class="line">    System.out.println(<span class="string">"10"</span>);<span class="comment">//2330</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>debug模式查看:</p>
<p><img src="/../../../images/image-20221121113447184.png" alt="image-20221121113447184"></p>
<p>Java 语言规范里要求完全相同的字符串字面量，应该包含同样的 Unicode 字符序列（包含同一份码点序列的常量），并且必须是指向同一个 String 类实例。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Memory</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {<span class="comment">//line 1</span></span><br><span class="line">        <span class="type">int</span> i= <span class="number">1</span>;<span class="comment">//line 2</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//line 3</span></span><br><span class="line">        <span class="type">Memory</span> <span class="variable">mem</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Memory</span>();<span class="comment">//Line 4</span></span><br><span class="line">        mem.foo(obj);<span class="comment">//Line 5</span></span><br><span class="line">    }<span class="comment">//Line 9</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(Object param)</span> {<span class="comment">//line 6</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> param.toString();<span class="comment">//line 7</span></span><br><span class="line">        System.out.println(str);</span><br><span class="line">    }<span class="comment">//Line 8</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/0ca01e17abb22f0fa16e87dd93b26a65.png" alt="image-20210511111607132"></p>
<h2 id="10-4-字符串拼接操作"><a href="#10-4-字符串拼接操作" class="headerlink" title="10.4. 字符串拼接操作"></a>10.4. 字符串拼接操作</h2><ul>
<li>常量与常量的拼接结果在<strong>常量池</strong>，原理是<strong>编译期优化</strong></li>
<li><strong>常量池</strong>中不会存在相同内容的变量</li>
<li>只要其中有一个是<strong>变量</strong>，结果就在<strong>堆</strong>中。变量拼接的原理是 StringBuilder</li>
<li>如果拼接的结果调用 intern()方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ul>
<p><strong>举例 1</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 都是常量，前端编译期会进行代码优化</span></span><br><span class="line">    <span class="comment">// 通过idea直接看对应的反编译的class文件，会显示 String s1 = "abc"; 说明做了代码优化</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span> + <span class="string">"b"</span> + <span class="string">"c"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"abc"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// true，有上述可知，s1和s2实际上指向字符串常量池中的同一个值</span></span><br><span class="line">    System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>举例 2</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"javaEE"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"hadoop"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"javaEEhadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"javaEE"</span> + <span class="string">"hadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">"hadoop"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">"javaEE"</span> + s2;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">    System.out.println(s3 == s4); <span class="comment">// true 编译期优化</span></span><br><span class="line">    System.out.println(s3 == s5); <span class="comment">// false s1是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s6); <span class="comment">// false s2是变量，不能编译期优化</span></span><br><span class="line">    System.out.println(s3 == s7); <span class="comment">// false s1、s2都是变量</span></span><br><span class="line">    System.out.println(s5 == s6); <span class="comment">// false s5、s6 不同的对象实例</span></span><br><span class="line">    System.out.println(s5 == s7); <span class="comment">// false s5、s7 不同的对象实例</span></span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// false s6、s7 不同的对象实例</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();</span><br><span class="line">    System.out.println(s3 == s8); <span class="comment">// true intern之后，s8和s3一样，指向字符串常量池中的"javaEEhadoop"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20221121151128082.png" alt="image-20221121151128082"></p>
<p>虽然 s3 和 s4 的指向的值都是“ab”,但是他们<br>各自存放的地方不一样，也就是地址不一样</p>
<p><strong>举例 3</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  1. 字符串拼接操作不一定使用的是 StringBuilder （变量拼接的原理是 StringBuilder）</span></span><br><span class="line"><span class="comment">  	 如果拼接符号左右两边都是字符串常量或常量引用，则仍然使用编译优化，即非StringBuilder的方式</span></span><br><span class="line"><span class="comment">  2. 针对于 final 修饰类、方法、基本数据类型、引用数据类型的量的结构时，能使用上 final 的时候建议使用上</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">"beijing"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"bei"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"jing"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s0 == s3); <span class="comment">// false 	s3指向堆空降中的对象实例，s0指向字符串常量池中的"beijing"</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> <span class="string">"shanxi"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"shan"</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> <span class="string">"xi"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> s4 + s5;</span><br><span class="line">    System.out.println(s6 == s7); <span class="comment">// true 	s4和s5是final修饰的，编译期就能确定s6的值了</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>不使用 final 修饰，即为变量。如 s3 行的 s1 和 s2，会通过 new StringBuilder 进行拼接</li>
<li>使用 final 修饰，即为常量。会在编译器进行代码优化。<mark>在实际开发中，能够使用 final 的，尽量使用</mark></li>
</ul>
<p><strong>举例 4</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>{</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">"a"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"b"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line">    System.out.println(s3==s4);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>字节码</strong></p>
<p>我们拿例 4 的字节码进行查看，可以发现<code>s1 + s2</code>实际上是 new 了一个 StringBuilder 对象，并使用了 append 方法将 s1 和 s2 添加进来，最后调用了 toString 方法赋给 s4</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> 0 ldc #2 &lt;a&gt;</span><br><span class="line"> 2 astore_1</span><br><span class="line"> 3 ldc #3 &lt;b&gt;</span><br><span class="line"> 5 astore_2</span><br><span class="line"> 6 ldc #4 &lt;ab&gt;</span><br><span class="line"> 8 astore_3</span><br><span class="line"> 9 new #5 &lt;java/lang/StringBuilder&gt;</span><br><span class="line">12 dup</span><br><span class="line">13 invokespecial #6 &lt;java/lang/StringBuilder.&lt;init&gt;&gt;</span><br><span class="line">16 aload_1</span><br><span class="line">17 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">20 aload_2</span><br><span class="line">21 invokevirtual #7 &lt;java/lang/StringBuilder.append&gt;</span><br><span class="line">24 invokevirtual #8 &lt;java/lang/StringBuilder.toString&gt;</span><br><span class="line">27 astore 4</span><br><span class="line">29 getstatic #9 &lt;java/lang/System.out&gt;</span><br><span class="line">32 aload_3</span><br><span class="line">33 aload 4</span><br><span class="line">35 if_acmpne 42 (+7)</span><br><span class="line">38 iconst_1</span><br><span class="line">39 goto 43 (+4)</span><br><span class="line">42 iconst_0</span><br><span class="line">43 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">46 return</span><br></pre></td></tr></tbody></table></figure>

<p><strong>字符串拼接操作性能对比</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>{   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {  </span><br><span class="line">        <span class="type">int</span> <span class="variable">times</span> <span class="operator">=</span> <span class="number">50000</span>;      </span><br><span class="line">        <span class="comment">// String      </span></span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();     </span><br><span class="line">        testString(times);  </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();       </span><br><span class="line">        System.out.println(<span class="string">"String: "</span> + (end-start) + <span class="string">"ms"</span>);     </span><br><span class="line">        <span class="comment">// StringBuilder       </span></span><br><span class="line">        start = System.currentTimeMillis();   </span><br><span class="line">        testStringBuilder(times);      </span><br><span class="line">        end = System.currentTimeMillis();  </span><br><span class="line">        System.out.println(<span class="string">"StringBuilder: "</span> + (end-start) + <span class="string">"ms"</span>);    </span><br><span class="line">        <span class="comment">// StringBuffer      </span></span><br><span class="line">        start = System.currentTimeMillis();      </span><br><span class="line">        testStringBuffer(times);   </span><br><span class="line">        end = System.currentTimeMillis();    </span><br><span class="line">        System.out.println(<span class="string">"StringBuffer: "</span> + (end-start) + <span class="string">"ms"</span>);   </span><br><span class="line">    }   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testString</span><span class="params">(<span class="type">int</span> times)</span> { </span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">""</span>;      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {     </span><br><span class="line">            str = str + <span class="string">"test"</span>;      </span><br><span class="line">        }  </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuilder</span><span class="params">(<span class="type">int</span> times)</span> {     </span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();    </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {        </span><br><span class="line">            sb.append(<span class="string">"test"</span>);     </span><br><span class="line">        }   </span><br><span class="line">    }  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testStringBuffer</span><span class="params">(<span class="type">int</span> times)</span> {   </span><br><span class="line">        <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();  </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; times; i++) {        </span><br><span class="line">            sb.append(<span class="string">"test"</span>);      </span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 结果String: 7963ms	StringBuilder: 1ms	StringBuffer: 4ms</span></span><br></pre></td></tr></tbody></table></figure>

<ol>
<li><p>本实验进行 5 万次循环，String 拼接方式的时间是 StringBuilder.append 方式的约 8000 倍，StringBuffer.append()方式的时间是 StringBuilder.append()方式的约 4 倍（StringBuffer是同步的，会慢些）</p>
</li>
<li><p>可以看到，通过 StringBuilder 的 append 方式的速度，要比直接对 String 使用“+”拼接的方式<mark>快的不是一点半点</mark></p>
</li>
</ol>
<p>​		因为：（1）StringBuiler 的 append()的方式：自始自终只创建过一个StringBuilder的对象</p>
<p>​							使用String的字符串拼接方式：创建过多个 StringBuilder 和 String 的对象</p>
<p>​					（2）使用String 的字符串拼接方式：内存中由于创建了较多的StringBuilder和String的对象，内存占用更大；如果进行GC，需要花费的额外时间。</p>
<ol start="3">
<li><p>那么，在实际开发中，对于需要<mark>多次或大量拼接</mark>的操作，在不考虑线程安全问题时，我们就应该尽可能<mark>使用 StringBuilder 进行 append 操作</mark></p>
</li>
<li><p><strong>改进的空间</strong>：除此之外，还有那些操作能够帮助我们提高字符串方面的运行效率呢？（改进的空间）</p>
</li>
</ol>
<p>​			在实际开发中，如果基本确定要前前后后添加的字符串长度不高于某个限定值hightLevel的情况下，<strong>建议使用<mark>带参构造器</mark>指定 capacity来实例化，以减少扩容的次数，优化程序执行效果</strong>（扩容的逻辑可以自行查看源代码）</p>
<p>​			StringBuilder 空参构造器的初始化大小为 16。</p>
<p>​			StringBuilder s = new StringBuilder(capacity); // new char[capacity]</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a string builder with no characters in it and an * initial capacity of 16 characters. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">()</span> { </span><br><span class="line">    <span class="built_in">super</span>(<span class="number">16</span>);</span><br><span class="line">}</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Constructs a string builder with no characters in it and an </span></span><br><span class="line"><span class="comment">* initial capacity specified by the {<span class="doctag">@code</span> capacity} argument. </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span>      capacity  the initial capacity. </span></span><br><span class="line"><span class="comment">* <span class="doctag">@throws</span>     NegativeArraySizeException  if the {<span class="doctag">@code</span> capacity} </span></span><br><span class="line"><span class="comment">*               argument is less than {<span class="doctag">@code</span> 0}. </span></span><br><span class="line"><span class="comment">*/</span><span class="keyword">public</span> <span class="title function_">StringBuilder</span><span class="params">(<span class="type">int</span> capacity)</span> {   </span><br><span class="line">    <span class="built_in">super</span>(capacity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-5-intern-的使用"><a href="#10-5-intern-的使用" class="headerlink" title="10.5. intern()的使用"></a>10.5. intern()的使用</h2><p>官方 API 文档中的解释</p>
<blockquote>
<p>public String intern()</p>
<p>Returns a canonical representation for the string object.</p>
<p>A pool of strings, initially empty, is maintained privately by the class <code>String</code>.</p>
<p>When the intern method is invoked, if the pool already contains a string equal to this <code>String</code> object as determined by the <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/java/lang/String.html#equals-java.lang.Object-"><code>equals(Object)</code></a> method, then the string from the pool is returned. Otherwise, this <code>String</code> object is added to the pool and a reference to this <code>String</code> object is returned.</p>
<p>It follows that for any two strings <code>s</code> and <code>t</code>, <code>s.intern() == t.intern()</code> is <code>true</code> if and only if <code>s.equals(t)</code> is <code>true</code>.</p>
<p>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.</p>
<ul>
<li><p><strong>Returns:</strong></p>
<p>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p>
</li>
</ul>
</blockquote>
<p>当调用 intern 方法时，如果池子里已经包含了一个与这个 String 对象相等的字符串，正如 equals(Object)方法所确定的，那么池子里的字符串会被返回。否则，这个 String 对象被添加到池中，并返回这个 String 对象的引用。</p>
<p>由此可见，对于任何两个字符串 s 和 t，当且仅当 s.equals(t)为真时，s.intern() == t.intern()为真。</p>
<p>所有字面字符串和以字符串为值的常量表达式都是 interned。</p>
<p>返回一个与此字符串内容相同的字符串，但保证是来自一个唯一的字符串池。</p>
<hr>
<p>intern 是一个 native 方法，调用的是底层 C 的方法</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title function_">intern</span><span class="params">()</span>;</span><br></pre></td></tr></tbody></table></figure>

<p>如果不是用双引号声明的 String 对象，可以使用 String 提供的 intern 方法，它会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">myInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">string</span>(<span class="string">"I love atguigu"</span>).intern();</span><br></pre></td></tr></tbody></table></figure>

<p>也就是说，如果在任意字符串上调用 String.intern 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。因此，下列表达式的值必定是 true</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">"a"</span>+<span class="string">"b"</span>+<span class="string">"c"</span>).intern() == <span class="string">"abc"</span></span><br></pre></td></tr></tbody></table></figure>

<p>通俗点讲，Interned string 就是确保字符串在内存里只有一份拷贝，这样可以节约内存空间，加快字符串操作任务的执行速度。注意，这个值会被存放在字符串内部池（String Intern Pool）</p>
<p><img src="/../../../images/image-20221121160359225.png" alt="image-20221121160359225"></p>
<p>如何保证变量 s 指向的是字符串常量池中的数据呢？</p>
<p>有两种方式：</p>
<p>方式一：字面量定义的方式</p>
<p>​			String s = “hhhh”;</p>
<p>方式二：调用 intern()</p>
<p>​			String s = new String(“hhhh”).intern();</p>
<p>​			String s = new StringBuilder(“hhhh”).toString().intern();</p>
<p>（用字面量或者intern方法才会在字符串常量池中创建，否则在堆中创建）</p>
<p><img src="/../../../images/image-20221121161348231.png" alt="image-20221121161348231"></p>
<p><img src="/../../../images/image-20221121163558377.png" alt="image-20221121163558377"></p>
<h3 id="10-5-1-intern-的使用：JDK6-vs-JDK7-x2F-8"><a href="#10-5-1-intern-的使用：JDK6-vs-JDK7-x2F-8" class="headerlink" title="10.5.1. intern 的使用：JDK6 vs JDK7/8"></a>10.5.1. intern 的使用：JDK6 vs JDK7/8</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* ① String s = new String("1")</span></span><br><span class="line"><span class="comment">* 创建了两个对象 </span></span><br><span class="line"><span class="comment">* 		堆空间中一个new对象</span></span><br><span class="line"><span class="comment">* 		字符串常量池中一个字符串常量"1"（注意：此时字符串常量池中已有"1"）</span></span><br><span class="line"><span class="comment">* ② s.intern(); 调用此方法之前，字符串常量池中已存在了"1" </span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* s  指向的是堆空间中的对象地址</span></span><br><span class="line"><span class="comment">* s2 指向的是堆空间中常量池中"1"的地址 </span></span><br><span class="line"><span class="comment">* 所以不相等 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">s.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"1"</span>;</span><br><span class="line">System.out.println(s==s2);<span class="comment">// jdk1.6 false jdk7/8 false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">① String s3 = new String("1") + new String("1") </span></span><br><span class="line"><span class="comment">* s3变量记录的地址为new String（"11"），等价于new String（"11"），但是，常量池中并不生成字符串"11"； </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* ② s3.intern() </span></span><br><span class="line"><span class="comment">* 由于此时常量池中并无"11"，所以这里会在字符串常量池中生成"11"，如何理解：</span></span><br><span class="line"><span class="comment">		jdk6: 创建了一个新的对象"11"，也就有新的地址</span></span><br><span class="line"><span class="comment">		jdk7: 此时常量中并没有创建"11"，则会把 对象的引用地址 复制一份，放入串池，并返回串池中的引用地址。</span></span><br><span class="line"><span class="comment">		      即，创建一个指向堆空间中 new String("11") 的地址</span></span><br><span class="line"><span class="comment">* String s4 = "11"; // s4 变量记录的地址：使用的是上一行代码执行时，在常量池中生成的"11"的地址</span></span><br><span class="line"><span class="comment">* 所以s3 和 s4 指向的都是一个地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>;</span><br><span class="line">System.out.println(s3==s4);  <span class="comment">//jdk1.6 false 	jdk7/8 true</span></span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/4c11070481d7c3cdb566163802cf582b.png" alt="image-20210511152240683"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3a3bab69ad3c6302ea00c301dffb5193.png" alt="image-20200711145925091"></p>
<p>面试题的扩展：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">// StringIntern.java中的练习扩展</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">// 执行完上一行代码以后，字符串常量池中，不存在 "11"</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">"11"</span>; <span class="comment">//在字符串常量池中生成对象"11"</span></span><br><span class="line"></span><br><span class="line">        s3.intern();</span><br><span class="line">        System.out.println( s3 == s4 );  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s3.intern();</span><br><span class="line">        System.out.println( s5 == s4 );  <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">        s3 = s3.intern();</span><br><span class="line">        System.out.println( s3 == s4 );  <span class="comment">// true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>总结 String 的 intern()的使用：</p>
<p>JDK1.6 中，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，会把此<mark><strong>对象</strong>复制一份</mark>，放入串池，并返回串池中的对象地址</li>
</ul>
<p>JDK1.7 起，将这个字符串对象尝试放入串池。</p>
<ul>
<li>如果串池中有，则并不会放入。返回已有的串池中的对象的地址</li>
<li>如果没有，则会把<mark>对象的<strong>引用地址</strong></mark>复制一份，放入串池，并返回串池中的引用地址</li>
</ul>
<p><strong>练习 1</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringExer1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"a"</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"b"</span>);  <span class="comment">// 变量s记录的地址为new String("ab")</span></span><br><span class="line">        <span class="comment">// 在执行完上一行代码后，字符串常量池中并没有"ab"</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * jdk6中：在 字符串常量池 中 创建一个 字符串"ab"</span></span><br><span class="line"><span class="comment">         * jdk8中：字符串常量池 中 没有创建 字符串"ab"，而是 创建 了一个 引用（指向 new String ("ab")）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> s.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s2 == <span class="string">"ab"</span>);  <span class="comment">// jdk6: true    jdk8: true</span></span><br><span class="line">        System.out.println(s == <span class="string">"ab"</span>);   <span class="comment">// jdk6: false   jdk8: true</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>图解：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bb9abdd927bd9ac80c1c18359d299629.png" alt="image-20200711150859709"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e6c4796fa8d9b5dda9438c799bb45540.png" alt="image-20200711151326909"></p>
<p><strong>练习 2</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ad465da04603bb228d6dde8950ee95ec.png" alt="image-20200711151433277"></p>
<p>练习3：（自己设置的）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>);</span><br><span class="line">    System.out.println(s1 == <span class="string">"ab"</span>);  <span class="comment">// false</span></span><br><span class="line">    System.out.println(s1 == s);     <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"ab"</span>;</span><br><span class="line">    System.out.println(s2 == <span class="string">"ab"</span>);  <span class="comment">// true</span></span><br><span class="line">    System.out.println(s2 == s);     <span class="comment">// true</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="10-5-2-intern-的效率测试：空间角度"><a href="#10-5-2-intern-的效率测试：空间角度" class="headerlink" title="10.5.2. intern 的效率测试：空间角度"></a>10.5.2. intern 的效率测试：空间角度</h3><p>我们通过测试一下，使用了 intern 和不使用的时候，其实相差还挺多的</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringIntern2</span> { </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAX_COUNT</span> <span class="operator">=</span> <span class="number">1000</span> * <span class="number">10000</span>;  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[MAX_COUNT];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {      </span><br><span class="line">        Integer [] data = <span class="keyword">new</span> <span class="title class_">Integer</span>[]{<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>};    </span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();     </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAX_COUNT; i++) {         </span><br><span class="line">            <span class="comment">// arr[i] = new String(String.valueOf(data[i%data.length]));    </span></span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">String</span>(String.valueOf(data[i%data.length])).intern(); </span><br><span class="line">        }       </span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();   </span><br><span class="line">        System.out.println(<span class="string">"花费的时间为："</span> + (end - start));      </span><br><span class="line">        <span class="keyword">try</span> {         </span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);   </span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {         </span><br><span class="line">            e.getStackTrace();       </span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 运行结果:   不使用intern：7256ms    使用intern：1395ms</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>结论</strong>：</p>
<p>对于程序中大量使用存在的字符串时，尤其存在很多已经重复的字符串时，使用 intern()方法能够节省内存空间。</p>
<p>而 arr[i] = new String(String.valueOf(data[i%data.length])).intern(); 中前面的 new String(String.valueOf(data[i%data.length])) 的对象，在堆空间中，后期被发现不用就会被GC垃圾回收销毁了，所以就不会在内存中创建过多的String</p>
<p>大的网站平台，需要内存中存储大量的字符串。比如社交网站，很多人都存储：北京市、海淀区等信息。这时候如果字符串都调用 intern()方法，就会很明显降低内存的大小。</p>
<h2 id="10-6-StringTable-的垃圾回收"><a href="#10-6-StringTable-的垃圾回收" class="headerlink" title="10.6. StringTable 的垃圾回收"></a>10.6. StringTable 的垃圾回收</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringGCTest</span> {  </span><br><span class="line">    <span class="comment">/**    </span></span><br><span class="line"><span class="comment">    * -Xms15m -Xmx15m -XX:+PrintGCDetails  </span></span><br><span class="line"><span class="comment">    */</span>   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {      </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) {    </span><br><span class="line">            String.valueOf(i).intern();       </span><br><span class="line">        }  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>运行结果</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 4096K-&gt;504K(4608K)] 4096K-&gt;1689K(15872K), <span class="number">0.0581583</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.06</span> secs] [GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 5785K-&gt;2310K(15872K), <span class="number">0.0015621</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] [GC (Allocation Failure) [PSYoungGen: 4600K-&gt;504K(4608K)] 6406K-&gt;2350K(15872K), <span class="number">0.0034849</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs]</span><br><span class="line">Heap PSYoungGen     </span><br><span class="line">    total 4608K, used 1919K [<span class="number">0x00000000ffb00000</span>, <span class="number">0x0000000100000000</span>, <span class="number">0x0000000100000000</span>)  eden space 4096K, <span class="number">34</span>% used [<span class="number">0x00000000ffb00000</span>,<span class="number">0x00000000ffc61d30</span>,<span class="number">0x00000000fff00000</span>)  from space 512K, <span class="number">98</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff7e010</span>,<span class="number">0x00000000fff80000</span>)  to   space 512K, <span class="number">0</span>% used [<span class="number">0x00000000fff80000</span>,<span class="number">0x00000000fff80000</span>,<span class="number">0x0000000100000000</span>) ParOldGen       total 11264K, used 1846K [<span class="number">0x00000000ff000000</span>, <span class="number">0x00000000ffb00000</span>, <span class="number">0x00000000ffb00000</span>)  object space 11264K, <span class="number">16</span>% used [<span class="number">0x00000000ff000000</span>,<span class="number">0x00000000ff1cd9b0</span>,<span class="number">0x00000000ffb00000</span>) Metaspace       used 3378K, capacity 4496K, committed 4864K, reserved 1056768K  <span class="keyword">class</span> <span class="title class_">space</span>    used 361K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></tbody></table></figure>

<h2 id="10-7-G1-中的-String-去重操作"><a href="#10-7-G1-中的-String-去重操作" class="headerlink" title="10.7. G1 中的 String 去重操作"></a>10.7. G1 中的 String 去重操作</h2><p>官网地址：<a target="_blank" rel="noopener" href="http://openjdk.java.net/jeps/192">JEP 192: String Deduplication in G1 (java.net)</a></p>
<blockquote>
<h2 id="Motivation-1"><a href="#Motivation-1" class="headerlink" title="Motivation"></a>Motivation</h2><p>Many large-scale Java applications are currently bottlenecked on memory. Measurements have shown that roughly 25% of the Java heap live data set in these types of applications is consumed by <code>String</code> objects. Further, roughly half of those <code>String</code> objects are duplicates, where duplicates means <code>string1.equals(string2)</code> is true. Having duplicate <code>String</code> objects on the heap is, essentially, just a waste of memory. This project will implement automatic and continuous <code>String</code> deduplication in the G1 garbage collector to avoid wasting memory and reduce the memory footprint.</p>
</blockquote>
<p>目前，许多大规模的 Java 应用程序在内存上遇到了瓶颈。测量表明，在这些类型的应用程序中，大约 25%的 Java 堆实时数据集被<code>String'对象所消耗。此外，这些 "String "对象中大约有一半是重复的，其中重复意味着 "string1.equals(string2) "是真的。在堆上有重复的</code>String’对象，从本质上讲，只是一种内存的浪费。这个项目将在 G1 垃圾收集器中实现自动和持续的`String’重复数据删除，以避免浪费内存，减少内存占用。</p>
<hr>
<p>注意这里说的重复，指的是在堆中的数据，而不是常量池中的，因为常量池中的本身就不会重复</p>
<p>背景：对许多 Java 应用（有大的也有小的）做的测试得出以下结果：</p>
<ul>
<li>堆存活数据集合里面 string 对象占了 25%</li>
<li>堆存活数据集合里面重复的 string 对象有 13.5%</li>
<li>string 对象的平均长度是 45</li>
</ul>
<p>许多大规模的 Java 应用的瓶颈在于内存，测试表明，在这些类型的应用里面，<mark>Java 堆中存活的数据集合差不多 25%是 String 对象</mark>。更进一步，这里面差不多一半 string 对象是重复的，重复的意思是说： **<code>stringl.equals(string2)= true</code>**。<mark>堆上存在重复的 String 对象必然是一种内存的浪费</mark>。这个项目将在 G1 垃圾收集器中实现自动持续对重复的 string 对象进行去重，这样就能避免浪费内存。</p>
<p><strong>实现</strong></p>
<ol>
<li>当垃圾收集器工作的时候，会访问堆上存活的对象。<mark>对每一个访问的对象都会检查是否是候选的要去重的 String 对象</mark></li>
<li>如果是，把这个对象的一个引用插入到队列中等待后续的处理。一个去重的线程在后台运行，处理这个队列。处理队列的一个元素意味着从队列删除这个元素，然后尝试去重它引用的 string 对象。</li>
<li>使用一个 hashtable 来记录所有的被 String 对象使用的不重复的 char 数组。当去重的时候，会查这个 hashtable，来看堆上是否已经存在一个一模一样的 char 数组。</li>
<li>如果存在，String 对象会被调整引用那个数组，释放对原来的数组的引用，最终会被垃圾收集器回收掉。</li>
<li>如果查找失败，char 数组会被插入到 hashtable，这样以后的时候就可以共享这个数组了。</li>
</ol>
<p><strong>命令行选项</strong></p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">开启String去重，默认是不开启的，需要手动开启。</span> </span><br><span class="line">UseStringDeduplication(bool) </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打印详细的去重统计信息</span> </span><br><span class="line">PrintStringDeduplicationStatistics(bool)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">达到这个年龄的String对象被认为是去重的候选对象</span></span><br><span class="line">StringpeDuplicationAgeThreshold(uintx)</span><br></pre></td></tr></tbody></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/21/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/10.%20StringTable/" data-id="cliiv9kv8007y3kv600mt4f20" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/2. 类加载子系统" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="post-time" datetime="2022-11-20T15:01:03.641Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/">2. 类加载子系统</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="2-类加载子系统"><a href="#2-类加载子系统" class="headerlink" title="2. 类加载子系统"></a>2. 类加载子系统</h1><h2 id="2-1-内存结构概述"><a href="#2-1-内存结构概述" class="headerlink" title="2.1. 内存结构概述"></a>2.1. 内存结构概述</h2><ul>
<li>Class 文件</li>
<li><mark>类加载子系统</mark></li>
<li>运行时数据区<ul>
<li>方法区</li>
<li>堆</li>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
</li>
<li>执行引擎</li>
<li>本地方法接口</li>
<li>本地方法库</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e4bc9ed374db7f35e68f23f4813205bd.png" alt="image-20200705080719531"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5f06cd7e27506a91940c7b87e01d0b46.png" alt="image-20200705080911284"></p>
<p>如果自己想手写一个 Java 虚拟机的话，主要考虑哪些结构呢？</p>
<ul>
<li>类加载器</li>
<li>执行引擎</li>
</ul>
<h2 id="2-2-类加载器与类的加载过程"><a href="#2-2-类加载器与类的加载过程" class="headerlink" title="2.2. 类加载器与类的加载过程"></a>2.2. 类加载器与类的加载过程</h2><p><strong>类加载器子系统作用</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3569bfb903e80b66ee7e972a6b4a5036.png" alt="image-20200705081813409"></p>
<ul>
<li>类加载器子系统负责<strong>从文件系统或者网络中加载 Class 文件</strong>，class 文件在文件开头有特定的文件标识。</li>
<li>ClassLoader 只负责 class 文件的加载，至于它是否可以运行，则由 <strong>Execution Engine 执行引擎</strong> 决定。</li>
<li>加载的类信息存放于一块称为<strong>方法区的内存空间</strong>。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）</li>
</ul>
<p><strong>类加载器 ClassLoader 角色</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8172076eaa7a152408633a353f06b2c.png" alt="image-20200705081913538"></p>
<ul>
<li>class file 存在于本地硬盘上，可以理解为设计师画在纸上的模板，而最终这个模板在执行的时候是要加载到 JVM 当中来根据这个文件实例化出 n 个一模一样的实例。</li>
<li>class file 加载到 JVM 中，被称为 DNA 元数据模板，放在方法区。</li>
<li>在.class 文件-&gt;JVM-&gt;最终成为元数据模板，此过程就要一个运输工具（类装载器 Class Loader），扮演一个快递员的角色。</li>
</ul>
<p><strong>类的加载过程</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *示例代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloLoader</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>用流程图表示上述示例代码：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8cc54647114c456695ac352336c74600.png" alt="image-20200705082255746"></p>
<h3 id="加载阶段"><a href="#加载阶段" class="headerlink" title="加载阶段"></a>加载阶段</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/a9497a1eeb7fae3022846b509186fdcd.png" alt="image-20200705082601441"></p>
<ul>
<li><ol>
<li>通过一个类的全限定名获取定义此类的二进制字节流</li>
</ol>
</li>
<li><ol start="2">
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
</ol>
</li>
<li><ol start="3">
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
</li>
</ul>
<p><strong>补充：加载 class 文件的方式</strong></p>
<ul>
<li>从<mark>本地系统</mark>中直接加载</li>
<li>通过<mark>网络</mark>获取，典型场景：Web Applet</li>
<li>从 zip<mark>压缩包</mark>中读取，成为日后 jar、war 格式的基础</li>
<li>运行时计算生成，使用最多的是：<mark>动态代理技术</mark></li>
<li>由其他文件生成，典型场景：<mark>JSP 应用</mark></li>
<li>从专有<mark>数据库</mark>中提取.class 文件，比较少见</li>
<li>从<mark>加密文件</mark>中获取，典型的防 Class 文件被反编译的保护措施</li>
</ul>
<h3 id="链接阶段"><a href="#链接阶段" class="headerlink" title="链接阶段"></a>链接阶段</h3><ul>
<li><strong>验证（Verify）</strong>：<ul>
<li>目的在于<strong>确保 Class 文件的字节流中包含信息符合当前虚拟机要求</strong>，<strong>保证被加载类的正确性，不会危害虚拟机自身安全。</strong></li>
<li>主要包括四种验证，<mark>文件格式验证，元数据验证，字节码验证，符号引用验证。</mark></li>
</ul>
</li>
<li><strong>准备（Prepare）</strong>：<ul>
<li><strong>为类变量分配内存</strong>并且<strong>设置该类变量的默认初始值</strong>，即零值。</li>
<li><mark>这里不包含用 final 修饰的 static，因为 final 在编译的时候就会分配了，准备阶段会显式初始化；</mark></li>
<li><mark>这里不会为实例变量分配初始化</mark>，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</li>
</ul>
</li>
<li><strong>解析（Resolve）</strong>：<ul>
<li>将<strong>常量池内</strong>的<mark>符号引用转换为直接引用</mark>的过程。</li>
<li>事实上，解析操作往往会伴随着 JVM 在执行完初始化之后再执行。</li>
<li>符号引用就是一组符号来描述所引用的目标。符号引用的字面量形式明确定义在《java 虚拟机规范》的 Class 文件格式中。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li>
<li>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info，CONSTANT_Fieldref_info、CONSTANT_Methodref_info 等。</li>
</ul>
</li>
</ul>
<h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><ul>
<li><mark>初始化阶段就是执行类构造器方法&lt;clinit&gt;()的过程。</mark></li>
<li>此方法不需定义，是 javac 编译器自动收集类中的所有类变量的赋值动作和静态代码块中的语句合并而来。</li>
<li>构造器方法中指令按语句在源文件中出现的顺序执行。</li>
<li><mark>&lt;clinit&gt;()不同于类的构造器。</mark>（关联：构造器是虚拟机视角下的&lt;init&gt;()）</li>
<li>若该类具有父类，JVM 会保证子类的&lt;clinit&gt;()执行前，父类的&lt;clinit&gt;()已经执行完毕。</li>
<li>虚拟机必须保证一个类的&lt;clinit&gt;()方法在多线程下被<strong>同步加锁</strong>。</li>
</ul>
<h2 id="2-3-类加载器分类"><a href="#2-3-类加载器分类" class="headerlink" title="2.3. 类加载器分类"></a>2.3. 类加载器分类</h2><p>JVM 支持两种类型的类加载器 。分别为<mark>引导类加载器（Bootstrap ClassLoader）</mark>和<mark>自定义类加载器（User-Defined ClassLoader）</mark>。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是 Java 虚拟机规范却没有这么定义，而是将<mark>所有派生于抽象类 ClassLoader 的类加载器都划分为自定义类加载器</mark>。</p>
<p>无论类加载器的类型如何划分，在程序中我们最常见的类加载器始终只有 3 个，如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1e553c6d5254f827d2dfab537bea3ab9.png" alt="image-20200705094149223"></p>
<p>这里的四者之间的关系是包含关系。不是上层下层，也不是子父类的继承关系。</p>
<h3 id="2-3-1-虚拟机自带的加载器"><a href="#2-3-1-虚拟机自带的加载器" class="headerlink" title="2.3.1. 虚拟机自带的加载器"></a>2.3.1. 虚拟机自带的加载器</h3><p><strong>启动类加载器（引导类加载器，Bootstrap ClassLoader）</strong></p>
<ul>
<li>这个类加载使用 <strong>C/C++语言</strong>实现的，嵌套在 JVM 内部。</li>
<li>它用来加载 Java 的核心库（JAVA_HOME/jre/lib/rt.jar、resources.jar 或 sun.boot.class.path 路径下的内容），用于提供 JVM 自身需要的类</li>
<li>并不继承自 java.lang.ClassLoader，没有父加载器。</li>
<li>加载扩展类和应用程序类加载器，并指定为他们的父类加载器。</li>
<li>出于安全考虑，Bootstrap 启动类加载器只加载包名为<font color="red"> <strong>java、javax、sun</strong> </font>等开头的类</li>
</ul>
<p><strong>扩展类加载器（Extension ClassLoader）</strong></p>
<ul>
<li>Java 语言编写，由 sun.misc.Launcher$ExtClassLoader 实现。</li>
<li>派生于 ClassLoader 类</li>
<li>父类加载器为启动类加载器</li>
<li>从 java.ext.dirs 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 jre/1ib/ext 子目录（扩展目录）下加载类库。如果用户创建的 JAR 放在此目录下，也会自动由扩展类加载器加载。</li>
</ul>
<p><strong>应用程序类加载器（系统类加载器，AppClassLoader）</strong></p>
<ul>
<li>java 语言编写，由 sun.misc.LaunchersAppClassLoader 实现</li>
<li>派生于 ClassLoader 类</li>
<li>父类加载器为扩展类加载器</li>
<li>它负责加载环境变量 classpath 或系统属性 java.class.path 指定路径下的类库</li>
<li><mark>该类加载是程序中<strong>默认</strong>的类加载器</mark>，一般来说，Java 应用的类都是由它来完成加载</li>
<li>通过 ClassLoader#getSystemclassLoader() 方法可以获取到该类加载器</li>
</ul>
<h3 id="2-3-2-用户自定义类加载器"><a href="#2-3-2-用户自定义类加载器" class="headerlink" title="2.3.2. 用户自定义类加载器"></a>2.3.2. 用户自定义类加载器</h3><p>在 Java 的日常应用程序开发中，类的加载几乎是由上述 3 种类加载器相互配合执行的，在必要时，我们还可以自定义类加载器，来定制类的加载方式。</p>
<p> 为什么要自定义类加载器？</p>
<ul>
<li>隔离加载类</li>
<li>修改类加载的方式</li>
<li>扩展加载源</li>
<li>防止源码泄漏</li>
</ul>
<p>用户自定义类加载器实现步骤：</p>
<ol>
<li>开发人员可以通过继承抽象类 ava.lang.ClassLoader 类的方式，实现自己的类加载器，以满足一些特殊的需求</li>
<li>在 JDK1.2 之前，在自定义类加载器时，总会去继承 ClassLoader 类并重写 loadClass() 方法，从而实现自定义的类加载类，但是在 JDK1.2 之后已不再建议用户去覆盖 loadclass() 方法，而是建议把自定义的类加载逻辑写在 findClass()方法中</li>
<li>在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承 URLClassLoader 类，这样就可以避免自己去编写 findClass() 方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</li>
</ol>
<h2 id="2-4-ClassLoader-的使用说明"><a href="#2-4-ClassLoader-的使用说明" class="headerlink" title="2.4. ClassLoader 的使用说明"></a>2.4. ClassLoader 的使用说明</h2><p>ClassLoader 类是一个抽象类，其后所有的类加载器都继承自 ClassLoader（不包括启动类加载器）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/876534b3c2f447d3fc33e6f1db218068.png" alt="image-20200705103516138"></p>
<p>sun.misc.Launcher 它是一个 java 虚拟机的入口应用</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a22114b608dffe484041b591d486a7fd.png" alt="image-20200705103636003"></p>
<p><strong>获取 ClassLoader 的途径</strong></p>
<ul>
<li><p>方式一：获取当前 ClassLoader</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clazz.getClassLoader()</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>方式二：获取当前线程上下文的 ClassLoader</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader()</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>方式三：获取系统的 ClassLoader</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>方式四：获取调用者的 ClassLoader</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.getCallerClassLoader()</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="2-5-双亲委派机制"><a href="#2-5-双亲委派机制" class="headerlink" title="2.5. 双亲委派机制"></a>2.5. 双亲委派机制</h2><p>Java 虚拟机对 class 文件采用的是<mark>按需加载</mark>的方式，也就是说当需要使用该类时才会将它的 class 文件加载到内存生成 class 对象。而且加载某个类的 class 文件时，Java 虚拟机采用的是<mark>双亲委派模式</mark>，即把请求交由父类处理，它是一种任务委派模式。</p>
<p><strong>工作原理</strong></p>
<ul>
<li>1）如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行；</li>
<li>2）如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器；</li>
<li>3）如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05fa27fcc38eeaaa5babff55a00882a3.png" alt="image-20200705105151258"></p>
<p><strong>举例</strong></p>
<p>当我们加载 jdbc.jar 用于实现数据库连接的时候，首先我们需要知道的是 jdbc.jar 是基于 SPI 接口进行实现的，所以在加载的时候，会进行双亲委派，最终从根加载器中加载 SPI 核心类，然后在加载 SPI 接口类，接着在进行反向委派，通过线程上下文类加载器进行实现类 jdbc.jar 的加载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bed320014f52bb27c8f3d795b3dc3b4a.png" alt="image-20200705105810107"></p>
<p><strong>优势</strong></p>
<ul>
<li>避免类的重复加载</li>
<li>保护程序安全，防止核心 API 被随意篡改<ul>
<li>自定义类：java.lang.String</li>
<li>自定义类：java.lang.ShkStart（报错：阻止创建 java.lang 开头的类）</li>
</ul>
</li>
</ul>
<p><strong>沙箱安全机制</strong></p>
<p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 jdk 自带的文件（rt.jar 包中 java\lang\String.class），报错信息说没有 main 方法，就是因为加载的是 rt.jar 包中的 string 类。这样可以保证对 java 核心源代码的保护，这就是沙箱安全机制。</p>
<h2 id="2-6-其他"><a href="#2-6-其他" class="headerlink" title="2.6. 其他"></a>2.6. 其他</h2><p><strong>如何判断两个 class 对象是否相同</strong></p>
<p>在 JVM 中表示两个 class 对象是否为同一个类存在两个必要条件：</p>
<ul>
<li>类的完整类名必须一致，包括包名。</li>
<li>加载这个类的 ClassLoader（指 ClassLoader 实例对象）必须相同。</li>
</ul>
<p>换句话说，在 JVM 中，即使这两个类对象（class 对象）来源同一个 Class 文件，被同一个虚拟机所加载，但只要加载它们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。</p>
<p><strong>对类加载器的引用</strong></p>
<p>JVM 必须知道一个类型是由启动加载器加载的还是由用户类加载器加载的。如果一个类型是由用户类加载器加载的，那么 JVM 会<mark>将这个类加载器的一个引用作为类型信息的一部分保存在方法区中</mark>。当解析一个类型到另一个类型的引用的时候，JVM 需要保证这两个类型的类加载器是相同的。</p>
<p><strong>类的主动使用和被动使用</strong></p>
<p>Java 程序对类的使用方式分为：主动使用和被动使用。</p>
<p>主动使用，又分为七种情况：</p>
<ul>
<li><p>创建类的实例</p>
</li>
<li><p>访问某个类或接口的静态变量，或者对该静态变量赋值</p>
</li>
<li><p>调用类的静态方法</p>
</li>
<li><p>反射（比如：Class.forName（”com.atguigu.Test”））</p>
</li>
<li><p>初始化一个类的子类</p>
</li>
<li><p>Java 虚拟机启动时被标明为启动类的类</p>
</li>
<li><p>JDK 7 开始提供的动态语言支持：</p>
<p>java.lang.invoke.MethodHandle 实例的解析结果</p>
<p>REF_getStatic、REF_putStatic、REF_invokeStatic 句柄对应的类没有初始化，则初始化</p>
</li>
</ul>
<p>除了以上七种情况，其他使用 Java 类的方式都被看作是对<mark>类的被动使用</mark>，都<mark>不会导致类的初始化</mark>。</p>
<hr>
<p><img src="/../../../images/image-20221120230332074.png" alt="image-20221120230332074"></p>
<p><img src="/../../../images/image-20221120230322953.png" alt="image-20221120230322953"></p>
<p><img src="/../../../images/image-20221120230310840.png" alt="image-20221120230310840"></p>
<p><img src="/../../../images/image-20221120230259551.png" alt="image-20221120230259551"></p>
<p><img src="/../../../images/image-20221120230251515.png" alt="image-20221120230251515"></p>
<p><img src="/../../../images/image-20221120230241584.png" alt="image-20221120230241584"></p>
<p><img src="/../../../images/image-20221120230234436.png" alt="image-20221120230234436"></p>
<p><img src="/../../../images/image-20221120230223130.png" alt="image-20221120230223130"></p>
<p><img src="/../../../images/image-20221120230214513.png" alt="image-20221120230214513"></p>
<p><img src="/../../../images/image-20221120230150104.png" alt="image-20221120230150104"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/2.%20%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%AD%90%E7%B3%BB%E7%BB%9F/" data-id="cliiv9kvi00873kv64jez1hyl" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/9. 执行引擎" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9.%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" class="article-date">
  <time class="post-time" datetime="2022-11-20T09:22:55.257Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9.%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/">9. 执行引擎</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="9-执行引擎"><a href="#9-执行引擎" class="headerlink" title="9. 执行引擎"></a>9. 执行引擎</h1><h2 id="9-1-执行引擎概述"><a href="#9-1-执行引擎概述" class="headerlink" title="9.1. 执行引擎概述"></a>9.1. 执行引擎概述</h2><p>执行引擎属于 JVM 的下层，里面包括<mark>解释器、及时编译器、垃圾回收器</mark></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9c0459b0f80a1c9bb534418b8e5a4ddd.png" alt="image-20200710080707873"></p>
<p>执行引擎是 Java 虚拟机核心的组成部分之一。</p>
<p>“虚拟机”是一个相对于“物理机”的概念，这两种机器都有代码执行能力，其区别是物理机的执行引擎是直接建立在处理器、缓存、指令集和操作系统层面上的，而<mark>虚拟机的执行引擎则是由软件自行实现的</mark>，因此可以不受物理条件制约地定制指令集与执行引擎的结构体系，<mark>能够执行那些不被硬件直接支持的指令集格式</mark>。</p>
<p>JVM 的主要任务是负责<mark>装载字节码到其内部</mark>，但字节码并不能够直接运行在操作系统之上，因为字节码指令并非等价于本地机器指令，它内部包含的仅仅只是一些能够被 JVM 所识别的字节码指令、符号表，以及其他辅助信息。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b28ff1d82bc72999d1cbbae3f419673d.png" alt="image-20200710081118053"></p>
<p>那么，如果想要让一个 Java 程序运行起来，执行引擎（Execution Engine）的任务就是<mark>将字节码指令解释/编译为对应平台上的本地机器指令</mark>.才可以。简单来说，JVM 中的执行引擎充当了将高级语言翻译为机器语言的译者。</p>
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-H3dqdi5T-1620741818957)(<a target="_blank" rel="noopener" href="https://gitee.com/vectorx/ImageCloud/raw/master/img/20210511090655.png)]">https://gitee.com/vectorx/ImageCloud/raw/master/img/20210511090655.png)]</a></p>
<h3 id="9-1-1-执行引擎的工作流程"><a href="#9-1-1-执行引擎的工作流程" class="headerlink" title="9.1.1. 执行引擎的工作流程"></a>9.1.1. 执行引擎的工作流程</h3><ol>
<li>执行引擎在执行的过程中究竟需要执行什么样的字节码指令完全依赖于 PC 寄存器。</li>
<li>每当执行完一项指令操作后，PC 寄存器就会更新下一条需要被执行的指令地址。</li>
<li>当然方法在执行的过程中，执行引擎有可能会通过存储在局部变量表中的对象引用准确定位到存储在 Java 堆区中的对象实例信息，以及通过对象头中的元数据指针定位到目标对象的类型信息。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a03c1910e508456b690ec9088300de5f.png" alt="image-20200710081627217"></p>
<p>从外观上来看，所有的 Java 虚拟机的执行引擎输入，输出都是一致的：输入的是<strong>字节码二进制流</strong>，处理过程是字节码解析执行的等效过程，输出的是<strong>执行过程</strong>。</p>
<p><img src="/../../../images/image-20221120193453610.png" alt="image-20221120193453610"></p>
<p>执行引擎就是负责将字节码指令，翻译成对应的机器指令，让程序能在操作系统中去执行，</p>
<h2 id="9-2-Java-代码编译和执行过程"><a href="#9-2-Java-代码编译和执行过程" class="headerlink" title="9.2. Java 代码编译和执行过程"></a>9.2. Java 代码编译和执行过程</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/e2a8ec10bc97a061e4b77abf63936ba1.png" alt="image-20200710082141643"></p>
<p>（绿色代表解析过程，蓝色代表编译过程）</p>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集之前，都需要经过上图中的各个步骤</p>
<p><strong>Java 代码编译</strong>是由 Java 源码编译器（<mark>前端编译器</mark>）来完成，流程图如下所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/93e5f0b67767b7d783ace2471447f449.png" alt="image-20200710082433146"></p>
<p><strong>Java 字节码的执行</strong>是由 JVM 执行引擎（<mark>后端编译器</mark>）来完成，流程图 如下所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bf1139f9652e2a1ac0cab00df869e23e.png" alt="image-20200710083036258"></p>
<h3 id="9-2-1-什么是解释器（Interpreter）？什么是-JIT-编译器？"><a href="#9-2-1-什么是解释器（Interpreter）？什么是-JIT-编译器？" class="headerlink" title="9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？"></a>9.2.1. 什么是解释器（Interpreter）？什么是 JIT 编译器？</h3><p><strong>解释器</strong>：当 Java 虚拟机启动时会根据预定义的规范<mark>对字节码采用逐行解释的方式执行</mark>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p><strong>JIT（Just In Time Compiler）编译器</strong>：就是虚拟机将源代码直接编译成和本地机器平台相关的机器语言。</p>
<h3 id="9-2-2-为什么-Java-是半编译半解释型语言？"><a href="#9-2-2-为什么-Java-是半编译半解释型语言？" class="headerlink" title="9.2.2. 为什么 Java 是半编译半解释型语言？"></a>9.2.2. 为什么 Java 是半编译半解释型语言？</h3><p>JDK1.0 时代，将 Java 语言定位为“解释执行”还是比较准确的。再后来，Java 也发展出可以直接生成本地代码的编译器。现在 JVM 在执行 Java 代码的时候，通常都会将解释执行与编译执行二者结合起来进行。</p>
<p><strong>图示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f10a353479e6d2bca99abd4781fd9940.png" alt="image-20200710083656277"></p>
<h2 id="9-3-机器码、指令、汇编语言"><a href="#9-3-机器码、指令、汇编语言" class="headerlink" title="9.3. 机器码、指令、汇编语言"></a>9.3. 机器码、指令、汇编语言</h2><h3 id="9-3-1-机器码"><a href="#9-3-1-机器码" class="headerlink" title="9.3.1. 机器码"></a>9.3.1. 机器码</h3><p>各种用二进制编码方式表示的指令，叫做机器指令码。开始，人们就用它采编写程序，这就是机器语言。</p>
<p>机器语言虽然能够被计算机理解和接受，但和人们的语言差别太大，不易被人们理解和记忆，并且用它编程容易出差错。</p>
<p>用它编写的程序一经输入计算机，CPU 直接读取运行，因此和其他语言编的程序相比，执行速度最快。</p>
<p>机器指令与 CPU 紧密相关，所以不同种类的 CPU 所对应的机器指令也就不同。</p>
<h3 id="9-3-2-指令"><a href="#9-3-2-指令" class="headerlink" title="9.3.2. 指令"></a>9.3.2. 指令</h3><p>由于机器码是有 0 和 1 组成的二进制序列，可读性实在太差，于是人们发明了指令。</p>
<p>指令就是把机器码中特定的 0 和 1 序列，简化成对应的指令（一般为英文简写，如 mov，inc 等），可读性稍好</p>
<p>由于不同的硬件平台，执行同一个操作，对应的机器码可能不同，所以不同的硬件平台的同一种指令（比如 mov），对应的机器码也可能不同。</p>
<h3 id="9-3-3-指令集"><a href="#9-3-3-指令集" class="headerlink" title="9.3.3. 指令集"></a>9.3.3. 指令集</h3><p>不同的硬件平台，各自支持的指令，是有差别的。因此每个平台所支持的指令，称之为对应平台的指令集。 如常见的</p>
<ul>
<li>x86 指令集，对应的是 x86 架构的平台</li>
<li>ARM 指令集，对应的是 ARM 架构的平台</li>
</ul>
<h3 id="9-3-4-汇编语言"><a href="#9-3-4-汇编语言" class="headerlink" title="9.3.4. 汇编语言"></a>9.3.4. 汇编语言</h3><p>由于指令的可读性还是太差，于是人们又发明了汇编语言。</p>
<p>在汇编语言中，<mark>用助记符（Mnemonics）代替机器指令的操作码，用&lt;mark 地址符号（Symbol）或标号（Label）代替指令或操作数的地址</mark>。在不同的硬件平台，汇编语言对应着不同的机器语言指令集，通过汇编过程转换成机器指令。</p>
<p>由于计算机只认识指令码，所以用<mark>汇编语言编写的程序还必须翻译成机器指令码</mark>，计算机才能识别和执行。</p>
<h3 id="9-3-5-高级语言"><a href="#9-3-5-高级语言" class="headerlink" title="9.3.5. 高级语言"></a>9.3.5. 高级语言</h3><p>为了使计算机用户编程序更容易些，后来就出现了各种高级计算机语言。高级语言比机器语言、汇编语言<mark>更接近人的语言</mark></p>
<p>当计算机执行高级语言编写的程序时，<mark>仍然需要把程序解释和编译成机器的指令码</mark>。完成这个过程的程序就叫做解释程序或编译程序。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c812403e1ebae81455d5276b884e5ca8.png" alt="image-20200710085323733"></p>
<p>高级语言也不是直接翻译成机器指令，而是翻译成汇编语言码，如下面说的 C 和 C++</p>
<h4 id="C、C-源程序执行过程"><a href="#C、C-源程序执行过程" class="headerlink" title="C、C++源程序执行过程"></a>C、C++源程序执行过程</h4><p>编译过程又可以分成两个阶段：编译和汇编。</p>
<p><strong>编译过程</strong>：是读取源程序（字符流），对之进行词法和语法的分析，将高级语言指令转换为功能等效的汇编代码</p>
<p><strong>汇编过程</strong>：实际上指把汇编语言代码翻译成目标机器指令的过程。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/71d4298a250e724d64d78a2d8ec67cdc.png" alt="image-20200710085553258"></p>
<h3 id="9-3-6-字节码"><a href="#9-3-6-字节码" class="headerlink" title="9.3.6. 字节码"></a>9.3.6. 字节码</h3><p>（字节码主要是为了实现跨平台性）</p>
<p>字节码是一种中间状态（中间码）的二进制代码（文件），它比机器码更抽象，需要直译器转译后才能成为机器码</p>
<p>字节码主要为了实现特定软件运行和软件环境、<mark>与硬件环境无关</mark>。</p>
<p>字节码的实现方式是通过编译器和虚拟机器。编译器将源码编译成字节码，特定平台上的虚拟机器将字节码转译为可以直接执行的指令。字节码典型的应用为：Java bytecode</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cba8c417f20ae9f6671e64574d2e229a.png" alt="image-20210511092336091"></p>
<h2 id="9-4-解释器"><a href="#9-4-解释器" class="headerlink" title="9.4. 解释器"></a>9.4. 解释器</h2><p>JVM 设计者们的初衷仅仅只是单纯地为了<mark>满足 Java 程序实现跨平台特性</mark>，因此避免采用静态编译的方式直接生成本地机器指令，从而诞生了实现解释器在运行时采用逐行解释字节码执行程序的想法。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f1a9c57cf4b6b4197b85d6e2a48a045e.png" alt="image-20200710090203674"></p>
<p>为什么 Java 源文件不直接翻译成 JMV，而是翻译成字节码文件？可能是因为直接翻译的代价是比较大的</p>
<h3 id="9-4-1-解释器工作机制"><a href="#9-4-1-解释器工作机制" class="headerlink" title="9.4.1. 解释器工作机制"></a>9.4.1. 解释器工作机制</h3><p>解释器真正意义上所承担的角色就是一个运行时“翻译者”，将字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</p>
<p>当一条字节码指令被解释执行完成后，接着再根据 PC 寄存器中记录的下一条需要被执行的字节码指令执行解释操作。</p>
<h3 id="9-4-2-解释器分类"><a href="#9-4-2-解释器分类" class="headerlink" title="9.4.2. 解释器分类"></a>9.4.2. 解释器分类</h3><p>在 Java 的发展历史里，一共有两套解释执行器，即古老的字节码解释器、现在普遍使用的模板解释器。</p>
<ul>
<li><strong>字节码解释器</strong>在执行时通过<mark>纯软件代码模拟字节码</mark>的执行，效率非常低下。</li>
<li>而<strong>模板解释器</strong>将<mark>每一条字节码和一个模板函数相关联</mark>，模板函数中直接产生这条字节码执行时的机器码，从而很大程度上提高了解释器的性能。</li>
</ul>
<p>在 HotSpot VM 中，解释器主要由 Interpreter 模块和 Code 模块构成。</p>
<ul>
<li>Interpreter 模块：实现了解释器的核心功能</li>
<li>Code 模块：用于管理 HotSpot VM 在运行时生成的本地机器指令</li>
</ul>
<h3 id="9-4-3-现状"><a href="#9-4-3-现状" class="headerlink" title="9.4.3. 现状"></a>9.4.3. 现状</h3><p>由于解释器在设计和实现上非常简单，因此除了 Java 语言之外，还有许多高级语言同样也是基于解释器执行的，比如 Python、Perl、Ruby 等。但是在今天，<mark>基于解释器执行已经沦落为低效的代名词</mark>，并且时常被一些 C/C++程序员所调侃。</p>
<p>为了解决这个问题，JVM 平台支持一种叫作即时编译的技术。即时编译的目的是避免函数被解释执行，而是<mark>将整个函数体编译成为机器码，每次函数执行时，只执行编译后的机器码即可</mark>，这种方式可以使执行效率大幅度提升。</p>
<p>不过无论如何，基于解释器的执行模式仍然为中间语言的发展做出了不可磨灭的贡献。</p>
<h2 id="9-5-JIT-编译器"><a href="#9-5-JIT-编译器" class="headerlink" title="9.5. JIT 编译器"></a>9.5. JIT 编译器</h2><h3 id="9-5-1-Java-代码的执行分类"><a href="#9-5-1-Java-代码的执行分类" class="headerlink" title="9.5.1. Java 代码的执行分类"></a>9.5.1. Java 代码的执行分类</h3><ul>
<li><p>第一种是将源代码编译成字节码文件，然后在运行时通过解释器将字节码文件转为机器码执行</p>
</li>
<li><p>第二种是编译执行（直接编译成机器码，但是要知道不同机器上编译的机器码是不一样，而字节码是可以跨平台的）。现代虚拟机为了提高执行效率，会使用即时编译技术（JIT，Just In Time）将方法编译成机器码后再执行</p>
</li>
</ul>
<p>HotSpot VM 是目前市面上高性能虚拟机的代表作之一。它采用<mark>解释器与即时编译器并存的架构</mark>。在 Java 虚拟机运行时，解释器和即时编译器能够相互协作，各自取长补短，尽力去选择最合适的方式来权衡编译本地代码的时间和直接解释执行代码的时间。</p>
<p>在今天，Java 程序的运行性能早已脱胎换骨，已经达到了可以和 C/C++ 程序一较高下的地步。</p>
<p><strong>问题来了</strong></p>
<p>有些开发人员会感觉到诧异，<mark>既然 HotSpot VM 中已经内置 JIT 编译器了，那么为什么还需要再使用解释器来“拖累”程序的执行性能呢？</mark>比如 JRockit VM 内部就不包含解释器，字节码全部都依靠即时编译器编译后执行。</p>
<p>首先明确： 当程序启动后，解释器可以马上发挥作用，省去编译的时间，立即执行。 编译器要想发挥作用，把代码编译成本地代码，需要一定的执行时间。但编译为本地代码后，执行效率高。</p>
<p>所以： 尽管 JRockit VM 中程序的执行性能会非常高效，但程序在启动时必然需要花费更长的时间来进行编译。对于服务端应用来说，启动时间并非是关注重点，但对于那些看中启动时间的应用场景而言，或许就需要采用解释器与即时编译器并存的架构来换取一个平衡点。在此模式下，<mark>当 Java 虚拟器启动时，解释器可以首先发挥作用，而不必等待即时编译器全部编译完成后再执行，这样可以省去许多不必要的编译时间</mark>。随着时间的推移，编译器发挥作用，把越来越多的代码编译成本地代码，获得更高的执行效率。</p>
<p>同时，解释执行在编译器进行激进优化不成立的时候，作为编译器的“逃生门”。</p>
<h3 id="9-5-2-HotSpot-JVM-执行方式"><a href="#9-5-2-HotSpot-JVM-执行方式" class="headerlink" title="9.5.2. HotSpot JVM 执行方式"></a>9.5.2. HotSpot JVM 执行方式</h3><p><font color="green"><strong>解析器和JIT编译器结合使用</strong></font></p>
<p>当虚拟机启动的时候，<mark>解释器可以首先发挥作用</mark>，而不必等待即时编译器全部编译完成再执行，这样可以省去许多不必要的编译时间。并且随着程序运行时间的推移，即时编译器逐渐发挥作用，根据热点探测功能，<mark>将有价值的字节码编译为本地机器指令</mark>，以换取更高的程序执行效率。</p>
<p><strong>案例来了</strong></p>
<p>注意解释执行与编译执行在线上环境微妙的辩证关系。<mark>机器在热机状态可以承受的负载要大于冷机状态</mark>。如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p>在生产环境发布过程中，以分批的方式进行发布，根据机器数量划分成多个批次，每个批次的机器数至多占到整个集群的 1/8。曾经有这样的故障案例：某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成分为两批发布。如果是热机状态，在正常情况下一半的机器可以勉强承载流量，但由于刚启动的 JVM 均是解释执行，还没有进行热点代码统计和 JIT 动态编译，导致机器启动之后，当前 1/2 发布成功的服务器马上全部宕机，此故障说明了 JIT 的存在。—阿里团队</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7f26fbc3a6ec701fe4f84eea99811540.png" alt="image-20200710095417462"></p>
<h3 id="9-5-3-概念解释"><a href="#9-5-3-概念解释" class="headerlink" title="9.5.3. 概念解释"></a>9.5.3. 概念解释</h3><p>Java 语言的“编译期”其实是一段“不确定”的操作过程，因为它可能是指一个<mark>前端编译器</mark>（其实叫“编译器的前端”更准确一些）把.java 文件转变成.class 文件的过程；</p>
<p>也可能是指虚拟机的<mark>后端运行期编译器</mark>（JIT 编译器，Just In Time Compiler）把字节码转变成机器码的过程。</p>
<p>还可能是指使用<mark>静态提前编译器</mark>（AOT 编译器，Ahead of Time Compiler）直接把.java 文件编译成本地机器代码的过程。</p>
<ul>
<li><p>前端编译器：Sun 的 Javac、Eclipse JDT 中的增量式编译器（ECJ）。</p>
</li>
<li><p>JIT 编译器：HotSpot VM 的 C1、C2 编译器。</p>
</li>
<li><p>AOT 编译器：GNU Compiler for the Java（GCJ）、Excelsior JET。</p>
</li>
</ul>
<h3 id="9-5-4-热点代码及探测技术"><a href="#9-5-4-热点代码及探测技术" class="headerlink" title="9.5.4. 热点代码及探测技术"></a>9.5.4. 热点代码及探测技术</h3><p>当然是否需要启动 JIT 编译器将字节码直接编译为对应平台的本地机器指令，则需要根据代码被调用执行的频率而定。关于那些需要被编译为本地代码的字节码，也被称之为“热点代码”，JIT 编译器在运行时会针对那些频繁被调用的“热点代码”做出深度优化，将其直接编译为对应平台的本地机器指令，以此提升 Java 程序的执行性能。</p>
<p><mark>一个被多次调用的方法，或者是一个方法体内部循环次数较多的循环体都可以被称之为“热点代码”</mark>，因此都可以通过 JIT 编译器编译为本地机器指令。由于这种编译方式发生在方法的执行过程中，因此被称之为栈上替换，或简称为<mark>OSR（On Stack Replacement）编译</mark>。</p>
<p>一个方法究竟要被调用多少次，或者一个循环体究竟需要执行多少次循环才可以达到这个标准？必然需要一个明确的阈值，JIT 编译器才会将这些“热点代码”编译为本地机器指令执行。这里主要依靠<mark>热点探测功能</mark>。</p>
<p><mark>目前 HotSpot VM 所采用的热点探测方式是基于计数器的热点探测</mark>。</p>
<p>采用基于计数器的热点探测，HotSpot VM 将会为每一个方法都建立 2 个不同类型的计数器，分别为<mark>方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）</mark>。</p>
<ul>
<li>方法调用计数器用于统计方法的调用次数</li>
<li>回边计数器则用于统计循环体执行的循环次数</li>
</ul>
<h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p><strong>这个计数器就用于统计方法被调用的次数，它的默认阀值在 Client 模式下是 1500 次，在 Server 模式下是 10000 次。超过这个阈值，就会触发 JIT 编译。</strong></p>
<p>这个阀值可以通过虚拟机参数 <code>-XX:CompileThreshold</code>来人为设定。</p>
<p>当一个方法被调用时，会先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加 1，然后判断<mark>方法调用计数器与回边计数器值之和</mark>是否超过方法调用计数器的阀值。如果已超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/26dc8459b4b31e3d9c40b3aec10b15cd.png" alt="image-20200710101829934"></p>
<h4 id="热点衰减"><a href="#热点衰减" class="headerlink" title="热点衰减"></a>热点衰减</h4><p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即<mark>一段时间之内方法被调用的次数</mark>。当超过<mark>一定的时间限度</mark>，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器就会被减少一半，这个过程称为方法调用计数器热度的<mark>衰减（Counter Decay）</mark>，而这段时间就称为此方法统计的<mark>半衰周期（Counter Half Life Time）</mark></p>
<p>进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数 <code>-XX:-UseCounterDecay</code> 来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。</p>
<p>另外，可以使用<code>-XX:CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p>
<h4 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h4><p>它的作用是统计一个<mark>方法中循环体代码执行的次数</mark>，在字节码中遇到控制流向后跳转的指令称为“回边”（Back Edge）。显然，建立回边计数器统计的目的就是为了触发 OSR 编译。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4de983636a290fde3fea83a6cd60d6a5.png" alt="image-20200710103103869"></p>
<h3 id="9-5-5-HotSpotVM-可以设置程序执行方法"><a href="#9-5-5-HotSpotVM-可以设置程序执行方法" class="headerlink" title="9.5.5. HotSpotVM 可以设置程序执行方法"></a>9.5.5. HotSpotVM 可以设置程序执行方法</h3><p>缺省情况下 HotSpot VM 是采用解释器与即时编译器并存的架构，当然开发人员可以根据具体的应用场景，<strong>通过命令显式地为 Java 虚拟机指定在运行时到底是完全采用解释器执行，还是完全采用即时编译器执行</strong>。如下所示：</p>
<ul>
<li><code>-Xint</code>：完全采用解释器模式执行程序；</li>
<li><code>-Xcomp</code>：完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行</li>
<li><code>-Xmixed</code>：采用解释器+即时编译器的混合模式共同执行程序。</li>
</ul>
<p><img src="/../../../images/image-20221120214349955.png" alt="image-20221120214349955"></p>
<p>例子：</p>
<p>通过设置三种不同的方式进行测试：</p>
<p><img src="/../../../images/image-20221120214924904.png" alt="image-20221120214924904"></p>
<p>设置方式如下：</p>
<p><img src="/../../../images/image-20221120214714985.png" alt="image-20221120214714985"></p>
<h3 id="9-5-6-HotSpotVM-中-JIT-分类"><a href="#9-5-6-HotSpotVM-中-JIT-分类" class="headerlink" title="9.5.6. HotSpotVM 中 JIT 分类"></a>9.5.6. HotSpotVM 中 JIT 分类</h3><p>JIT 的编译器还分为了两种，分别是 C1 和 C2，在 HotSpot VM 中内嵌有两个 JIT 编译器，分别为 Client Compiler 和 Server Compiler，但大多数情况下我们简称为 C1 编译器 和 C2 编译器。开发人员可以通过如下命令显式指定 Java 虚拟机在运行时到底使用哪一种即时编译器，如下所示：</p>
<ul>
<li><code>-client</code>：指定 Java 虚拟机运行在 Client 模式下，并使用 C1 编译器；C1 编译器会对字节码<mark>进行简单和可靠的优化，耗时短</mark>，以达到更快的编译速度。</li>
<li><code>-server</code>：指定 Java 虚拟机运行在 server 模式下，并使用 C2 编译器。C2<mark>进行耗时较长的优化，以及激进优化</mark>，但优化的代码执行效率更高。</li>
</ul>
<p><mark>分层编译（Tiered Compilation）策略</mark>：程序解释执行（ 不开启性能监控）可以触发 C1 编译，将字节码编译成机器码，可以进行简单优化，也可以加上性能监控，C2 编译会根据性能监控信息进行激进优化。</p>
<p>不过在 Java7 版本之后，一旦开发人员在程序中显式指定命令“-server”时，默认将会开启分层编译策略，由 C1 编译器和 C2 编译器相互协作共同来执行编译任务。</p>
<h4 id="C1-和-C2-编译器不同的优化策略"><a href="#C1-和-C2-编译器不同的优化策略" class="headerlink" title="C1 和 C2 编译器不同的优化策略"></a>C1 和 C2 编译器不同的优化策略</h4><p>在不同的编译器上有不同的优化策略，C1 编译器上主要有<mark>方法内联、去虚拟化、冗余消除</mark>。</p>
<ul>
<li>方法内联：将引用的函数代码编译到引用点处，这样可以减少栈帧的生成，减少参数传递以及跳转过程</li>
<li>去虚拟化：对唯一的实现类进行内联</li>
<li>冗余消除：在运行期间把一些不会执行的代码折叠掉</li>
</ul>
<p>C2 的优化主要是在全局层面，逃逸分析（前面讲过，并不成熟）是优化的基础。基于逃逸分析在 C2 上有如下几种优化：</p>
<ul>
<li><mark>标量替换</mark>：用标量值代替聚合对象的属性值</li>
<li><mark>栈上分配</mark>：对于未逃逸的对象分配对象在栈而不是堆</li>
<li><mark>同步消除</mark>：清除同步操作，通常指 synchronized</li>
</ul>
<p><img src="/../../../images/image-20221120215856902.png" alt="image-20221120215856902"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一般来讲，JIT 编译出来的机器码性能比解释器高。</p>
<p>C2 编译器启动时长比 C1 慢，系统稳定执行以后，C2 编译器执行速度远快于 C1 编译器</p>
<h3 id="写到最后-1"><a href="#写到最后-1" class="headerlink" title="写到最后 1"></a>写到最后 1</h3><ul>
<li>自 JDK10 起，HotSpot 又加入了一个全新的及时编译器：Graal 编译器</li>
<li>编译效果短短几年时间就追评了 C2 编译器，未来可期</li>
<li>目前，带着实验状态标签，需要使用开关参数<code>-XX:+UnlockExperimentalvMOptions -XX:+UseJVMCICompiler</code>去激活才能使用</li>
</ul>
<h3 id="写到最后-2：AOT-编译器"><a href="#写到最后-2：AOT-编译器" class="headerlink" title="写到最后 2：AOT 编译器"></a>写到最后 2：AOT 编译器</h3><p>jdk9 引入了 AOT 编译器（静态提前编译器，Ahead of Time Compiler）</p>
<p>Java 9 引入了实验性 AOT 编译工具 jaotc。它借助了 Graal 编译器，将所输入的 Java 类文件转换为机器码，并存放至生成的动态共享库之中。</p>
<p>所谓 AOT 编译，是与即时编译相对立的一个概念。我们知道，<mark>即时编译指的是在程序的运行过程中，将字节码转换为可在硬件上直接运行的机器码</mark>，并部署至托管环境中的过程。而<mark>AOT 编译指的则是，在程序运行之前，便将字节码转换为机器码的过程。</mark></p>
<p>最大的好处：Java 虚拟机加载已经预编译成二进制库，可以直接执行。不必等待及时编译器的预热，减少 Java 应用给人带来“第一次运行慢” 的不良体验</p>
<p>缺点：</p>
<ul>
<li><mark>破坏了 java “ 一次编译，到处运行”的理念</mark>，必须为每个不同的硬件，OS 编译对应的发行包</li>
<li><mark>降低了 Java 链接过程的动态性</mark>，加载的代码在编译器就必须全部已知。</li>
<li>还需要继续优化中，最初只支持 Linux X64 java base</li>
</ul>
<h3 id="为什么不全部使用-AOT-呢？"><a href="#为什么不全部使用-AOT-呢？" class="headerlink" title="为什么不全部使用 AOT 呢？"></a>为什么不全部使用 AOT 呢？</h3><p>AOT 可以提前编译节省启动时间，那为什么不全部使用这种编译方式呢？</p>
<p>长话短说，这和 Java 语言的动态特性有千丝万缕的联系了。举个例子，CGLIB 动态代理使用的是 ASM 技术，而这种技术大致原理是运行时直接在内存中生成并加载修改后的字节码文件也就是 <code>.class</code> 文件，如果全部使用 AOT 提前编译，也就不能使用 ASM 技术了。为了支持类似的动态特性，所以选择使用 JIT 即时编译器。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/9.%20%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/" data-id="cliiv9kwn008m3kv622qtfrh8" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/8.对象实例化及直接内存" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/" class="article-date">
  <time class="post-time" datetime="2022-11-20T04:16:21.730Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/">8. 对象实例化及直接内存</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="8-对象实例化及直接内存"><a href="#8-对象实例化及直接内存" class="headerlink" title="8. 对象实例化及直接内存"></a>8. 对象实例化及直接内存</h1><h2 id="8-1-对象实例化"><a href="#8-1-对象实例化" class="headerlink" title="8.1. 对象实例化"></a>8.1. 对象实例化</h2><p><strong>面试题</strong></p>
<blockquote>
<p><mark>美团</mark>：</p>
<p>对象在 JVM 中是怎么存储的？</p>
<p>对象头信息里面有哪些东西？</p>
<p><mark>蚂蚁金服</mark>：</p>
<p>Java 对象头有什么？</p>
</blockquote>
<p><img src="/../../../images/image-20221120122751656.png" alt="image-20221120122751656"></p>
<h3 id="8-1-1-创建对象的方式"><a href="#8-1-1-创建对象的方式" class="headerlink" title="8.1.1. 创建对象的方式"></a>8.1.1. 创建对象的方式</h3><ul>
<li>new：最常见的方式、Xxx 的静态方法，XxxBuilder/XxxFactory 的静态方法</li>
<li>Class 的 newInstance 方法：反射的方式，只能调用空参的构造器，权限必须是 public</li>
<li>Constructor 的 newInstance(XXX)：反射的方式，可以调用空参、带参的构造器，权限没有要求</li>
<li>使用 clone()：不调用任何的构造器，要求当前的类需要实现 Cloneable 接口，实现 clone()</li>
<li>使用序列化：从文件中、从网络中获取一个对象的二进制流</li>
<li>第三方库 Objenesis</li>
</ul>
<h3 id="8-1-2-创建对象的步骤"><a href="#8-1-2-创建对象的步骤" class="headerlink" title="8.1.2. 创建对象的步骤"></a>8.1.2. 创建对象的步骤</h3><p>前面所述是从字节码角度看待对象的创建过程，现在从执行步骤的角度来分析：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/504c93d37f3d51c88b1834d78c33eaa2.png" alt="image-20210510220743192"></p>
<h4 id="1-判断对象对应的类是否加载、链接、初始化（即，要加载创建的对象所属的类）"><a href="#1-判断对象对应的类是否加载、链接、初始化（即，要加载创建的对象所属的类）" class="headerlink" title="1. 判断对象对应的类是否加载、链接、初始化（即，要加载创建的对象所属的类）"></a>1. 判断对象对应的类是否加载、链接、初始化（即，要加载创建的对象所属的类）</h4><p>虚拟机遇到一条 new 指令，首先去检查这个指令的参数能否在 Metaspace 的常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化（即判断类元信息是否存在）。</p>
<p>如果没有，那么在<strong>双亲委派</strong>模式下，使用当前类加载器以 ClassLoader + 包名 + 类名为 key 进行查找对应的 .class 文件；</p>
<ul>
<li>如果没有找到文件，则抛出 ClassNotFoundException 异常</li>
<li>如果找到，则进行类加载，并生成对应的 Class 对象</li>
</ul>
<h4 id="2-为对象分配内存"><a href="#2-为对象分配内存" class="headerlink" title="2. 为对象分配内存"></a>2. 为对象分配内存</h4><p>首先计算对象占用空间的大小，接着在堆中划分一块内存给新对象。如果实例成员变量是引用变量，仅分配引用变量空间即可，即 4 个字节大小</p>
<p><strong>如果内存规整</strong>：虚拟机将采用的是<mark>指针碰撞法（Bump The Point）</mark>来为对象分配内存。</p>
<ul>
<li>意思是所有用过的内存在一边，空闲的内存放另外一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针指向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial ，ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带 Compact（整理）过程的收集器时，使用指针碰撞。</li>
</ul>
<p><strong>如果内存不规整</strong>：虚拟机需要维护一个<mark>空闲列表（Free List）</mark>来为对象分配内存。</p>
<ul>
<li>已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表来为对象分配内存。意思是虚拟机维护了一个列表，记录上哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。</li>
</ul>
<p>选择哪种分配方式由 Java 堆是否规整所决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<h4 id="3-处理并发问题"><a href="#3-处理并发问题" class="headerlink" title="3. 处理并发问题"></a>3. 处理并发问题</h4><ul>
<li><p>采用 CAS 失败重试、区域加锁保证更新的原子性</p>
<ul>
<li>ps ： CAS（Compare-And-Swap）,它是一条CPU并发原语，用于判断内存中某个位置的值是否为<strong>预期值</strong>，如果是则更改为新的值，这个过程是<strong>原子</strong>的。</li>
</ul>
</li>
<li><p>每个线程预先分配一块 TLAB：通过设置 <code>-XX:+UseTLAB</code>参数来设定</p>
<ul>
<li>ps：TLAB是线程私有的，不会被其它线程共享使用，但是TLAB区域不大</li>
</ul>
</li>
</ul>
<h4 id="4-初始化分配到的内存"><a href="#4-初始化分配到的内存" class="headerlink" title="4. 初始化分配到的内存"></a>4. 初始化分配到的内存</h4><p>所有属性设置默认值，保证对象实例字段在不赋值时可以直接使用</p>
<h4 id="5-设置对象的对象头"><a href="#5-设置对象的对象头" class="headerlink" title="5. 设置对象的对象头"></a>5. 设置对象的对象头</h4><p>将对象的所属类（即类的元数据信息）、对象的 HashCode 和对象的 GC 信息、锁信息等数据存储在对象的对象头中。这个过程的具体设置方式取决于 JVM 实现。</p>
<h4 id="6-执行-init-方法进行初始化"><a href="#6-执行-init-方法进行初始化" class="headerlink" title="6. 执行 init 方法进行初始化"></a>6. 执行 init 方法进行初始化</h4><p>在 Java 程序的视角看来，初始化才正式开始。<mark>初始化成员变量，执行实例化代码块，调用类的构造方法</mark>，并把堆内对象的首地址赋值给引用变量。</p>
<p>因此一般来说（由字节码中跟随 invokespecial 指令所决定），new 指令之后会接着就是执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完成创建出来。</p>
<p><strong>给对象属性赋值的操作</strong></p>
<ul>
<li>属性的默认初始化</li>
<li>显式初始化</li>
<li>代码块中初始化</li>
<li>构造器中初始化</li>
</ul>
<p><strong>对象实例化的过程</strong></p>
<ol>
<li>加载类元信息</li>
<li>为对象分配内存</li>
<li>处理并发问题</li>
<li>属性的默认初始化（零值初始化）</li>
<li>设置对象头信息</li>
<li>属性的显示初始化、代码块中初始化、构造器中初始化</li>
</ol>
<h2 id="8-2-对象内存布局"><a href="#8-2-对象内存布局" class="headerlink" title="8.2. 对象内存布局"></a>8.2. 对象内存布局</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f6e34140a6bd24a85d9f766652b57d98.png" alt="image-20200709151033237"></p>
<h3 id="8-2-1-对象头（Header）"><a href="#8-2-1-对象头（Header）" class="headerlink" title="8.2.1. 对象头（Header）"></a>8.2.1. 对象头（Header）</h3><p>对象头包含了两部分，分别是<mark>运行时元数据（Mark Word）</mark>和<mark>类型指针</mark>。如果是数组，还需要记录数组的长度</p>
<h4 id="运行时元数据"><a href="#运行时元数据" class="headerlink" title="运行时元数据"></a>运行时元数据</h4><ul>
<li>哈希值（HashCode）</li>
<li>GC 分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程 ID</li>
<li>翩向时间戳</li>
</ul>
<h4 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h4><p>指向类元数据 InstanceKlass，确定该对象所属的类型。</p>
<h3 id="8-2-2-实例数据（Instance-Data）"><a href="#8-2-2-实例数据（Instance-Data）" class="headerlink" title="8.2.2. 实例数据（Instance Data）"></a>8.2.2. 实例数据（Instance Data）</h3><p>它是对象真正存储的有效信息，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p>
<ul>
<li>相同宽度的字段总是被分配在一起</li>
<li>父类中定义的变量会出现在子类之前</li>
<li>如果 CompactFields 参数为 true（默认为 true）：子类的窄变量可能插入到父类变量的空隙</li>
</ul>
<h3 id="8-2-3-对齐填充（Padding）"><a href="#8-2-3-对齐填充（Padding）" class="headerlink" title="8.2.3. 对齐填充（Padding）"></a>8.2.3. 对齐填充（Padding）</h3><p>不是必须的，也没有特别的含义，仅仅起到占位符的作用</p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Customer</span>{</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    String name;</span><br><span class="line">    Account acct;</span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        name = <span class="string">"匿名客户"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Customer</span><span class="params">()</span> {</span><br><span class="line">        acct = <span class="keyword">new</span> <span class="title class_">Account</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomerTest</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(string[] args)</span>{</span><br><span class="line">        Customer cust=<span class="keyword">new</span> <span class="title class_">Customer</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>图示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/1bba0ee2a8a614b80d6cac9fecbb3f8a.png" alt="image-20200709152801713"></p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/3be25c48b29d3cef51354f19cbe31d7d.png" alt="image-20210510225407119"></p>
<h2 id="8-3-对象的访问定位"><a href="#8-3-对象的访问定位" class="headerlink" title="8.3. 对象的访问定位"></a>8.3. 对象的访问定位</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/375b00ca9022291e7d2e214ce2d7cbfd.png" alt="image-20210510230045654"></p>
<p>JVM 是如何通过栈帧中的对象引用访问到其内部的对象实例呢？</p>
<p>定位，通过栈上reference访问</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/deab7773248ea150e5f7dee3901700cd.png" alt="image-20200709164149920"></p>
<h3 id="8-3-1-句柄访问"><a href="#8-3-1-句柄访问" class="headerlink" title="8.3.1. 句柄访问"></a>8.3.1. 句柄访问</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/59cc079fe02b7a5836ff7c2c7fffb635.png" alt="image-20210510230241991"></p>
<p>reference 中存储稳定句柄地址，对象被移动（垃圾收集时移动对象很普遍）时只会改变句柄中实例数据指针即可，reference 本身不需要被修改</p>
<h3 id="8-3-2-直接指针（HotSpot-采用）"><a href="#8-3-2-直接指针（HotSpot-采用）" class="headerlink" title="8.3.2. 直接指针（HotSpot 采用）"></a>8.3.2. 直接指针（HotSpot 采用）</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/694601dcb023c6d10168a00fe000becc.png" alt="image-20210510230337956"></p>
<p>直接指针是局部变量表中的引用，直接指向堆中的实例，在对象实例中有类型指针，指向的是方法区中的对象类型数据</p>
<p>直接指针的reference是不稳定的，可能发生变化的，因为reference指向的对象，在垃圾回收时，需要移动，所以reference就会跟着修改</p>
<h2 id="8-4-直接内存（Direct-Memory）"><a href="#8-4-直接内存（Direct-Memory）" class="headerlink" title="8.4. 直接内存（Direct Memory）"></a>8.4. 直接内存（Direct Memory）</h2><h3 id="8-4-1-直接内存概述"><a href="#8-4-1-直接内存概述" class="headerlink" title="8.4.1. 直接内存概述"></a>8.4.1. 直接内存概述</h3><p>不是虚拟机运行时数据区的一部分，也不是《Java 虚拟机规范》中定义的内存区域。<mark>直接内存是在 Java 堆外的、直接向系统申请的内存区间</mark>。来源于 NIO，通过存在堆中的 DirectByteBuffer 操作 Native 内存。通常，访问直接内存的速度会优于 Java 堆，即<mark>读写性能高</mark>。</p>
<ul>
<li>因此出于性能考虑，读写频繁的场合可能会考虑使用直接内存。</li>
<li>Java 的 NIO 库允许 Java 程序使用直接内存，用于数据缓冲区</li>
</ul>
<h3 id="8-4-2-非直接缓存区"><a href="#8-4-2-非直接缓存区" class="headerlink" title="8.4.2. 非直接缓存区"></a>8.4.2. 非直接缓存区</h3><p>使用 IO 读写文件，需要与磁盘交互，需要由用户态切换到内核态。在内核态时，需要两份内存存储重复数据，效率低。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c691d62d73e977fb942748a81313f5e6.png" alt="image-20210510231408607"></p>
<h3 id="8-4-3-直接缓存区"><a href="#8-4-3-直接缓存区" class="headerlink" title="8.4.3. 直接缓存区"></a>8.4.3. 直接缓存区</h3><p>使用 NIO 时，操作系统划出的直接缓存区可以被 java 代码直接访问，只有一份。<strong>NIO</strong> 适合对大文件的读写操作。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d13b08447999ab32811a440496e4dac7.png" alt="image-20210510231456550"></p>
<p>也可能导致 OutOfMemoryError 异常</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">    at java.nio.Bits.reserveMemory(Bits.java:<span class="number">693</span>)</span><br><span class="line">    at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:<span class="number">123</span>)</span><br><span class="line">    at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:<span class="number">311</span>)</span><br><span class="line">    at com.atguigu.java.BufferTest2.main(BufferTest2.java:<span class="number">20</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>由于直接内存在 Java 堆外，因此它的大小不会直接受限于-Xmx 指定的最大堆大小，但是系统内存是有限的，Java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。</p>
<ul>
<li>分配回收成本较高</li>
<li>不受 JVM 内存回收管理</li>
</ul>
<p>直接内存大小可以通过<code>MaxDirectMemorySize</code>设置。如果不指定，默认与堆的最大值-Xmx 参数值一致</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0ac6c50a98325c93b5652602137b9dea.png" alt="image-20200709230647277"></p>
<p>java总的进程空间 = java的堆空间 + 本地内存空间</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/8.%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%8F%8A%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98/" data-id="cliiv9kww008r3kv62ggd26yl" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/7-8运行时数据区的总结以及常见大厂面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7-8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2022-11-20T02:58:43.530Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7-8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/">运行时数据区的总结以及常见大厂面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/interview/">interview</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>,<a class="article-category-link" href="/categories/interview/">interview</a>,<a class="article-category-link" href="/categories/interview/JVM/">JVM</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="运行时数据区的总结以及常见大厂面试题"><a href="#运行时数据区的总结以及常见大厂面试题" class="headerlink" title="运行时数据区的总结以及常见大厂面试题"></a>运行时数据区的总结以及常见大厂面试题</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f73315a70302396e391a532dcf87ce26.png" alt="image-20200708220303243"></p>
<p>线程私有的：程序计数器、本地方法栈、虚拟机栈</p>
<p>虚拟机栈里的栈帧的结构：返回值、局部变量表、操作数栈、动态链接（装着指向运行时常量池的当前方法的引用，知道当前方法是引用运行时常量池中的哪个方法）</p>
<p><img src="/../../../images/image-20221120105434202.png" alt="image-20221120105434202"></p>
<h2 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h2><blockquote>
<p><mark>百度</mark>：</p>
<h3 id="说一下-JVM-内存模型吧，有哪些区？分别干什么的？"><a href="#说一下-JVM-内存模型吧，有哪些区？分别干什么的？" class="headerlink" title="说一下 JVM 内存模型吧，有哪些区？分别干什么的？"></a>说一下 JVM 内存模型吧，有哪些区？分别干什么的？</h3><p><strong>答：</strong></p>
<p>JVM内存区域主要包含：方法区 程序计数器 Java虚拟机栈 本地方法栈 Java堆</p>
<p><strong>1、方法区：</strong></p>
<p>方法区在JDK1.8之后把名字改成了“Metaspace”，可以翻译成”元数据空间”，这是一块<strong>线程共享</strong>的内存空间，主要用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。</p>
<p>Java虚拟机规范将方法区描述为堆的一个逻辑部分，但它有一个别名”Non-Heap 非堆“ 用于与Java堆区分。</p>
<p>很多人愿意把方法区成为”永久代“，本质上两者并不等价。HotSpot虚拟机 团队选择把GC分代收集扩展至方法区，或者说使用永久带实现方法区而已。</p>
<p>方法区存在的<strong>问题</strong>：</p>
<p>永久代容易遇到内存溢出问题（HotSpot永久代有-XX:MaxPermSize上限）当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常<strong>运行时常量池</strong>也是方法区的一个部分，主要用于存放编译器生成的各种字面量和符号引用。类加载后会进入方法区的运行时常量池</p>
<p>运行时常量池存在的<strong>问题：</strong></p>
<p>当常量池无法再申请到内存空间时会抛出OutOfMemoryError异常</p>
<p><strong>2、虚拟机栈</strong></p>
<p>虚拟机栈是<strong>线程私有</strong>的内存空间，其生命周期与线程相同，是用于<strong>Java方法执行的内存模型</strong>。方法执行时会创建栈帧，用于存储局部变量表，操作数栈，动态链接，方法出口等。</p>
<p>虚拟机栈存在的<strong>问题：</strong></p>
<p>线程请求的栈深度大于虚拟机所允许的深度，抛出StackOverflowError异常虚拟机栈动态扩展时无法申请到足够的内存，抛出OutOfMemoryError异常</p>
<p><strong>3、本地方法栈</strong></p>
<p>其发挥的作用和存在的问题与Java虚拟机栈类似，这里主要说一下其区别。其区别主要是虚拟机栈为虚拟机执行Java方法服务，而<font color="red">本地方法栈为虚拟机使用到Native方法服务。</font></p>
<p><strong>知识点：</strong>Hotspot虚拟机中将本地方法栈与虚拟机栈合二为一。</p>
<p><strong>4、Java堆</strong></p>
<p>Java堆是虚拟机中占内存最大的一块内存空间，是所<strong>有线程共享</strong>的内存区域，当虚拟机启动的时候就会创建。它的作用主要是存放对象实例，几乎所有的对象实例都在这里分配内存。我们来看下Java虚拟机规范是怎么描述它的：</p>
<p>所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换优化</strong>技术将会导致一些微妙的变化发生，所有的对象都分配到堆上也渐渐变得不是那么”绝对“了。</p>
<p>这一块内存空间也是垃圾收集器管理的主要区域，所以有时候也被称为”GC堆“。</p>
<p>Java堆存在的<strong>问题：</strong></p>
<p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p>
<p><strong>5、程序计数器</strong></p>
<p>程序计数器是<strong>线程私有</strong>的一块占用较小的内存空间，主要用于记录当前线程执行到哪里了。而且这也是<strong>唯一一个没有内存溢出</strong>的区域。</p>
<p><strong>6、直接内存</strong></p>
<p>除了以上几块内存空间外，还有一块内存空间就是直接内存，它不属于运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分频繁使用也可能导致OutOfMemoryError异常。NIO可以使用Native函数库直接分配堆外内存空间。</p>
<p><strong>文末小结</strong></p>
<p>关于jvm内存区域空间要重点关注<strong>方法区，程序计数器，Java虚拟机栈</strong>和<strong>Java堆</strong>这些内存区域的作用。只有在了解了虚拟机是怎么使用内存的之后，才能在出现内存溢出和泄漏时更快速的定位和排查解决问题。</p>
<p><mark>蚂蚁金服</mark>：</p>
<p>Java8 的内存分代改进 JVM 内存分哪几个区，每个区的作用是什么？</p>
<p>栈和堆的区别？</p>
<p>答：</p>
<ol>
<li><p>栈(stack)与堆(heap)都是Java用来在Ram(随机存储内存)中存放数据的地方。Java自动管理栈和堆，程序员不能直接地设置栈或堆。</p>
</li>
<li><p>java内存的划分 </p>
<p> （1）栈内存：基本类型的变量和对象的引用变量</p>
<pre><code>                   优势：存取速度比堆要快，仅次于直接位于CPU中的寄存器；  栈数据可以共享

                   劣势：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性
</code></pre>
<p>   （2）堆内存：存放由new创建的对象和数组</p>
<pre><code>                   优势：动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据

                   劣势：由于要在运行时动态分配内存，存取速度较慢
</code></pre>
</li>
<li><p>内存的释放：</p>
<pre><code>（1）栈内存： 当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。

 （2）堆内存：由Java虚拟机的自动垃圾回收器来管理。
</code></pre>
</li>
</ol>
<p>一面：JVM 内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个 survivor 区？</p>
<p><strong>二面：Eden 和 survior 的比例分配</strong></p>
<p>答：8 : 1 : 1</p>
<p><mark>小米</mark>：</p>
<p>jvm 内存分区，为什么要有新生代和老年代</p>
<p>答：</p>
<p>其实不分代完全可以，分代的唯一理由就是<strong>优化 GC 性能</strong>。如果没有分代，那所有的对象都在一块，就如同把一个学校的人都关在一个教室。GC 的时候要找到哪些对象没用，这样就会对堆的所有区域进行扫描。而很多对象都是朝生夕死的，如果分代的话，把新创建的对象放到某一地方，当 GC 的时候先把这块存储“朝生夕死”对象的区域进行回收，这样就会腾出很大的空间出来。</p>
<p>答案一：</p>
<p>对于JVM而言，大部分对象都是属于一个朝生夕死的状态，这部分对象随着方法的调用而创建，方法的结束而消亡，只有少部分的对象会长久的留在JVM 内存中，所以根据这样的特性JVM 把内存分为了新生代 和老年代两个区，一般情况新创建的对象会放到新生代中，只有经过一定次数的GC后还没有被回收的对象，我们认为这部分对象在未来也会长时间存在，所以会把这部分的对象转移到老年代的区域中去。</p>
<p>答案二：</p>
<p>1）新生代(Young Gen)：年轻代主要存放新创建的对象，内存大小相对会比较小，垃圾回收会比较频繁。年轻代分成1个Eden Space和2个Suvivor Space（from 和to）。<br>2）老年代(Tenured Gen)：年老代主要存放JVM认为生命周期比较长的对象（经过几次的Young Gen的垃圾回收后仍然存在），内存大小相对会比较大，垃圾回收也相对没有那么频繁。</p>
</blockquote>
<blockquote>
<p><mark>字节跳动</mark>：</p>
<p>二面：Java 的内存分区</p>
<p>二面：讲讲 vm 运行时数据库区 什么时 候对象会进入老年代？</p>
<p>答：</p>
<ol>
<li><p><strong>长期存活的对象</strong>:虚拟机给每个对象定义了一个对象年龄(Age)计数器,如果对象在Eden出生并经过第一次Minor GC后仍然存活,并且能被Survivor容纳的话,将被移动到Survivor空间中,并且对象年龄设为1,。对象在Survivor区中每熬过一次Minor GC,年龄就增加1,当他的年龄增加到一定程度(默认是15岁), 就将会被晋升到老年代中。对象晋升到老年代的年龄阈值,可以通过参数-XX:MaxTenuringThreshold设置。</p>
</li>
<li><p>当遇到<strong>超大对象</strong>时，发现新生代中的Eden区(即便进行了Minor GC)放不下，就会直接尝试放到老年代Tenured/OId，如果老年代也放不下，就触发Major GC 或 Full GC，之后老年代区能放得下就放，不能的话就报OOM。大对象对虚拟机的内存分配就是坏消息,尤其是一些朝生夕灭的短命大对象,写程序时应避免。</p>
</li>
<li><p><strong>动态对象年龄判定</strong>:为了能更好地适应不同程度的内存状况,虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升到老年代,如果在Survivor空间中<strong>相同年龄的所有对象大小的总和大于Survivor空间的一半</strong>, <strong>年龄大于或等于年龄的对象就可以直接进入老年代</strong>,无须等到MaxTenuringThreshold中要求的年龄。</p>
</li>
</ol>
<p><mark>京东</mark>：</p>
<p><strong>JVM 的内存结构，Eden 和 Survivor 比例。</strong> 8 ：1 ：1</p>
<p><strong>JVM 内存为什么要分成新生代，老年代，持久代。</strong></p>
<p><strong>新生代中为什么要分为 Eden 和 survivor。</strong></p>
<p>答：</p>
<ol>
<li><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC.老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多，大概是Minor GC的十倍以上, 如果Major GC触发次数多的话，就会降低性能，所以要尽可能避免或减少老年代触发Major GC。因此需要分为Eden和Survivor。</p>
</li>
<li><p>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p>
</li>
<li><p><strong>设置两个Survivor区最大的好处</strong>就是<font color="blue"><strong>解决了碎片化</strong></font>，刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor spaceS1（这个过程非常重要，因为这种 <strong>复制算法 保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生</strong>）</p>
</li>
</ol>
<p><mark>天猫</mark>：</p>
<p>一面：Jvm 内存模型以及分区，需要详细到每个区放什么。</p>
<p>一面：JVM 的内存模型，Java8 做了什么改</p>
<p>答：</p>
<table>
<thead>
<tr>
<th align="left">JDK1.6 及之前</th>
<th align="left">有永久代（permanet），静态变量存储在永久代上</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>JDK1.7</strong></td>
<td align="left"><strong>有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中</strong></td>
</tr>
<tr>
<td align="left"><strong>JDK1.8</strong></td>
<td align="left"><strong>无永久代，类型信息，字段，方法，常量保存在本地内存的元空间，但字符串常量池、静态变量仍然在堆中。</strong></td>
</tr>
</tbody></table>
<p>其中，String Table之所以要调整位置：</p>
<p>jdk7 中将 StringTable 放到了堆空间中。因为<strong>永久代的回收效率很低</strong>，在 full gc 的时候才会触发。而 full gc 是老年代的空间不足、永久代不足时才会触发。</p>
<p>这就导致 StringTable 回收效率不高。而我们开发中会有大量的字符串被创建，回收效率低，导致永久代内存不足。放到堆里，能及时回收内存。</p>
<p><mark>拼多多</mark>：</p>
<p>JVM 内存分哪几个区，每个区的作用是什么？</p>
<p><mark>美团</mark>：</p>
<p>java 内存分配 jvm 的永久代中会发生垃圾回收吗？</p>
<p>一面：jvm 内存分区，为什么要有新生代和老年代？</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/20/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/7-8%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%9A%84%E6%80%BB%E7%BB%93%E4%BB%A5%E5%8F%8A%E5%B8%B8%E8%A7%81%E5%A4%A7%E5%8E%82%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="cliiv9kwu008p3kv61sebeyb4" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/interview/" rel="tag">interview</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/7/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><a class="page-number" href="/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/9/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>