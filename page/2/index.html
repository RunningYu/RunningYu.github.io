<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>76</strong><br>分类</div></a>
      <a href="/tags"><div><strong>57</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-juc/CAS" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/16/juc/CAS/" class="article-date">
  <time class="post-time" datetime="2023-03-16T01:34:43.961Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">16</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/16/juc/CAS/">CAS</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/juc/">juc</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="并发编程的灵魂cas机制详解"><a class="markdownIt-Anchor" href="#并发编程的灵魂cas机制详解"></a> 并发编程的灵魂：CAS机制详解</h1>
<p>Java中提供了很多原子操作类来保证共享变量操作的原子性。这些原子操作的底层原理都是使用了CAS机制。在使用一门技术之前，了解这个技术的底层原理是非常重要的，所以本篇文章就先来讲讲什么是CAS机制，CAS机制存在的一些问题以及在Java中怎么使用CAS机制。</p>
<p>其实Java并发框架的基石一共有两块，一块是本文介绍的CAS，另一块就是AQS，后续也会写文章介绍。</p>
<h2 id="什么是cas机制"><a class="markdownIt-Anchor" href="#什么是cas机制"></a> 什么是CAS机制</h2>
<p>CAS机制是一种数据更新的方式。在具体讲什么是CAS机制之前，我们先来聊下在多线程环境下，对共享变量进行数据更新的两种模式：悲观锁模式和乐观锁模式。</p>
<p>悲观锁更新的方式认为：在更新数据的时候大概率会有其他线程去争夺共享资源，所以悲观锁的做法是：第一个获取资源的线程会将资源锁定起来，其他没争夺到资源的线程只能进入阻塞队列，等第一个获取资源的线程释放锁之后，这些线程才能有机会重新争夺资源。synchronized就是java中悲观锁的典型实现，synchronized使用起来非常简单方便，但是会使没争抢到资源的线程进入阻塞状态，线程在阻塞状态和Runnable状态之间切换效率较低（比较慢）。比如你的更新操作其实是非常快的，这种情况下你还用synchronized将其他线程都锁住了，线程从Blocked状态切换回Runnable华的时间可能比你的更新操作的时间还要长。</p>
<p>乐观锁更新方式认为:在更新数据的时候其他线程争抢这个共享变量的概率非常小，所以更新数据的时候不会对共享数据加锁。但是在正式更新数据之前会检查数据是否被其他线程改变过，如果未被其他线程改变过就将共享变量更新成最新值，如果发现共享变量已经被其他线程更新过了，就重试，直到成功为止。CAS机制就是乐观锁的典型实现。</p>
<p>CAS，是Compare and Swap的简称，在这个机制中有三个核心的参数：</p>
<ul>
<li>主内存中存放的共享变量的值：V（一般情况下这个V是内存的地址值，通过这个地址可以获得内存中的值）</li>
<li>工作内存中共享变量的副本值，也叫预期值：A</li>
<li>需要将共享变量更新到的最新值：B</li>
</ul>
<p><img src="https://pic1.zhimg.com/80/v2-f32df3fde2dc0132c05533572e2b659c_720w.webp" alt="img"></p>
<p>如上图中，主存中保存V值，线程中要使用V值要先从主存中读取V值到线程的工作内存A中，然后计算后变成B值，最后再把B值写回到内存V值中。多个线程共用V值都是如此操作。CAS的核心是在将B值写入到V之前要比较A值和V值是否相同，如果不相同证明此时V值已经被其他线程改变，重新将V值赋给A，并重新计算得到B，如果相同，则将B值赋给V。</p>
<p>值得注意的是CAS机制中的这步步骤是原子性的（从指令层面提供的原子操作），所以CAS机制可以解决多线程并发编程对共享变量读写的原子性问题。</p>
<h2 id="cas机制优缺点"><a class="markdownIt-Anchor" href="#cas机制优缺点"></a> CAS机制优缺点</h2>
<h3 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点</h3>
<p><strong>1. ABA问题</strong><br>
ABA问题：CAS在操作的时候会检查变量的值是否被更改过，如果没有则更新值，但是带来一个问题，最开始的值是A，接着变成B，最后又变成了A。经过检查这个值确实没有修改过，因为最后的值还是A，但是实际上这个值确实已经被修改过了。为了解决这个问题，在每次进行操作的时候加上一个版本号，每次操作的就是两个值，一个版本号和某个值，A——&gt;B——&gt;A问题就变成了1A——&gt;2B——&gt;3A。在jdk中提供了AtomicStampedReference类解决ABA问题，用Pair这个内部类实现，包含两个属性，分别代表版本号和引用，在compareAndSet中先对当前引用进行检查，再对版本号标志进行检查，只有全部相等才更新值。</p>
<p><strong>2. 可能会消耗较高的CPU</strong><br>
看起来CAS比锁的效率高，从阻塞机制变成了非阻塞机制，减少了线程之间等待的时间。每个方法不能绝对的比另一个好，在线程之间竞争程度大的时候，如果使用CAS，每次都有很多的线程在竞争，也就是说CAS机制不能更新成功。这种情况下CAS机制会一直重试，这样就会比较耗费CPU。因此可以看出，如果线程之间竞争程度小，使用CAS是一个很好的选择；但是如果竞争很大，使用锁可能是个更好的选择。在并发量非常高的环境中，如果仍然想通过原子类来更新的话，可以使用AtomicLong的替代类：LongAdder。</p>
<p><strong>3. 不能保证代码块的原子性</strong><br>
Java中的CAS机制只能保证共享变量操作的原子性，而不能保证代码块的原子性。</p>
<h3 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h3>
<ul>
<li>可以保证变量操作的原子性；</li>
<li>并发量不是很高的情况下，使用CAS机制比使用锁机制效率更高；</li>
<li>在线程对共享资源占用时间较短的情况下，使用CAS机制效率也会较高。</li>
</ul>
<h2 id="java提供的cas操作类unsafe类"><a class="markdownIt-Anchor" href="#java提供的cas操作类unsafe类"></a> Java提供的CAS操作类–Unsafe类</h2>
<p>从Java5开始引入了对CAS机制的底层的支持，在这之前需要开发人员编写相关的代码才可以实现CAS。在原子变量类Atomic<strong>中（例如AtomicInteger、AtomicLong）可以看到CAS操作的代码，在这里的代码都是调用了底层（核心代码调用native修饰的方法）的实现方法。在AtomicInteger源码中可以看getAndSet方法和compareAndSet方法之间的关系，compareAndSet方法调用了底层的实现，该方法可以实现与一个volatile变量的读取和写入相同的效果。在前面说到了volatile不支持例如i++这样的复合操作，在Atomic</strong>中提供了实现该操作的方法。JVM对CAS的支持通过这些原子类（Atomic）暴露出来，供我们使用。</p>
<p>而Atomic系类的类底层调用的是Unsafe类的API，Unsafe类提供了一系列的compareAndSwap*方法，下面就简单介绍下Unsafe类的API：</p>
<ul>
<li>long objectFieldOffset（Field field）方法：返回指定的变量在所属类中的内存偏移地址，该偏移地址仅仅在该Unsafe函数中访问指定字段时使用。如下代码使用Unsafe类获取变量value在AtomicLong对象中的内存偏移。</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static {</span><br><span class="line">   try {</span><br><span class="line">       valueOffset = unsafe.objectFieldOffset</span><br><span class="line">           (AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">   } catch (Exception ex) { throw new Error(ex); }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>int arrayBaseOffset（Class arrayClass）方法：获取数组中第一个元素的地址。</li>
<li>int arrayIndexScale（Class arrayClass）方法：获取数组中一个元素占用的字节。</li>
<li>boolean compareAndSwapLong（Object obj, long offset, long expect, long update）方法：比较对象obj中偏移量为offset的变量的值是否与expect相等，相等则使用update值更新，然后返回true，否则返回false。</li>
<li>public native long getLongvolatile（Object obj, long offset）方法：获取对象obj中偏移量为offset的变量对应volatile语义的值。</li>
<li>void putLongvolatile（Object obj, long offset, long value）方法：设置obj对象中offset偏移的类型为long的field的值为value，支持volatile语义。</li>
<li>void putOrderedLong（Object obj, long offset, long value）方法：设置obj对象中offset偏移地址对应的long型field的值为value。这是一个有延迟的putLongvolatile方法，并且不保证值修改对其他线程立刻可见。只有在变量使用volatile修饰并且预计会被意外修改时才使用该方法。</li>
<li>void park（boolean isAbsolute, long time）方法：阻塞当前线程，其中参数isAbsolute等于false且time等于0表示一直阻塞。time大于0表示等待指定的time后阻塞线程会被唤醒，这个time是个相对值，是个增量值，也就是相对当前时间累加time后当前线程就会被唤醒。如果isAbsolute等于true，并且time大于0，则表示阻塞的线程到指定的时间点后会被唤醒，这里time是个绝对时间，是将某个时间点换算为ms后的值。另外，当其他线程调用了当前阻塞线程的interrupt方法而中断了当前线程时，当前线程也会返回，而当其他线程调用了unPark方法并且把当前线程作为参数时当前线程也会返回。</li>
<li>void unpark（Object thread）方法：唤醒调用park后阻塞的线程。</li>
</ul>
<p>下面是JDK8新增的函数，这里只列出Long类型操作。</p>
<ul>
<li>long getAndSetLong（Object obj, long offset, long update）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量volatile语义的值为update。</li>
</ul>
<figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//这个方法只是封装了compareAndSwapLong的使用，不需要自己写重试机制</span><br><span class="line">public final long getAndSetLong(Object var1, long var2, long var4) {</span><br><span class="line">    long var6;</span><br><span class="line">    do {</span><br><span class="line">        var6 = this.getLongVolatile(var1, var2);</span><br><span class="line">    } while(!this.compareAndSwapLong(var1, var2, var6, var4));</span><br><span class="line"></span><br><span class="line">    return var6;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>long getAndAddLong（Object obj, long offset, long addValue）方法：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量值为原始值+addValue，原理和上面的方法类似。</li>
</ul>
<h2 id="cas使用场景"><a class="markdownIt-Anchor" href="#cas使用场景"></a> CAS使用场景</h2>
<ul>
<li>使用一个变量统计网站的访问量；</li>
<li>Atomic类操作；</li>
<li>数据库乐观锁更新。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/16/juc/CAS/" data-id="clihlibq9004yu4v6guisdl5d" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/juc/" rel="tag">juc</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-elasticsearch/聚合的分类" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/" class="article-date">
  <time class="post-time" datetime="2023-03-13T14:10:42.070Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">13</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/">聚合的分类</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>,<a class="article-category-link" href="/categories/Elasticsearch/DSL/">DSL</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="../../images/image-20230313221322812.png" alt="image-20230313221322812"></p>
<p><img src="../../images/image-20230313221351783.png" alt="image-20230313221351783"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/13/elasticsearch/%E8%81%9A%E5%90%88%E7%9A%84%E5%88%86%E7%B1%BB/" data-id="clihlibp80037u4v67yvq5ppp" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/零碎面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-03-12T07:06:34.463Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PARENT</span> <span class="operator">=</span> <span class="string">"parent"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">CHILD</span> <span class="operator">=</span> <span class="string">"child"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Parent</span><span class="params">()</span> {</span><br><span class="line">    	System.out.print(PARENT + <span class="string">"A "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">   		System.out.print(PARENT + <span class="string">"B "</span>);</span><br><span class="line">    }</span><br><span class="line">    {</span><br><span class="line">    	System.out.print(PARENT + <span class="string">"C "</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> {</span><br><span class="line">    	<span class="keyword">public</span> <span class="title function_">Child</span><span class="params">()</span> {</span><br><span class="line">    	System.out.print(CHILD + <span class="string">"A "</span>);</span><br><span class="line">    	}</span><br><span class="line">    	<span class="keyword">static</span> {</span><br><span class="line">    		System.out.print(CHILD + <span class="string">"B "</span>);</span><br><span class="line">    	}</span><br><span class="line">        {</span><br><span class="line">        	System.out.print(CHILD + <span class="string">"C "</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    	<span class="type">Child</span> <span class="variable">child</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Child</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>输出结果：parentB childB parentC parentA childC childA</p>
<p>官方解析：考察父类、子类的加载顺序：</p>
<p><strong>父类的静态代码块 &gt; 子类的静态代码块 &gt; 父类的动态代码块 &gt; 父类的构造方法 &gt; 子类的动态代码块 &gt; 子类的构造方法。</strong></p>
<h2 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2、</h2>
<p><img src="../../images/image-20230312151036608.png" alt="image-20230312151036608"></p>
<h2 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3、</h2>
<p><img src="../../images/image-20230312151525256.png" alt="image-20230312151525256"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/12/interview/%E9%9B%B6%E7%A2%8E%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clihlibpn003su4v64clwhoqt" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-SpringCloud微服务/Elasticsearch/分布式搜索引擎03" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/" class="article-date">
  <time class="post-time" datetime="2023-03-05T07:37:10.157Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/">3-Elasticsearch</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>,<a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/">Elasticsearch</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式搜索引擎03"><a class="markdownIt-Anchor" href="#分布式搜索引擎03"></a> 分布式搜索引擎03</h1>
<h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1>
<h1 id="1数据聚合"><a class="markdownIt-Anchor" href="#1数据聚合"></a> 1.数据聚合</h1>
<p>**<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">聚合（</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">aggregations</a><a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html">）</a>**可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p>
<ul>
<li>什么品牌的手机最受欢迎？</li>
<li>这些手机的平均价格、最高价格、最低价格？</li>
<li>这些手机每月的销售情况如何？</li>
</ul>
<p>实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p>
<h2 id="11聚合的种类"><a class="markdownIt-Anchor" href="#11聚合的种类"></a> 1.1.聚合的种类</h2>
<p>聚合常见的有三类：</p>
<ul>
<li>
<p>**桶（Bucket）**聚合：用来对文档做分组</p>
<ul>
<li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li>
<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>
</ul>
</li>
<li>
<p>**度量（Metric）**聚合：用以计算一些值，比如：最大值、最小值、平均值等</p>
<ul>
<li>Avg：求平均值</li>
<li>Max：求最大值</li>
<li>Min：求最小值</li>
<li>Stats：同时求max、min、avg、sum等</li>
</ul>
</li>
<li>
<p>**管道（pipeline）**聚合：其它聚合的结果为基础做聚合</p>
</li>
</ul>
<blockquote>
<p>**注意：**参加聚合的字段必须是keyword、日期、数值、布尔类型</p>
</blockquote>
<h2 id="12dsl实现聚合"><a class="markdownIt-Anchor" href="#12dsl实现聚合"></a> 1.2.DSL实现聚合</h2>
<p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。</p>
<h3 id="121bucket聚合语法"><a class="markdownIt-Anchor" href="#121bucket聚合语法"></a> 1.2.1.Bucket聚合语法</h3>
<p>语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;设置size为0，结果中不包含文档，只包含聚合结果</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;定义聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//给聚合起个名字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合的类型，按照品牌值聚合，所以选择term</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;参与聚合的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span>&nbsp;<span class="comment">//&nbsp;希望获取的聚合结果数量</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>结果如图：</p>
<p><img src="../../../images/image-20210723171948228.png" alt="image-20210723171948228"></p>
<h3 id="122聚合结果排序"><a class="markdownIt-Anchor" href="#122聚合结果排序"></a> 1.2.2.聚合结果排序</h3>
<p>默认情况下，Bucket聚合会统计Bucket内的文档数量，记为_count，并且按照_count降序排序。</p>
<p>我们可以指定order属性，自定义聚合的排序方式：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_count"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span> <span class="comment">//&nbsp;按照_count升序排列</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="123限定聚合范围"><a class="markdownIt-Anchor" href="#123限定聚合范围"></a> 1.2.3.限定聚合范围</h3>
<p>默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p>
<p>我们可以限定要聚合的文档范围，只要添加query条件即可：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">200</span> <span class="comment">// 只对200元以下的文档聚合</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>这次，聚合得到的品牌明显变少了：</p>
<p><img src="../../../images/image-20210723172404836.png" alt="image-20210723172404836"></p>
<h3 id="124metric聚合语法"><a class="markdownIt-Anchor" href="#124metric聚合语法"></a> 1.2.4.Metric聚合语法</h3>
<p>上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。</p>
<p>这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。</p>
<p>语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brandAgg"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"terms"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"brand"</span><span class="punctuation">,</span>&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"aggs"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;是brands聚合的子聚合，也就是分组后对每组分别计算</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"score_stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"stats"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;聚合类型，这里stats可以计算min、max、avg等</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"score"</span>&nbsp;<span class="comment">//&nbsp;聚合字段，这里是score</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p>
<p>另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：</p>
<p><img src="../../../images/image-20210723172917636.png" alt="image-20210723172917636"></p>
<h3 id="125小结"><a class="markdownIt-Anchor" href="#125小结"></a> 1.2.5.小结</h3>
<p>aggs代表聚合，与query同级，此时query的作用是？</p>
<ul>
<li>限定聚合的的文档范围</li>
</ul>
<p>聚合必须的三要素：</p>
<ul>
<li>聚合名称</li>
<li>聚合类型</li>
<li>聚合字段</li>
</ul>
<p>聚合可配置属性有：</p>
<ul>
<li>size：指定聚合结果数量</li>
<li>order：指定聚合结果排序方式</li>
<li>field：指定聚合字段</li>
</ul>
<h2 id="13restapi实现聚合"><a class="markdownIt-Anchor" href="#13restapi实现聚合"></a> 1.3.RestAPI实现聚合</h2>
<h3 id="131api语法"><a class="markdownIt-Anchor" href="#131api语法"></a> 1.3.1.API语法</h3>
<p>聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。</p>
<p>聚合条件的语法：</p>
<p><img src="../../../images/image-20210723173057733.png" alt="image-20210723173057733"></p>
<p>聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：</p>
<p><img src="../../../images/image-20210723173215728.png" alt="image-20210723173215728"></p>
<h3 id="132业务需求"><a class="markdownIt-Anchor" href="#132业务需求"></a> 1.3.2.业务需求</h3>
<p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的：</p>
<p><img src="../../../images/image-20210723192605566.png" alt="image-20210723192605566"></p>
<p>分析：</p>
<p>目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p>
<p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。</p>
<p>也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p>
<p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p>
<p>使用聚合功能，利用Bucket聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p>
<p>因为是对搜索结果聚合，因此聚合是<strong>限定范围的聚合</strong>，也就是说聚合的限定条件跟搜索文档的条件一致。</p>
<p>查看浏览器可以发现，前端其实已经发出了这样的一个请求：</p>
<p><img src="../../../images/image-20210723193730799.png" alt="image-20210723193730799"></p>
<p>请求<strong>参数与搜索文档的参数完全一致</strong>。</p>
<p>返回值类型就是页面要展示的最终结果：</p>
<p><img src="../../../images/image-20210723203915982.png" alt="image-20210723203915982"></p>
<p>结果是一个Map结构：</p>
<ul>
<li>key是字符串，城市、星级、品牌、价格</li>
<li>value是集合，例如多个城市的名称</li>
</ul>
<h3 id="133业务实现"><a class="markdownIt-Anchor" href="#133业务实现"></a> 1.3.3.业务实现</h3>
<p>在<code>cn.itcast.hotel.web</code>包的<code>HotelController</code>中添加一个方法，遵循下面的要求：</p>
<ul>
<li>请求方式：<code>POST</code></li>
<li>请求路径：<code>/hotel/filters</code></li>
<li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li>
<li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li>
</ul>
<p>代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping("filters")</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">getFilters</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">    <span class="keyword">return</span> hotelService.getFilters(params);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>这里调用了IHotelService中的getFilters方法，尚未实现。</p>
<p>在<code>cn.itcast.hotel.service.IHotelService</code>中定义新方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">filters</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line">        <span class="comment">// 2.2.设置size</span></span><br><span class="line">        request.source().size(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 2.3.聚合</span></span><br><span class="line">        buildAggregation(request);</span><br><span class="line">        <span class="comment">// 3.发出请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Aggregations</span> <span class="variable">aggregations</span> <span class="operator">=</span> response.getAggregations();</span><br><span class="line">        <span class="comment">// 4.1.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; brandList = getAggByName(aggregations, <span class="string">"brandAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"品牌"</span>, brandList);</span><br><span class="line">        <span class="comment">// 4.2.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; cityList = getAggByName(aggregations, <span class="string">"cityAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"城市"</span>, cityList);</span><br><span class="line">        <span class="comment">// 4.3.根据品牌名称，获取品牌结果</span></span><br><span class="line">        List&lt;String&gt; starList = getAggByName(aggregations, <span class="string">"starAgg"</span>);</span><br><span class="line">        result.put(<span class="string">"星级"</span>, starList);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildAggregation</span><span class="params">(SearchRequest request)</span> {</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"brandAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"brand"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"cityAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"city"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">    request.source().aggregation(AggregationBuilders</span><br><span class="line">                                 .terms(<span class="string">"starAgg"</span>)</span><br><span class="line">                                 .field(<span class="string">"starName"</span>)</span><br><span class="line">                                 .size(<span class="number">100</span>)</span><br><span class="line">                                );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; <span class="title function_">getAggByName</span><span class="params">(Aggregations aggregations, String aggName)</span> {</span><br><span class="line">    <span class="comment">// 4.1.根据聚合名称获取聚合结果</span></span><br><span class="line">    <span class="type">Terms</span> <span class="variable">brandTerms</span> <span class="operator">=</span> aggregations.get(aggName);</span><br><span class="line">    <span class="comment">// 4.2.获取buckets</span></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Terms</span>.Bucket&gt; buckets = brandTerms.getBuckets();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;String&gt; brandList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Terms.Bucket bucket : buckets) {</span><br><span class="line">        <span class="comment">// 4.4.获取key</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> bucket.getKeyAsString();</span><br><span class="line">        brandList.add(key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> brandList;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="2自动补全"><a class="markdownIt-Anchor" href="#2自动补全"></a> 2.自动补全</h1>
<p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，如图：</p>
<p><img src="../../../images/image-20210723204936367.png" alt="image-20210723204936367"></p>
<p>这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p>
<p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p>
<h2 id="21拼音分词器"><a class="markdownIt-Anchor" href="#21拼音分词器"></a> 2.1.拼音分词器</h2>
<p>要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：<a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-pinyin">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p>
<p><img src="../../../images/image-20210723205932746.png" alt="image-20210723205932746"></p>
<p>课前资料中也提供了拼音分词器的安装包：</p>
<p><img src="../../../images/image-20210723205722303.png" alt="image-20210723205722303"></p>
<p>安装方式与IK分词器一样，分三步：</p>
<p>​	①解压</p>
<p>​	②上传到虚拟机中，elasticsearch的plugin目录</p>
<p>​	③重启elasticsearch</p>
<p>​	④测试</p>
<p>详细安装步骤可以参考IK分词器的安装过程。</p>
<p>测试用法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST&nbsp;/_analyze</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家酒店还不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<p><img src="../../../images/image-20210723210126506.png" alt="image-20210723210126506"></p>
<h2 id="22自定义分词器"><a class="markdownIt-Anchor" href="#22自定义分词器"></a> 2.2.自定义分词器</h2>
<p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p>
<p>elasticsearch中分词器（analyzer）的组成包含三部分：</p>
<ul>
<li>character filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符</li>
<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart</li>
<li>tokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>
</ul>
<p>文档分词时会依次由这三部分来处理文档：</p>
<p><img src="../../../images/image-20210723210427878.png" alt="image-20210723210427878"></p>
<p>声明自定义分词器的语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">PUT&nbsp;/test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"settings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analysis"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义分词器</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"my_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;&nbsp;<span class="comment">//&nbsp;分词器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"tokenizer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="string">"py"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;自定义tokenizer&nbsp;filter</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"py"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;过滤器名称</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"pinyin"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;过滤器类型，这里是pinyin</span></span><br><span class="line">		  <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"keep_original"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span>&nbsp;<span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">false</span></span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"my_analyzer"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"search_analyzer"</span><span class="punctuation">:</span>&nbsp;<span class="string">"ik_smart"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>测试：</p>
<p><img src="../../../images/image-20210723211829150.png" alt="image-20210723211829150"></p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3>
<p>如何使用拼音分词器？</p>
<ul>
<li>
<p>①下载pinyin分词器</p>
</li>
<li>
<p>②解压并放到elasticsearch的plugin目录</p>
</li>
<li>
<p>③重启即可</p>
</li>
</ul>
<p>如何自定义分词器？</p>
<ul>
<li>
<p>①创建索引库时，在settings中配置，可以包含三部分</p>
</li>
<li>
<p>②character filter</p>
</li>
<li>
<p>③tokenizer</p>
</li>
<li>
<p>④filter</p>
</li>
</ul>
<p>拼音分词器注意事项？</p>
<ul>
<li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li>
</ul>
<h2 id="23自动补全查询"><a class="markdownIt-Anchor" href="#23自动补全查询"></a> 2.3.自动补全查询</h2>
<p>elasticsearch提供了<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html">Completion Suggester</a>查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p>
<ul>
<li>
<p>参与补全查询的字段必须是completion类型。</p>
</li>
<li>
<p>字段的内容一般是用来补全的多个词条形成的数组。</p>
</li>
</ul>
<p>比如，一个这样的索引库：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;创建索引库</span></span><br><span class="line">PUT&nbsp;test</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"mappings"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"properties"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"type"</span><span class="punctuation">:</span>&nbsp;<span class="string">"completion"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>然后插入下面的数据：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例数据</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Sony"</span><span class="punctuation">,</span>&nbsp;<span class="string">"WH-1000XM3"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"SK-II"</span><span class="punctuation">,</span>&nbsp;<span class="string">"PITERA"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST&nbsp;test/_doc</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"title"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"Nintendo"</span><span class="punctuation">,</span>&nbsp;<span class="string">"switch"</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>查询的DSL语句如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;自动补全查询</span></span><br><span class="line">GET&nbsp;/test/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"title_suggest"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"text"</span><span class="punctuation">:</span>&nbsp;<span class="string">"s"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;关键字</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"completion"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"field"</span><span class="punctuation">:</span>&nbsp;<span class="string">"title"</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;补全查询的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"skip_duplicates"</span><span class="punctuation">:</span>&nbsp;<span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;跳过重复的</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span>&nbsp;<span class="comment">//&nbsp;获取前10条结果</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="24实现酒店搜索框自动补全"><a class="markdownIt-Anchor" href="#24实现酒店搜索框自动补全"></a> 2.4.实现酒店搜索框自动补全</h2>
<p>现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p>
<p>另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。</p>
<p>因此，总结一下，我们需要做的事情包括：</p>
<ol>
<li>
<p>修改hotel索引库结构，设置自定义拼音分词器</p>
</li>
<li>
<p>修改索引库的name、all字段，使用自定义分词器</p>
</li>
<li>
<p>索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器</p>
</li>
<li>
<p>给HotelDoc类添加suggestion字段，内容包含brand、business</p>
</li>
<li>
<p>重新导入数据到hotel库</p>
</li>
</ol>
<h3 id="241修改酒店映射结构"><a class="markdownIt-Anchor" href="#241修改酒店映射结构"></a> 2.4.1.修改酒店映射结构</h3>
<p>代码如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 酒店数据索引库</span></span><br><span class="line">PUT /hotel</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">  <span class="attr">"settings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"analysis"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"text_anlyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"ik_max_word"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"completion_analyzer"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"tokenizer"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="string">"py"</span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"filter"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"py"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"pinyin"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_joined_full_pinyin"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"keep_original"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"limit_first_letter_length"</span><span class="punctuation">:</span> <span class="number">16</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"remove_duplicated_term"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"none_chinese_pinyin_tokenize"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">        <span class="punctuation">}</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">"mappings"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"properties"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">      <span class="attr">"id"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"name"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"address"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"price"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"score"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"integer"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"brand"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"city"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"starName"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"business"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"copy_to"</span><span class="punctuation">:</span> <span class="string">"all"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"location"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"geo_point"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"pic"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"keyword"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"index"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"all"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"text"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"text_anlyzer"</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">"search_analyzer"</span><span class="punctuation">:</span> <span class="string">"ik_smart"</span></span><br><span class="line">      <span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"suggestion"</span><span class="punctuation">:</span><span class="punctuation">{</span></span><br><span class="line">          <span class="attr">"type"</span><span class="punctuation">:</span> <span class="string">"completion"</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">"analyzer"</span><span class="punctuation">:</span> <span class="string">"completion_analyzer"</span></span><br><span class="line">      <span class="punctuation">}</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">  <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="242修改hoteldoc实体"><a class="markdownIt-Anchor" href="#242修改hoteldoc实体"></a> 2.4.2.修改HotelDoc实体</h3>
<p>HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p>
<p>因此我们在HotelDoc中添加一个suggestion字段，类型为<code>List&lt;String&gt;</code>，然后将brand、city、business等信息放到里面。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line">    <span class="keyword">private</span> Boolean isAD;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; suggestion;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">        <span class="comment">// 组装suggestion</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">this</span>.business.contains(<span class="string">"/"</span>)){</span><br><span class="line">            <span class="comment">// business有多个值，需要切割</span></span><br><span class="line">            String[] arr = <span class="built_in">this</span>.business.split(<span class="string">"/"</span>);</span><br><span class="line">            <span class="comment">// 添加元素</span></span><br><span class="line">            <span class="built_in">this</span>.suggestion = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="built_in">this</span>.suggestion.add(<span class="built_in">this</span>.brand);</span><br><span class="line">            Collections.addAll(<span class="built_in">this</span>.suggestion, arr);</span><br><span class="line">        }<span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">this</span>.suggestion = Arrays.asList(<span class="built_in">this</span>.brand, <span class="built_in">this</span>.business);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="243重新导入"><a class="markdownIt-Anchor" href="#243重新导入"></a> 2.4.3.重新导入</h3>
<p>重新执行之前编写的导入数据功能，可以看到新的酒店数据中包含了suggestion：</p>
<p><img src="../../../images/image-20210723213546183.png" alt="image-20210723213546183"></p>
<h3 id="244自动补全查询的javaapi"><a class="markdownIt-Anchor" href="#244自动补全查询的javaapi"></a> 2.4.4.自动补全查询的JavaAPI</h3>
<p>之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：</p>
<p><img src="../../../images/image-20210723213759922.png" alt="image-20210723213759922"></p>
<p>而自动补全的结果也比较特殊，解析的代码如下：</p>
<p><img src="../../../images/image-20210723213917524.png" alt="image-20210723213917524"></p>
<h3 id="245实现搜索框自动补全"><a class="markdownIt-Anchor" href="#245实现搜索框自动补全"></a> 2.4.5.实现搜索框自动补全</h3>
<p>查看前端页面，可以发现当我们在输入框键入时，前端会发起ajax请求：</p>
<p><img src="../../../images/image-20210723214021062.png" alt="image-20210723214021062"></p>
<p>返回值是补全词条的集合，类型为<code>List&lt;String&gt;</code></p>
<p>1）在<code>cn.itcast.hotel.web</code>包下的<code>HotelController</code>中添加新接口，接收新的请求：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping("suggestion")</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(<span class="meta">@RequestParam("key")</span> String prefix)</span> {</span><br><span class="line">    <span class="keyword">return</span> hotelService.getSuggestions(prefix);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2）在<code>cn.itcast.hotel.service</code>包下的<code>IhotelService</code>中添加方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>3）在<code>cn.itcast.hotel.service.impl.HotelService</code>中实现该方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;String&gt; <span class="title function_">getSuggestions</span><span class="params">(String prefix)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        request.source().suggest(<span class="keyword">new</span> <span class="title class_">SuggestBuilder</span>().addSuggestion(</span><br><span class="line">            <span class="string">"suggestions"</span>,</span><br><span class="line">            SuggestBuilders.completionSuggestion(<span class="string">"suggestion"</span>)</span><br><span class="line">            .prefix(prefix)</span><br><span class="line">            .skipDuplicates(<span class="literal">true</span>)</span><br><span class="line">            .size(<span class="number">10</span>)</span><br><span class="line">        ));</span><br><span class="line">        <span class="comment">// 3.发起请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析结果</span></span><br><span class="line">        <span class="type">Suggest</span> <span class="variable">suggest</span> <span class="operator">=</span> response.getSuggest();</span><br><span class="line">        <span class="comment">// 4.1.根据补全查询名称，获取补全结果</span></span><br><span class="line">        <span class="type">CompletionSuggestion</span> <span class="variable">suggestions</span> <span class="operator">=</span> suggest.getSuggestion(<span class="string">"suggestions"</span>);</span><br><span class="line">        <span class="comment">// 4.2.获取options</span></span><br><span class="line">        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();</span><br><span class="line">        <span class="comment">// 4.3.遍历</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(options.size());</span><br><span class="line">        <span class="keyword">for</span> (CompletionSuggestion.Entry.Option option : options) {</span><br><span class="line">            <span class="type">String</span> <span class="variable">text</span> <span class="operator">=</span> option.getText().toString();</span><br><span class="line">            list.add(text);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3数据同步"><a class="markdownIt-Anchor" href="#3数据同步"></a> 3.数据同步</h1>
<p>elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的<strong>数据同步</strong>。</p>
<p><img src="../../../images/image-20210723214758392.png" alt="image-20210723214758392"></p>
<h2 id="31思路分析"><a class="markdownIt-Anchor" href="#31思路分析"></a> 3.1.思路分析</h2>
<p>常见的数据同步方案有三种：</p>
<ul>
<li>同步调用</li>
<li>异步通知</li>
<li>监听binlog</li>
</ul>
<h3 id="311同步调用"><a class="markdownIt-Anchor" href="#311同步调用"></a> 3.1.1.同步调用</h3>
<p>方案一：同步调用</p>
<p><img src="../../../images/image-20210723214931869.png" alt="image-20210723214931869"></p>
<p>基本步骤如下：</p>
<ul>
<li>hotel-demo对外提供接口，用来修改elasticsearch中的数据</li>
<li>酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，</li>
</ul>
<h3 id="312异步通知"><a class="markdownIt-Anchor" href="#312异步通知"></a> 3.1.2.异步通知</h3>
<p>方案二：异步通知</p>
<p><img src="../../../images/image-20210723215140735.png" alt="image-20210723215140735"></p>
<p>流程如下：</p>
<ul>
<li>hotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息</li>
<li>hotel-demo监听MQ，接收到消息后完成elasticsearch数据修改</li>
</ul>
<h3 id="313监听binlog"><a class="markdownIt-Anchor" href="#313监听binlog"></a> 3.1.3.监听binlog</h3>
<p>方案三：监听binlog</p>
<p><img src="../../../images/image-20210723215518541.png" alt="image-20210723215518541"></p>
<p>流程如下：</p>
<ul>
<li>给mysql开启binlog功能</li>
<li>mysql完成增、删、改操作都会记录在binlog中</li>
<li>hotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容</li>
</ul>
<h3 id="314选择"><a class="markdownIt-Anchor" href="#314选择"></a> 3.1.4.选择</h3>
<p>方式一：同步调用</p>
<ul>
<li>优点：实现简单，粗暴</li>
<li>缺点：业务耦合度高</li>
</ul>
<p>方式二：异步通知</p>
<ul>
<li>优点：低耦合，实现难度一般</li>
<li>缺点：依赖mq的可靠性</li>
</ul>
<p>方式三：监听binlog</p>
<ul>
<li>优点：完全解除服务间耦合</li>
<li>缺点：开启binlog增加数据库负担、实现复杂度高</li>
</ul>
<h2 id="32实现数据同步"><a class="markdownIt-Anchor" href="#32实现数据同步"></a> 3.2.实现数据同步</h2>
<h3 id="321思路"><a class="markdownIt-Anchor" href="#321思路"></a> 3.2.1.思路</h3>
<p>利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。</p>
<p>步骤：</p>
<ul>
<li>
<p>导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD</p>
</li>
<li>
<p>声明exchange、queue、RoutingKey</p>
</li>
<li>
<p>在hotel-admin中的增、删、改业务中完成消息发送</p>
</li>
<li>
<p>在hotel-demo中完成消息监听，并更新elasticsearch中数据</p>
</li>
<li>
<p>启动并测试数据同步功能</p>
</li>
</ul>
<h3 id="322导入demo"><a class="markdownIt-Anchor" href="#322导入demo"></a> 3.2.2.导入demo</h3>
<p>导入课前资料提供的hotel-admin项目：</p>
<p><img src="../../../images/image-20210723220237930.png" alt="image-20210723220237930"></p>
<p>运行后，访问 <a target="_blank" rel="noopener" href="http://localhost:8099">http://localhost:8099</a></p>
<p><img src="../../../images/image-20210723220354464.png" alt="image-20210723220354464"></p>
<p>其中包含了酒店的CRUD功能：</p>
<p><img src="../../../images/image-20210723220511090.png" alt="image-20210723220511090"></p>
<h3 id="323声明交换机-队列"><a class="markdownIt-Anchor" href="#323声明交换机-队列"></a> 3.2.3.声明交换机、队列</h3>
<p>MQ结构如图：</p>
<p><img src="../../../images/image-20210723215850307.png" alt="image-20210723215850307"></p>
<h4 id="1引入依赖"><a class="markdownIt-Anchor" href="#1引入依赖"></a> 1）引入依赖</h4>
<p>在hotel-admin、hotel-demo中引入rabbitmq的依赖：</p>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--amqp--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2声明队列交换机名称"><a class="markdownIt-Anchor" href="#2声明队列交换机名称"></a> 2）声明队列交换机名称</h4>
<p>在hotel-admin和hotel-demo中的<code>cn.itcast.hotel.constatnts</code>包下新建一个类<code>MqConstants</code>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.constatnts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConstants</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换机</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_EXCHANGE</span> <span class="operator">=</span> <span class="string">"hotel.topic"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听新增和修改的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.insert.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听删除的队列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_QUEUE</span> <span class="operator">=</span> <span class="string">"hotel.delete.queue"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增或修改的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_INSERT_KEY</span> <span class="operator">=</span> <span class="string">"hotel.insert"</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除的RoutingKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">HOTEL_DELETE_KEY</span> <span class="operator">=</span> <span class="string">"hotel.delete"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="3声明队列交换机"><a class="markdownIt-Anchor" href="#3声明队列交换机"></a> 3）声明队列交换机</h4>
<p>在hotel-demo中，定义配置类，声明队列、交换机：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Binding;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.BindingBuilder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Queue;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.TopicExchange;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MqConfig</span> {</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TopicExchange <span class="title function_">topicExchange</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TopicExchange</span>(MqConstants.HOTEL_EXCHANGE, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">insertQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_INSERT_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Queue <span class="title function_">deleteQueue</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Queue</span>(MqConstants.HOTEL_DELETE_QUEUE, <span class="literal">true</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">insertQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Binding <span class="title function_">deleteQueueBinding</span><span class="params">()</span>{</span><br><span class="line">        <span class="keyword">return</span> BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="324发送mq消息"><a class="markdownIt-Anchor" href="#324发送mq消息"></a> 3.2.4.发送MQ消息</h3>
<p>在hotel-admin中的增、删、改业务中分别发送MQ消息：</p>
<p><img src="../../../images/image-20210723221843816.png" alt="image-20210723221843816"></p>
<h3 id="325接收mq消息"><a class="markdownIt-Anchor" href="#325接收mq消息"></a> 3.2.5.接收MQ消息</h3>
<p>hotel-demo接收到MQ消息要做的事情包括：</p>
<ul>
<li>新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库</li>
<li>删除消息：根据传递的hotel的id删除索引库中的一条数据</li>
</ul>
<p>1）首先在hotel-demo的<code>cn.itcast.hotel.service</code>包下的<code>IHotelService</code>中新增新增、删除业务</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>2）给hotel-demo中的<code>cn.itcast.hotel.service.impl</code>包下的HotelService中实现业务：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">DeleteRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeleteRequest</span>(<span class="string">"hotel"</span>, id.toString());</span><br><span class="line">        <span class="comment">// 2.发送请求</span></span><br><span class="line">        client.delete(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertById</span><span class="params">(Long id)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 0.根据id查询酒店数据</span></span><br><span class="line">        <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> getById(id);</span><br><span class="line">        <span class="comment">// 转换为文档类型</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDoc</span>(hotel);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.准备Request对象</span></span><br><span class="line">        <span class="type">IndexRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IndexRequest</span>(<span class="string">"hotel"</span>).id(hotel.getId().toString());</span><br><span class="line">        <span class="comment">// 2.准备Json文档</span></span><br><span class="line">        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);</span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3）编写监听器</p>
<p>在hotel-demo中的<code>cn.itcast.hotel.mq</code>包新增一个类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.mq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.constants.MqConstants;</span><br><span class="line"><span class="keyword">import</span> cn.itcast.hotel.service.IHotelService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelListener</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店新增或修改的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelInsertOrUpdate</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.insertById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听酒店删除的业务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id 酒店id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">listenHotelDelete</span><span class="params">(Long id)</span>{</span><br><span class="line">        hotelService.deleteById(id);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="4集群"><a class="markdownIt-Anchor" href="#4集群"></a> 4.集群</h1>
<p>单机的elasticsearch做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>
<ul>
<li>海量数据存储问题：将索引库从逻辑上拆分为N个分片（shard），存储到多个节点</li>
<li>单点故障问题：将分片数据在不同节点备份（replica ）</li>
</ul>
<p><strong>ES集群相关概念</strong>:</p>
<ul>
<li>
<p>集群（cluster）：一组拥有共同的 cluster name 的 节点。</p>
</li>
<li>
<p><font color="red">节点（node)</font>   ：集群中的一个 Elasticearch 实例</p>
</li>
<li>
<p><font color="red">分片（shard）</font>：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</p>
<p>解决问题：数据量太大，单点存储量有限的问题。</p>
<p><img src="../../../images/image-20200104124440086-5602723.png" alt="image-20200104124440086"></p>
<blockquote>
<p>此处，我们把数据分成3片：shard0、shard1、shard2</p>
</blockquote>
</li>
<li>
<p>主分片（Primary shard）：相对于副本分片的定义。</p>
</li>
<li>
<p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p>
<p>​</p>
</li>
</ul>
<p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p>
<p>为了在高可用和成本间寻求平衡，我们可以这样做：</p>
<ul>
<li>首先对数据分片，存储到不同节点</li>
<li>然后对每个分片进行备份，放到对方节点，完成互相备份</li>
</ul>
<p>这样可以大大减少所需要的服务节点数量，如图，我们以3分片，每个分片备份一份为例：</p>
<p><img src="../../../images/image-20200104124551912.png" alt="image-20200104124551912"></p>
<p>现在，每个分片都有1个备份，存储在3个节点：</p>
<ul>
<li>node0：保存了分片0和1</li>
<li>node1：保存了分片0和2</li>
<li>node2：保存了分片1和2</li>
</ul>
<h2 id="41搭建es集群"><a class="markdownIt-Anchor" href="#41搭建es集群"></a> 4.1.搭建ES集群</h2>
<p>参考课前资料的文档：</p>
<p><img src="../../../images/image-20210723222732427.png" alt="image-20210723222732427"></p>
<p>其中的第四章节：</p>
<p><img src="../../../images/image-20210723222812619.png" alt="image-20210723222812619"></p>
<h2 id="42集群脑裂问题"><a class="markdownIt-Anchor" href="#42集群脑裂问题"></a> 4.2.集群脑裂问题</h2>
<h3 id="421集群职责划分"><a class="markdownIt-Anchor" href="#421集群职责划分"></a> 4.2.1.集群职责划分</h3>
<p>elasticsearch中集群节点有不同的职责划分：</p>
<p><img src="../../../images/image-20210723223008967.png" alt="image-20210723223008967"></p>
<p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p>
<p>但是真实的集群一定要将集群职责分离：</p>
<ul>
<li>master节点：对CPU要求高，但是内存要求第</li>
<li>data节点：对CPU和内存要求都高</li>
<li>coordinating节点：对网络带宽、CPU要求高</li>
</ul>
<p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p>
<p>一个典型的es集群职责划分如图：</p>
<p><img src="../../../images/image-20210723223629142.png" alt="image-20210723223629142"></p>
<h3 id="422脑裂问题"><a class="markdownIt-Anchor" href="#422脑裂问题"></a> 4.2.2.脑裂问题</h3>
<p>脑裂是因为集群中的节点失联导致的。</p>
<p>例如一个集群中，主节点与其它节点失联：</p>
<p><img src="../../../images/image-20210723223804995.png" alt="image-20210723223804995"></p>
<p>此时，node2和node3认为node1宕机，就会重新选主：</p>
<p><img src="../../../images/image-20210723223845754.png" alt="image-20210723223845754"></p>
<p>当node3当选后，集群继续对外提供服务，node2和node3自成集群，node1自成集群，两个集群数据不同步，出现数据差异。</p>
<p>当网络恢复后，因为集群中有两个master节点，集群状态的不一致，出现脑裂的情况：</p>
<p><img src="../../../images/image-20210723224000555.png" alt="image-20210723224000555"></p>
<p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此eligible节点数量最好是奇数。对应配置项是discovery.zen.minimum_master_nodes，在es7.0以后，已经成为默认配置，因此一般不会发生脑裂问题</p>
<p>例如：3个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是2票。node3得到node2和node3的选票，当选为主。node1只有自己1票，没有当选。集群中依然只有1个主节点，没有出现脑裂。</p>
<h3 id="423小结"><a class="markdownIt-Anchor" href="#423小结"></a> 4.2.3.小结</h3>
<p>master eligible节点的作用是什么？</p>
<ul>
<li>参与集群选主</li>
<li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li>
</ul>
<p>data节点的作用是什么？</p>
<ul>
<li>数据的CRUD</li>
</ul>
<p>coordinator节点的作用是什么？</p>
<ul>
<li>
<p>路由请求到其它节点</p>
</li>
<li>
<p>合并查询到的结果，返回给用户</p>
</li>
</ul>
<h2 id="43集群分布式存储"><a class="markdownIt-Anchor" href="#43集群分布式存储"></a> 4.3.集群分布式存储</h2>
<p>当新增文档时，应该保存到不同分片，保证数据均衡，那么coordinating node如何确定数据该存储到哪个分片呢？</p>
<h3 id="431分片存储测试"><a class="markdownIt-Anchor" href="#431分片存储测试"></a> 4.3.1.分片存储测试</h3>
<p>插入三条数据：</p>
<p><img src="../../../images/image-20210723225006058.png" alt="image-20210723225006058"></p>
<p><img src="../../../images/image-20210723225034637.png" alt="image-20210723225034637"></p>
<p><img src="../../../images/image-20210723225112029.png" alt="image-20210723225112029"></p>
<p>测试可以看到，三条数据分别在不同分片：</p>
<p><img src="../../../images/image-20210723225227928.png" alt="image-20210723225227928"></p>
<p>结果：</p>
<p><img src="../../../images/image-20210723225342120.png" alt="image-20210723225342120"></p>
<h3 id="432分片存储原理"><a class="markdownIt-Anchor" href="#432分片存储原理"></a> 4.3.2.分片存储原理</h3>
<p>elasticsearch会通过hash算法来计算文档应该存储到哪个分片：</p>
<p><img src="../../../images/image-20210723224354904.png" alt="image-20210723224354904"></p>
<p>说明：</p>
<ul>
<li>_routing默认是文档的id</li>
<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li>
</ul>
<p>新增文档的流程如下：</p>
<p><img src="../../../images/image-20210723225436084.png" alt="image-20210723225436084"></p>
<p>解读：</p>
<ul>
<li>1）新增一个id=1的文档</li>
<li>2）对id做hash运算，假如得到的是2，则应该存储到shard-2</li>
<li>3）shard-2的主分片在node3节点，将数据路由到node3</li>
<li>4）保存文档</li>
<li>5）同步给shard-2的副本replica-2，在node2节点</li>
<li>6）返回结果给coordinating-node节点</li>
</ul>
<h2 id="44集群分布式查询"><a class="markdownIt-Anchor" href="#44集群分布式查询"></a> 4.4.集群分布式查询</h2>
<p>elasticsearch的查询分成两个阶段：</p>
<ul>
<li>
<p>scatter phase：分散阶段，coordinating node会把请求分发到每一个分片</p>
</li>
<li>
<p>gather phase：聚集阶段，coordinating node汇总data node的搜索结果，并处理为最终结果集返回给用户</p>
</li>
</ul>
<p><img src="../../../images/image-20210723225809848.png" alt="image-20210723225809848"></p>
<h2 id="45集群故障转移"><a class="markdownIt-Anchor" href="#45集群故障转移"></a> 4.5.集群故障转移</h2>
<p>集群的master节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p>
<p>1）例如一个集群结构如图：</p>
<p><img src="../../../images/image-20210723225945963.png" alt="image-20210723225945963"></p>
<p>现在，node1是主节点，其它两个节点是从节点。</p>
<p>2）突然，node1发生了故障：</p>
<p><img src="../../../images/image-20210723230020574.png" alt="image-20210723230020574"></p>
<p>宕机后的第一件事，需要重新选主，例如选中了node2：</p>
<p><img src="../../../images/image-20210723230055974.png" alt="image-20210723230055974"></p>
<p>node2成为主节点后，会检测集群监控状态，发现：shard-1、shard-0没有副本节点。因此需要将node1上的数据迁移到node2、node3：</p>
<p><img src="../../../images/image-20210723230216642.png" alt="image-20210723230216642"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E03/" data-id="clihlibt4009nu4v6hw5seamk" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-SpringCloud微服务/Elasticsearch/分布式搜索引擎02" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/" class="article-date">
  <time class="post-time" datetime="2023-03-05T07:37:03.155Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/">2-Elasticsearch</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>,<a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/">Elasticsearch</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="分布式搜索引擎02"><a class="markdownIt-Anchor" href="#分布式搜索引擎02"></a> 分布式搜索引擎02</h1>
<p>在昨天的学习中，我们已经导入了大量数据到elasticsearch中，实现了elasticsearch的数据存储功能。但elasticsearch最擅长的还是搜索和数据分析。</p>
<p>所以今天，我们研究下elasticsearch的数据搜索功能。我们会分别使用<strong>DSL</strong>和<strong>RestClient</strong>实现搜索。</p>
<h1 id="0学习目标"><a class="markdownIt-Anchor" href="#0学习目标"></a> 0.学习目标</h1>
<h1 id="1dsl查询文档"><a class="markdownIt-Anchor" href="#1dsl查询文档"></a> 1.DSL查询文档</h1>
<p>elasticsearch的查询依然是基于JSON风格的DSL来实现的。</p>
<h2 id="11dsl查询分类"><a class="markdownIt-Anchor" href="#11dsl查询分类"></a> 1.1.DSL查询分类</h2>
<p>Elasticsearch提供了基于JSON的DSL（<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p>
<ul>
<li>
<p><strong>查询所有</strong>：查询出所有数据，一般测试用。例如：match_all</p>
</li>
<li>
<p><strong>全文检索（full text）查询</strong>：<mark>利用分词器对用户输入<strong>内容分词</strong>，然后去<strong>倒排索引库</strong>中匹配</mark>。例如：</p>
<ul>
<li>match_query</li>
<li>multi_match_query</li>
</ul>
</li>
<li>
<p><strong>精确查询</strong>：根据精确词条值查找数据，一般是查找keyword、数值、日期、boolean等类型字段。例如：</p>
<ul>
<li>ids</li>
<li>range</li>
<li>term</li>
</ul>
</li>
<li>
<p><strong>地理（geo）查询</strong>：根据经纬度查询。例如：</p>
<ul>
<li>geo_distance</li>
<li>geo_bounding_box</li>
</ul>
</li>
<li>
<p><strong>复合（compound）查询</strong>：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>
<ul>
<li>bool</li>
<li>function_score</li>
</ul>
</li>
</ul>
<p>查询的语法基本一致：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询类型"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"查询条件"</span><span class="punctuation">:</span>&nbsp;<span class="string">"条件值"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>我们以查询所有为例，其中：</p>
<ul>
<li>查询类型为match_all</li>
<li>没有查询条件</li>
</ul>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查询所有</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>其它查询无非就是<strong>查询类型</strong>、<strong>查询条件</strong>的变化。</p>
<h2 id="12全文检索查询"><a class="markdownIt-Anchor" href="#12全文检索查询"></a> 1.2.全文检索查询</h2>
<h3 id="121使用场景"><a class="markdownIt-Anchor" href="#121使用场景"></a> 1.2.1.使用场景</h3>
<p>全文检索查询的基本流程如下：</p>
<ul>
<li>对用户搜索的内容做分词，得到词条</li>
<li>根据词条去倒排索引库中匹配，得到文档id</li>
<li>根据文档id找到文档，返回给用户</li>
</ul>
<p>比较常用的场景包括：</p>
<ul>
<li>商城的输入框搜索</li>
<li>百度输入框搜索</li>
</ul>
<p>例如京东：</p>
<p><img src="../../../images/image-20210721165326938.png" alt="image-20210721165326938"></p>
<p>因为是拿着词条去匹配，因此<font color="red">参与搜索的字段也必须是可分词的text类型</font>的字段。</p>
<h3 id="122基本语法"><a class="markdownIt-Anchor" href="#122基本语法"></a> 1.2.2.基本语法</h3>
<p>常见的全文检索查询包括：</p>
<ul>
<li>match查询：单字段查询</li>
<li>multi_match查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>
</ul>
<p>match查询语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>mulit_match语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"multi_match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span><span class="string">"FIELD1"</span><span class="punctuation">,</span>&nbsp;<span class="string">" FIELD12"</span><span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="123示例"><a class="markdownIt-Anchor" href="#123示例"></a> 1.2.3.示例</h3>
<p>match查询示例：</p>
<p><img src="../../../images/image-20210721170455419.png" alt="image-20210721170455419"></p>
<p>multi_match查询示例：</p>
<p><img src="../../../images/image-20210721170720691.png" alt="image-20210721170720691"></p>
<p>可以看到，两种查询结果是一样的，为什么？</p>
<p>因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。</p>
<p>但是，<strong>搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。</strong></p>
<h3 id="124总结"><a class="markdownIt-Anchor" href="#124总结"></a> 1.2.4.总结</h3>
<p>match和multi_match的区别是什么？</p>
<ul>
<li>match：根据一个字段查询</li>
<li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li>
</ul>
<h2 id="13精准查询"><a class="markdownIt-Anchor" href="#13精准查询"></a> 1.3.精准查询</h2>
<p>精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以<strong>不会</strong>对搜索条件分词。常见的有：</p>
<ul>
<li>term：根据词条精确值查询</li>
<li>range：根据值的范围查询</li>
</ul>
<h3 id="131term查询"><a class="markdownIt-Anchor" href="#131term查询"></a> 1.3.1.term查询</h3>
<p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>
<p>语法说明：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;term查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"value"</span><span class="punctuation">:</span>&nbsp;<span class="string">"VALUE"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例：</p>
<p>当我搜索的是精确词条时，能正确查询出结果：</p>
<p><img src="../../../images/image-20210721171655308.png" alt="image-20210721171655308"></p>
<p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p>
<p><img src="../../../images/image-20210721171838378.png" alt="image-20210721171838378"></p>
<h3 id="132range查询"><a class="markdownIt-Anchor" href="#132range查询"></a> 1.3.2.range查询</h3>
<p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>
<p>基本语法：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;range查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span> <span class="comment">// 这里的gte代表大于等于，gt则代表大于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">20</span> <span class="comment">// lte代表小于等于，lt则代表小于</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例：</p>
<p><img src="../../../images/image-20210721172307172.png" alt="image-20210721172307172"></p>
<h3 id="133总结"><a class="markdownIt-Anchor" href="#133总结"></a> 1.3.3.总结</h3>
<p>精确查询常见的有哪些？</p>
<ul>
<li>term查询：根据词条精确匹配，一般搜索keyword类型、数值类型、布尔类型、日期类型字段</li>
<li>range查询：根据数值范围查询，可以是数值、日期的范围</li>
</ul>
<h2 id="14地理坐标查询"><a class="markdownIt-Anchor" href="#14地理坐标查询"></a> 1.4.地理坐标查询</h2>
<p>所谓的地理坐标查询，其实就是根据经纬度查询，官方文档：<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html</a></p>
<p>常见的使用场景包括：</p>
<ul>
<li>携程：搜索我附近的酒店</li>
<li>滴滴：搜索我附近的出租车</li>
<li>微信：搜索我附近的人</li>
</ul>
<p>附近的酒店：</p>
<p><img src="../../../images/image-20210721172645103.png" alt="image-20210721172645103"></p>
<p>附近的车：</p>
<p><img src="../../../images/image-20210721172654880.png" alt="image-20210721172654880"></p>
<h3 id="141矩形范围查询"><a class="markdownIt-Anchor" href="#141矩形范围查询"></a> 1.4.1.矩形范围查询</h3>
<p>矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：</p>
<p><img src="../../../images/DKV9HZbVS6.gif" alt="DKV9HZbVS6"></p>
<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>
<p>语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_bounding_box查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_bounding_box"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"top_left"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 左上点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">31.1</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.5</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bottom_right"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span> <span class="comment">// 右下点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lat"</span><span class="punctuation">:</span>&nbsp;<span class="number">30.9</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"lon"</span><span class="punctuation">:</span>&nbsp;<span class="number">121.7</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>这种并不符合“附近的人”这样的需求，所以我们就不做了。</p>
<h3 id="142附近查询"><a class="markdownIt-Anchor" href="#142附近查询"></a> 1.4.2.附近查询</h3>
<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p>
<p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/vZrdKAh19C.gif" alt="vZrdKAh19C"></p>
<p>语法说明：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&nbsp;geo_distance 查询</span></span><br><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"geo_distance"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"distance"</span><span class="punctuation">:</span>&nbsp;<span class="string">"15km"</span><span class="punctuation">,</span> <span class="comment">// 半径</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"31.21,121.5"</span> <span class="comment">// 圆心</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>示例：</p>
<p>我们先搜索陆家嘴附近15km的酒店：</p>
<p><img src="../../../images/image-20210721175443234.png" alt="image-20210721175443234"></p>
<p>发现共有47家酒店。</p>
<p>然后把半径缩短到3公里：</p>
<p><img src="../../../images/image-20210721182031475.png" alt="image-20210721182031475"></p>
<p>可以发现，搜索到的酒店数量减少到了5家。</p>
<h2 id="15复合查询"><a class="markdownIt-Anchor" href="#15复合查询"></a> 1.5.复合查询</h2>
<p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p>
<ul>
<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>
<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>
</ul>
<h3 id="151相关性算分"><a class="markdownIt-Anchor" href="#151相关性算分"></a> 1.5.1.相关性算分</h3>
<p>当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p>
<p>例如，我们搜索 “虹桥如家”，结果如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">17.850193</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"虹桥如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">12.259849</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"外滩如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_score"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="number">11.91091</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_source"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"name"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"迪士尼如家酒店真不错"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></tbody></table></figure>
<p>在elasticsearch中，早期使用的打分算法是TF-IDF算法，公式如下：</p>
<p><img src="../../../images/image-20210721190152134.png" alt="image-20210721190152134"></p>
<p>在后来的5.1版本升级中，elasticsearch将算法改进为BM25算法，公式如下：</p>
<p><img src="../../../images/image-20210721190416214.png" alt="image-20210721190416214"></p>
<p>TF-IDF算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而BM25则会让单个词条的算分有一个上限，曲线更加平滑：</p>
<p><img src="../../../images/image-20210721190907320.png" alt="image-20210721190907320"></p>
<p>小结：elasticsearch会根据词条和文档的相关度做打分，算法由两种：</p>
<ul>
<li>TF-IDF算法</li>
<li>BM25算法，elasticsearch5.1版本后采用的算法</li>
</ul>
<h3 id="152算分函数查询"><a class="markdownIt-Anchor" href="#152算分函数查询"></a> 1.5.2.算分函数查询</h3>
<p>根据相关度打分是比较合理的需求，但<strong>合理的不一定是产品经理需要</strong>的。</p>
<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。如图：</p>
<p><img src="../../../images/image-20210721191144560.png" alt="image-20210721191144560"></p>
<p>要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。</p>
<h4 id="1语法说明"><a class="markdownIt-Anchor" href="#1语法说明"></a> 1）语法说明</h4>
<p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p>
<p>function score 查询中包含四部分内容：</p>
<ul>
<li><strong>原始查询</strong>条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，<strong>原始算分</strong>（query score)</li>
<li><strong>过滤条件</strong>：filter部分，符合该条件的文档才会重新算分</li>
<li><strong>算分函数</strong>：符合filter条件的文档要根据这个函数做运算，得到的<strong>函数算分</strong>（function score），有四种函数
<ul>
<li>weight：函数结果是常量</li>
<li>field_value_factor：以文档中的某个字段值作为函数结果</li>
<li>random_score：以随机数作为函数结果</li>
<li>script_score：自定义算分函数算法</li>
</ul>
</li>
<li><strong>运算模式</strong>：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：
<ul>
<li>multiply：相乘</li>
<li>replace：用function score替换query score</li>
<li>其它，例如：sum、avg、max、min</li>
</ul>
</li>
</ul>
<p>function score的运行流程如下：</p>
<ul>
<li>1）根据<strong>原始条件</strong>查询搜索文档，并且计算相关性算分，称为<strong>原始算分</strong>（query score）</li>
<li>2）根据<strong>过滤条件</strong>，过滤文档</li>
<li>3）符合<strong>过滤条件</strong>的文档，基于<strong>算分函数</strong>运算，得到<strong>函数算分</strong>（function score）</li>
<li>4）将<strong>原始算分</strong>（query score）和<strong>函数算分</strong>（function score）基于<strong>运算模式</strong>做运算，得到最终结果，作为相关性算分。</li>
</ul>
<p>因此，其中的关键点是：</p>
<ul>
<li>过滤条件：决定哪些文档的算分被修改</li>
<li>算分函数：决定函数算分的算法</li>
<li>运算模式：决定最终算分结果</li>
</ul>
<h4 id="2示例"><a class="markdownIt-Anchor" href="#2示例"></a> 2）示例</h4>
<p>需求：给“如家”这个品牌的酒店排名靠前一些</p>
<p>翻译一下这个需求，转换为之前说的四个要点：</p>
<ul>
<li>原始条件：不确定，可以任意变化</li>
<li>过滤条件：brand = “如家”</li>
<li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li>
<li>运算模式：比如求和</li>
</ul>
<p>因此最终的DSL语句如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"function_score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>  .... <span class="punctuation">}</span><span class="punctuation">,</span> <span class="comment">// 原始查询，可以是任意条件</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"functions"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span>&nbsp;<span class="comment">//&nbsp;算分函数</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;满足的条件，品牌必须是如家</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"如家"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"weight"</span><span class="punctuation">:</span>&nbsp;<span class="number">2</span>&nbsp;<span class="comment">//&nbsp;算分权重为2</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">"boost_mode"</span><span class="punctuation">:</span> <span class="string">"sum"</span> <span class="comment">// 加权模式，求和</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>测试，在未添加算分函数时，如家得分如下：</p>
<p><img src="../../../images/image-20210721193152520.png" alt="image-20210721193152520"></p>
<p>添加了算分函数后，如家得分就提升了：</p>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721193458182.png" alt="image-20210721193458182"></p>
<h4 id="3小结"><a class="markdownIt-Anchor" href="#3小结"></a> 3）小结</h4>
<p>function score query定义的三要素是什么？</p>
<ul>
<li>过滤条件：哪些文档要加分</li>
<li>算分函数：如何计算function score</li>
<li>加权方式：function score 与 query score如何运算</li>
</ul>
<h3 id="153布尔查询"><a class="markdownIt-Anchor" href="#153布尔查询"></a> 1.5.3.布尔查询</h3>
<p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个<strong>子查询</strong>。子查询的组合方式有：</p>
<ul>
<li>must：必须匹配每个子查询，类似“与”</li>
<li>should：选择性匹配子查询，类似“或”</li>
<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>
<li>filter：必须匹配，<strong>不参与算分</strong></li>
</ul>
<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：</p>
<p><img src="../../../images/image-20210721193822848.png" alt="image-20210721193822848"></p>
<p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。</p>
<p>需要注意的是，搜索时，参与**<mark>打分的字段越多，查询的性能也越差</mark>**。因此这种多条件查询时，建议这样做：</p>
<ul>
<li>搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分</li>
<li>其它过滤条件，采用filter查询。不参与算分</li>
</ul>
<h4 id="1语法示例"><a class="markdownIt-Anchor" href="#1语法示例"></a> 1）语法示例：</h4>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"bool"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"city"</span><span class="punctuation">:</span>&nbsp;<span class="string">"上海"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"should"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"皇冠假日"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">{</span><span class="attr">"term"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"brand"</span><span class="punctuation">:</span>&nbsp;<span class="string">"华美达"</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"must_not"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"lte"</span><span class="punctuation">:</span>&nbsp;<span class="number">500</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"filter"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"range"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="attr">"score"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="attr">"gte"</span><span class="punctuation">:</span>&nbsp;<span class="number">45</span>&nbsp;<span class="punctuation">}</span>&nbsp;<span class="punctuation">}</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2示例-2"><a class="markdownIt-Anchor" href="#2示例-2"></a> 2）示例</h4>
<p>需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。</p>
<p>分析：</p>
<ul>
<li>名称搜索，属于全文检索查询，应该参与算分。放到must中</li>
<li>价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中</li>
<li>周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中</li>
</ul>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721194744183.png" alt="image-20210721194744183"></p>
<h4 id="3小结-2"><a class="markdownIt-Anchor" href="#3小结-2"></a> 3）小结</h4>
<p>bool查询有几种逻辑关系？</p>
<ul>
<li>must：必须匹配的条件，可以理解为“与”</li>
<li>should：选择性匹配的条件，可以理解为“或”</li>
<li>must_not：必须不匹配的条件，不参与打分</li>
<li>filter：必须匹配的条件，不参与打分</li>
</ul>
<h1 id="2搜索结果处理"><a class="markdownIt-Anchor" href="#2搜索结果处理"></a> 2.搜索结果处理</h1>
<p>搜索的结果可以按照用户指定的方式去处理或展示。</p>
<h2 id="21排序"><a class="markdownIt-Anchor" href="#21排序"></a> 2.1.排序</h2>
<p>elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html">结果排序</a>。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。</p>
<h3 id="211普通字段排序"><a class="markdownIt-Anchor" href="#211普通字段排序"></a> 2.1.1.普通字段排序</h3>
<p>keyword、数值、日期类型排序的语法基本一致。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span> </span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"desc"</span>&nbsp;&nbsp;<span class="comment">//&nbsp;排序字段、排序方式ASC、DESC</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p>
<p><strong>示例</strong>：</p>
<p>需求描述：酒店数据按照用户评价（score)降序排序，评价相同的按照价格(price)升序排序</p>
<p><img src="../../../images/image-20210721195728306.png" alt="image-20210721195728306"></p>
<h3 id="212地理坐标排序"><a class="markdownIt-Anchor" href="#212地理坐标排序"></a> 2.1.2.地理坐标排序</h3>
<p>地理坐标排序略有不同。</p>
<p><strong>语法说明</strong>：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span> <span class="comment">// 文档中geo_point类型的字段名、目标坐标点</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span> <span class="comment">// 排序方式</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span> <span class="comment">// 排序的距离单位</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>这个查询的含义是：</p>
<ul>
<li>指定一个坐标，作为目标点</li>
<li>计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少</li>
<li>根据距离排序</li>
</ul>
<p><strong>示例：</strong></p>
<p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p>
<p>提示：获取你的位置的经纬度的方式：<a target="_blank" rel="noopener" href="https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p>
<p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p>
<p><img src="../../../images/image-20210721200214690.png" alt="image-20210721200214690"></p>
<h2 id="22分页"><a class="markdownIt-Anchor" href="#22分页"></a> 2.2.分页</h2>
<p><strong>elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了</strong>。elasticsearch中通过修改from、size参数来控制要返回的分页结果：</p>
<ul>
<li>from：从第几个文档开始</li>
<li>size：总共查询几个文档</li>
</ul>
<p>类似于mysql中的<code>limit ?, ?</code></p>
<h3 id="221基本的分页"><a class="markdownIt-Anchor" href="#221基本的分页"></a> 2.2.1.基本的分页</h3>
<p>分页的基本语法如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">0</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="222深度分页问题"><a class="markdownIt-Anchor" href="#222深度分页问题"></a> 2.2.2.深度分页问题</h3>
<p>现在，我要查询990~1000的数据，查询逻辑要这么写：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"from"</span><span class="punctuation">:</span>&nbsp;<span class="number">990</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;分页开始的位置，默认为0</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"size"</span><span class="punctuation">:</span>&nbsp;<span class="number">10</span><span class="punctuation">,</span>&nbsp;<span class="comment">//&nbsp;期望获取的文档总数</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span><span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>这里是查询990开始的数据，也就是 第990~第1000条 数据。</p>
<p>不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：</p>
<p><img src="../../../images/image-20210721200643029.png" alt="image-20210721200643029"></p>
<p>查询TOP1000，如果es是单点模式，这并无太大影响。</p>
<p>但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。</p>
<p>因为节点A的TOP200，在另一个节点可能排到10000名以外了。</p>
<p>因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，重新排名，重新截取TOP1000。</p>
<p><img src="../../../images/image-20210721201003229.png" alt="image-20210721201003229"></p>
<p>那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？</p>
<p>当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。</p>
<p>针对深度分页，ES提供了两种解决方案，<a target="_blank" rel="noopener" href="https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html">官方文档</a>：</p>
<ul>
<li><mark>search after</mark>：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li>
<li>scroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。</li>
</ul>
<h3 id="223小结"><a class="markdownIt-Anchor" href="#223小结"></a> 2.2.3.小结</h3>
<p>分页查询的常见实现方案以及优缺点：</p>
<ul>
<li>
<p><code>from + size</code>：</p>
<ul>
<li>优点：支持随机翻页</li>
<li>缺点：深度分页问题，默认查询上限（from + size）是10000</li>
<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li>
</ul>
</li>
<li>
<p><code>after search</code>：</p>
<ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：只能向后逐页查询，不支持随机翻页</li>
<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li>
</ul>
</li>
<li>
<p><code>scroll</code>：</p>
<ul>
<li>优点：没有查询上限（单次查询的size不超过10000）</li>
<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>
<li>场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。</li>
</ul>
</li>
</ul>
<h2 id="23高亮"><a class="markdownIt-Anchor" href="#23高亮"></a> 2.3.高亮</h2>
<h3 id="231高亮原理"><a class="markdownIt-Anchor" href="#231高亮原理"></a> 2.3.1.高亮原理</h3>
<p>什么是高亮显示呢？</p>
<p>我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：</p>
<p><img src="../../../images/image-20210721202705030.png" alt="image-20210721202705030"></p>
<p>高亮显示的实现分为两步：</p>
<ul>
<li>1）给文档中的所有关键字都添加一个标签，例如<code>&lt;em&gt;</code>标签</li>
<li>2）页面给<code>&lt;em&gt;</code>标签编写CSS样式</li>
</ul>
<h3 id="232实现高亮"><a class="markdownIt-Anchor" href="#232实现高亮"></a> 2.3.2.实现高亮</h3>
<p><strong>高亮的语法</strong>：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/hotel/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="string">"TEXT"</span> <span class="comment">// 查询条件，高亮一定要使用全文检索查询</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"highlight"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"fields"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span>&nbsp;<span class="comment">//&nbsp;指定要高亮的字段</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"pre_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;em&gt;"</span><span class="punctuation">,</span>&nbsp;&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的前置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"post_tags"</span><span class="punctuation">:</span>&nbsp;<span class="string">"&lt;/em&gt;"</span>&nbsp;<span class="comment">//&nbsp;用来标记高亮字段的后置标签</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>高亮是对关键字高亮，因此<strong>搜索条件必须带有关键字</strong>，而不能是范围这样的查询。</li>
<li>默认情况下，<strong>高亮的字段，必须与搜索指定的字段一致</strong>，否则无法高亮</li>
<li>如果要对非搜索字段高亮，则需要添加一个属性：required_field_match=false</li>
</ul>
<p><strong>示例</strong>：</p>
<p><img src="../../../images/image-20210721203349633.png" alt="image-20210721203349633"></p>
<h2 id="24总结"><a class="markdownIt-Anchor" href="#24总结"></a> 2.4.总结</h2>
<p>查询的DSL是一个大的JSON对象，包含下列属性：</p>
<ul>
<li>query：查询条件</li>
<li>from和size：分页条件</li>
<li>sort：排序条件</li>
<li>highlight：高亮条件</li>
</ul>
<p>示例：</p>
<p><img src="../../../images/image-20210721203657850.png" alt="image-20210721203657850"></p>
<h1 id="3restclient查询文档"><a class="markdownIt-Anchor" href="#3restclient查询文档"></a> 3.RestClient查询文档</h1>
<p>文档的查询同样适用前面学习的 RestHighLevelClient对象，基本步骤包括：</p>
<ul>
<li>1）准备Request对象</li>
<li>2）准备请求参数</li>
<li>3）发起请求</li>
<li>4）解析响应</li>
</ul>
<h2 id="31快速入门"><a class="markdownIt-Anchor" href="#31快速入门"></a> 3.1.快速入门</h2>
<p>我们以match_all查询为例</p>
<h3 id="311发起查询请求"><a class="markdownIt-Anchor" href="#311发起查询请求"></a> 3.1.1.发起查询请求</h3>
<p><img src="../../../images/image-20210721203950559.png" alt="image-20210721203950559"></p>
<p>代码解读：</p>
<ul>
<li>
<p>第一步，创建<code>SearchRequest</code>对象，指定索引库名</p>
</li>
<li>
<p>第二步，利用<font color="red"><code>request.source()</code></font>构建DSL，DSL中可以包含查询、分页、排序、高亮等</p>
<ul>
<li><code>query()</code>：代表查询条件，利用<code>QueryBuilders.matchAllQuery()</code>构建一个match_all查询的DSL</li>
</ul>
</li>
<li>
<p>第三步，利用client.search()发送请求，得到响应</p>
</li>
</ul>
<p>这里关键的API有两个，一个是<code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能：</p>
<p><img src="../../../images/image-20210721215640790.png" alt="image-20210721215640790"></p>
<p>另一个是<code>QueryBuilders</code>，其中包含match、term、function_score、bool等各种查询：</p>
<p><img src="../../../images/image-20210721215729236.png" alt="image-20210721215729236"></p>
<h3 id="312解析响应"><a class="markdownIt-Anchor" href="#312解析响应"></a> 3.1.2.解析响应</h3>
<p>响应结果的解析：</p>
<p><img src="../../../images/image-20210721214221057.png" alt="image-20210721214221057"></p>
<p>elasticsearch返回的结果是一个JSON字符串，结构包含：</p>
<ul>
<li><code>hits</code>：命中的结果
<ul>
<li><code>total</code>：总条数，其中的value是具体的总条数值</li>
<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>
<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个json对象
<ul>
<li><code>_source</code>：文档中的原始数据，也是json对象</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：</p>
<ul>
<li><code>SearchHits</code>：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果
<ul>
<li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li>
<li><code>SearchHits#getHits()</code>：获取SearchHit数组，也就是文档数组
<ul>
<li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的json文档数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="313完整代码"><a class="markdownIt-Anchor" href="#313完整代码"></a> 3.1.3.完整代码</h3>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatchAll</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="314小结"><a class="markdownIt-Anchor" href="#314小结"></a> 3.1.4.小结</h3>
<p>查询的基本步骤是：</p>
<ol>
<li>
<p>创建SearchRequest对象</p>
</li>
<li>
<p>准备Request.source()，也就是DSL。</p>
<p>① QueryBuilders来构建查询条件</p>
<p>② 传入Request.source() 的 query() 方法</p>
</li>
<li>
<p>发送请求，得到结果</p>
</li>
<li>
<p>解析结果（参考JSON结果，从外到内，逐层解析）</p>
</li>
</ol>
<h2 id="32match查询"><a class="markdownIt-Anchor" href="#32match查询"></a> 3.2.match查询</h2>
<p>全文检索的match和multi_match查询与match_all的API基本一致。差别是查询条件，也就是query的部分。</p>
<p><img src="../../../images/image-20210721215923060.png" alt="image-20210721215923060"></p>
<p>因此，Java代码上的差异主要是request.source().query()中的参数了。同样是利用QueryBuilders提供的方法：</p>
<p><img src="../../../images/image-20210721215843099.png" alt="image-20210721215843099"></p>
<p>而结果解析代码则完全一致，可以抽取并共享。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testMatch</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    request.source()</span><br><span class="line">        .query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="33精确查询"><a class="markdownIt-Anchor" href="#33精确查询"></a> 3.3.精确查询</h2>
<p>精确查询主要是两者：</p>
<ul>
<li>term：词条精确匹配</li>
<li>range：范围查询</li>
</ul>
<p>与之前的查询相比，差异同样在查询条件，其它都一样。</p>
<p>查询条件构造的API如下：</p>
<p><img src="../../../images/image-20210721220305140.png" alt="image-20210721220305140"></p>
<h2 id="34布尔查询"><a class="markdownIt-Anchor" href="#34布尔查询"></a> 3.4.布尔查询</h2>
<p>布尔查询是用must、must_not、filter等方式组合其它查询，代码示例如下：</p>
<p><img src="../../../images/image-20210721220927286.png" alt="image-20210721220927286"></p>
<p>可以看到，API与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testBool</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.准备BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.2.添加term</span></span><br><span class="line">    boolQuery.must(QueryBuilders.termQuery(<span class="string">"city"</span>, <span class="string">"杭州"</span>));</span><br><span class="line">    <span class="comment">// 2.3.添加range</span></span><br><span class="line">    boolQuery.filter(QueryBuilders.rangeQuery(<span class="string">"price"</span>).lte(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="35排序-分页"><a class="markdownIt-Anchor" href="#35排序-分页"></a> 3.5.排序、分页</h2>
<p>搜索结果的排序和分页是与query同级的参数，因此同样是使用request.source()来设置。</p>
<p>对应的API如下：</p>
<p><img src="../../../images/image-20210721221121266.png" alt="image-20210721221121266"></p>
<p>完整代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testPageAndSort</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 页码，每页大小</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchAllQuery());</span><br><span class="line">    <span class="comment">// 2.2.排序 sort</span></span><br><span class="line">    request.source().sort(<span class="string">"price"</span>, SortOrder.ASC);</span><br><span class="line">    <span class="comment">// 2.3.分页 from、size</span></span><br><span class="line">    request.source().from((page - <span class="number">1</span>) * size).size(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="36高亮"><a class="markdownIt-Anchor" href="#36高亮"></a> 3.6.高亮</h2>
<p>高亮的代码与之前代码差异较大，有两点：</p>
<ul>
<li>查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。</li>
<li>结果解析：结果除了要解析_source文档数据，还要解析高亮结果</li>
</ul>
<h3 id="361高亮请求构建"><a class="markdownIt-Anchor" href="#361高亮请求构建"></a> 3.6.1.高亮请求构建</h3>
<p>高亮请求的构建API如下：</p>
<p><img src="../../../images/image-20210721221744883.png" alt="image-20210721221744883"></p>
<p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testHighlight</span><span class="params">()</span> <span class="keyword">throws</span> IOException {</span><br><span class="line">    <span class="comment">// 1.准备Request</span></span><br><span class="line">    <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">    <span class="comment">// 2.准备DSL</span></span><br><span class="line">    <span class="comment">// 2.1.query</span></span><br><span class="line">    request.source().query(QueryBuilders.matchQuery(<span class="string">"all"</span>, <span class="string">"如家"</span>));</span><br><span class="line">    <span class="comment">// 2.2.高亮</span></span><br><span class="line">    request.source().highlighter(<span class="keyword">new</span> <span class="title class_">HighlightBuilder</span>().field(<span class="string">"name"</span>).requireFieldMatch(<span class="literal">false</span>));</span><br><span class="line">    <span class="comment">// 3.发送请求</span></span><br><span class="line">    <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    handleResponse(response);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="362高亮结果解析"><a class="markdownIt-Anchor" href="#362高亮结果解析"></a> 3.6.2.高亮结果解析</h3>
<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>
<p>因此解析高亮的代码需要额外处理：</p>
<p><img src="../../../images/image-20210721222057212.png" alt="image-20210721222057212"></p>
<p>代码解读：</p>
<ul>
<li>第一步：从结果中获取source。hit.getSourceAsString()，这部分是非高亮结果，json字符串。还需要反序列为HotelDoc对象</li>
<li>第二步：获取高亮结果。hit.getHighlightFields()，返回值是一个Map，key是高亮字段名称，值是HighlightField对象，代表高亮值</li>
<li>第三步：从map中根据高亮字段名称，获取高亮字段值对象HighlightField</li>
<li>第四步：从HighlightField中获取Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li>
<li>第五步：用高亮的结果替换HotelDoc中的非高亮结果</li>
</ul>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    System.out.println(<span class="string">"共搜索到"</span> + total + <span class="string">"条数据"</span>);</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">        <span class="comment">// 获取高亮结果</span></span><br><span class="line">        Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();</span><br><span class="line">        <span class="keyword">if</span> (!CollectionUtils.isEmpty(highlightFields)) {</span><br><span class="line">            <span class="comment">// 根据字段名获取高亮结果</span></span><br><span class="line">            <span class="type">HighlightField</span> <span class="variable">highlightField</span> <span class="operator">=</span> highlightFields.get(<span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (highlightField != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 获取高亮值</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> highlightField.getFragments()[<span class="number">0</span>].string();</span><br><span class="line">                <span class="comment">// 覆盖非高亮结果</span></span><br><span class="line">                hotelDoc.setName(name);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"hotelDoc = "</span> + hotelDoc);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="4黑马旅游案例"><a class="markdownIt-Anchor" href="#4黑马旅游案例"></a> 4.黑马旅游案例</h1>
<p>下面，我们通过黑马旅游的案例来实战演练下之前学习的知识。</p>
<p>我们实现四部分功能：</p>
<ul>
<li>酒店搜索和分页</li>
<li>酒店结果过滤</li>
<li>我周边的酒店</li>
<li>酒店竞价排名</li>
</ul>
<p>启动我们提供的hotel-demo项目，其默认端口是8089，访问<a target="_blank" rel="noopener" href="http://localhost:8090">http://localhost:8090</a>，就能看到项目页面了：</p>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210721223159598.png" alt="image-20210721223159598"></p>
<h2 id="41酒店搜索和分页"><a class="markdownIt-Anchor" href="#41酒店搜索和分页"></a> 4.1.酒店搜索和分页</h2>
<p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p>
<h3 id="411需求分析"><a class="markdownIt-Anchor" href="#411需求分析"></a> 4.1.1.需求分析</h3>
<p>在项目的首页，有一个大大的搜索框，还有分页按钮：</p>
<p><img src="../../../images/image-20210721223859419.png" alt="image-20210721223859419"></p>
<p>点击搜索按钮，可以看到浏览器控制台发出了请求：</p>
<p><img src="../../../images/image-20210721224033789.png" alt="image-20210721224033789"></p>
<p>请求参数如下：</p>
<p><img src="../../../images/image-20210721224112708.png" alt="image-20210721224112708"></p>
<p>由此可以知道，我们这个请求的信息如下：</p>
<ul>
<li>请求方式：POST</li>
<li>请求路径：/hotel/list</li>
<li>请求参数：JSON对象，包含4个字段：
<ul>
<li>key：搜索关键字</li>
<li>page：页码</li>
<li>size：每页大小</li>
<li>sortBy：排序，目前暂不实现</li>
</ul>
</li>
<li>返回值：分页查询，需要返回分页结果PageResult，包含两个属性：
<ul>
<li><code>total</code>：总条数</li>
<li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li>
</ul>
</li>
</ul>
<p>因此，我们实现业务的流程如下：</p>
<ul>
<li>步骤一：定义实体类，接收请求参数的JSON对象</li>
<li>步骤二：编写controller，接收页面的请求</li>
<li>步骤三：编写业务实现，利用RestHighLevelClient实现搜索、分页</li>
</ul>
<h3 id="412定义实体类"><a class="markdownIt-Anchor" href="#412定义实体类"></a> 4.1.2.定义实体类</h3>
<p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p>
<p>1）请求参数</p>
<p>前端请求的json结构如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"key"</span><span class="punctuation">:</span> <span class="string">"搜索关键字"</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"page"</span><span class="punctuation">:</span> <span class="number">1</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"size"</span><span class="punctuation">:</span> <span class="number">3</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">"sortBy"</span><span class="punctuation">:</span> <span class="string">"default"</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>因此，我们在<code>cn.itcast.hotel.pojo</code>包下定义一个实体类：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>2）返回值</p>
<p>分页查询，需要返回分页结果PageResult，包含两个属性：</p>
<ul>
<li><code>total</code>：总条数</li>
<li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li>
</ul>
<p>因此，我们在<code>cn.itcast.hotel.pojo</code>中定义返回结果：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PageResult</span> {</span><br><span class="line">    <span class="keyword">private</span> Long total;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HotelDoc&gt; hotels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">PageResult</span><span class="params">(Long total, List&lt;HotelDoc&gt; hotels)</span> {</span><br><span class="line">        <span class="built_in">this</span>.total = total;</span><br><span class="line">        <span class="built_in">this</span>.hotels = hotels;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="413定义controller"><a class="markdownIt-Anchor" href="#413定义controller"></a> 4.1.3.定义controller</h3>
<p>定义一个HotelController，声明查询接口，满足下列要求：</p>
<ul>
<li>请求方式：Post</li>
<li>请求路径：/hotel/list</li>
<li>请求参数：对象，类型为RequestParam</li>
<li>返回值：PageResult，包含两个属性
<ul>
<li><code>Long total</code>：总条数</li>
<li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li>
</ul>
</li>
</ul>
<p>因此，我们在<code>cn.itcast.hotel.web</code>中定义HotelController：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping("/hotel")</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelController</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IHotelService hotelService;</span><br><span class="line">	<span class="comment">// 搜索酒店数据</span></span><br><span class="line">    <span class="meta">@PostMapping("/list")</span></span><br><span class="line">    <span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(<span class="meta">@RequestBody</span> RequestParams params)</span>{</span><br><span class="line">        <span class="keyword">return</span> hotelService.search(params);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="414实现搜索业务"><a class="markdownIt-Anchor" href="#414实现搜索业务"></a> 4.1.4.实现搜索业务</h3>
<p>我们在controller调用了IHotelService，并没有实现该方法，因此下面我们就在IHotelService中定义方法，并且去实现业务逻辑。</p>
<p>1）在<code>cn.itcast.hotel.service</code>中的<code>IHotelService</code>接口中定义一个方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据关键字搜索酒店信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params 请求参数对象，包含用户输入的关键字 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 酒店文档列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>2）实现搜索业务，肯定离不开RestHighLevelClient，我们需要把它注册到Spring中作为一个Bean。在<code>cn.itcast.hotel</code>中的<code>HotelDemoApplication</code>中声明这个Bean：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RestHighLevelClient <span class="title function_">client</span><span class="params">()</span>{</span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> <span class="title class_">RestHighLevelClient</span>(RestClient.builder(</span><br><span class="line">        HttpHost.create(<span class="string">"http://192.168.150.101:9200"</span>)</span><br><span class="line">    ));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>3）在<code>cn.itcast.hotel.service.impl</code>中的<code>HotelService</code>中实现search方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果解析</span></span><br><span class="line"><span class="keyword">private</span> PageResult <span class="title function_">handleResponse</span><span class="params">(SearchResponse response)</span> {</span><br><span class="line">    <span class="comment">// 4.解析响应</span></span><br><span class="line">    <span class="type">SearchHits</span> <span class="variable">searchHits</span> <span class="operator">=</span> response.getHits();</span><br><span class="line">    <span class="comment">// 4.1.获取总条数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> searchHits.getTotalHits().value;</span><br><span class="line">    <span class="comment">// 4.2.文档数组</span></span><br><span class="line">    SearchHit[] hits = searchHits.getHits();</span><br><span class="line">    <span class="comment">// 4.3.遍历</span></span><br><span class="line">    List&lt;HotelDoc&gt; hotels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : hits) {</span><br><span class="line">        <span class="comment">// 获取文档source</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">json</span> <span class="operator">=</span> hit.getSourceAsString();</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        <span class="type">HotelDoc</span> <span class="variable">hotelDoc</span> <span class="operator">=</span> JSON.parseObject(json, HotelDoc.class);</span><br><span class="line">		<span class="comment">// 放入集合</span></span><br><span class="line">        hotels.add(hotelDoc);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.4.封装返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PageResult</span>(total, hotels);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="42酒店结果过滤"><a class="markdownIt-Anchor" href="#42酒店结果过滤"></a> 4.2.酒店结果过滤</h2>
<p>需求：添加品牌、城市、星级、价格等过滤功能</p>
<h3 id="421需求分析"><a class="markdownIt-Anchor" href="#421需求分析"></a> 4.2.1.需求分析</h3>
<p>在页面搜索框下面，会有一些过滤项：</p>
<p><img src="../../../images/image-20210722091940726.png" alt="image-20210722091940726"></p>
<p>传递的参数如图：</p>
<p><img src="../../../images/image-20210722092051994.png" alt="image-20210722092051994"></p>
<p>包含的过滤条件有：</p>
<ul>
<li>brand：品牌值</li>
<li>city：城市</li>
<li>minPrice~maxPrice：价格范围</li>
<li>starName：星级</li>
</ul>
<p>我们需要做两件事情：</p>
<ul>
<li>修改请求参数的对象RequestParams，接收上述参数</li>
<li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li>
</ul>
<h3 id="422修改实体类"><a class="markdownIt-Anchor" href="#422修改实体类"></a> 4.2.2.修改实体类</h3>
<p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="comment">// 下面是新增的过滤条件参数</span></span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="423修改搜索业务"><a class="markdownIt-Anchor" href="#423修改搜索业务"></a> 4.2.3.修改搜索业务</h3>
<p>在HotelService的search方法中，只有一个地方需要修改：requet.source().query( … )其中的查询条件。</p>
<p>在之前的业务中，只有match查询，根据关键字搜索，现在要添加条件过滤，包括：</p>
<ul>
<li>品牌过滤：是keyword类型，用term查询</li>
<li>星级过滤：是keyword类型，用term查询</li>
<li>价格过滤：是数值类型，用range查询</li>
<li>城市过滤：是keyword类型，用term查询</li>
</ul>
<p>多个查询条件组合，肯定是boolean查询来组合：</p>
<ul>
<li>关键字搜索放到must中，参与算分</li>
<li>其它过滤条件放到filter中，不参与算分</li>
</ul>
<p>因为条件构建的逻辑比较复杂，这里先封装为一个函数：</p>
<p><img src="../../../images/image-20210722092935453.png" alt="image-20210722092935453"></p>
<p>buildBasicQuery的代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 2.关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 3.城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 4.品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 5.星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 6.价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line">	<span class="comment">// 7.放入source</span></span><br><span class="line">    request.source().query(boolQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="43我周边的酒店"><a class="markdownIt-Anchor" href="#43我周边的酒店"></a> 4.3.我周边的酒店</h2>
<p>需求：我附近的酒店</p>
<h3 id="431需求分析"><a class="markdownIt-Anchor" href="#431需求分析"></a> 4.3.1.需求分析</h3>
<p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置：</p>
<p><img src="../../../images/image-20210722093414542.png" alt="image-20210722093414542"></p>
<p>并且，在前端会发起查询请求，将你的坐标发送到服务端：</p>
<p><img src="../../../images/image-20210722093642382.png" alt="image-20210722093642382"></p>
<p>我们要做的事情就是基于这个location坐标，然后按照距离对周围酒店排序。实现思路如下：</p>
<ul>
<li>修改RequestParams参数，接收location字段</li>
<li>修改search方法业务逻辑，如果location有值，添加根据geo_distance排序的功能</li>
</ul>
<h3 id="432修改实体类"><a class="markdownIt-Anchor" href="#432修改实体类"></a> 4.3.2.修改实体类</h3>
<p>修改在<code>cn.itcast.hotel.pojo</code>包下的实体类RequestParams：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RequestParams</span> {</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line">    <span class="keyword">private</span> String sortBy;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> Integer minPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer maxPrice;</span><br><span class="line">    <span class="comment">// 我当前的地理坐标</span></span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="433距离排序api"><a class="markdownIt-Anchor" href="#433距离排序api"></a> 4.3.3.距离排序API</h3>
<p>我们以前学习过排序功能，包括两种：</p>
<ul>
<li>普通字段排序</li>
<li>地理坐标排序</li>
</ul>
<p>我们只讲了普通字段排序对应的java写法。地理坐标排序只学过DSL语法，如下：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET&nbsp;/indexName/_search</span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;<span class="attr">"query"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"match_all"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span><span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line"> &nbsp;<span class="attr">"sort"</span><span class="punctuation">:</span>&nbsp;<span class="punctuation">[</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"price"</span><span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span>&nbsp;&nbsp;</span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"_geo_distance"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="punctuation">{</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"FIELD"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"纬度，经度"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"order"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"asc"</span><span class="punctuation">,</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="attr">"unit"</span>&nbsp;<span class="punctuation">:</span>&nbsp;<span class="string">"km"</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;&nbsp;&nbsp;<span class="punctuation">}</span></span><br><span class="line">&nbsp;&nbsp;<span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<p>对应的java代码示例：</p>
<p><img src="../../../images/image-20210722095227059.png" alt="image-20210722095227059"></p>
<h3 id="434添加距离排序"><a class="markdownIt-Anchor" href="#434添加距离排序"></a> 4.3.4.添加距离排序</h3>
<p>在<code>cn.itcast.hotel.service.impl</code>的<code>HotelService</code>的<code>search</code>方法中，添加一个排序功能：</p>
<p><img src="../../../images/image-20210722095902314.png" alt="image-20210722095902314"></p>
<p>完整代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PageResult <span class="title function_">search</span><span class="params">(RequestParams params)</span> {</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 1.准备Request</span></span><br><span class="line">        <span class="type">SearchRequest</span> <span class="variable">request</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SearchRequest</span>(<span class="string">"hotel"</span>);</span><br><span class="line">        <span class="comment">// 2.准备DSL</span></span><br><span class="line">        <span class="comment">// 2.1.query</span></span><br><span class="line">        buildBasicQuery(params, request);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2.分页</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">page</span> <span class="operator">=</span> params.getPage();</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> params.getSize();</span><br><span class="line">        request.source().from((page - <span class="number">1</span>) * size).size(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.3.排序</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">location</span> <span class="operator">=</span> params.getLocation();</span><br><span class="line">        <span class="keyword">if</span> (location != <span class="literal">null</span> &amp;&amp; !location.equals(<span class="string">""</span>)) {</span><br><span class="line">            request.source().sort(SortBuilders</span><br><span class="line">                                  .geoDistanceSort(<span class="string">"location"</span>, <span class="keyword">new</span> <span class="title class_">GeoPoint</span>(location))</span><br><span class="line">                                  .order(SortOrder.ASC)</span><br><span class="line">                                  .unit(DistanceUnit.KILOMETERS)</span><br><span class="line">                                 );</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.发送请求</span></span><br><span class="line">        <span class="type">SearchResponse</span> <span class="variable">response</span> <span class="operator">=</span> client.search(request, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">// 4.解析响应</span></span><br><span class="line">        <span class="keyword">return</span> handleResponse(response);</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="435排序距离显示"><a class="markdownIt-Anchor" href="#435排序距离显示"></a> 4.3.5.排序距离显示</h3>
<p>重启服务后，测试我的酒店功能：</p>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100040674.png" alt="image-20210722100040674"></p>
<p>发现确实可以实现对我附近酒店的排序，不过并没有看到酒店到底距离我多远，这该怎么办？</p>
<p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p>
<p><img src="../../../images/image-20210722095648542.png" alt="image-20210722095648542"></p>
<p>因此，我们在结果解析阶段，除了解析source部分以外，还要得到<mark><strong>sort</strong></mark>部分，也就是排序的距离，然后放到响应结果中。</p>
<p>我们要做两件事：</p>
<ul>
<li>修改HotelDoc，添加排序距离字段，用于页面显示</li>
<li>修改HotelService类中的handleResponse方法，添加对sort值的获取</li>
</ul>
<p>1）修改HotelDoc类，添加距离字段</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.hotel.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDoc</span> {</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> Integer price;</span><br><span class="line">    <span class="keyword">private</span> Integer score;</span><br><span class="line">    <span class="keyword">private</span> String brand;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String starName;</span><br><span class="line">    <span class="keyword">private</span> String business;</span><br><span class="line">    <span class="keyword">private</span> String location;</span><br><span class="line">    <span class="keyword">private</span> String pic;</span><br><span class="line">    <span class="comment">// 排序时的 距离值</span></span><br><span class="line">    <span class="keyword">private</span> Object distance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HotelDoc</span><span class="params">(Hotel hotel)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">        <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">        <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">        <span class="built_in">this</span>.price = hotel.getPrice();</span><br><span class="line">        <span class="built_in">this</span>.score = hotel.getScore();</span><br><span class="line">        <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">        <span class="built_in">this</span>.city = hotel.getCity();</span><br><span class="line">        <span class="built_in">this</span>.starName = hotel.getStarName();</span><br><span class="line">        <span class="built_in">this</span>.business = hotel.getBusiness();</span><br><span class="line">        <span class="built_in">this</span>.location = hotel.getLatitude() + <span class="string">", "</span> + hotel.getLongitude();</span><br><span class="line">        <span class="built_in">this</span>.pic = hotel.getPic();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>2）修改HotelService中的handleResponse方法</p>
<p><img src="../../../images/image-20210722100613966.png" alt="image-20210722100613966"></p>
<p>重启后测试，发现页面能成功显示距离了：</p>
<p><img src="/.com//../../../../../Java/idea/SpringCloud/%E8%B5%84%E6%96%99/day06-Elasticsearch02/%E8%AE%B2%E4%B9%89/assets/image-20210722100838604.png" alt="image-20210722100838604"></p>
<h2 id="44酒店竞价排名"><a class="markdownIt-Anchor" href="#44酒店竞价排名"></a> 4.4.酒店竞价排名</h2>
<p>需求：让指定的酒店在搜索结果中排名置顶</p>
<h3 id="441需求分析"><a class="markdownIt-Anchor" href="#441需求分析"></a> 4.4.1.需求分析</h3>
<p>要让指定酒店在搜索结果中排名置顶，效果如图：</p>
<p><img src="../../../images/image-20210722100947292.png" alt="image-20210722100947292"></p>
<p>页面会给指定的酒店添加<strong>广告</strong>标记。</p>
<p>那怎样才能让指定的酒店排名置顶呢？</p>
<p>我们之前学习过的function_score查询可以影响算分，算分高了，自然排名也就高了。而function_score包含3个要素：</p>
<ul>
<li>过滤条件：哪些文档要加分</li>
<li>算分函数：如何计算function score</li>
<li>加权方式：function score 与 query score如何运算</li>
</ul>
<p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以<strong>根据这个标记来判断，是否要提高算分</strong>。</p>
<p>比如，我们给酒店添加一个字段：isAD，Boolean类型：</p>
<ul>
<li>true：是广告</li>
<li>false：不是广告</li>
</ul>
<p>这样function_score包含3个要素就很好确定了：</p>
<ul>
<li>过滤条件：判断isAD 是否为true</li>
<li>算分函数：我们可以用最简单暴力的weight，固定加权值</li>
<li>加权方式：可以用默认的相乘，大大提高算分</li>
</ul>
<p>因此，业务的实现步骤包括：</p>
<ol>
<li>
<p>给HotelDoc类添加isAD字段，Boolean类型</p>
</li>
<li>
<p>挑选几个你喜欢的酒店，给它的文档数据添加isAD字段，值为true</p>
</li>
<li>
<p>修改search方法，添加function score功能，给isAD值为true的酒店增加权重</p>
</li>
</ol>
<h3 id="442修改hoteldoc实体"><a class="markdownIt-Anchor" href="#442修改hoteldoc实体"></a> 4.4.2.修改HotelDoc实体</h3>
<p>给<code>cn.itcast.hotel.pojo</code>包下的HotelDoc类添加isAD字段：</p>
<p><img src="../../../images/image-20210722101908062.png" alt="image-20210722101908062"></p>
<h3 id="443添加广告标记"><a class="markdownIt-Anchor" href="#443添加广告标记"></a> 4.4.3.添加广告标记</h3>
<p>接下来，我们挑几个酒店，添加isAD字段，设置为true：</p>
<figure class="highlight json"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">POST /hotel/_update/<span class="number">1902197537</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056126831</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">1989806195</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br><span class="line">POST /hotel/_update/<span class="number">2056105938</span></span><br><span class="line"><span class="punctuation">{</span></span><br><span class="line">    <span class="attr">"doc"</span><span class="punctuation">:</span> <span class="punctuation">{</span></span><br><span class="line">        <span class="attr">"isAD"</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">    <span class="punctuation">}</span></span><br><span class="line"><span class="punctuation">}</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="444添加算分函数查询"><a class="markdownIt-Anchor" href="#444添加算分函数查询"></a> 4.4.4.添加算分函数查询</h3>
<p>接下来我们就要修改查询条件了。之前是用的boolean 查询，现在要改成function_socre查询。</p>
<p>function_score查询结构如下：</p>
<p><img src="../../../images/image-20210721191544750.png" alt="image-20210721191544750"></p>
<p>对应的JavaAPI如下：</p>
<p><img src="../../../images/image-20210722102850818.png" alt="image-20210722102850818"></p>
<p>我们可以将之前写的boolean查询作为<strong>原始查询</strong>条件放到query中，接下来就是添加<strong>过滤条件</strong>、<strong>算分函数</strong>、<strong>加权模式</strong>了。所以原来的代码依然可以沿用。</p>
<p>修改<code>cn.itcast.hotel.service.impl</code>包下的<code>HotelService</code>类中的<code>buildBasicQuery</code>方法，添加算分函数查询：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">buildBasicQuery</span><span class="params">(RequestParams params, SearchRequest request)</span> {</span><br><span class="line">    <span class="comment">// 1.构建BooleanQuery</span></span><br><span class="line">    <span class="type">BoolQueryBuilder</span> <span class="variable">boolQuery</span> <span class="operator">=</span> QueryBuilders.boolQuery();</span><br><span class="line">    <span class="comment">// 关键字搜索</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> params.getKey();</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="literal">null</span> || <span class="string">""</span>.equals(key)) {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchAllQuery());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        boolQuery.must(QueryBuilders.matchQuery(<span class="string">"all"</span>, key));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 城市条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getCity() != <span class="literal">null</span> &amp;&amp; !params.getCity().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"city"</span>, params.getCity()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 品牌条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getBrand() != <span class="literal">null</span> &amp;&amp; !params.getBrand().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"brand"</span>, params.getBrand()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 星级条件</span></span><br><span class="line">    <span class="keyword">if</span> (params.getStarName() != <span class="literal">null</span> &amp;&amp; !params.getStarName().equals(<span class="string">""</span>)) {</span><br><span class="line">        boolQuery.filter(QueryBuilders.termQuery(<span class="string">"starName"</span>, params.getStarName()));</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 价格</span></span><br><span class="line">    <span class="keyword">if</span> (params.getMinPrice() != <span class="literal">null</span> &amp;&amp; params.getMaxPrice() != <span class="literal">null</span>) {</span><br><span class="line">        boolQuery.filter(QueryBuilders</span><br><span class="line">                         .rangeQuery(<span class="string">"price"</span>)</span><br><span class="line">                         .gte(params.getMinPrice())</span><br><span class="line">                         .lte(params.getMaxPrice())</span><br><span class="line">                        );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.算分控制</span></span><br><span class="line">    <span class="type">FunctionScoreQueryBuilder</span> <span class="variable">functionScoreQuery</span> <span class="operator">=</span></span><br><span class="line">        QueryBuilders.functionScoreQuery(</span><br><span class="line">        <span class="comment">// 原始查询，相关性算分的查询</span></span><br><span class="line">        boolQuery,</span><br><span class="line">        <span class="comment">// function score的数组</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]{</span><br><span class="line">            <span class="comment">// 其中的一个function score 元素</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(</span><br><span class="line">                <span class="comment">// 过滤条件</span></span><br><span class="line">                QueryBuilders.termQuery(<span class="string">"isAD"</span>, <span class="literal">true</span>),</span><br><span class="line">                <span class="comment">// 算分函数</span></span><br><span class="line">                ScoreFunctionBuilders.weightFactorFunction(<span class="number">10</span>)</span><br><span class="line">            )</span><br><span class="line">        });</span><br><span class="line">    request.source().query(functionScoreQuery);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/05/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Elasticsearch/%E5%88%86%E5%B8%83%E5%BC%8F%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E02/" data-id="clihlibte00a3u4v63ix873ow" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/Elasticsearch面试" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="post-time" datetime="2023-03-05T07:18:41.560Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">05</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<hr>
<h1 id="1-elasticsearch是什么"><a class="markdownIt-Anchor" href="#1-elasticsearch是什么"></a> 1、Elasticsearch是什么</h1>
<h2 id="11-概念"><a class="markdownIt-Anchor" href="#11-概念"></a> 1.1 概念:</h2>
<p>Elasticsearch是由 Java语言开发<strong>基于Lucene</strong>的一款开源的搜索、聚合分析和存储引擎。同时它也可以称作是一种非关系型文档数据库。</p>
<p><img src="../../images/image-20230305161034119.png" alt="image-20230305161034119"></p>
<h2 id="es可以替代mysql吗"><a class="markdownIt-Anchor" href="#es可以替代mysql吗"></a> ES可以替代MySQL吗？</h2>
<p>ElasticSearch和MySql分工不同，MySQL负责存储数据，ElasticSearch负责搜索数据</p>
<ul>
<li>
<p>MySQL有事务性，而ElasticSearch<mark>没有事务性</mark>，所以你<font color="red">删了的数据是无法恢复的</font>。</p>
</li>
<li>
<p>ElasticSearch<mark>没有物理外键</mark>这个特性，如果你的数据强一致性要求比较高还是建议慎用</p>
</li>
</ul>
<p><img src="../../images/image-20230305161337185.png" alt="image-20230305161337185"></p>
<h2 id="12特点"><a class="markdownIt-Anchor" href="#12特点"></a> 1.2特点</h2>
<ul>
<li>天生分布式、高性能（PB数据下可以秒读）、高可用、易扩展、易维护</li>
<li>跨语言、跨平台:几乎支持所有主流编程语言，并且支持在“Linux、Windows、MacOs”多平台部署</li>
<li>支持结构化、非结构化、地理位置搜索等</li>
</ul>
<h2 id="13适用场景"><a class="markdownIt-Anchor" href="#13适用场景"></a> 1.3适用场景</h2>
<ul>
<li>海量数据的全文检索，搜索引擎、垂直搜索、站内搜索:
<ul>
<li>百度、知乎、微博、CSDN</li>
<li>导航、外卖、团购等软件</li>
<li>以京东、淘宝为代表的垂直搜索</li>
<li>B站、抖音、爱奇艺、QQ音乐等音视频软件Glthub</li>
</ul>
</li>
<li>数据分析和聚合查询.</li>
<li>日志系统 : ELK</li>
</ul>
<h1 id="elasticsearch核心概念"><a class="markdownIt-Anchor" href="#elasticsearch核心概念"></a> Elasticsearch核心概念</h1>
<p><img src="../../images/image-20230305161535075.png" alt="image-20230305161535075"></p>
<p><img src="../../images/image-20230305161817337.png" alt="image-20230305161817337"></p>
<p><img src="../../images/image-20230305162010287.png" alt="image-20230305162010287"></p>
<h1 id="mysql数据库查询存在的问题"><a class="markdownIt-Anchor" href="#mysql数据库查询存在的问题"></a> MySQL数据库查询存在的问题：</h1>
<p><img src="../../images/image-20230305153910496.png" alt="image-20230305153910496"></p>
<p><img src="../../images/image-20230305154253699.png" alt="image-20230305154253699"></p>
<h1 id="es的倒排索引"><a class="markdownIt-Anchor" href="#es的倒排索引"></a> ES的倒排索引</h1>
<p><img src="../../images/image-20230305154901840.png" alt="image-20230305154901840"></p>
<h1 id="elasticsearch数据的存储和搜索原理"><a class="markdownIt-Anchor" href="#elasticsearch数据的存储和搜索原理"></a> Elasticsearch数据的存储和搜索原理</h1>
<p><img src="../../images/image-20230305155606164.png" alt="image-20230305155606164"></p>
<p><img src="../../images/image-20230305155847211.png" alt="image-20230305155847211"></p>
<h3 id="1-解决性能低问题"><a class="markdownIt-Anchor" href="#1-解决性能低问题"></a> 1. 解决性能低问题：</h3>
<h4 id="如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"><a class="markdownIt-Anchor" href="#如果倒排索引中tearm词条太多不会导致一样要遍历很久吗不会"></a> <strong>如果倒排索引中tearm词条太多不会导致一样要遍历很久吗？不会</strong></h4>
<p>因为ES生成的到排序索引中，词条会排序，形成一颗树形结构，提升词条的查询速度。</p>
<h3 id="2-解决功能弱问题"><a class="markdownIt-Anchor" href="#2-解决功能弱问题"></a> 2. 解决功能弱问题：</h3>
<p>ES会先对查询关键字进行分词，再进行查询。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/05/interview/Elasticsearch%E9%9D%A2%E8%AF%95/" data-id="clihlibpc003bu4v64j5adguw" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-interview/Netty面试" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="post-time" datetime="2023-03-04T02:25:13.345Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">04</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/">Netty面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-基本概念"><a class="markdownIt-Anchor" href="#1-基本概念"></a> 1 基本概念</h1>
<h2 id="1-什么是-netty"><a class="markdownIt-Anchor" href="#1-什么是-netty"></a> 1、什么是 Netty？</h2>
<p>Netty 是由 JBOSS 提供的一个 Java 开源框架。Netty 提供异步的、基于事件驱动的网络应用程序框架，用以快速开发高性能、高可靠性的网络 IO 程序,是目前最流行的 NIO 框架，Netty 在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，知名的 Elasticsearch 、Dubbo 框架内部都采用了 Netty。</p>
<h2 id="2-netty-的优势"><a class="markdownIt-Anchor" href="#2-netty-的优势"></a> 2、Netty 的优势？</h2>
<ul>
<li>
<p>使用简单：封闭了 Java 原生 NIO 类库繁琐的 API，使用起来更加高效；</p>
</li>
<li>
<p>功能强大：预置多种编码能力，支持多种主流协议。同时通过 <mark>ChannelHandler</mark> 可以进行灵活的拓展，支持很强的定制能力；</p>
</li>
<li>
<p>高性能：与其它业界主流 NIO 框架相比，Netty 综合更优。主要体现在<mark>吞吐量更高、延迟更低、减少资源消耗以及最小化不必要的内存复制；</mark></p>
</li>
<li>
<p>社区活跃与稳定：版本更新周期短，BUG 修复速度快，让开发者可以专注业务本身。</p>
</li>
</ul>
<h2 id="3-netty-有什么特点"><a class="markdownIt-Anchor" href="#3-netty-有什么特点"></a> 3、Netty 有什么特点？</h2>
<ul>
<li>
<p><strong>高并发</strong>：Netty 是一款基于 NIO（Nonblocking I/O，非阻塞IO）开发的网络通信框架。</p>
</li>
<li>
<p><strong>传输快</strong>：Netty 使用零拷贝特性，尽量减少不必要的内存拷贝，实现更快的传输效率。</p>
</li>
<li>
<p><strong>封装好</strong>：Netty 封装了 NIO 操作的很多细节，提供易于使用的 API。</p>
</li>
</ul>
<h2 id="4-netty-有哪些应用场景"><a class="markdownIt-Anchor" href="#4-netty-有哪些应用场景"></a> 4、Netty 有哪些应用场景？</h2>
<p>理论上来说，NIO 可以做的事情，Netty 都可以做并且更好。Netty 主要用来做网络通信：</p>
<ul>
<li>RPC 框架的网络通信工具；</li>
<li>实现一个 HTTP 服务器；</li>
<li>实现一个即时通讯系统；</li>
<li>实现消息推送系统。</li>
</ul>
<h2 id="5-netty-的高性能体现在"><a class="markdownIt-Anchor" href="#5-netty-的高性能体现在"></a> 5、Netty 的高性能体现在？</h2>
<ul>
<li><strong>IO 线程模型</strong>：同步非阻塞；</li>
<li><strong>零拷贝</strong>：尽量做到不必要的内存拷贝：</li>
<li><strong>内存池设计</strong>：使用直接内存，并且可重复利用；</li>
<li><strong>串行化处理读写</strong>：避免使用锁带来的额外开销；</li>
<li><strong>高性能序列化协议</strong>：支持 protobuf 等高性能序列化协议。</li>
</ul>
<h2 id="6-相比原生-nio-的优势"><a class="markdownIt-Anchor" href="#6-相比原生-nio-的优势"></a> 6、相比原生 NIO 的优势？</h2>
<p>1）易用性：Netty 在 NIO 基础上封装了更加人性化的 API，大大降低开发人员的学习成本，同时还提供了很多开箱即用的工具。</p>
<p>2）稳定性：Netty 修复了 Java NIO 较多已知问题，如 select 空转导致 CPU 100%，TCP 断线重连，Keep-alive 检测等问题。</p>
<p>3）高性能：对象池复用（通过对象复用避免频繁创建和销毁带来的开销）和零拷贝技术。</p>
<h2 id="7-netty-和-tomcat-的区别"><a class="markdownIt-Anchor" href="#7-netty-和-tomcat-的区别"></a> 7、Netty 和 Tomcat 的区别？</h2>
<p>Netty 和 Tomcat 最大的区别在于对通信协议的支持：</p>
<ul>
<li>
<p>Tomcat 是基于 Http 协议的，本质是一个基于 http 协议的 web 容器，而 Netty 不仅支持 HTTP，还能通过编程自定义各种协议，通过 codec 自定义编码/解码字节流，完成数据传输。</p>
</li>
<li>
<p>Tomcat 需要遵循 Servlet 规范（HTTP 协议的请求-响应模型），而 Netty 不需要受到 Servlet 规范约束，可以发挥 NIO 最大特性。</p>
</li>
</ul>
<h2 id="8-bio-nio-aio-分别是什么"><a class="markdownIt-Anchor" href="#8-bio-nio-aio-分别是什么"></a> 8、BIO. NIO. AIO 分别是什么？</h2>
<ul>
<li>
<p><strong>BIO（同步阻塞 IO）</strong><br>
服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。BIO 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK 1.4 以前的唯一选择，但程序直观简单易理解。</p>
</li>
<li>
<p><strong>NIO（同步非阻塞 IO）</strong><br>
服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 IO 请求时才启动一个线程进行处理。NIO 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK 1.4 开始支持。</p>
</li>
<li>
<p><strong>AIO（异步非阻塞 IO）</strong><br>
服务器实现模式为一个有效请求一个线程，客户端的 IO 请求都是由 OS 先完成了再通知服务器应用去启动线程进行处理。 AIO 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 OS 参与并发操作，编程比较复杂，JDK 1.7 开始支持。</p>
</li>
</ul>
<h2 id="9-select-poll-epoll-的区别"><a class="markdownIt-Anchor" href="#9-select-poll-epoll-的区别"></a> 9、Select、Poll、Epoll 的区别？</h2>
<p>ref</p>
<h2 id="10-什么是-reactor-模型"><a class="markdownIt-Anchor" href="#10-什么是-reactor-模型"></a> 10、什么是 Reactor 模型？</h2>
<h1 id="2-架构组件"><a class="markdownIt-Anchor" href="#2-架构组件"></a> 2 架构组件</h1>
<h2 id="1-netty-有哪些核心组件"><a class="markdownIt-Anchor" href="#1-netty-有哪些核心组件"></a> 1、Netty 有哪些核心组件？</h2>
<ul>
<li>
<p><strong>Channel</strong><br>
基础的 IO 操作，如绑定、连接、读写等都依赖于底层网络传输所提供的原语，在 Java 的网络编程中，基础核心类是 Socket，而 Netty 的 Channel 提供了一组 API，极大地简化了直接与 Socket 进行操作的复杂性，并且 Channel 是很多类的父类，如 EmbeddedChannel、LocalServerChannel、NioDatagramChannel、NioSctpChannel、NioSocketChannel 等。</p>
</li>
<li>
<p><strong>EventLoop</strong><br>
EventLoop 定义了处理在连接过程中发生的事件的核心抽象。</p>
</li>
</ul>
<p>​		说白了，EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 IO 操作的处理。</p>
<p>​		<strong>那 Channel 和 EventLoop 直接有啥联系呢？</strong></p>
<p>​		Channel 为 Netty 网络操作（<strong>读写</strong>等操作）抽象类，EventLoop 负责处理注册到其上的 Channel 处理 IO 操作，两者配合参与 IO 操作。</p>
<ul>
<li>
<p><strong>ChannelFuture</strong></p>
<ul>
<li>由于 Netty 是异步非阻塞的，所有的 IO 操作也都为异步的，我们不能立刻得到操作是否执行成功，因此 Netty 提供 ChannelFuture 接口，使用其 addListener() 方法注册一个 ChannelFutureListener，当操作执行成功或者失败时，监听就会自动触发返回结果。</li>
<li>并且，我们还可以通过 ChannelFuture 的 channel() 方法获取关联的Channel，甚至使用 sync() 方法让异步的操作变成同步的。</li>
</ul>
</li>
<li>
<p><strong>ChannelHandler 和 ChannelPipeline</strong></p>
<ul>
<li>从应用开发者看来，ChannelHandler 是最重要的组件，其中存放用来处理进站和出站数据的用户逻辑。ChannelHandler 的方法被网络事件触发，可以用于几乎任何类型的操作，如将数据从一种格式转换为另一种格式或处理抛出的异常。如其子接口ChannelInboundHandler，接受进站的事件和数据以便被用户定义的逻辑处理，或者当响应所连接的客户端时刷新ChannelInboundHandler的数据。</li>
<li>ChannelPipeline为ChannelHandler 链提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API。当创建 Channel 时，会自动创建一个附属的 ChannelPipeline。</li>
</ul>
</li>
<li>
<p><strong>Bootstrap 和 ServerBootstrap</strong><br>
Netty 的引导类应用程序网络层配置提供容器，其涉及将进程绑定到给定端口或连接一个进程到在指定主机上指定端口上运行的另一进程。引导类分为客户端引导 Bootstrap 和服务端引导 ServerBootstrap。</p>
</li>
</ul>
<h2 id="2-什么是-eventloop-和-eventloopgroup"><a class="markdownIt-Anchor" href="#2-什么是-eventloop-和-eventloopgroup"></a> 2、什么是 EventLoop 和 EventLoopGroup？</h2>
<p>EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程），上面我们已经说了 EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。</p>
<p>并且 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。</p>
<p>上图是一个服务端对 EventLoopGroup 使用的大致模块图，其中 Boss EventloopGroup 用于接收连接，Worker EventloopGroup 用于具体的处理（消息的读写以及其他逻辑处理）。</p>
<p><img src="../../images/image-20230304103657806.png" alt="image-20230304103657806"></p>
<p>从上图可以看出：当客户端通过 connect 方法连接服务端时，bossGroup 处理客户端连接请求。当客户端处理完成后，会将这个连接提交给 workerGroup 来处理，然后 workerGroup 负责处理其 IO 相关操作。</p>
<h2 id="3-说说-netty-的线程模型"><a class="markdownIt-Anchor" href="#3-说说-netty-的线程模型"></a> 3、说说 Netty 的线程模型？</h2>
<p>Netty 通过 Reactor 模型基于多路复用器接收并处理用户请求，内部实现了两个线程池，boss 线程池和 work 线程池，其中 boss 线程池的线程负责处理请求的 accept 事件，当接收到 accept 事件的请求时，把对应的 socket 封装到一个 NioSocketChannel 中，并交给 work 线程池，其中 work 线程池负责请求的 read 和 write 事件，由对应的 Handler 处理。</p>
<ul>
<li><strong>单线程模型</strong><br>
所有 IO 操作都由一个线程完成，即多路复用、事件分发和处理都是在一个 Reactor 线程上完成的。既要接收客户端的连接请求，向服务端发起连接，又要发送、读取请求或应答、响应消息。一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，速度慢，若线程进入死循环，整个程序不可用，对于高负载、高并发的应用场景不合适。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.eventGroup既用于处理客户端连接，又负责具体的处理。 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">eventGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">boobtstrap.group(eventGroup, eventGroup) </span><br><span class="line"><span class="comment">//......</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>多线程模型</strong><br>
有一个 NIO 线程（Acceptor） 只负责监听服务端，接收客户端的 TCP 连接请求；NIO 线程池负责网络 IO 的操作，即消息的读取、解码、编码和发送；1 个 NIO 线程可以同时处理 N 条链路，但是 1 个链路只对应 1 个 NIO 线程，这是为了防止发生并发操作问题。但在并发百万客户端连接或需要安全认证时，一个 Acceptor 线程可能会存在性能不足问题。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/1d2358f8e6484e0db5a574a4701960bf.png#pic_center" alt="在这里插入图片描述"></p>
<p>对于代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>主从多线程模型</strong><br>
Acceptor 线程用于绑定监听端口，接收客户端连接，将 SocketChannel 从主线程池的 Reactor 线程的多路复用器上移除，重新注册到 Sub 线程池的线程上，用于处理 IO 的读写等操作，从而保证主 Reactor 只负责接入认证、握手等操作。如果多线程模型无法满足你的需求的时候，可以考虑使用主从多线程模型 。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/993566982c15443eb242cf628adc4d9b.png#pic_center" alt="在这里插入图片描述"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理</span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：</span></span><br><span class="line">    ServerBootstrap <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup) </span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="4-netty-服务端的启动过程"><a class="markdownIt-Anchor" href="#4-netty-服务端的启动过程"></a> 4、Netty 服务端的启动过程？</h2>
<p>先来看一段代码实现：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.bossGroup 用于接收连接，workerGroup 用于具体的处理 </span></span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">bossGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>); </span><br><span class="line"><span class="type">EventLoopGroup</span> <span class="variable">workerGroup</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(); </span><br><span class="line"><span class="keyword">try</span> { </span><br><span class="line">    <span class="comment">//2.创建服务端启动引导/辅助类：ServerBootstrap </span></span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>(); </span><br><span class="line">    <span class="comment">//3.给引导类配置两大线程组,确定了线程模型 </span></span><br><span class="line">    b.group(bossGroup, workerGroup)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.INFO))  <span class="comment">// (非必备)打印日志  </span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 4.指定 IO 模型 </span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() {</span><br><span class="line">         <span class="meta">@Override</span> </span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> {</span><br><span class="line">             <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> ch.pipeline(); </span><br><span class="line">             <span class="comment">//5.可以自定义客户端消息的业务处理逻辑 </span></span><br><span class="line">             p.addLast(<span class="keyword">new</span> <span class="title class_">HelloServerHandler</span>()); </span><br><span class="line">        } </span><br><span class="line">    }); </span><br><span class="line">    <span class="comment">// 6.绑定端口,调用 sync 方法阻塞知道绑定完成 </span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">f</span> <span class="operator">=</span> b.bind(port).sync();</span><br><span class="line">    <span class="comment">// 7.阻塞等待直到服务器Channel关闭(closeFuture()方法获取Channel 的CloseFuture对象,然后调用sync()方法) </span></span><br><span class="line">    f.channel().closeFuture().sync(); </span><br><span class="line">} <span class="keyword">finally</span> { </span><br><span class="line">    <span class="comment">//8.优雅关闭相关线程组资源 </span></span><br><span class="line">    bossGroup.shutdownGracefully(); </span><br><span class="line">    workerGroup.shutdownGracefully(); </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="3-具体实现"><a class="markdownIt-Anchor" href="#3-具体实现"></a> 3 具体实现</h1>
<h2 id="1-netty-的无锁化体现在哪里"><a class="markdownIt-Anchor" href="#1-netty-的无锁化体现在哪里"></a> 1、Netty 的无锁化体现在哪里？</h2>
<p>Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p>
<p><img src="https://img-blog.csdnimg.cn/1ed6fd9de8a64328806c5225edfc6bdb.png#pic_center" alt="在这里插入图片描述"></p>
<p>Netty 的 NioEventLoop 读取到消息后，直接调用 ChannelPipeline 的 fireChannelRead（Object msg），只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁竞争，从性能角度看是最优的。</p>
<h2 id="2-如何解决-jdk-epoll-空轮询问题"><a class="markdownIt-Anchor" href="#2-如何解决-jdk-epoll-空轮询问题"></a> 2、如何解决 JDK epoll 空轮询问题？</h2>
<p>这个 BUG 是指 Java 的 NIO 在 Linux 下进行 selector.select() 时，本来如果轮询的结果为空并且不调用 wakeup 方法的话，这个 selector.select() 应该是一直阻塞的，但是 Java 却会打破阻塞，继续执行，导致程序无限空转，造成 CPU 使用率 100%。（这个问题只存在 Linux 是因为 Linux 的 NIO 是基于 epoll 实现的，而 Java 实现的 epoll 存在 BUG，windows 下 NIO 基于 poll 就不存在此问题）</p>
<p><strong>Netty 的解决方案：</strong></p>
<p>为 Selector 的 select 操作设置超时时间，同时定义可以跳出阻塞的四种情况：</p>
<ul>
<li>有事件发生</li>
<li>wakeup</li>
<li>超时</li>
<li>空轮询 BUG</li>
</ul>
<p>而前两种返回值不为 0，可以跳出循环，超时有时间戳记录，所以每次空轮询，有专门的计数器进行 +1，如果空轮询的次数超过了 512 次（默认），就认为其触发了空轮询 BUG。</p>
<p>当触发 BUG 后，Netty 直接重建一个 Selector，将原来的 Channel 重新注册到新的 Selector 上，并将旧的 Selector 关掉。</p>
<h2 id="3-什么是拆包和粘包"><a class="markdownIt-Anchor" href="#3-什么是拆包和粘包"></a> 3、什么是拆包和粘包？</h2>
<p>TCP 是一个面向流的传输协议，所谓流，就是没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP <strong>粘包和拆包问题</strong>。</p>
<p>粘包和拆包是 TCP 网络编程中不可避免的，无论是服务端还是客户端，当我们读取或者发送消息的时候，都需要考虑 TCP 底层的粘包/拆包机制。</p>
<p><img src="https://img-blog.csdnimg.cn/6e67b9fbe3fa41e5b087e648a74c3af3.png#pic_center" alt="在这里插入图片描述"></p>
<p>数据从发送方到接收方需要经过操作系统的缓冲区，而造成粘包和拆包的主要原因就在这个缓冲区上。粘包可以理解为缓冲区数据堆积，导致多个请求数据粘在一起，而拆包可以理解为发送的数据大于缓冲区，进行拆分处理。</p>
<p>详细来说，造成粘包和拆包的原因主要有以下三个：</p>
<p>1）应用程序 write 写入的字节大小大于套接口发送缓冲区大小；</p>
<p>2）进行 MSS 大小的 TCP 分段；</p>
<p>3）以太网帧的 payload 大于 MTU 进行 IP 分片。</p>
<h2 id="4-拆包粘包的解决方案"><a class="markdownIt-Anchor" href="#4-拆包粘包的解决方案"></a> 4、拆包粘包的解决方案？</h2>
<p>由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议可以归纳出以下解决方案：</p>
<p>1）消息长度固定，累计读取到长度和为定长LEN的报文后，就认为读取到了一个完整的信息。</p>
<p>2）将特殊的分隔符作为消息的结束标志，如回车换行符。</p>
<p>3）通过在消息头中定义长度字段来标识消息的总长度。</p>
<h2 id="5-netty-如何解决拆包粘包"><a class="markdownIt-Anchor" href="#5-netty-如何解决拆包粘包"></a> 5、Netty 如何解决拆包粘包？</h2>
<p>相比粘包，拆包问题比较简单，用户可以自己定义自己的编码器进行处理，Netty 并没有提供相应的组件。对于粘包的问题，代码比较繁琐，Netty 提供了 4 种解码器来解决，分别如下：</p>
<ul>
<li><strong>固定长度的拆包器</strong>（FixedLengthFrameDecoder），每个应用层数据包的都拆分成都是固定长度的大小；</li>
<li><strong>行拆包器</strong>（LineBasedFrameDecoder），每个应用层数据包都以换行符作为分隔符，进行分割拆分；</li>
<li>**分隔符拆包器(**DelimiterBasedFrameDecoder），每个应用层数据包，都通过自定义的分隔符，进行分割拆分；</li>
<li><strong>基于数据包长度的拆包器</strong>（LengthFieldBasedFrameDecoder），将应用层数据包的长度，作为接收端应用层数据包的拆分依据。按照应用层数据包的大小，拆包。这个拆包器，有一个要求，就是应用层协议中包含数据包的长度。</li>
</ul>
<h2 id="6-netty-零拷贝体现在哪里"><a class="markdownIt-Anchor" href="#6-netty-零拷贝体现在哪里"></a> 6、Netty 零拷贝体现在哪里？</h2>
<p>Zero-copy 就是在操作数据时, 不需要将数据 buffer从 一个内存区域拷贝到另一个内存区域。 少了一次内存的拷贝，CPU 效率就得到的提升。</p>
<ul>
<li>
<p>接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝；</p>
</li>
<li>
<p>提供了组合 Buffer 对象，可以聚合多个 ByteBuffer 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作；</p>
</li>
<li>
<p>文件传输采用了 transferTo 方法，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p>
</li>
</ul>
<p><strong>和操作系统上的零拷贝的区别？</strong></p>
<p>Netty 的 Zero-copy 完全是在用户态（Java 应用层）的, 更多的偏向于优化数据操作。而在 OS 层面上的 Zero-copy 通常指避免在用户态（User-space）与内核态（Kernel-space）之间来回拷贝数据。</p>
<h2 id="7-tcp-的长连接和短连接"><a class="markdownIt-Anchor" href="#7-tcp-的长连接和短连接"></a> 7、TCP 的长连接和短连接？</h2>
<p>我们知道 TCP 在进行读写之前，server 与 client 之间必须提前建立一个连接。建立连接的过程，需要我们常说的三次握手，释放/关闭连接的话需要四次挥手。这个过程是比较消耗网络资源并且有时间延迟的。</p>
<p>所谓，短连接说的就是 server 端 与 client 端建立连接之后，读写完成之后就关闭掉连接，如果下一次再要互相发送消息，就要重新连接。短连接的有点很明显，就是管理和实现都比较简单，缺点也很明显，每一次的读写都要建立连接必然会带来大量网络资源的消耗，并且连接的建立也需要耗费时间。</p>
<p>长连接说的就是 client 向 server 双方建立连接之后，即使 client 与 server 完成一次读写，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的可以省去较多的 TCP 建立和关闭的操作，降低对网络资源的依赖，节约时间。对于频繁请求资源的客户来说，非常适用长连接。</p>
<h2 id="8-netty-长连接-心跳机制了解么"><a class="markdownIt-Anchor" href="#8-netty-长连接-心跳机制了解么"></a> 8、Netty 长连接、心跳机制了解么？</h2>
<p>在 TCP 保持长连接的过程中，可能会出现断网等网络异常出现，异常发生的时候， client 与 server 之间如果没有交互的话，它们是无法发现对方已经掉线的。为了解决这个问题, 我们就需要引入<strong>心跳机制</strong>。</p>
<p>心跳机制的工作原理是: 在 client 与 server 之间在一定时间内没有数据交互（即处于 idle 状态）时, 客户端或服务器就会发送一个特殊的数据包给对方, 当接收方收到这个数据报文后, 也立即发送一个特殊的数据报文, 回应发送方, 此即一个 <font color="red">PING-PONG</font> 交互。所以, 当某一端收到心跳消息后, 就知道了对方仍然在线, 这就确保 TCP 连接的有效性。</p>
<p>TCP 实际上自带的就有长连接选项，本身是也有心跳包机制，也就是 TCP 的选项：<font color="red">SO_KEEPALIVE</font>。但 TCP 协议层面的长连接灵活性不够，所以，一般情况下我们都是在应用层协议上实现自定义心跳机制的，也就是在 Netty 层面通过编码实现。通过 Netty 实现心跳机制的话，核心类是 IdleStateHandler 。</p>
<h2 id="9-说说-netty-的对象池技术"><a class="markdownIt-Anchor" href="#9-说说-netty-的对象池技术"></a> 9、说说 Netty 的对象池技术？</h2>
<p>对象池其实就是缓存一些对象从而避免大量创建同一个类型的对象，类似线程池的概念。对象池缓存了一些已经创建好的对象，避免需要时才创建对象，同时限制了实例的个数。池化技术最终要的就是重复的使用池内已经创建的对象。从上面的内容就可以看出对象池适用于以下几个场景：</p>
<ul>
<li>创建对象的开销大；</li>
<li>会创建大量的实例；</li>
<li>限制一些资源的使用。</li>
</ul>
<p>Netty 自己实现了一套轻量级的对象池。在 Netty 中，通常会有多个 IO 线程独立工作（基于 NioEventLoop 实现）。每个 IO 线程轮询单独的 Selector 实例来检索 IO 事件，并在 IO 来临时开始处理。最常见的 IO 操作就是读写，具体到 NIO 就是从内核缓冲区拷贝数据到用户缓冲区或者从用户缓冲区拷贝数据到内核缓冲区。这里会涉及到大量的创建和回收 Buffer， Netty 对 Buffer 进行了池化从而降低系统开销。</p>
<p>ref</p>
<h2 id="10-有哪些序列化协议"><a class="markdownIt-Anchor" href="#10-有哪些序列化协议"></a> 10 有哪些序列化协议？</h2>
<p><strong>序列化</strong>（编码）是将对象序列化为二进制形式（字节数组），主要用于网络传输、数据持久化等；而反序列化（解码）则是将从网络、磁盘等读取的字节数组还原成原始对象，主要用于网络传输对象的解码，以便完成远程调用。</p>
<p>影响序列化性能的关键因素：序列化后的码流大小（网络带宽的占用）、序列化的性能（CPU资源占用）；是否支持跨语言（异构系统的对接和开发语言切换）。</p>
<p><strong>目前几种主流协议</strong></p>
<ul>
<li>
<p><strong>Java 默认提供的序列化</strong><br>
无法跨语言、序列化后的码流太大、序列化的性能差。</p>
</li>
<li>
<p><strong>XML</strong><br>
优点是人机可读性好，可指定元素或特性的名称。缺点：序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息；只能序列化公共属性和字段；不能序列化方法；文件庞大，文件格式复杂，传输占带宽。适用场景：当做配置文件存储数据，实时数据转换。</p>
</li>
<li>
<p><strong>JSON</strong><br>
是一种轻量级的数据交换格式，优点：兼容性高、数据格式比较简单，易于读写、序列化后数据较小，可扩展性好，兼容性好、与XML相比，其协议比较简单，解析速度比较快。缺点：数据的描述性比XML差、不适合性能要求为ms级别的情况、额外空间开销比较大。适用场景（可替代ＸＭＬ）：跨防火墙访问、可调式性要求高、基于Web browser的Ajax请求、传输数据量相对小，实时性要求相对低（例如秒级别）的服务。</p>
</li>
<li>
<p><strong>Fastjson</strong><br>
采用一种“假定有序快速匹配”的算法。优点：接口简单易用、目前java语言中最快的json库。缺点：过于注重快，而偏离了“标准”及功能性、代码质量不高，文档不全。适用场景：协议交互、Web输出、Android客户端。</p>
</li>
<li>
<p><strong>Thrift</strong><br>
不仅是序列化协议，还是一个RPC框架。优点：序列化后的体积小, 速度快、支持多种语言和丰富的数据类型、对于数据字段的增删具有较强的兼容性、支持二进制压缩编码。缺点：使用者较少、跨防火墙访问时，不安全、不具有可读性，调试代码时相对困难、不能与其他传输层协议共同使用（例如HTTP）、无法支持向持久层直接读写数据，即不适合做数据持久化序列化协议。适用场景：分布式系统的RPC解决方案。</p>
</li>
<li>
<p><strong>Avro</strong><br>
Hadoop的一个子项目，解决了JSON的冗长和没有IDL的问题。优点：支持丰富的数据类型、简单的动态语言结合功能、具有自我描述属性、提高了数据解析速度、快速可压缩的二进制数据形式、可以实现远程过程调用RPC、支持跨编程语言实现。缺点：对于习惯于静态类型语言的用户不直观。适用场景：在Hadoop中做Hive、Pig和MapReduce的持久化数据格式。</p>
</li>
<li>
<p><strong>Protobuf</strong><br>
将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。优点：序列化后码流小，性能高、结构化数据存储格式（XML JSON等）、通过标识字段的顺序，可以实现协议的前向兼容、结构化的文档更容易管理和维护。缺点：需要依赖于工具生成代码、支持的语言相对较少，官方只支持Java 、C++ 、python。适用场景：对性能要求高的RPC调用、具有良好的跨防火墙的访问属性、适合应用层对象的持久化。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/04/interview/Netty%E9%9D%A2%E8%AF%95/" data-id="clihlibpg003eu4v6343d5fuz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/Spring Boot面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-03-03T11:20:43.310Z" itemprop="datePublished">
    <span class="post-month">3月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/">Spring Boot面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="spring-boot面试题总结最全面的面试题"><a class="markdownIt-Anchor" href="#spring-boot面试题总结最全面的面试题"></a> Spring Boot面试题（总结最全面的面试题！！！）</h1>
<p>2020年04月13日</p>
<blockquote>
<p>Java面试总结汇总，整理了包括Java重点知识，以及常用开源框架，欢迎大家阅读。文章可能有错误的地方，因为个人知识有限，欢迎各位大佬指出！文章持续更新中…</p>
</blockquote>
<blockquote>
<table>
<thead>
<tr>
<th>ID</th>
<th>标题</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>设计模式面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125721772039">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>2</td>
<td>Java基础知识面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059738631">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>3</td>
<td>Java集合面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125939843079">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>4</td>
<td>JavaIO、BIO、NIO、AIO、Netty面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125700784136">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>5</td>
<td>Java并发编程面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125755293710">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>6</td>
<td>Java异常面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904128959741965">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>7</td>
<td>Java虚拟机（JVM）面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125696573448">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>8</td>
<td>Spring面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127051513864">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>9</td>
<td>Spring MVC面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059722253">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>10</td>
<td>Spring Boot面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125709156359">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>11</td>
<td>Spring Cloud面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125717544973">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>12</td>
<td>Redis面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127055527950">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>13</td>
<td>MyBatis面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125935648776">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>14</td>
<td>MySQL面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127047139335">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>15</td>
<td>TCP、UDP、Socket、HTTP面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125692379143">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>16</td>
<td>Nginx面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125784653837">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>17</td>
<td>ElasticSearch面试题</td>
<td></td>
</tr>
<tr>
<td>18</td>
<td>kafka面试题</td>
<td></td>
</tr>
<tr>
<td>19</td>
<td>RabbitMQ面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904125935665160">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>20</td>
<td>Dubbo面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127076499463">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>21</td>
<td>ZooKeeper面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127076499464">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>22</td>
<td>Netty面试题（总结最全面的面试题）</td>
<td></td>
</tr>
<tr>
<td>23</td>
<td>Tomcat面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059722247">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>24</td>
<td>Linux面试题（总结最全面的面试题）</td>
<td><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059738637">juejin.cn/post/684490…</a></td>
</tr>
<tr>
<td>25</td>
<td>互联网相关面试题（总结最全面的面试题）</td>
<td></td>
</tr>
<tr>
<td>26</td>
<td>互联网安全面试题（总结最全面的面试题）</td>
<td></td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="什么是-spring-boot"><a class="markdownIt-Anchor" href="#什么是-spring-boot"></a> 什么是 Spring Boot？</h3>
<ul>
<li>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件一站式解决方案，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了各种启动器，使开发者能快速上手。</li>
</ul>
<h3 id="为什么要用springboot"><a class="markdownIt-Anchor" href="#为什么要用springboot"></a> 为什么要用SpringBoot</h3>
<ul>
<li>快速开发，快速整合，配置简化、内嵌服务容器</li>
</ul>
<h3 id="springboot与springcloud-区别"><a class="markdownIt-Anchor" href="#springboot与springcloud-区别"></a> SpringBoot与SpringCloud 区别</h3>
<ul>
<li>SpringBoot是快速开发的Spring框架，SpringCloud是完整的微服务框架，SpringCloud依赖于SpringBoot。</li>
</ul>
<h3 id="spring-boot-有哪些优点"><a class="markdownIt-Anchor" href="#spring-boot-有哪些优点"></a> Spring Boot 有哪些优点？</h3>
<ul>
<li>Spring Boot 主要有如下优点：
<ol>
<li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li>
<li>开箱即用，远离繁琐的配置。</li>
<li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li>
<li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等等</li>
<li>快速轻松地开发基于 Spring 的应用程序；</li>
<li>无需部署war文件；</li>
<li>创建独立应用程序的能力；</li>
<li>帮助将 Tomcat、Jetty 或 Undertow 直接嵌入到应用程序中；</li>
<li>无需XML配置；</li>
<li>减少源代码数量；</li>
<li>额外的开箱即用功能；</li>
<li>轻松启动；</li>
<li>简单的设置和管理；</li>
</ol>
</li>
</ul>
<h3 id="spring-boot-的核心注解是哪个它主要由哪几个注解组成的"><a class="markdownIt-Anchor" href="#spring-boot-的核心注解是哪个它主要由哪几个注解组成的"></a> Spring Boot 的核心注解是哪个？它主要由哪几个注解组成的？</h3>
<ul>
<li>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：
<ul>
<li>@SpringBootConfiguration：组合了 @Configuration 注解，实现配置文件的功能。</li>
<li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项， 例如：<code>java 如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</code></li>
<li>@ComponentScan：Spring组件扫描。</li>
</ul>
</li>
</ul>
<h3 id="spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"><a class="markdownIt-Anchor" href="#spring-boot-支持哪些日志框架推荐和默认的日志框架是哪个"></a> Spring Boot 支持哪些日志框架？推荐和默认的日志框架是哪个？</h3>
<ul>
<li>Spring Boot 支持 Java Util Logging, Log4j2, Lockback 作为日志框架，如果你使用 Starters 启动器，Spring Boot 将使用 Logback 作为默认日志框架，但是不管是那种日志框架他都支持将配置文件输出到控制台或者文件中。</li>
</ul>
<h3 id="spring-boot-中的-starter-到底是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的-starter-到底是什么"></a> Spring Boot 中的 starter 到底是什么 ?</h3>
<ul>
<li>首先，这个 Starter 并非什么新的技术点，基本上还是基于 Spring 已有功能来实现的。首先它提供了一个自动化配置类，一般命名为 <code>XXXAutoConfiguration</code> ，在这个配置类中通过条件注解来决定一个配置是否生效（条件注解就是 Spring 中原本就有的），然后它还会提供一系列的默认配置，也允许开发者根据实际情况自定义相关配置，然后通过类型安全的属性(spring.factories)注入将这些配置属性注入进来，新注入的属性会代替掉默认属性。正因为如此，很多第三方框架，我们只需要引入依赖就可以直接使用了。当然，开发者也可以自定义 Starter</li>
</ul>
<h3 id="springboot-starter的工作原理"><a class="markdownIt-Anchor" href="#springboot-starter的工作原理"></a> SpringBoot Starter的工作原理</h3>
<ul>
<li><code>我个人理解SpringBoot就是由各种Starter组合起来的，我们自己也可以开发Starter</code></li>
<li>在sprinBoot启动时由@SpringBootApplication注解会自动去maven中读取每个starter中的spring.factories文件,该文件里配置了所有需要被创建spring容器中的bean，并且进行自动配置把bean注入SpringContext中 //（SpringContext是Spring的配置文件）</li>
</ul>
<h3 id="spring-boot-2x-有什么新特性与-1x-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-2x-有什么新特性与-1x-有什么区别"></a> Spring Boot 2.X 有什么新特性？与 1.X 有什么区别？</h3>
<ul>
<li>配置变更</li>
<li>JDK 版本升级</li>
<li>第三方类库升级</li>
<li>响应式 Spring 编程支持</li>
<li>HTTP/2 支持</li>
<li>配置属性绑定</li>
<li>更多改进与加强</li>
</ul>
<h3 id="springboot支持什么前端模板"><a class="markdownIt-Anchor" href="#springboot支持什么前端模板"></a> SpringBoot支持什么前端模板，</h3>
<ul>
<li>thymeleaf，freemarker，jsp，官方不推荐JSP会有限制</li>
</ul>
<h3 id="springboot的缺点"><a class="markdownIt-Anchor" href="#springboot的缺点"></a> SpringBoot的缺点</h3>
<p>尽管 Spring Boot 有很多优点，但它仍然有一些缺点需要牢记：</p>
<ul>
<li>由于不用自己做的配置，<mark>报错时很难定位</mark>。</li>
<li>缺乏控制。 Spring Boot 会<mark>创建大量未使用的依赖项，导致部署文件很大</mark>；</li>
<li>将遗留或现有 Spring 项目转换为 Spring Boot 应用程序的复杂且耗时的过程；</li>
<li>不适合大型项目。 尽管它非常适合使用微服务，但许多开发人员声称 Spring Boot 不适合构建单体应用程序。</li>
</ul>
<h3 id="运行-spring-boot-有哪几种方式"><a class="markdownIt-Anchor" href="#运行-spring-boot-有哪几种方式"></a> 运行 Spring Boot 有哪几种方式？</h3>
<ol>
<li>打包用命令或者放到容器中运行</li>
<li>用 Maven/ Gradle 插件运行</li>
<li>直接执行 main 方法运行</li>
</ol>
<h3 id="spring-boot-需要独立的容器运行吗"><a class="markdownIt-Anchor" href="#spring-boot-需要独立的容器运行吗"></a> Spring Boot 需要独立的容器运行吗？</h3>
<ul>
<li>可以不需要，内置了 Tomcat/ Jetty 等容器。</li>
</ul>
<h3 id="开启-spring-boot-特性有哪几种方式"><a class="markdownIt-Anchor" href="#开启-spring-boot-特性有哪几种方式"></a> 开启 Spring Boot 特性有哪几种方式？</h3>
<h4 id="1-继承spring-boot-starter-parent项目"><a class="markdownIt-Anchor" href="#1-继承spring-boot-starter-parent项目"></a> 1. 继承spring-boot-starter-parent项目</h4>
<parent>
	<groupid>org.springframework.boot</groupid>
    <artifactid>spring-boot-starter-parent</artifactid>
    <version>2.2.6.RELEASE</version>
</parent>
<p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p>
<dependencies>
	<dependency>
		<groupid>org.springframework.boot</groupid>
	    <artifactid>spring-boot-starter</artifactid>
	</dependency>
</dependencies>
<h4 id="2-导入spring-boot-dependencies项目依赖"><a class="markdownIt-Anchor" href="#2-导入spring-boot-dependencies项目依赖"></a> 2. 导入spring-boot-dependencies项目依赖</h4>
<dependencymanagement>
    <dependencies>
      <dependency>
        <groupid>org.springframework.boot</groupid>
        <artifactid>spring-boot-dependencies</artifactid>
        <version>1.5.4.RELEASE</version>
        <type>pom</type>
        <scope>import</scope>
      </dependency>
    </dependencies>
</dependencymanagement>
<p>这个时候再导入我们需要的springboot starter时，就可以忽略版本号：</p>
<dependencies>
	<dependency>
		<groupid>org.springframework.boot</groupid>
	    <artifactid>spring-boot-starter</artifactid>
	</dependency>
</dependencies>
<h3 id="springboot-实现热部署有哪几种方式"><a class="markdownIt-Anchor" href="#springboot-实现热部署有哪几种方式"></a> SpringBoot 实现热部署有哪几种方式？</h3>
<ul>
<li>热部署就是可以不用重新运行SpringBoot项目可以实现操作后台代码自动更新到以运行的项目中</li>
<li>主要有两种方式：
<ul>
<li>Spring Loaded</li>
<li>Spring-boot-devtools</li>
</ul>
</li>
</ul>
<h3 id="springboot事务的使用"><a class="markdownIt-Anchor" href="#springboot事务的使用"></a> SpringBoot事务的使用</h3>
<ul>
<li>SpringBoot的事务很简单，首先使用注解@EnableTransactionManagement开启事务之后，然后在Service方法上添加注解@Transactional便可。</li>
</ul>
<h3 id="async异步调用方法"><a class="markdownIt-Anchor" href="#async异步调用方法"></a> Async异步调用方法</h3>
<ul>
<li>在SpringBoot中使用异步调用是很简单的，只需要在方法上使用@Async注解即可实现方法的异步调用。 注意：需要在启动类加入**@EnableAsync<strong>使异步调用</strong>@Async**注解生效。</li>
</ul>
<h3 id="如何在-spring-boot-启动的时候运行一些特定的代码"><a class="markdownIt-Anchor" href="#如何在-spring-boot-启动的时候运行一些特定的代码"></a> 如何在 Spring Boot 启动的时候运行一些特定的代码？</h3>
<p>可以实现接口 ApplicationRunner 或者 CommandLineRunner，这两个接口实现方式一样，它们都只提供了一个 run 方法</p>
<h4 id="1-applicationrunner"><a class="markdownIt-Anchor" href="#1-applicationrunner"></a> 1. ApplicationRunner</h4>
<ul>
<li>在项目中，可能会遇到这样一个问题：在项目启动完成之后，紧接着执行一段代码。<br>
在SpringBoot中，提供了一个接口：ApplicationRunner。该接口中，只有一个run方法，他执行的时机是：spring容器启动完成之后，就会紧接着执行这个接口实现类的run方法。</li>
<li>实现了ApplicationRunner接口的类，并重写run方法，在springBoot项目启动后就是调用执行一次run方法</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestImplApplicationRunner</span> <span class="keyword">implements</span> <span class="title class_">ApplicationRunner</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(ApplicationArguments args)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">        System.out.println(<span class="string">"测试ApplicationRunner接口1"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>@Component注解<br>
这个实现类，要注入到spring容器中，这里使用了@Component注解；<br>
在同一个项目中，可以定义多个ApplicationRunner的实现类，他们的执行顺序通过注解@Order注解或者再实现Ordered接口来实现。</p>
</li>
<li>
<p>run方法的参数：ApplicationArguments可以获取到当前项目执行的命令参数。（比如把这个项目打成jar执行的时候，带的参数可以通过ApplicationArguments获取到）；由于该方法是在容器启动完成之后，才执行的，所以，这里可以从spring容器中拿到其他已经注入的bean。</p>
</li>
<li>
<p>@Order注解<br>
如果有多个实现类，而你需要他们按一定顺序执行的话，可以在实现类上加上@Order注解。@Order(value=整数值)。SpringBoot会按照@Order中的value值从小到大依次执行。<br>
@order，使用注解方式使bean的加载顺序得到控制,@Order标记定义了组件的加载顺序，值越小拥有越高的优先级，可为负数。值越小，越先被加载。</p>
</li>
<li>
<p>@Order(-1)优先于@Order(0)<br>
@Order(1)优先于@Order(2)</p>
</li>
</ul>
<h4 id="2-commandlinerunner"><a class="markdownIt-Anchor" href="#2-commandlinerunner"></a> 2. CommandLineRunner</h4>
<p><strong>背景</strong></p>
<p>项目启动之前，预先加载数据。比如，权限容器、特殊用户数据等。通常我们可以使用监听器、事件来操作。但是，springboot提供了一个简单的方式来实现此类需求，即，CommandLineRunner。</p>
<p>先了解一下这个类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.Order;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Interface used to indicate that a bean should &lt;em&gt;run&lt;/em&gt; when it is contained within</span></span><br><span class="line"><span class="comment"> * a {<span class="doctag">@link</span> SpringApplication}. Multiple {<span class="doctag">@link</span> CommandLineRunner} beans can be defined</span></span><br><span class="line"><span class="comment"> * within the same application context and can be ordered using the {<span class="doctag">@link</span> Ordered}</span></span><br><span class="line"><span class="comment"> * interface or {<span class="doctag">@link</span> Order <span class="doctag">@Order</span>} annotation.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If you need access to {<span class="doctag">@link</span> ApplicationArguments} instead of the raw String array</span></span><br><span class="line"><span class="comment"> * consider using {<span class="doctag">@link</span> ApplicationRunner}.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Dave Syer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> ApplicationRunner</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Callback used to run the bean.</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> args incoming main method arguments</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception on error</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>文档中，我们可以知道以下几点。</p>
<ul>
<li>这是一个接口，用户可以自定义实现该接口，具体实现run方法</li>
<li>任何在上下文容器之内的bean都可以实现run方法</li>
<li>如果在上下文中，存在多个该接口实现类，可以通过@order注解，指定加载顺序</li>
</ul>
<p>所以我们基本上大概已经了解了这个接口的作用以及用法。</p>
<p><strong>案例说明</strong><br>
分别定义一个数据加载类MyStartupRunner1，排序为2；另一个数据加载类MyStartupRunner2,排序为1。看看它们记载数据的顺序。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 2)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner1</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span>{</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">       System.out.println(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner1 order 2 &lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order(value = 1)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyStartupRunner2</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> {</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... strings)</span> <span class="keyword">throws</span> Exception {</span><br><span class="line">   		System.out.println(<span class="string">"&gt;&gt;&gt;&gt;服务启动执行，执行加载数据等操作 MyStartupRunner2 order 1 &lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span>);</span><br><span class="line">   	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="spring-boot-有哪几种读取配置的方式"><a class="markdownIt-Anchor" href="#spring-boot-有哪几种读取配置的方式"></a> Spring Boot 有哪几种读取配置的方式？</h3>
<ul>
<li>Spring Boot 可以通过 @PropertySource,@Value,@Environment, @ConfigurationPropertie注解来绑定变量</li>
</ul>
<h3 id="什么是-javaconfig"><a class="markdownIt-Anchor" href="#什么是-javaconfig"></a> 什么是 JavaConfig？</h3>
<ul>
<li>Spring JavaConfig 是 Spring 社区的产品，Spring 3.0引入了他，它提供了配置 Spring IOC 容器的纯Java 方法。因此它有助于避免使用 XML 配置。使用 JavaConfig 的优点在于：
<ul>
<li>面向对象的配置。由于配置被定义为 JavaConfig 中的类，因此用户可以充分利用 Java 中的面向对象功能。一个配置类可以继承另一个，重写它的@Bean 方法等。</li>
<li>减少或消除 XML 配置。基于依赖注入原则的外化配置的好处已被证明。但是，许多开发人员不希望在 XML 和 Java 之间来回切换。JavaConfig 为开发人员提供了一种纯 Java 方法来配置与 XML 配置概念相似的 Spring 容器。从技术角度来讲，只使用 JavaConfig 配置类来配置容器是可行的，但实际上很多人认为将JavaConfig 与 XML 混合匹配是理想的。</li>
<li>类型安全和重构友好。JavaConfig 提供了一种类型安全的方法来配置 Spring容器。由于 Java 5.0 对泛型的支持，现在可以按类型而不是按名称检索 bean，不需要任何强制转换或基于字符串的查找。</li>
</ul>
</li>
<li>常用的Java config：
<ul>
<li>@Configuration：在类上打上写下此注解，表示这个类是配置类</li>
<li>@ComponentScan：在配置类上添加 @ComponentScan 注解。该注解默认会扫描该类所在的包下所有的配置类，相当于之前的 &lt;context:component-scan &gt;。</li>
<li>@Bean：bean的注入：相当于以前的&lt; bean id=“objectMapper” class=“org.codehaus.jackson.map.ObjectMapper” /&gt;</li>
<li>@EnableWebMvc：相当于xml的&lt;mvc:annotation-driven &gt;</li>
<li>@ImportResource： 相当于xml的 &lt; import resource=“applicationContext-cache.xml”&gt;</li>
</ul>
</li>
</ul>
<h3 id="springboot的自动配置原理是什么"><a class="markdownIt-Anchor" href="#springboot的自动配置原理是什么"></a> SpringBoot的自动配置原理是什么</h3>
<ul>
<li>主要是Spring Boot的启动类上的核心注解SpringBootApplication注解主配置类，有了这个主配置类启动时就会为SpringBoot开启一个@EnableAutoConfiguration注解自动配置功能。</li>
<li>有了这个EnableAutoConfiguration的话就会：
<ol>
<li>从配置文件META_INF/Spring.factories加载可能用到的自动配置类</li>
<li>去重，并将exclude和excludeName属性携带的类排除</li>
<li>过滤，将满足条件（@Conditional）的自动配置类返回</li>
</ol>
</li>
</ul>
<h3 id="你如何理解-spring-boot-配置加载顺序"><a class="markdownIt-Anchor" href="#你如何理解-spring-boot-配置加载顺序"></a> 你如何理解 Spring Boot 配置加载顺序？</h3>
<ul>
<li>
<p>在 Spring Boot 里面，可以使用以下几种方式来加载配置。</p>
<ul>
<li>1.properties文件；</li>
<li>2.YAML文件；</li>
<li>3.系统环境变量；</li>
<li>4.命令行参数；</li>
<li>等等……</li>
</ul>
<p>常用配置文件中读取配置的结论：config配置中心 =&gt; jvm参数 =&gt; 系统环境变量 =&gt; 项目内的application-xxx.yaml =&gt; 项目内的application.yaml =&gt; bootstrap.yaml</p>
</li>
</ul>
<h3 id="什么是-yaml"><a class="markdownIt-Anchor" href="#什么是-yaml"></a> 什么是 YAML？</h3>
<ul>
<li>YAML 是一种<mark>人类可读的数据序列化语言</mark>。它通常用于配置文件。与属性文件相比，如果我们想要在配置文件中添加复杂的属性，YAML 文件就更加结构化，而且更少混淆。可以看出 YAML 具有分层配置数据。</li>
<li>YAML 的语法比较简洁直观，特点是使用空格来表达层次结构，其最大优势在于<strong>数据结构</strong>方面的表达，所以 YAML 更多应用于<strong>编写配置文件</strong>，其文件一般以 <strong>.yml</strong> 为后缀。</li>
</ul>
<h3 id="yaml-配置的优势在哪里"><a class="markdownIt-Anchor" href="#yaml-配置的优势在哪里"></a> YAML 配置的优势在哪里 ?</h3>
<ul>
<li>YAML 现在可以算是非常流行的一种配置文件格式了，无论是前端还是后端，都可以见到 YAML 配置。那么 YAML 配置和传统的 properties 配置相比到底有哪些优势呢？
<ul>
<li>配置有序，在一些特殊的场景下，配置有序很关键</li>
<li>简洁明了，他还支持数组，数组中的元素可以是基本数据类型也可以是对象</li>
<li>相比 properties 配置文件，YAML 还有一个缺点，就是不支持 @PropertySource 注解导入自定义的 YAML 配置。</li>
</ul>
</li>
</ul>
<h3 id="spring-boot-是否可以使用-xml-配置"><a class="markdownIt-Anchor" href="#spring-boot-是否可以使用-xml-配置"></a> Spring Boot 是否可以使用 XML 配置 ?</h3>
<ul>
<li>Spring Boot 推荐使用 Java 配置而非 XML 配置，但是 Spring Boot 中也可以使用 XML 配置，通过 @ImportResource 注解可以引入一个 XML 配置。</li>
</ul>
<h3 id="spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"><a class="markdownIt-Anchor" href="#spring-boot-核心配置文件是什么bootstrapproperties-和-applicationproperties-有何区别"></a> spring boot 核心配置文件是什么？bootstrap.properties 和 application.properties 有何区别 ?</h3>
<ul>
<li>单纯做 Spring Boot 开发，可能不太容易遇到 bootstrap.properties 配置文件，但是在结合 Spring Cloud 时，这个配置就会经常遇到了，特别是在需要加载一些远程配置文件的时侯。</li>
<li>spring boot 核心的两个配置文件：
<ul>
<li>bootstrap (. yml 或者 . properties)：boostrap 由父 ApplicationContext 加载的，比 applicaton 优先加载，配置在应用程序上下文的引导阶段生效。一般来说我们在 Spring Cloud 配置就会使用这个文件。且 boostrap 里面的属性不能被覆盖；</li>
<li>application (. yml 或者 . properties)： 由ApplicatonContext 加载，用于 <mark>spring boot 项目的<strong>自动化配置</strong></mark>。</li>
</ul>
</li>
</ul>
<h3 id="什么是-spring-profiles"><a class="markdownIt-Anchor" href="#什么是-spring-profiles"></a> 什么是 Spring Profiles？</h3>
<ul>
<li>在项目的开发中，有些配置文件在开发、测试或者生产等不同环境中可能是不同的，例如数据库连接、redis的配置等等。那我们如何在不同环境中自动实现配置的切换呢？Spring给我们提供了profiles机制给我们提供的就是来回切换配置文件的功能</li>
<li>Spring Profiles 允许用户根据配置文件（dev，test，prod 等）来注册 bean。因此，当应用程序在开发中运行时，只有某些 bean 可以加载，而在 PRODUCTION中，某些其他 bean 可以加载。假设我们的要求是 Swagger 文档仅适用于 QA 环境，并且禁用所有其他文档。这可以使用配置文件来完成。Spring Boot 使得使用配置文件非常简单。</li>
</ul>
<h3 id="springboot多数据源拆分的思路"><a class="markdownIt-Anchor" href="#springboot多数据源拆分的思路"></a> SpringBoot多数据源拆分的思路</h3>
<ul>
<li>先在properties配置文件中配置两个数据源，创建分包mapper，使用@ConfigurationProperties读取properties中的配置，使用@MapperScan注册到对应的mapper包中</li>
</ul>
<h3 id="springboot多数据源事务如何管理"><a class="markdownIt-Anchor" href="#springboot多数据源事务如何管理"></a> SpringBoot多数据源事务如何管理</h3>
<ul>
<li>第一种方式是在service层的@TransactionManager中使用transactionManager指定DataSourceConfig中配置的事务</li>
<li>第二种是使用jta-atomikos实现分布式事务管理</li>
</ul>
<h3 id="保护-spring-boot-应用有哪些方法"><a class="markdownIt-Anchor" href="#保护-spring-boot-应用有哪些方法"></a> 保护 Spring Boot 应用有哪些方法？</h3>
<ul>
<li>在生产中使用HTTPS</li>
<li>使用Snyk检查你的依赖关系</li>
<li>升级到最新版本</li>
<li>启用CSRF保护</li>
<li>使用内容安全策略防止XSS攻击</li>
</ul>
<h3 id="如何实现-spring-boot-应用程序的安全性"><a class="markdownIt-Anchor" href="#如何实现-spring-boot-应用程序的安全性"></a> 如何实现 Spring Boot 应用程序的安全性？</h3>
<ul>
<li>为了实现 Spring Boot 的安全性，我们使用 spring-boot-starter-security 依赖项，并且必须添加安全配置。它只需要很少的代码。配置类将必须扩展WebSecurityConfigurerAdapter 并覆盖其方法。</li>
</ul>
<h3 id="比较一下-spring-security-和-shiro-各自的优缺点"><a class="markdownIt-Anchor" href="#比较一下-spring-security-和-shiro-各自的优缺点"></a> 比较一下 Spring Security 和 Shiro 各自的优缺点 ?</h3>
<ul>
<li>由于 Spring Boot 官方提供了大量的非常方便的开箱即用的 Starter ，包括 Spring Security 的 Starter ，使得在 Spring Boot 中使用 Spring Security 变得更加容易，甚至只需要添加一个依赖就可以保护所有的接口，所以，如果是 Spring Boot 项目，一般选择 Spring Security 。当然这只是一个建议的组合，单纯从技术上来说，无论怎么组合，都是没有问题的。Shiro 和 Spring Security 相比，主要有如下一些特点：
<ul>
<li>Spring Security 是一个重量级的安全管理框架；Shiro 则是一个轻量级的安全管理框架</li>
<li>Spring Security 概念复杂，配置繁琐；Shiro 概念简单、配置简单</li>
<li>Spring Security 功能强大；Shiro 功能简单</li>
</ul>
</li>
</ul>
<h3 id="spring-boot-中如何解决跨域问题"><a class="markdownIt-Anchor" href="#spring-boot-中如何解决跨域问题"></a> Spring Boot 中如何解决跨域问题 ?</h3>
<ul>
<li>跨域可以在前端通过 JSONP 来解决，但是 JSONP 只可以发送 GET 请求，无法发送其他类型的请求，在 RESTful 风格的应用中，就显得非常鸡肋，因此我们推荐在后端通过 （CORS，Cross-origin resource sharing） 来解决跨域问题。这种解决方案并非 Spring Boot 特有的，在传统的 SSM 框架中，就可以通过 CORS 来解决跨域问题，只不过之前我们是在 XML 文件中配置 CORS ，现在可以通过实现WebMvcConfigurer接口然后重写addCorsMappings方法解决跨域问题。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorsConfig</span> <span class="keyword">extends</span> <span class="title class_">WebMvcConfigurerAdapter</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> {</span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>) 		<span class="comment">//可以被跨域的路径</span></span><br><span class="line">            .allowedOrigins(<span class="string">"*"</span>) 		<span class="comment">//域名的白名单</span></span><br><span class="line">            .allowedMethods(<span class="string">"*"</span>)		<span class="comment">/*"GET", "POST", "DELETE", "PUT"*/</span></span><br><span class="line">            .allowedHeaders(<span class="string">"*"</span>) 		<span class="comment">//允许所有的请求header访问，可以自定义设置任意请求头信息</span></span><br><span class="line">            .maxAge(<span class="number">3600</span>); 				<span class="comment">//这个复杂请求是预检用的，设置预检多久失效</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何使用-spring-boot-实现全局异常处理"><a class="markdownIt-Anchor" href="#如何使用-spring-boot-实现全局异常处理"></a> 如何使用 Spring Boot 实现全局异常处理？</h3>
<ul>
<li>Spring 提供了一种使用 <mark>ControllerAdvice</mark> 处理异常的非常有用的方法。 我们通过实现一个 ControlerAdvice 类，来处理控制器类抛出的所有异常。</li>
</ul>
<h4 id="controlleradvice-作用"><a class="markdownIt-Anchor" href="#controlleradvice-作用"></a> @ControllerAdvice 作用</h4>
<p><font color="red"><strong>controller 的增强，用于对controller 做一些统一的操作，一般是用于全局的异常处理，也可以用于全局结果的返回处理</strong></font></p>
<p>可以在一定程度上简化代码，减少代码的书写量，统一对所有结果和异常做处理，包括异常信息的返回和错误日志的答应等</p>
<p>@ControllerAdvice，是Spring3.2提供的新注解,它是一个Controller增强器,可对controller中被 @RequestMapping注解的方法加一些逻辑处理。主要作用有一下三种 :</p>
<ul>
<li>通过@ControllerAdvice注解可以将对于控制器的全局配置放在同一个位置。</li>
<li>注解了@ControllerAdvice的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上。
<ul>
<li>@ExceptionHandler：用于全局处理控制器里的异常，进行全局异常处理</li>
<li>@InitBinder：用来设置WebDataBinder，用于自动绑定前台请求参数到Model中，全局数据预处理。</li>
<li>@ModelAttribute：本来作用是绑定键值对到Model中，此处让全局的@RequestMapping都能获得在此处设置的键值对 ，全局数据绑定。</li>
</ul>
</li>
<li>@ControllerAdvice注解将作用在所有注解了@RequestMapping的控制器的方法上。</li>
</ul>
<p>需要配合@ExceptionHandler使用。 当将异常抛到controller时,可以对异常进行统一处理,规定返回的json格式或是跳转到一个错误页面</p>
<p>全局异常处理举例以及说明<br>
@ControllerAdvice ，@ExceptionHandler 的全局处理</p>
<p>Slf4j 为日志注解</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ControllerAdvice;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyGlobalExceptionHandler</span> {</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 自定义异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MyException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handle</span><span class="params">(HttpServletRequest request, MyException e)</span> {</span><br><span class="line">        log.error(<span class="string">"错误信息:{}"</span>, e.getMessage(), e);</span><br><span class="line">		<span class="keyword">return</span> Response.failMessage(e.getCode(), e.getMessage());</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// @Valid 校验框架抛出的特殊异常类</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = MethodArgumentNotValidException.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleValidException</span><span class="params">(HttpServletRequest request, MethodArgumentNotValidException e)</span> {</span><br><span class="line">        <span class="type">BindingResult</span> <span class="variable">bindingResult</span> <span class="operator">=</span> e.getBindingResult();</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">if</span> (bindingResult.hasErrors()) {</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = bindingResult.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span> (ObjectError allError : allErrors) {</span><br><span class="line">                message.append(allError.getDefaultMessage()).append(<span class="string">", "</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(message.toString());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认其他的所有异常</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@ExceptionHandler(value = Exception.class)</span></span><br><span class="line">    <span class="keyword">public</span> Response&lt;String&gt; <span class="title function_">handleOtherException</span><span class="params">(HttpServletRequest request, Exception e)</span> {</span><br><span class="line">        log.error(<span class="string">"request error Exception:"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> Response.failMessage(e.getMessage());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h3 id="spring-boot-中的监视器是什么"><a class="markdownIt-Anchor" href="#spring-boot-中的监视器是什么"></a> Spring Boot 中的监视器是什么？</h3>
<ul>
<li>
<p>Spring boot actuator 是 spring 启动框架中的重要功能之一。Spring boot 监视器可帮助您<mark>访问生产环境中正在运行的应用程序的当前状态</mark>。有几个指标必须在生产环境中进行检查和监控。即使一些外部应用程序可能正在使用这些服务来向相关人员触发警报消息。监视器模块公开了一组可直接作为 HTTP URL 访问的REST 端点来检查状态。</p>
</li>
<li>
<p>Spring Boot自带监控组件—Actuator，它可以帮助实现对程序内部运行情况的监控。本章首先介绍Actuator轻松实现应用程序的监控治理，比如健康状况、审计、统计和HTTP追踪、Bean加载情况、环境变量、日志信息、线程信息等，然后介绍如何使用Spring Boot Admin构建完整的运维监控平台。<br>
<strong>Actuator的核心是端点（Endpoint）</strong>，它用来监视、提供应用程序的信息，Spring Boot提供的spring-boot-actuator组件中已经内置了非常多的Endpoint（health、info、beans、metrics、httptrace、shutdown等），每个端点都可以启用和禁用。</p>
<p><strong>监控端点分类：</strong><br>
1）应用配置类：可以查看应用在运行期的静态信息，比如自动配置信息、加载的Spring Bean信息、YML文件配置信息、环境信息、请求映射信息。<br>
2）度量指标类：主要是运行期的动态信息，如堆栈、请求连接、健康状态、系统性能等<br>
3）操作控制类：主要是指shutdown，用户可以发送一个请求将应用的监控功能关闭。</p>
</li>
</ul>
<h3 id="我们如何监视所有-spring-boot-微服务"><a class="markdownIt-Anchor" href="#我们如何监视所有-spring-boot-微服务"></a> 我们如何监视所有 Spring Boot 微服务？</h3>
<ul>
<li>Spring Boot 提供 <strong>监视器端点</strong> 以监控各个微服务的度量。这些端点对于获取有关应用程序的信息（如它们是否已启动）以及它们的组件（如数据库等）是否正常运行很有帮助。但是，使用监视器的一个主要缺点或困难是，我们必须单独打开应用程序的知识点以了解其状态或健康状况。想象一下涉及 50 个应用程序的微服务，管理员将不得不击中所有 50 个应用程序的执行终端。为了帮助我们处理这种情况，我们将使用位于的开源项目。 它建立在 <strong>Spring Boot Actuator</strong> 之上，它提供了一个 Web UI，使我们能够可视化多个应用程序的度量。</li>
</ul>
<h3 id="springboot性能如何优化"><a class="markdownIt-Anchor" href="#springboot性能如何优化"></a> SpringBoot性能如何优化</h3>
<ul>
<li>如果项目比较大，类比较多，不使用@SpringBootApplication，采用@Compoment指定扫包范围</li>
<li>在项目启动时设置JVM初始内存和最大内存相同</li>
<li>将springboot内置服务器由tomcat设置为undertow</li>
</ul>
<h3 id="如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"><a class="markdownIt-Anchor" href="#如何重新加载-spring-boot-上的更改而无需重新启动服务器spring-boot项目如何热部署"></a> 如何重新加载 Spring Boot 上的更改，而无需重新启动服务器？Spring Boot项目如何热部署？</h3>
<ul>
<li>这可以使用 DEV 工具来实现。通过这种依赖关系，您可以节省任何更改，嵌入式tomcat 将重新启动。Spring Boot 有一个开发工具（<mark><strong>DevTools</strong></mark>）模块，它有助于提高开发人员的生产力。Java 开发人员面临的一个主要挑战是将文件更改自动部署到服务器并自动重启服务器。开发人员可以重新加载 Spring Boot 上的更改，而无需重新启动服务器。这将消除每次手动部署更改的需要。Spring Boot 在发布它的第一个版本时没有这个功能。这是开发人员最需要的功能。DevTools 模块完全满足开发人员的需求。该模块将在生产环境中被禁用。它还提供 H2 数据库控制台以更好地测试应用程序。</li>
</ul>
<figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="spring-boot微服务中如何实现-session-共享"><a class="markdownIt-Anchor" href="#spring-boot微服务中如何实现-session-共享"></a> Spring Boot微服务中如何实现 session 共享 ?</h3>
<ul>
<li>在微服务中，一个完整的项目被拆分成多个不相同的独立的服务，各个服务独立部署在不同的服务器上，各自的 session 被从物理空间上隔离开了，但是经常，我们需要在不同微服务之间共享 session ，<mark>常见的方案就是 Spring Session + Redis 来实现 session 共享。将所有微服务的 session 统一保存在 Redis 上，当各个微服务对 session 有相关的读写操作时，都去操作 Redis 上的 session </mark>。这样就实现了 session 共享，Spring Session 基于 Spring 中的代理过滤器实现，使得 session 的同步操作对开发人员而言是透明的，非常简便。</li>
</ul>
<h3 id="您使用了哪些-starter-maven-依赖项"><a class="markdownIt-Anchor" href="#您使用了哪些-starter-maven-依赖项"></a> 您使用了哪些 starter maven 依赖项？</h3>
<ul>
<li>使用了下面的一些依赖项
<ul>
<li>spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持</li>
<li>spring-boot-starter-data-jpa 数据库支持</li>
<li>spring-boot-starter-data-redis redis数据库支持</li>
<li>spring-boot-starter-data-solr solr支持</li>
<li>mybatis-spring-boot-starter 第三方的mybatis集成starter</li>
<li>自定义的starter(如果自己开发过就可以说出来)</li>
</ul>
</li>
</ul>
<h3 id="spring-boot-中如何实现定时任务"><a class="markdownIt-Anchor" href="#spring-boot-中如何实现定时任务"></a> Spring Boot 中如何实现定时任务 ?</h3>
<ul>
<li>在 Spring Boot 中使用定时任务主要有两种不同的方式，一个就是使用 Spring 中的 <mark>@Scheduled 注解</mark>，另一个则是使用第三方框架 <mark>Quartz</mark>。</li>
<li>使用 Spring 中的 @Scheduled 的方式主要通过 @Scheduled 注解来实现。</li>
</ul>
<h3 id="spring-boot-starter-parent-有什么用"><a class="markdownIt-Anchor" href="#spring-boot-starter-parent-有什么用"></a> spring-boot-starter-parent 有什么用 ?</h3>
<ul>
<li>
<p>我们都知道，新创建一个 Spring Boot 项目，默认都是有 parent 的，这个 parent 就是 spring-boot-starter-parent ，spring-boot-starter-parent 主要有如下作用：</p>
<ol>
<li>
<p>定义了 Java 编译版本为 1.8 。</p>
</li>
<li>
<p>使用 UTF-8 格式编码。</p>
</li>
<li>
<p>继承自 spring-boot-dependencies，这个里边定义了依赖的版本，也正是因为继承了这个依赖，所以我们在写依赖时才不需要写版本号。看源码发现：</p>
<p><img src="../../images/image-20230303224702882.png" alt="image-20230303224702882"></p>
</li>
<li>
<p>执行打包操作的配置。</p>
</li>
<li>
<p>自动化的资源过滤。</p>
</li>
<li>
<p>自动化的插件配置。</p>
</li>
<li>
<p>针对 application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件，例如 application-dev.properties 和 application-dev.yml。</p>
</li>
</ol>
</li>
<li>
<p>总结就是打包用的</p>
</li>
</ul>
<h3 id="springboot如何实现打包"><a class="markdownIt-Anchor" href="#springboot如何实现打包"></a> SpringBoot如何实现打包</h3>
<ul>
<li>进入项目目录在控制台输入mvn clean package，clean是清空已存在的项目包，package进行打包</li>
<li>或者点击右边选项栏中的Maven，先点击clean在点击package</li>
</ul>
<h3 id="spring-boot-打成的-jar-和普通的-jar-有什么区别"><a class="markdownIt-Anchor" href="#spring-boot-打成的-jar-和普通的-jar-有什么区别"></a> Spring Boot 打成的 jar 和普通的 jar 有什么区别 ?</h3>
<ul>
<li>Spring Boot 项目最终打包成的 jar 是可执行 jar ，这种 jar 可以直接通过 <code>java -jar xxx.jar</code> 命令来运行，这种 jar 不可以作为普通的 jar 被其他项目依赖，即使依赖了也无法使用其中的类。</li>
<li>Spring Boot 的 jar 无法被其他项目依赖，主要还是他和普通 jar 的结构不同。普通的 jar 包，解压后直接就是包名，包里就是我们的代码，而 Spring Boot 打包成的可执行 jar 解压后，在 <code>\BOOT-INF\classes</code> 目录下才是我们的代码，因此无法被直接引用。如果非要引用，可以在 pom.xml 文件中增加配置，将 Spring Boot 项目打包成两个 jar ，一个可执行，一个可引用。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/03/03/interview/Spring%20Boot%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clihlibpi003hu4v692deadm8" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-SpringCloud微服务/Sentinel/Sentinel-限流规则(流控模式：直接、关联、链路)" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/" class="article-date">
  <time class="post-time" datetime="2023-02-26T04:28:58.799Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">26</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/">Sentinel-限流规则(流控模式：直接、关联、链路)</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a>,<a class="article-category-link" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/">Sentinel</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>​	<strong>QPS</strong> <code>Queries Per Second</code> 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/061b8c23ef694d6e9d18abe3647c9dbe.png" alt="img"></p>
<h1 id="一-流控模式-直接"><a class="markdownIt-Anchor" href="#一-流控模式-直接"></a> 一、流控模式-直接</h1>
<p>添加规则：</p>
<p><img src="https://img-blog.csdnimg.cn/6d5781b7da1345f59e3321b3c8806571.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/8df1b81beca34a90a71af4aa2f1b8026.png" alt="img"></p>
<p>测试例子分析：</p>
<p><img src="https://img-blog.csdnimg.cn/39b96b130c9046078bc6d632580aff3e.png" alt="img"></p>
<p>启动测试</p>
<p><img src="https://img-blog.csdnimg.cn/5ec171ee24494c7488e3b09e3d7d8b47.png" alt="img"></p>
<p>点击 <strong>察看结果树</strong></p>
<p><img src="https://img-blog.csdnimg.cn/cc093a02f2be44fd938dfcc603a06ca3.png" alt="img"></p>
<p>上面测试例子，到Sentinel控制台的实时监控可以看到<img src="https://img-blog.csdnimg.cn/3dd6594966864a3a8f8d230c66387980.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/57592224a235458b826fc55819f5ea3d.png" alt="img"></p>
<h1 id="二-流控模式-关联"><a class="markdownIt-Anchor" href="#二-流控模式-关联"></a> 二、流控模式-关联</h1>
<p>•<strong>关联模式</strong>：统计与当前资源相关的另一个资源，触发阈值时，对当前资源限流</p>
<p>•<strong>使用场景</strong>：比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是有限支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流。</p>
<p><img src="https://img-blog.csdnimg.cn/b8cf0fa094f0443db55cd6567f70b192.png" alt="img"></p>
<p>当**/write<strong>资源访问量触发阈值时，就会对</strong>/read**资源限流，避免影响/write资源。</p>
<h2 id="案例"><a class="markdownIt-Anchor" href="#案例"></a> 案例：</h2>
<p>​    需求：</p>
<p>​     •在OrderController新建两个端点：/order/query和/order/update，无需实现业务</p>
<p>​     •配置流控规则，当/order/update资源被访问的QPS超过5时，对/order/query请求限流</p>
<h2 id="1-编写测试controller方法"><a class="markdownIt-Anchor" href="#1-编写测试controller方法"></a> 1. 编写测试controller方法:</h2>
<p><img src="https://img-blog.csdnimg.cn/dfda223212c6437a96852a8aa4d744e0.png" alt="img"></p>
<h2 id="2-添加规则想给谁限流就给谁添加规则"><a class="markdownIt-Anchor" href="#2-添加规则想给谁限流就给谁添加规则"></a> 2. 添加规则（想给谁限流，就给谁添加规则）</h2>
<h2 id="img"><a class="markdownIt-Anchor" href="#img"></a> <img src="https://img-blog.csdnimg.cn/9fc5937b14504fce8dde85b0c1a5cfb6.png" alt="img"></h2>
<h2 id="img-2"><a class="markdownIt-Anchor" href="#img-2"></a> <img src="https://img-blog.csdnimg.cn/d93155d750694872a0818677f4cb81a8.png" alt="img"></h2>
<h2 id="img-3"><a class="markdownIt-Anchor" href="#img-3"></a> <img src="https://img-blog.csdnimg.cn/ddfa4ee5ed00436c9c0f3e147d8c7b6d.png" alt="img"></h2>
<h2 id="3-借助jmeter进行测试"><a class="markdownIt-Anchor" href="#3-借助jmeter进行测试"></a> 3. 借助JMeter进行测试：</h2>
<p><img src="https://img-blog.csdnimg.cn/5ff99d435d124355914f816b525b9a7a.png" alt="img"></p>
<h2 id="img-4-去网页访问验证img"><a class="markdownIt-Anchor" href="#img-4-去网页访问验证img"></a> <img src="https://img-blog.csdnimg.cn/38c110824b1f478883e86b43a4df0017.png" alt="img"> 4. 去网页访问验证:<img src="https://img-blog.csdnimg.cn/6d7e4884e3314d76a707bf0e0e6548d0.png" alt="img"></h2>
<p>query被限流 <img src="https://img-blog.csdnimg.cn/21342817472a4d2587669ada29df161c.png" alt="img"></p>
<h2 id="5-总结-满足下面条件可以使用关联模式"><a class="markdownIt-Anchor" href="#5-总结-满足下面条件可以使用关联模式"></a> 5. 总结： 满足下面条件可以使用关联模式</h2>
<ol>
<li>
<p>两个有<mark>竞争关系</mark>的资源</p>
</li>
<li>
<p>一个优先级较高，一个优先级较低（优先级高的触发阈值时（本案例的order），对优先级低的限流（本案例的query））</p>
</li>
</ol>
<h1 id="三-流控模式-链路"><a class="markdownIt-Anchor" href="#三-流控模式-链路"></a> 三、流控模式-链路</h1>
<p><img src="https://img-blog.csdnimg.cn/56e2dc9f451441a2bbb8483750137bf4.png" alt="img"></p>
<h2 id="案例-2"><a class="markdownIt-Anchor" href="#案例-2"></a> 案例：</h2>
<p><img src="https://img-blog.csdnimg.cn/00c8c659e1c44e098c46b7ce5fd7b219.png" alt="img"></p>
<h2 id="1-编写测试代码"><a class="markdownIt-Anchor" href="#1-编写测试代码"></a> 1. 编写测试代码：</h2>
<p><img src="https://img-blog.csdnimg.cn/540402db64874fab953436a286717e02.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/32565b6a61534e3d87a9de1d1d9b7446.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/b0c343dd8ae54320bed317a725bda5d6.png" alt="img"></p>
<h2 id="2-注意"><a class="markdownIt-Anchor" href="#2-注意"></a> <strong>2. 注意：</strong></h2>
<p>Sentinel默认只标记Controller中的方法为资源，如果要标记其它方法，需要利用<mark><strong>@SentinelResource</strong>注解</mark></p>
<p>去配置文件里配置，<mark>关闭contextM</mark>，就可以让controller里的方法单独成为一个链路；不关闭context的话，controller里的方法都会默认进去sentinel默认的根链路里，这样就只有一条链路，无法流控链路模式</p>
<p><img src="https://img-blog.csdnimg.cn/dba8e68e6bc049b18fceab90848e5a24.png" alt="img"></p>
<h2 id="3-启动之后并到网页里分别访问了orderquery和ordersave接口后"><a class="markdownIt-Anchor" href="#3-启动之后并到网页里分别访问了orderquery和ordersave接口后"></a> 3. 启动之后，并到网页里分别访问了/order/query和/order/save接口后</h2>
<p><img src="https://img-blog.csdnimg.cn/bb6e754ffb7e4e4f8b715fe3910cbecd.png" alt="img"></p>
<h2 id="4-添加规则对query做限制save没有做限制"><a class="markdownIt-Anchor" href="#4-添加规则对query做限制save没有做限制"></a> 4. 添加规则：(对query做限制，save没有做限制)</h2>
<p><img src="https://img-blog.csdnimg.cn/cc38bc601afc440f9405972e04257f5b.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/feb37cb8556e49c4a151ff9c8397497f.png" alt="img"></p>
<h2 id="5-借助jmeter来测试"><a class="markdownIt-Anchor" href="#5-借助jmeter来测试"></a> 5. 借助JMeter来测试：</h2>
<p><img src="https://img-blog.csdnimg.cn/ed662f7afdb54e60a0455ce48d55c18e.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/7f1e916b436d43379585d1e9a52828a4.png" alt="img"></p>
<p>启动测试 <img src="https://img-blog.csdnimg.cn/4917bbf6a6b34670aed4ad9d3c751b02.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/45dd3918b3124af6983bfb648adfbb3a.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/df349c02421040b9bc8e00a398be0c9d.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/26/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1/Sentinel/Sentinel-%E9%99%90%E6%B5%81%E8%A7%84%E5%88%99(%E6%B5%81%E6%8E%A7%E6%A8%A1%E5%BC%8F%EF%BC%9A%E7%9B%B4%E6%8E%A5%E3%80%81%E5%85%B3%E8%81%94%E3%80%81%E9%93%BE%E8%B7%AF)/" data-id="clihlibsy009cu4v68r3m11yz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sentinel/" rel="tag">Sentinel</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" rel="tag">微服务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/应用层常见协议总结（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-20T05:55:49.239Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">应用层常见协议总结（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="http超文本传输协议"><a class="markdownIt-Anchor" href="#http超文本传输协议"></a> HTTP:超文本传输协议</h2>
<p><strong>超文本传输协议（HTTP，HyperText Transfer Protocol)</strong> 主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的，整个过程如下图所示。</p>
<p><img src="../../../images/image-20230220135638150.png" alt="image-20230220135638150"></p>
<p>HTTP 协是基于 TCP协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#smtp-%E7%AE%80%E5%8D%95%E9%82%AE%E4%BB%B6%E4%BC%A0%E8%BE%93-%E5%8F%91%E9%80%81-%E5%8D%8F%E8%AE%AE">#</a> SMTP:简单邮件<font color="red">传输(发送)</font>协议</h2>
<p><strong>简单邮件传输(发送)协议（SMTP，Simple Mail Transfer Protocol）</strong> 基于 TCP 协议，用来发送电子邮件。</p>
<p><img src="../../../images/image-20230220135632455.png" alt="image-20230220135632455"></p>
<p>注意⚠️：<strong>接受邮件的协议不是 SMTP 而是 POP3 协议。</strong></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给163邮箱服务器（邮局）。</li>
<li>163邮箱服务器发现我发送的邮箱是qq邮箱，然后它使用 SMTP协议将我的邮件转发到 qq邮箱服务器。</li>
<li>qq邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://verify-email.org/">https://verify-email.org/</a></li>
<li><a target="_blank" rel="noopener" href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li>
<li><a target="_blank" rel="noopener" href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li>
</ol>
<h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#pop3-imap-%E9%82%AE%E4%BB%B6%E6%8E%A5%E6%94%B6%E7%9A%84%E5%8D%8F%E8%AE%AE">#</a> POP3/IMAP:邮件<font color="red">接收</font>的协议</h2>
<p>这两个协议没必要多做阐述，只需要了解 <strong>POP3 和 IMAP 两者都是负责邮件接收的协议</strong>即可。另外，需要注意不要将这两者和 SMTP 协议搞混淆了。<strong>SMTP 协议只负责邮件的发送，真正负责接收的协议是POP3/IMAP。</strong></p>
<p>IMAP 协议相比于POP3更新一点，为用户提供的可选功能也更多一点,几乎所有现代电子邮件客户端和服务器都支持IMAP。大部分网络邮件服务提供商都支持POP3和IMAP。</p>
<h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#ftp-%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> FTP:文件传输协议</h2>
<p><strong>FTP 协议</strong> 主要提供文件传输服务，基于 TCP 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img src="../../../images/image-20230220135623263.png" alt="image-20230220135623263"></p>
<h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#telnet-%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86%E5%8D%8F%E8%AE%AE">#</a> Telnet:远程登陆协议</h2>
<p><strong>Telnet 协议</strong> 通过一个终端登陆到其他服务器，建立在可靠的传输协议 TCP 之上。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用Telnet并被一种称为SSH的非常安全的协议所取代的主要原因。</p>
<h2 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#ssh-%E5%AE%89%E5%85%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">#</a> SSH:安全的网络传输协议</h2>
<p><strong>SSH（ Secure Shell）</strong> 是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</p>
<p><strong>Telnet 和 SSH 之间的主要区别在于 SSH 协议会对传输的数据进行加密保证数据安全性。</strong></p>
<p><img src="../../../images/image-20230220135616527.png" alt="image-20230220135616527"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%BA%94%E7%94%A8%E5%B1%82%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="clihlibur00ceu4v6808h9umj" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/3/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>76</strong><br>分类</div></a>
      <a href="/tags"><div><strong>57</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>