<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/3/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>76</strong><br>分类</div></a>
      <a href="/tags"><div><strong>57</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-interview/计算机网络面试题/TCP 传输可靠性保障（传输层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-20T05:53:11.455Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">20</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 传输可靠性保障（传输层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="tcp-如何保证传输的可靠性"><a class="markdownIt-Anchor" href="#tcp-如何保证传输的可靠性"></a> TCP 如何保证传输的可靠性？</h2>
<ol>
<li><strong>基于数据块传输</strong> ：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失open in new window</a>并进行重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的**滑动窗口协议（**TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">#</a> TCP 如何实现流量控制？</h2>
<p><strong>TCP 利用<font color="red">滑动窗口</font>实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<h3 id="为什么需要流量控制"><a class="markdownIt-Anchor" href="#为什么需要流量控制"></a> <strong>为什么需要流量控制?</strong></h3>
<p>这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<p>这里需要注意的是（常见误区）：</p>
<ul>
<li>发送端不等同于客户端</li>
<li>接收端不等同于服务端</li>
</ul>
<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是接收端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>
<h3 id="tcp-发送窗口可以划分成四个部分"><a class="markdownIt-Anchor" href="#tcp-发送窗口可以划分成四个部分"></a> <strong>TCP 发送窗口可以划分成四个部分</strong> ：</h3>
<ol>
<li>已经发送并且确认的TCP段（<strong>已经发送并确认</strong>）；</li>
<li>已经发送但是没有确认的TCP段（<strong>已经发送未确认</strong>）；</li>
<li>未发送但是接收方准备接收的TCP段（<strong>可以发送</strong>）；</li>
<li>未发送并且接收方也并未准备接受的TCP段（<strong>不可发送</strong>）。</li>
</ol>
<h3 id="tcpfont-colorred发送font窗口结构图示"><a class="markdownIt-Anchor" href="#tcpfont-colorred发送font窗口结构图示"></a> <strong>TCP<font color="red">发送</font>窗口结构图示</strong> ：</h3>
<p><img src="../../../images/image-20230220135411913.png" alt="image-20230220135411913"></p>
<ul>
<li><strong>SND.WND</strong> ：发送窗口。</li>
<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>
<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>
</ul>
<p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>
<h3 id="tcp-font-colorred接收font窗口可以划分成三个部分"><a class="markdownIt-Anchor" href="#tcp-font-colorred接收font窗口可以划分成三个部分"></a> <strong>TCP <font color="red">接收</font>窗口可以划分成三个部分</strong> ：</h3>
<ol>
<li>已经接收并且已经确认的 TCP 段（<strong>已经接收并确认</strong>）；</li>
<li>等待接收且允许发送方发送 TCP 段（<strong>可以接收未确认</strong>）；</li>
<li>不可接收且不允许发送方发送TCP段（<strong>不可接收</strong>）。</li>
</ol>
<h3 id="tcp-接收窗口结构图示"><a class="markdownIt-Anchor" href="#tcp-接收窗口结构图示"></a> <strong>TCP 接收窗口结构图示</strong> ：</h3>
<p><img src="../../../images/image-20230220135419120.png" alt="image-20230220135419120"></p>
<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>
<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>
<h2 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#tcp-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">#</a> TCP 的拥塞控制是怎么实现的？</h2>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><img src="../../../images/image-20230220135425341.png" alt="image-20230220135425341"></p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是<strong>由小到大逐渐增大拥塞窗口数值</strong>。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h2 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#arq-%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3%E5%90%97">#</a> ARQ 协议了解吗?（Automatic Repeat-reQuest）</h2>
<p><font color="red"><strong>自动重传请求</strong></font>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的<strong>错误纠正协</strong>议之一。<strong>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输</strong>。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括<strong>停止等待 ARQ 协议</strong>和<strong>连续 ARQ 协议</strong>。</p>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85-arq-%E5%8D%8F%E8%AE%AE">#</a> 停止等待 ARQ 协议</h3>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h4 id="1-无差错情况"><a class="markdownIt-Anchor" href="#1-无差错情况"></a> <strong>1) 无差错情况:</strong></h4>
<p>发送方发送分组, 接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<h4 id="2-出现差错情况超时重传"><a class="markdownIt-Anchor" href="#2-出现差错情况超时重传"></a> <strong>2) 出现差错情况（超时重传）:</strong></h4>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<h4 id="3-确认丢失和确认迟到"><a class="markdownIt-Anchor" href="#3-确认丢失和确认迟到"></a> <strong>3) 确认丢失和确认迟到</strong></h4>
<ul>
<li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E8%BF%9E%E7%BB%AD-arq-%E5%8D%8F%E8%AE%AE">#</a> 连续 ARQ 协议</h3>
<p>连续 ARQ 协议可<strong>提高信道利用率</strong>。发送方维持一个<strong>发送窗口</strong>，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对<mark>按序到达</mark>的<mark>最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</mark></p>
<h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> <strong>优点：</strong></h4>
<p>信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<h4 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> <strong>缺点：</strong></h4>
<p>不能向发送方反映出接收方已经正确收到的所有分组的信息。 <font color="blue">比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认</font>。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/20/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E9%9A%9C%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" data-id="clihlibup00c9u4v69sfn6bfz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/OSI 和 TCPIP 网络分层模型详解（基础）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:06:44.282Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/">OSI 和 TCP/IP 网络分层模型详解（基础）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>OSI模型</strong>: 即<strong>开放式通信系统互联参考模型</strong>（<strong>Open System Interconnection Reference Model</strong>），是国际标准化组织（ISO）提出的一个试图使各种计算机在世界范围内互连为网络的标准框架，简称OSI。</p>
<h2 id="osi-七层模型"><a class="markdownIt-Anchor" href="#osi-七层模型"></a> OSI 七层模型</h2>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="../../../images/image-20230220134708482.png" alt="image-20230220134708482"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。下面这个图片是我在国外的一个网站上看到的，非常赞！</p>
<p><img src="../../../images/image-20230220134715273.png" alt="image-20230220134715273"></p>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>
<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>
<p><img src="../../../images/image-20230220134722147.png" alt="image-20230220134722147"></p>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#tcp-ip-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B">#</a> TCP/IP 四层模型</h2>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img src="../../../images/image-20230220134732543.png" alt="image-20230220134732543"></p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#%E5%BA%94%E7%94%A8%E5%B1%82-application-layer">#</a> 应用层（Application layer）</h3>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img src="../../../images/image-20230220134737489.png" alt="image-20230220134737489"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><img src="../../../images/image-20230220134743725.png" alt="image-20230220134743725"></p>
<p>应用层常见协议总结，请看这篇文章：<a href="">应用层常见协议总结（应用层）</a>。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#%E4%BC%A0%E8%BE%93%E5%B1%82-transport-layer">#</a> 传输层（Transport layer）</h3>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>运输层主要使用以下两种协议：</strong></p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）–提供 <strong>面向连接</strong> 的，<strong>可靠的</strong> 数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供 <strong>无连接</strong> 的，尽最大努力的数据传输服务（不保证数据传输的可靠性）。</li>
</ol>
<p><img src="../../../images/image-20230220134748906.png" alt="image-20230220134748906"></p>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%B1%82-network-layer">#</a> 网络层（Network layer）</h3>
<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️注意 ：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Prococol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<p><img src="../../../images/image-20230220134754055.png" alt="image-20230220134754055"></p>
<p><strong>网络层常见协议</strong> ：</p>
<ul>
<li><strong>IP:网际协议</strong> ：网际协议 IP 是TCP/IP协议中最重要的协议之一，也是网络层最重要的协议之一，IP协议的作用包括寻址规约、定义数据包的格式等等，是网络层信息传输的主力协议。目前IP协议主要分为两种，一种是过去的IPv4，另一种是较新的IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</li>
<li><strong>ARP 协议</strong> ：ARP协议，全称地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个IP数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但IP地址属于逻辑地址，而MAC地址才是物理地址，ARP协议解决了IP地址转MAC地址的一些问题。</li>
<li><strong>NAT:网络地址转换协议</strong> ：NAT协议（Network Address Translation）的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个LAN下的IP地址，但在该LAN以外，在广域网（WAN）中，需要一个统一的IP地址来标识该LAN在整个Internet上的位置。</li>
<li>…</li>
</ul>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82-network-interface-layer">#</a> 网络接口层（Network interface layer）</h3>
<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<p><img src="../../../images/image-20230220134759211.png" alt="image-20230220134759211"></p>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h3>
<p>简单总结一下每一层包含的协议和核心技术:</p>
<p><img src="../../../images/image-20230220134804106.png" alt="image-20230220134804106"></p>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP 协议（超文本传输协议，网页浏览常用的协议）</li>
<li>DHCP 协议（动态主机配置）</li>
<li>DNS 系统原理（域名系统）</li>
<li>FTP 协议（文件传输协议）</li>
<li>Telnet协议（远程登陆协议）</li>
<li>电子邮件协议等（SMTP、POP3、IMAP）</li>
<li>…</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议
<ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议
<ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP 协议（TCP/IP 协议的基础，分为 IPv4 和 IPv6）</li>
<li>ARP 协议（地址解析协议，用于解析 IP 地址和 MAC 地址之间的映射）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT 协议（网络地址转换协议）</li>
<li>RIP 协议、OSPF 协议、BGP 协议（路由选择协议）</li>
<li>…</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA/CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
<li>…</li>
</ul>
<h2 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E7%9A%84%E5%8E%9F%E5%9B%A0">#</a> 网络分层的原因</h2>
<p>在这篇文章的最后，我想聊聊：“为什么网络要分层？”。</p>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OSI%20%E5%92%8C%20TCPIP%20%E7%BD%91%E7%BB%9C%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%9F%BA%E7%A1%80%EF%BC%89/" data-id="clihlibuk00byu4v685zzfuh6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/HTTP vs HTTPS（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:05:17.336Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP vs HTTPS（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="http-协议"><a class="markdownIt-Anchor" href="#http-协议"></a> HTTP 协议</h2>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTP 协议介绍</h3>
<p>HTTP 协议，全称<strong>超文本传输协议</strong>（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B">#</a> HTTP 协议通信过程</h3>
<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 80 端口等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#http-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTP 协议优点</h3>
<p>扩展性强、速度快、跨平台支持性好。</p>
<h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#https-%E5%8D%8F%E8%AE%AE">#</a> HTTPS 协议</h2>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#https-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D">#</a> HTTPS 协议介绍</h3>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#https-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9">#</a> HTTPS 协议优点</h3>
<p>保密性好、信任度高。</p>
<h2 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#https-%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94ssl-tls%E5%8D%8F%E8%AE%AE">#</a> HTTPS 的核心—SSL/TLS协议</h2>
<p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>
<h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#ssl-%E5%92%8C-tls-%E7%9A%84%E5%8C%BA%E5%88%AB">#</a> SSL 和 TLS 的区别？</h3>
<p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p>
<h3 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#ssl-tls-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> SSL/TLS 的工作原理</h3>
<h4 id="-10"><a class="markdownIt-Anchor" href="#-10"></a> <a href="#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 非对称加密</h4>
<p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<p><img src="../../../images/image-20230220134425749.png" alt="image-20230220134425749"></p>
<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<p><img src="../../../images/image-20230220134444105.png" alt="image-20230220134444105"></p>
<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>
<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<h4 id="-11"><a class="markdownIt-Anchor" href="#-11"></a> <a href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">#</a> 对称加密</h4>
<p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<p><img src="../../../images/image-20230220134457419.png" alt="image-20230220134457419"></p>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h4 id="-12"><a class="markdownIt-Anchor" href="#-12"></a> <a href="#%E5%85%AC%E9%92%A5%E4%BC%A0%E8%BE%93%E7%9A%84%E4%BF%A1%E8%B5%96%E6%80%A7">#</a> 公钥传输的信赖性</h4>
<p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<p><img src="../../../images/image-20230220134509815.png" alt="image-20230220134509815"></p>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<h4 id="-13"><a class="markdownIt-Anchor" href="#-13"></a> <a href="#%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">#</a> 数字签名</h4>
<p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<p><img src="../../../images/image-20230220134547914.png" alt="image-20230220134547914"></p>
<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<p><img src="../../../images/image-20230220134604571.png" alt="image-20230220134604571"></p>
<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV18N411X7ty/">数字签名及数字证书原理open in new window</a>这个视频，这是我看过最清晰的讲解。</p>
<p><img src="https://guide-blog-images.oss-cn-shenzhen.aliyuncs.com/github/javaguide/image-20220321121814946.png" alt="img"></p>
<h2 id="-14"><a class="markdownIt-Anchor" href="#-14"></a> <a href="#%E6%80%BB%E7%BB%93">#</a> 总结</h2>
<ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%20vs%20HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="clihlibui00buu4v6h4698ct2" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/HTTP常见状态码总结（应用层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:03:30.381Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/">HTTP 常见状态码总结（应用层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="../../../images/image-20230220134615645.png" alt="image-20230220134615645"></p>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#_1xx-informational-%E4%BF%A1%E6%81%AF%E6%80%A7%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 1xx Informational（信息性状态码）</h3>
<p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#_2xx-success-%E6%88%90%E5%8A%9F%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 2xx Success（成功状态码）</h3>
<ul>
<li><strong>200 OK</strong> ：请求被成功处理。比如我们发送一个查询用户数据的HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>
<li><strong>201 Created</strong> ：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>
<li><strong>202 Accepted</strong> ：服务端已经接收到了请求，但是还未处理。</li>
<li><strong>204 No Content</strong> ： 服务端已经成功处理了请求，但是没有返回任何内容。</li>
</ul>
<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2616#section-10.2.5">HTTP RFC 2616对204状态码的描述open in new window</a>如下：</p>
<blockquote>
<p>The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant.</p>
<p>If the client is a user agent, it SHOULD NOT change its document view from that which caused the request to be sent. This response is primarily intended to allow input for actions to take place without causing a change to the user agent’s active document view, although any new or updated metainformation SHOULD be applied to the document currently in the user agent’s active view.</p>
<p>The 204 response MUST NOT include a message-body, and thus is always terminated by the first empty line after the header fields.</p>
</blockquote>
<p>简单来说，204状态码描述的是我们向服务端发送 HTTP 请求之后，只关注处理结果是否成功的场景。也就是说我们需要的就是一个结果：true/false。</p>
<p>举个例子：你要追一个女孩子，你问女孩子：“我能追你吗？”，女孩子回答：“好！”。我们把这个女孩子当做是服务端就很好理解 204 状态码了。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#_3xx-redirection-%E9%87%8D%E5%AE%9A%E5%90%91%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 3xx Redirection（重定向状态码）</h3>
<ul>
<li><strong>301 Moved Permanently</strong> ： 资源被永久重定向了。比如你的网站的网址更换了。</li>
<li><strong>302 Found</strong> ：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>
</ul>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#_4xx-client-error-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 4xx Client Error（客户端错误状态码）</h3>
<ul>
<li><strong>400 Bad Request</strong> ： 发送的HTTP请求存在问题。比如请求参数不合法、请求方法错误。</li>
<li><strong>401 Unauthorized</strong> ： 未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong> ：直接拒绝HTTP请求，不处理。一般用来针对非法请求。</li>
<li><strong>404 Not Found</strong> ： 你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>
<li><strong>409 Conflict</strong> ： 表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#_5xx-server-error-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81%E7%A0%81">#</a> 5xx Server Error（服务端错误状态码）</h3>
<ul>
<li><strong>500 Internal Server Error</strong> ： 服务端出问题了（通常是服务端出Bug了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>
<li><strong>502 Bad Gateway</strong> ：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E7%BB%93%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89/" data-id="clihlibum00c2u4v62i37g91g" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/TCP 三次握手和四次挥手（传输层）" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" class="article-date">
  <time class="post-time" datetime="2023-02-19T09:01:27.122Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/">TCP 三次握手和四次挥手（传输层）</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>(了解一下 半关闭状态)</p>
<p><strong>SYN</strong>：同步序列编号（<strong>Synchronize Sequence Numbers</strong>）。是TCP/IP建立连接时使用的<strong>握手信号</strong>。</p>
<p><strong>ACK</strong> : (<strong>Acknowledge character</strong>）即是确认字符，在数据通信中，接收站发给发送站的一种传输类<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6/6913704?fromModule=lemma_inlink">控制字符</a>。表示发来的数据已确认接收无误。</p>
<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 建立连接-TCP 三次握手</h2>
<p><img src="../../../images/image-20230220134640946.png" alt="image-20230220134640946"></p>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可 ：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li>
</ul>
<p><strong>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</strong></p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B">#</a> 为什么要三次握手?</h3>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是<mark>双方确认自己与对方的发送与接收是正常的</mark>。</p>
<ol>
<li><strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p>更详细的解答可以看这个：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎open in new window</a> 。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#%E7%AC%AC2%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86ack-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9Esyn">#</a> 第2次握手传回了ACK，为什么还要传回SYN？</h3>
<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 <strong>SYN 则是为了建立并确认从服务端到客户端的通信</strong>。</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h2 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 断开连接-TCP 四次挥手</h2>
<p><img src="../../../images/image-20230220134646808.png" alt="image-20230220134646808"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可 ：</p>
<ol>
<li><strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li>
<li><strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li>
<li><strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 <strong>CLOSE</strong> 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h4 id="ps-tcp状态说明"><a class="markdownIt-Anchor" href="#ps-tcp状态说明"></a> <strong>ps: TCP状态说明</strong></h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CLOSED：表示初始状态。对服务端和C客户端双方都一样。</span><br><span class="line">LISTEN：表示监听状态。服务端调用了listen函数，可以开始accept连接了。</span><br><span class="line">SYN_SENT：表示客户端已经发送了SYN报文。当客户端调用connect函数发起连接时，首先发SYN给服务端，然后自己进入SYN_SENT状态，并等待服务端发送ACK+SYN。</span><br><span class="line">SYN_RCVD：表示服务端收到客户端发送SYN报文。服务端收到这个报文后，进入SYN_RCVD状态，然后发送ACK+SYN给客户端。</span><br><span class="line">ESTABLISHED：表示连接已经建立成功了。服务端发送完ACK+SYN后进入该状态，客户端收到ACK后也进入该状态。</span><br><span class="line">FIN_WAIT_1：表示主动关闭连接。无论哪方调用close函数发送FIN报文都会进入这个这个状态。</span><br><span class="line">FIN_WAIT_2：表示被动关闭方同意关闭连接。主动关闭连接方收到被动关闭方返回的ACK后，会进入该状态。</span><br><span class="line">TIME_WAIT：表示收到对方的FIN报文并发送了ACK报文，就等2MSL后即可回到CLOSED状态了。如果FIN_WAIT_1状态下，收到对方同时带FIN标志和ACK标志的报文时，可以直接进入TIME_WAIT状态，而无须经过FIN_WAIT_2状态。</span><br><span class="line">CLOSING：表示双方同时关闭连接。如果双方几乎同时调用close函数，那么会出现双方同时发送FIN报文的情况，此时就会出现CLOSING状态，表示双方都在关闭连接。</span><br><span class="line">CLOSE_WAIT：表示被动关闭方等待关闭。当收到对方调用close函数发送的FIN报文时，回应对方ACK报文，此时进入CLOSE_WAIT状态。</span><br><span class="line">LAST_ACK：表示被动关闭方发送FIN报文后，等待对方的ACK报文状态，当收到ACK后进入CLOSED状态。</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">特别提示的是：为什么TIME_WAIT状态还需要等待2MSL才能回到CLOSED状态？或者为什么TCP要引入TIME_WAIT状态？</span><br><span class="line">《TCP/IP详解》中如此解释：当TCP执行一个主动关闭，并发回最后一个ACK后，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL，这样可以让TCP再次发送最后的ACK以防止这个ACK丢失（另一端超时重发最后的FIN）。</span><br><span class="line">附注：MSL（Maximum Segment Lifetime）即最大生存时间，RFC 793中指出MSL为2分钟，但是实现中的常用值为30秒、1分钟或者2分钟。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么要四次挥手？</h3>
<p>TCP是全双工通信，可以双向传输数据。<mark>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入<strong>半关闭状态</strong>。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接</mark>。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong> ： A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong> ：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong> ：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong> ：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ack-%E5%92%8C-fin-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5-%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B">#</a> 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</h3>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h3 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7">#</a> 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</h3>
<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81">#</a> 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端没有因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89/" data-id="clihlibuo00c6u4v67bypfoqo" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/计算机网络面试题/计算机网络面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-02-19T08:59:06.959Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">计算机网络基础</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络基础"><a class="markdownIt-Anchor" href="#计算机网络基础"></a> 计算机网络基础</h2>
<h3 id="osi-和-tcpip-网络分层模型"><a class="markdownIt-Anchor" href="#osi-和-tcpip-网络分层模型"></a> OSI 和 TCP/IP 网络分层模型</h3>
<p><strong>相关面试题</strong> ：</p>
<ul>
<li>OSI 七层模型是什么？每一层的作用是什么？</li>
<li>TCP/IP 四层模型是什么？每一层的作用是什么？</li>
<li>为什么网络要分层？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="">OSI 和 TCP/IP 网络分层模型详解（基础）</a>。</p>
<h3 id="应用层有哪些常见的协议"><a class="markdownIt-Anchor" href="#应用层有哪些常见的协议"></a> 应用层有哪些常见的协议？</h3>
<p><a href="">应用层常见协议总结（应用层）</a></p>
<h2 id="tcp-与-udp"><a class="markdownIt-Anchor" href="#tcp-与-udp"></a> TCP 与 UDP</h2>
<p><strong>TCP</strong>: **传输控制协议（TCP，Transmission Control Protocol）**是一种面向连接的、可靠的、基于<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E6%B5%81/3196772?fromModule=lemma_inlink">字节流</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536?fromModule=lemma_inlink">传输层</a><a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/3351624?fromModule=lemma_inlink">通信协议</a>，由<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/IETF/2800318?fromModule=lemma_inlink">IETF</a>的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/RFC/2798645?fromModule=lemma_inlink">RFC</a> 定义。</p>
<p><strong>UDP</strong>: [Internet ](<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/Internet">https://baike.baidu.com/item/Internet</a> /272794?fromModule=lemma_inlink)协议集支持一个无连接的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/8048821?fromModule=lemma_inlink">传输协议</a>，该协议称为<strong>用户数据报协议（UDP，User Datagram Protocol）</strong>。UDP 为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/5985445?fromModule=lemma_inlink">应用程序</a>提供了一种<strong>无需建立连接</strong>就可以发送封装的 IP 数据包的方法。RFC 描述了 UDP。</p>
<h3 id="tcp-与-udp-的区别重要"><a class="markdownIt-Anchor" href="#tcp-与-udp-的区别重要"></a> TCP 与 UDP 的区别（重要）</h3>
<ol>
<li><strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong> ：这个和上面的“是否可靠传输”相对应。<strong>TCP 传输是有状态的</strong>，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态服务</strong>，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong> ：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
<li>…</li>
</ol>
<p>我把上面总结的内容通过表格形式展示出来了！</p>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h3 id="什么时候选择-tcp什么时候选-udp"><a class="markdownIt-Anchor" href="#什么时候选择-tcp什么时候选-udp"></a> 什么时候选择 TCP,什么时候选 UDP?</h3>
<ul>
<li><strong>UDP 一般用于<mark>即时通信</mark></strong>，比如： 语音、 视频 、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输<mark>准确性要求特别高</mark>的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h3 id="http-基于-tcp-还是-udp"><a class="markdownIt-Anchor" href="#http-基于-tcp-还是-udp"></a> HTTP 基于 TCP 还是 UDP？</h3>
<p><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</p>
<h3 id="使用-tcp-的协议有哪些使用-udp-的协议有哪些"><a class="markdownIt-Anchor" href="#使用-tcp-的协议有哪些使用-udp-的协议有哪些"></a> 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3>
<p><strong>运行于 TCP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>HTTP 协议</strong> ：超文本传输协议（HTTP，HyperText Transfer Protocol)主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong> ：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol），提供文件传输服务，<strong>基于 TCP</strong> 实现可靠的传输。使用 FTP 传输文件的好处是可以屏蔽操作系统和文件存储方式。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，<strong>基于 TCP 协议</strong>，用来发送电子邮件。注意 ⚠️：接受邮件的协议不是 SMTP 而是 POP3 协议。</li>
<li><strong>POP3/IMAP 协议</strong>： POP3 和 IMAP 两者都是负责邮件接收的协议。</li>
<li><strong>Telent 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。被一种称为 SSH 的非常安全的协议所取代。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>…</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong> ：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong> ： <strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，<a target="_blank" rel="noopener" href="http://www.baidu.com">www.baidu.com</a>) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
</ol>
<h3 id="tcp-三次握手和四次挥手非常重要"><a class="markdownIt-Anchor" href="#tcp-三次握手和四次挥手非常重要"></a> TCP 三次握手和四次挥手（非常重要）</h3>
<p><strong>相关面试题</strong> ：</p>
<ul>
<li>为什么要三次握手?</li>
<li>第 2 次握手传回了ACK，为什么还要传回SYN？</li>
<li>为什么要四次挥手？</li>
<li>为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</li>
<li>如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</li>
<li>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</li>
</ul>
<p><strong>参考答案</strong> ：<a href="">TCP 三次握手和四次挥手（传输层）</a> 。</p>
<h3 id="tcp-如何保证传输的可靠性重要"><a class="markdownIt-Anchor" href="#tcp-如何保证传输的可靠性重要"></a> TCP 如何保证传输的可靠性？（重要）</h3>
<p><a href="">TCP 传输可靠性保障（传输层）</a></p>
<h2 id="http"><a class="markdownIt-Anchor" href="#http"></a> HTTP</h2>
<h3 id="从输入url-到页面展示到底发生了什么非常重要"><a class="markdownIt-Anchor" href="#从输入url-到页面展示到底发生了什么非常重要"></a> 从输入URL 到页面展示到底发生了什么？（非常重要）</h3>
<blockquote>
<p>类似的问题：打开一个网页，整个过程会使用哪些协议？</p>
</blockquote>
<p>图解（图片来源：《图解 HTTP》）：</p>
<p><img src="../../../images/image-20230220134232347.png" alt="image-20230220134232347"></p>
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这两篇文章：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000006879700">从输入URL到页面加载发生了什么？open in new window</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程open in new window</a></li>
</ul>
<h3 id="http-状态码有哪些"><a class="markdownIt-Anchor" href="#http-状态码有哪些"></a> HTTP 状态码有哪些？</h3>
<p>HTTP 状态码用于描述 HTTP 请求的结果，比如2xx 就代表请求被成功处理。</p>
<p><img src="../../../images/image-20230220134252269.png" alt="image-20230220134252269"></p>
<p>关于 HTTP 状态码更详细的总结，可以看我写的这篇文章：<a href="">HTTP 常见状态码总结（应用层）</a>。</p>
<h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#http-%E5%92%8C-https-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81">#</a> HTTP 和 HTTPS 有什么区别？（重要）</h3>
<ul>
<li><strong>端口号</strong> ：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong> ：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong> ： HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
<p>关于 HTTP 和 HTTPS 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP vs HTTPS（应用层）</a> 。</p>
<h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="#http-1-0-%E5%92%8C-http-1-1-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a> HTTP 1.0 和 HTTP 1.1 有什么区别？</h3>
<ul>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1中新加入了大量的状态码，光是错误响应状态码就新增了24种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host头处理</strong> : HTTP/1.1在请求头中加入了<code>Host</code>字段。</li>
</ul>
<p>关于 HTTP 1.0 和 HTTP 1.1 更详细的对比总结，可以看我写的这篇文章：<a href="">HTTP 1.0 vs HTTP 1.1（应用层）</a> 。</p>
<h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="#http-%E6%98%AF%E4%B8%8D%E4%BF%9D%E5%AD%98%E7%8A%B6%E6%80%81%E7%9A%84%E5%8D%8F%E8%AE%AE-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81">#</a> HTTP 是不保存状态的协议, 如何保存用户状态?</h3>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<p><img src="../../../images/image-20230220134259293.png" alt="image-20230220134259293"></p>
<h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="#uri-%E5%92%8C-url-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88">#</a> URI 和 URL 的区别是什么?</h3>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h2 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="#arp">#</a> ARP</h2>
<h3 id="-6"><a class="markdownIt-Anchor" href="#-6"></a> <a href="#%E4%BB%80%E4%B9%88%E6%98%AF-mac-%E5%9C%B0%E5%9D%80">#</a> 什么是 Mac 地址？</h3>
<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p><img src="/.com//../../../../../assets/2008410143049281.3c367990.png" alt="路由器的背面就会注明 MAC 位址"></p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>48</mn></msup></mrow><annotation encoding="application/x-tex">2^{48}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mtight">8</span></span></span></span></span></span></span></span></span></span></span></span>），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3 id="-7"><a class="markdownIt-Anchor" href="#-7"></a> <a href="#arp-%E5%8D%8F%E8%AE%AE%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%9C%B0%E4%BD%8D%E5%A6%82%E4%BD%95">#</a> ARP 协议解决了什么问题地位如何？</h3>
<p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<h3 id="-8"><a class="markdownIt-Anchor" href="#-8"></a> <a href="#arp-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">#</a> ARP 协议的工作原理？</h3>
<p><a href="">ARP 协议详解(网络层)</a></p>
<h2 id="-9"><a class="markdownIt-Anchor" href="#-9"></a> <a href="#%E5%A4%8D%E4%B9%A0%E5%BB%BA%E8%AE%AE">#</a> 复习建议</h2>
<p>非常推荐大家看一下 《图解 HTTP》 这本书，这本书页数不多，但是内容很是充实，不管是用来系统的掌握网络方面的一些知识还是说纯粹为了应付面试都有很大帮助。下面的一些文章只是参考。大二学习这门课程的时候，我们使用的教材是 《计算机网络第七版》（谢希仁编著），不推荐大家看这本教材，书非常厚而且知识偏理论，不确定大家能不能心平气和的读完。</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clihlibuw00cqu4v6fdr7gab6" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/牛客网java核心基础面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-02-19T08:22:52.808Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">19</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">牛客网java核心基础面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/">牛客网java核心基础面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="为什么java代码可以实现一次编写-到处运行"><a class="markdownIt-Anchor" href="#为什么java代码可以实现一次编写-到处运行"></a> 为什么Java代码可以实现一次编写、到处运行？</h2>
<p><img src="../../images/image-20230222165320333.png" alt="image-20230222165320333"></p>
<h2 id="遇到过异常吗如何处理"><a class="markdownIt-Anchor" href="#遇到过异常吗如何处理"></a> 遇到过异常吗，如何处理？</h2>
<p><strong>参考答案</strong></p>
<p>在Java中，可以按照如下三个步骤处理异常：</p>
<ol>
<li><strong>捕获异常</strong></li>
</ol>
<p>将业务代码包裹在try块内部，当业务代码中发生任何异常时，系统都会为此异常创建一个异常对象。创建异常对象之后，JVM会在try块之后寻找可以处理它的catch块，并将异常对象交给这个catch块处理。</p>
<ol start="2">
<li><strong>处理异常</strong></li>
</ol>
<p>在catch块中处理异常时，应该先记录日志，便于以后追溯这个异常。然后根据异常的类型、结合当前的业务情况，进行相应的处理。比如，给变量赋予一个默认值、直接返回空值、向外抛出一个新的业务异常交给调用者处理，等等。</p>
<ol start="3">
<li><strong>回收资源</strong></li>
</ol>
<p>如果业务代码打开了某个资源，比如<mark>数据库连接、网络连接、磁盘文件</mark>等，则需要在这段业务代码执行完毕后关闭这项资源。并且，无论是否发生异常，都要尝试关闭这项资源。将关闭资源的代码写在finally块内，可以满足这种需求，即无论是否发生异常，finally块内的代码总会被执行。</p>
<h2 id="说一说java的异常机制"><a class="markdownIt-Anchor" href="#说一说java的异常机制"></a> 说一说Java的异常机制？</h2>
<p><strong>参考答案</strong></p>
<p><strong>关于异常的处理：</strong></p>
<p>在Java中，处理异常的语句由try、catch、finally三部分组成。其中，<strong>try块用于包裹业务代码，catch块用于捕获并处理某个类型的异常，finally块则用于回收资源</strong>。当业务代码发生异常时，系统会创建一个异常对象，然后由JVM寻找可以处理这个异常的catch块，并将异常对象交给这个catch块处理。若业务代码打开了某项资源，则可以在finally块中关闭这项资源，因为无论是否发生异常，finally块一定会执行。</p>
<p><strong>关于抛出异常：</strong></p>
<p>当程序出现错误时，系统会自动抛出异常。除此以外，Java也允许程序主动抛出异常。当业务代码中，判断某项错误的条件成立时，可以使用throw关键字向外抛出异常。在这种情况下，如果当前方法不知道该如何处理这个异常，可以在方法签名上<strong>通过throws关键字声明抛出异常，则该异常将交给JVM处理</strong>。</p>
<p><strong>关于异常跟踪栈：</strong></p>
<p>程序运行时，经常会发生一系列方法调用，从而形成方法调用栈。异常机制会导致异常在这些方法之间传播，而异常传播的顺序与方法的调用相反。异常从发生异常的方法向外传播，首先传给该方法的调用者，再传给上层调用者，以此类推。最终会传到main方法，若依然没有得到处理，则JVM会终止程序，并打印异常跟踪栈的信息</p>
<h2 id="finally是无条件执行的吗"><a class="markdownIt-Anchor" href="#finally是无条件执行的吗"></a> finally是无条件执行的吗？</h2>
<p><strong>参考答案</strong></p>
<p>不管try块中的代码是否出现异常，也不管哪一个catch块被执行，甚至在try块或catch块中执行了return语句，finally块总会被执行。</p>
<p><strong>注意事项</strong></p>
<p>如果在try块或catch块中使用 System.exit(1); 来退出虚拟机，则finally块将失去执行的机会。但是我们在实际的开发中，重来都不会这样做，所以尽管存在这种导致finally块无法执行的可能，也只是一种可能而已。</p>
<h2 id="在finally中return会发生什么"><a class="markdownIt-Anchor" href="#在finally中return会发生什么"></a> 在finally中return会发生什么？</h2>
<p><strong>参考答案</strong></p>
<p>在通常情况下，不要在finally块中使用return、throw等导致方法终止的语句，一旦在finally块中使用了return、throw语句，将会导致try块、catch块中return、throw语句失效。</p>
<p><strong>详细解析</strong></p>
<p>当Java程序执行try块、catch块时遇到了return或throw语句，这两个语句都会导致该方法立即结束，但是系统执行这两个语句并不会结束该方法，而是去寻找该异常处理流程中是否包含finally块，如果没有finally块，程序立即执行return或throw语句，方法终止；如果有finally块，系统立即开始执行finally块。只有当finally块执行完成后，系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等导致方法终止的语句，finally块已经终止了方法，系统将不会跳回去执行try块、catch块里的任何代码。</p>
<h2 id="static和final有什么区别"><a class="markdownIt-Anchor" href="#static和final有什么区别"></a> static和final有什么区别？</h2>
<p><img src="../../images/image-20230219163021865.png" alt="image-20230219163021865"></p>
<p><img src="../../images/image-20230219163033920.png" alt="image-20230219163033920"></p>
<h2 id="说说你对泛型的理解"><a class="markdownIt-Anchor" href="#说说你对泛型的理解"></a> 说说你对泛型的理解</h2>
<p><img src="../../images/image-20230219162902190.png" alt="image-20230219162902190"></p>
<h2 id="list-super-t和list-extends-t有什么区别"><a class="markdownIt-Anchor" href="#list-super-t和list-extends-t有什么区别"></a> List&lt;? super T&gt;和List&lt;? extends T&gt;有什么区别？</h2>
<p><strong>参考答案</strong></p>
<ul>
<li>
<p>? 是类型通配符， List&lt;?&gt; 可以表示各种泛型List的父类，意思是元素类型未知的List；</p>
</li>
<li>
<p>List&lt;? super T&gt; 用于设定类型通配符的下限，此处 ? 代表一个未知的类型，但它必须是T的父类型；</p>
</li>
<li>
<p>List&lt;? extends T&gt; 用于设定类型通配符的上限，此处 ? 代表一个未知的类型，但它必须是T的子类型。</p>
</li>
</ul>
<p><strong>扩展阅读</strong></p>
<p>在Java的早期设计中，允许把Integer[]数组赋值给Number[]变量，此时如果试图把一个Double对象保存到该Number[]数组中，编译可以通过，但在运行时抛出ArrayStoreException异常。这显然是一种不安全的设计，因此Java在泛型设计时进行了改进，它不再允许把 List<integer> 对象赋值给List<number> 变量。</number></integer></p>
<p>数组和泛型有所不同，假设Foo是Bar的一个子类型（子类或者子接口），那么Foo[]依然是Bar[]的子类型，但 G<foo> 不是 G<bar> 的子类型。Foo[]自动向上转型为Bar[]的方式被称为型变，也就是说，Java的数组支持型变，但Java集合并不支持型变。Java泛型的设计原则是，只要代码在编译时没有出现警告，就不会遇到运行时ClassCastException异常。</bar></foo></p>
<h2 id="说说你对java反射机制的理解"><a class="markdownIt-Anchor" href="#说说你对java反射机制的理解"></a> 说说你对Java反射机制的理解</h2>
<p><img src="../../images/image-20230219162554595.png" alt="image-20230219162554595"></p>
<h2 id="java反射在实际项目种有哪些应用场景"><a class="markdownIt-Anchor" href="#java反射在实际项目种有哪些应用场景"></a> Java反射在实际项目种有哪些应用场景？</h2>
<p><strong>参考答案</strong></p>
<p>Java的反射机制在实际项目中应用广泛，常见的应用场景有：</p>
<ul>
<li>
<p>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</p>
</li>
<li>
<p>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</p>
</li>
<li>
<p>面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。</p>
</li>
</ul>
<p><img src="../../images/image-20230219162329199.png" alt="image-20230219162329199"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/19/interview/%E7%89%9B%E5%AE%A2%E7%BD%91java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clihlibpl003ou4v6fdwse78d" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/java核心基础面试" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/18/interview/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="post-time" datetime="2023-02-18T12:03:42.694Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">18</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/18/interview/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">java核心基础面试</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>,<a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/">java核心基础面试</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="java概述"><a class="markdownIt-Anchor" href="#java概述"></a> Java概述</h2>
<h3 id="何为编程"><a class="markdownIt-Anchor" href="#何为编程"></a> 何为编程</h3>
<ul>
<li><strong>编程</strong>就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。</li>
<li>为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。</li>
</ul>
<h3 id="什么是java"><a class="markdownIt-Anchor" href="#什么是java"></a> 什么是Java</h3>
<ul>
<li>Java是一门面向对象编程语言，不仅吸收了C<ins>语言的各种优点，还摒弃了C</ins>里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。</li>
</ul>
<h3 id="jdk15之后的三大版本"><a class="markdownIt-Anchor" href="#jdk15之后的三大版本"></a> jdk1.5之后的三大版本</h3>
<ul>
<li>Java SE（J2SE，Java 2 Platform Standard Edition，标准版）<br>
Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。</li>
<li>Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）<br>
Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE</li>
<li>Java ME（J2ME，Java 2 Platform Micro Edition，微型版）<br>
Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。</li>
</ul>
<h3 id="3-jdk和jre和jvm的区别"><a class="markdownIt-Anchor" href="#3-jdk和jre和jvm的区别"></a> 3 Jdk和Jre和JVM的区别</h3>
<p>看Java官方的图片，<strong>Jdk中包括了Jre，Jre中包括了JVM</strong></p>
<ul>
<li>
<p>JDK ：Jdk还包括了一些Jre之外的东西 ，就是这些东西帮我们编译Java代码的， 还有就是监控Jvm的一些工具 Java Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等</p>
</li>
<li>
<p>JRE ：Jre大部分都是 C 和 C++ 语言编写的，他是我们在编译java时所需要的基础的类库 Java Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包</p>
<p>如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。</p>
</li>
<li>
<p>Jvm：在倒数第二层   由他可以在（最后一层的）各种平台上运行 Java Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c434318a82~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h3 id="什么是跨平台性原理是什么"><a class="markdownIt-Anchor" href="#什么是跨平台性原理是什么"></a> 什么是跨平台性？原理是什么</h3>
<ul>
<li>所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。</li>
<li>实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。</li>
</ul>
<h3 id="为什么java代码可以实现一次编写-到处运行"><a class="markdownIt-Anchor" href="#为什么java代码可以实现一次编写-到处运行"></a> 为什么Java代码可以实现一次编写、到处运行？</h3>
<p><strong>参考答案：</strong></p>
<p>JVM（Java虚拟机）是Java跨平台的关键。</p>
<p>在程序运行前，<strong>Java源代码（.java）<strong>需要经过编译器编译成</strong>字节码（.class）</strong>。在程序运行时，JVM负责将字节码翻译成特定平台下的<strong>机器码</strong>并运行，也就是说，只要在不同的平台上安装对应的JVM，就可以运行字节码文件。</p>
<p>同一份Java源代码在不同的平台上运行，它不需要做任何的改变，并且只需要编译一次。而编译好的字节码，是通过JVM这个中间的“桥梁”实现跨平台的，JVM是与平台相关的软件，它能将统一的字节码翻译成该平台的机器码。</p>
<p><strong>注意事项：</strong></p>
<ol>
<li>
<p>编译的结果是生成字节码、不是机器码，字节码不能直接运行，必须通过JVM翻译成机器码才能运行；</p>
</li>
<li>
<p>跨平台的是Java程序、而不是JVM，JVM是用C/C++开发的软件，不同平台下需要安装不同版本的JVM。</p>
</li>
</ol>
<h3 id="java语言有哪些特点"><a class="markdownIt-Anchor" href="#java语言有哪些特点"></a> Java语言有哪些特点</h3>
<ul>
<li>简单易学（Java语言的语法与C语言和C++语言很接近）</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机实现平台无关性）</li>
<li>支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的）</li>
<li>支持多线程（多线程机制使应用程序在同一时间并行执行多项任务）</li>
<li>健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等）</li>
<li>安全性好</li>
</ul>
<h3 id="什么是字节码采用字节码的最大好处是什么"><a class="markdownIt-Anchor" href="#什么是字节码采用字节码的最大好处是什么"></a> 什么是字节码？采用字节码的最大好处是什么</h3>
<ul>
<li>
<p><strong>字节码</strong>：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
</li>
<li>
<p><strong>采用字节码的好处</strong>：</p>
<p>Java语言通过字节码的方式，在<strong>一定程度上解决了传统解释型语言执行效率低的问题</strong>，</p>
<p>同时又<strong>保留了解释型语言可移植的特点</strong>。所以Java程序运行时比较高效，</p>
<p>而且，由于<strong>字节码并不专对一种特定的机器</strong>，因此，Java程序<strong>无须重新编译</strong>便可在多种不同的计算机上运行。</p>
</li>
<li>
<p><strong>先看下java中的编译器和解释器</strong>：</p>
<p>Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。<strong>Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行</strong>，这就是上面提到的Java的特点的编译与解释并存的解释。</p>
<p>Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。</p>
</li>
</ul>
<h3 id="什么是java程序的主类应用程序和小程序的主类有何不同"><a class="markdownIt-Anchor" href="#什么是java程序的主类应用程序和小程序的主类有何不同"></a> 什么是Java程序的主类？应用程序和小程序的主类有何不同？</h3>
<ul>
<li>一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。</li>
</ul>
<h3 id="java应用程序与小程序之间有那些差别"><a class="markdownIt-Anchor" href="#java应用程序与小程序之间有那些差别"></a> Java应用程序与小程序之间有那些差别？</h3>
<ul>
<li>简单说应用程序是从主线程启动(也就是main()方法)。</li>
<li>applet小程序没有main方法，主要是<strong>嵌在浏览器</strong>页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。</li>
</ul>
<h3 id="java和c的区别"><a class="markdownIt-Anchor" href="#java和c的区别"></a> Java和C++的区别</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。</li>
<li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li>
</ul>
<h3 id="oracle-jdk-和-openjdk-的对比"><a class="markdownIt-Anchor" href="#oracle-jdk-和-openjdk-的对比"></a> Oracle JDK 和 OpenJDK 的对比</h3>
<ol>
<li>Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次；</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题；</li>
<li>在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能；</li>
<li>Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。</li>
</ol>
<h2 id="基础语法"><a class="markdownIt-Anchor" href="#基础语法"></a> 基础语法</h2>
<h3 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h3>
<h4 id="java有哪些数据类型"><a class="markdownIt-Anchor" href="#java有哪些数据类型"></a> Java有哪些数据类型</h4>
<p><strong>定义</strong>：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。</p>
<p><strong>分类</strong></p>
<ul>
<li>基本数据类型
<ul>
<li>数值型
<ul>
<li>整数类型(byte,short,int,long)</li>
<li>浮点类型(float,double)</li>
</ul>
</li>
<li>字符型(char)</li>
<li>布尔型(boolean)</li>
</ul>
</li>
<li>引用数据类型
<ul>
<li>类(class)</li>
<li>接口(interface)</li>
<li>数组([])</li>
</ul>
</li>
</ul>
<p><strong>Java基本数据类型图</strong></p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c434465b69~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h4 id="switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上"><a class="markdownIt-Anchor" href="#switch-是否能作用在-byte-上是否能作用在-long-上是否能作用在-string-上"></a> switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上</h4>
<ul>
<li>在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</li>
</ul>
<h4 id="用最有效率的方法计算-2-乘以-8"><a class="markdownIt-Anchor" href="#用最有效率的方法计算-2-乘以-8"></a> 用最有效率的方法计算 2 乘以 8</h4>
<ul>
<li>
<p>2 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。</p>
</li>
<li>
<pre class="highlight"><code class="java"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;
        a = a &lt;&lt; <span class="number">3</span>;
        System.out.println( a );  <span class="comment">// a = 8</span>

        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">16</span>;
        b =  b &gt;&gt; <span class="number">3</span>;
        System.out.println( b ); <span class="comment">// b = 2</span>
&lt;!--code￼<span class="number">1</span>--&gt;
</code></pre>
</li>
</ul>
<p>注意事项：多行和文档注释都不能嵌套使用。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 访问修饰符</span><br><span class="line"></span><br><span class="line">#### 访问修饰符 public,private,protected,以及不写（默认default）时的区别</span><br><span class="line"></span><br><span class="line">- **定义**：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</span><br><span class="line">- **分类**</span><br><span class="line">  - private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</span><br><span class="line">  - default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</span><br><span class="line">  - protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</span><br><span class="line">  - public : 对所有类可见。使用对象：类、接口、变量、方法</span><br><span class="line"></span><br><span class="line">**访问修饰符图**</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">![在这里插入图片描述](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c433bcfd38~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 运算符</span><br><span class="line"></span><br><span class="line">#### &amp;和&amp;&amp;的区别</span><br><span class="line"></span><br><span class="line">- &amp;运算符有两种用法：(1)按位与；(2)逻辑与。</span><br><span class="line">- &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 关键字</span><br><span class="line"></span><br><span class="line">#### Java 有没有 goto</span><br><span class="line"></span><br><span class="line">- goto 是 Java 中的保留字，在目前版本的 Java 中没有使用。</span><br><span class="line"></span><br><span class="line">#### final 有什么用？</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>用于修饰类、属性和方法；</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 被final修饰的类不可以被继承</span><br><span class="line">- 被final修饰的方法不可以被重写</span><br><span class="line">- 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的</span><br><span class="line"></span><br><span class="line">#### final finally finalize区别</span><br><span class="line"></span><br><span class="line">- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表 示该变量是一个常量不能被重新赋值。</span><br><span class="line">- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块 中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。</span><br><span class="line">- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调 用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的 最后判断。</span><br><span class="line"></span><br><span class="line">#### this关键字的用法</span><br><span class="line"></span><br><span class="line">- this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。</span><br><span class="line"></span><br><span class="line">- this的用法在java中大体可以分为3种：</span><br><span class="line"></span><br><span class="line">  - 1.普通的直接引用，this相当于是指向当前对象本身。</span><br><span class="line"></span><br><span class="line">  - 2.形参与成员名字重名，用this来区分：</span><br><span class="line"></span><br><span class="line">    ```java</span><br><span class="line">    public Person(String name, int age) {</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>3.引用本类的构造函数</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> {</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age)</span> {</span><br><span class="line">        <span class="built_in">this</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="super关键字的用法"><a class="markdownIt-Anchor" href="#super关键字的用法"></a> super关键字的用法</h4>
<ul>
<li>
<p>super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。</p>
</li>
<li>
<p>super也有三种用法：</p>
<ul>
<li>
<p>1.普通的直接引用</p>
<p>与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。</p>
</li>
<li>
<p>2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分</p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>{</span><br><span class="line">    <span class="keyword">protected</span> <span class="title class_">String</span> name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Person</span>(<span class="title class_">String</span> name) {</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="title class_">String</span> name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title class_">Student</span>(<span class="title class_">String</span> name, <span class="title class_">String</span> name1) {</span><br><span class="line">        <span class="variable language_">super</span>(name);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name1;</span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> <span class="title function_">getInfo</span>(<span class="params"></span>){</span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">this</span>.<span class="property">name</span>);      <span class="comment">//Child</span></span><br><span class="line">        <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="variable language_">super</span>.<span class="property">name</span>);     <span class="comment">//Father</span></span><br><span class="line">    }</span><br><span class="line"> </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) {</span><br><span class="line">       <span class="title class_">Student</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">"Father"</span>,<span class="string">"Child"</span>);</span><br><span class="line">       s1.<span class="title function_">getInfo</span>();</span><br><span class="line"> </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>3.引用父类构造函数</p>
<ul>
<li>super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。</li>
<li>this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="this与super的区别"><a class="markdownIt-Anchor" href="#this与super的区别"></a> this与super的区别</h4>
<ul>
<li>super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参）</li>
<li>this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名）</li>
<li>super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。</li>
<li>super()和this()均需放在构造方法内第一行。</li>
<li>尽管可以用this调用一个构造器，但却不能调用两个。</li>
<li>this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</li>
<li>this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。</li>
<li>从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。</li>
</ul>
<h4 id="static存在的主要意义"><a class="markdownIt-Anchor" href="#static存在的主要意义"></a> static存在的主要意义</h4>
<ul>
<li>static的主要意义是在于创建独立于具体对象的域变量或者方法。<strong>以致于即使没有创建对象，也能使用属性和调用方法</strong>！</li>
<li>static关键字还有一个比较关键的作用就是 <strong>用来形成静态代码块以优化程序性能</strong>。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。</li>
<li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。</li>
</ul>
<h4 id="static的独特之处"><a class="markdownIt-Anchor" href="#static的独特之处"></a> static的独特之处</h4>
<ul>
<li>1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法<strong>不属于任何一个实例对象，而是被类的实例对象所共享</strong>。</li>
</ul>
<blockquote>
<p>怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？</p>
</blockquote>
<ul>
<li>2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。</li>
<li>3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！</li>
<li>4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。</li>
</ul>
<h4 id="static应用场景"><a class="markdownIt-Anchor" href="#static应用场景"></a> static应用场景</h4>
<ul>
<li>因为static是被类的实例对象所共享，因此如果<strong>某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量</strong>。</li>
<li>因此比较常见的static应用场景有：</li>
</ul>
<blockquote>
<p>1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包</p>
</blockquote>
<h4 id="static注意事项"><a class="markdownIt-Anchor" href="#static注意事项"></a> static注意事项</h4>
<ul>
<li>1、静态只能访问静态</li>
<li>2、非静态既可以访问非静态的，也可以访问静态的。</li>
</ul>
<h3 id="流程控制语句"><a class="markdownIt-Anchor" href="#流程控制语句"></a> 流程控制语句</h3>
<h4 id="break-continue-return-的区别及作用"><a class="markdownIt-Anchor" href="#break-continue-return-的区别及作用"></a> break ,continue ,return 的区别及作用</h4>
<ul>
<li>break 跳出总上一层循环，不再执行循环(结束当前的循环体)</li>
<li>continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件)</li>
<li>return 程序返回，不再执行下面的代码(结束当前的方法 直接返回)</li>
</ul>
<h4 id="在-java-中如何跳出当前的多重嵌套循环"><a class="markdownIt-Anchor" href="#在-java-中如何跳出当前的多重嵌套循环"></a> 在 Java 中，如何跳出当前的多重嵌套循环</h4>
<ul>
<li>
<p>在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如：</p>
<figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">String</span>[] args)</span> </span>{</span><br><span class="line">    ok:</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) {</span><br><span class="line">            System.out.<span class="built_in">println</span>(<span class="string">"i="</span> + i + <span class="string">",j="</span> + j);</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">5</span>) {</span><br><span class="line">                <span class="keyword">break</span> ok;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h2 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h2>
<h3 id="面向对象概述"><a class="markdownIt-Anchor" href="#面向对象概述"></a> 面向对象概述</h3>
<h4 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h4>
<ul>
<li><strong>面向过程</strong>：
<ul>
<li>优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
</li>
<li><strong>面向对象</strong>：
<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。</span><br><span class="line">面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。</span><br><span class="line">面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="面向对象三大特性"><a class="markdownIt-Anchor" href="#面向对象三大特性"></a> 面向对象三大特性</h3>
<h4 id="面向对象的特征有哪些方面"><a class="markdownIt-Anchor" href="#面向对象的特征有哪些方面"></a> 面向对象的特征有哪些方面</h4>
<p><strong>面向对象的特征主要有以下几个方面</strong>：</p>
<ul>
<li><strong>抽象</strong>：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。（抽象类不可实例化）</li>
<li><strong>封装</strong>：把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</li>
<li><strong>继承</strong>：是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。
<ul>
<li>关于继承如下 3 点请记住：
<ul>
<li>子类拥有父类非 private 的属性和方法。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>多态</strong>：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</li>
</ul>
<h4 id="什么是多态机制java语言是如何实现多态的"><a class="markdownIt-Anchor" href="#什么是多态机制java语言是如何实现多态的"></a> 什么是多态机制？Java语言是如何实现多态的？</h4>
<ul>
<li>所谓<mark>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定</mark>，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。</li>
<li>多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。</li>
</ul>
<p><strong>多态的实现</strong></p>
<ul>
<li>Java实现多态有三个必要条件：继承、重写、向上转型。
<ul>
<li>继承：在多态中必须存在有继承关系的子类和父类。</li>
<li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li>
<li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。</span><br><span class="line">对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。</span><br></pre></td></tr></tbody></table></figure>
<h4 id="面向对象五大基本原则是什么可选"><a class="markdownIt-Anchor" href="#面向对象五大基本原则是什么可选"></a> 面向对象五大基本原则是什么（可选）</h4>
<ul>
<li>单一职责原则SRP(Single Responsibility Principle)<br>
类的功能要单一，不能包罗万象，跟杂货铺似的。</li>
<li>开放封闭原则OCP(Open－Close Principle)<br>
一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。</li>
<li>里式替换原则LSP(the Liskov Substitution Principle LSP)<br>
子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~</li>
<li>依赖倒置原则DIP(the Dependency Inversion Principle DIP)<br>
高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。</li>
<li>接口分离原则ISP(the Interface Segregation Principle ISP)<br>
设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。</li>
</ul>
<h3 id="类与接口"><a class="markdownIt-Anchor" href="#类与接口"></a> 类与接口</h3>
<h4 id="抽象类和接口的对比"><a class="markdownIt-Anchor" href="#抽象类和接口的对比"></a> 抽象类和接口的对比</h4>
<ul>
<li>抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。</li>
<li>从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。</li>
</ul>
<p><strong>相同点</strong></p>
<ul>
<li>接口和抽象类都不能实例化</li>
<li>都位于继承的顶端，用于被其他实现或继承</li>
<li>都包含抽象方法，其子类都必须覆写这些抽象方法</li>
</ul>
<p><strong>不同点</strong></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>抽象类</th>
<th>接口</th>
</tr>
</thead>
<tbody>
<tr>
<td>声明</td>
<td>抽象类使用abstract关键字声明</td>
<td>接口使用interface关键字声明</td>
</tr>
<tr>
<td>实现</td>
<td>子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现</td>
<td>子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现</td>
</tr>
<tr>
<td>构造器</td>
<td>抽象类可以有构造器</td>
<td>接口不能有构造器</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>抽象类中的方法可以是任意访问修饰符</td>
<td>接口方法默认修饰符是public。并且不允许定义为 private 或者 protected</td>
</tr>
<tr>
<td>多继承</td>
<td>一个类最多只能继承一个抽象类</td>
<td>一个类可以实现多个接口</td>
</tr>
<tr>
<td>字段声明</td>
<td>抽象类的字段声明可以是任意的</td>
<td>接口的字段默认都是 static 和 final 的</td>
</tr>
</tbody>
</table>
<p><strong>备注</strong>：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则：
<ul>
<li>行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。</li>
<li>选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。</li>
</ul>
</li>
</ul>
<h4 id="普通类和抽象类有哪些区别"><a class="markdownIt-Anchor" href="#普通类和抽象类有哪些区别"></a> 普通类和抽象类有哪些区别？</h4>
<ul>
<li>普通类不能包含抽象方法，抽象类可以包含抽象方法。</li>
<li>抽象类不能直接实例化，普通类可以直接实例化。</li>
</ul>
<h4 id="抽象类能使用-final-修饰吗"><a class="markdownIt-Anchor" href="#抽象类能使用-final-修饰吗"></a> 抽象类能使用 final 修饰吗？</h4>
<ul>
<li>不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类</li>
</ul>
<h4 id="创建一个对象用什么关键字对象实例与对象引用有何不同"><a class="markdownIt-Anchor" href="#创建一个对象用什么关键字对象实例与对象引用有何不同"></a> 创建一个对象用什么关键字？对象实例与对象引用有何不同？</h4>
<ul>
<li>new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球）</li>
</ul>
<h3 id="变量与方法"><a class="markdownIt-Anchor" href="#变量与方法"></a> 变量与方法</h3>
<h4 id="成员变量与局部变量的区别有哪些"><a class="markdownIt-Anchor" href="#成员变量与局部变量的区别有哪些"></a> 成员变量与局部变量的区别有哪些</h4>
<ul>
<li>变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域</li>
<li>成员变量：方法外部，类内部定义的变量</li>
<li>局部变量：类的方法中的变量。</li>
<li>成员变量和局部变量的区别</li>
</ul>
<p><strong>作用域</strong></p>
<ul>
<li>成员变量：针对整个类有效。</li>
<li>局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)</li>
</ul>
<p><strong>存储位置</strong></p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。</li>
<li>局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p><strong>生命周期</strong></p>
<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失</li>
<li>局部变量：当方法调用完，或者语句结束后，就自动释放。</li>
</ul>
<p><strong>初始值</strong></p>
<ul>
<li>成员变量：有默认初始值。</li>
<li>局部变量：没有默认初始值，使用前必须赋值。</li>
</ul>
<h4 id="在java中定义一个不做事且没有参数的构造方法的作用"><a class="markdownIt-Anchor" href="#在java中定义一个不做事且没有参数的构造方法的作用"></a> 在Java中定义一个不做事且没有参数的构造方法的作用</h4>
<ul>
<li>Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</li>
</ul>
<h4 id="在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是"><a class="markdownIt-Anchor" href="#在调用子类构造方法之前会先调用父类没有参数的构造方法其目的是"></a> 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？</h4>
<ul>
<li>帮助子类做初始化工作。</li>
</ul>
<h4 id="一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么"><a class="markdownIt-Anchor" href="#一个类的构造方法的作用是什么若一个类没有声明构造方法改程序能正确执行吗为什么"></a> 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？</h4>
<ul>
<li>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</li>
</ul>
<h4 id="构造方法有哪些特性"><a class="markdownIt-Anchor" href="#构造方法有哪些特性"></a> 构造方法有哪些特性？</h4>
<ul>
<li>名字与类名相同；</li>
<li>没有返回值，但不能用void声明构造函数；</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ul>
<h4 id="静态变量和实例变量区别"><a class="markdownIt-Anchor" href="#静态变量和实例变量区别"></a> 静态变量和实例变量区别</h4>
<ul>
<li>静态变量： 静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。</li>
<li>实例变量： 每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。</li>
</ul>
<h4 id="静态变量与普通变量区别"><a class="markdownIt-Anchor" href="#静态变量与普通变量区别"></a> 静态变量与普通变量区别</h4>
<ul>
<li>static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。</li>
<li>还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。</li>
</ul>
<h4 id="静态方法和实例方法有何不同"><a class="markdownIt-Anchor" href="#静态方法和实例方法有何不同"></a> 静态方法和实例方法有何不同？</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">静态方法和实例方法的区别主要体现在两个方面：</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>在外部调用静态方法时，可以使用"类名.方法名"的方式，也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制</li>
</ul>
<h4 id="在一个静态方法内调用一个非静态成员为什么是非法的"><a class="markdownIt-Anchor" href="#在一个静态方法内调用一个非静态成员为什么是非法的"></a> 在一个静态方法内调用一个非静态成员为什么是非法的？</h4>
<ul>
<li>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</li>
</ul>
<h4 id="什么是方法的返回值返回值的作用是什么"><a class="markdownIt-Anchor" href="#什么是方法的返回值返回值的作用是什么"></a> 什么是方法的返回值？返回值的作用是什么？</h4>
<ul>
<li>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</li>
</ul>
<h3 id="内部类"><a class="markdownIt-Anchor" href="#内部类"></a> 内部类</h3>
<h4 id="什么是内部类"><a class="markdownIt-Anchor" href="#什么是内部类"></a> 什么是内部类？</h4>
<ul>
<li>在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是<strong>内部类</strong>。内部类本身就是类的一个属性，与其他属性定义方式一致。</li>
</ul>
<h4 id="内部类的分类有哪些"><a class="markdownIt-Anchor" href="#内部类的分类有哪些"></a> 内部类的分类有哪些</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内部类可以分为四种：**成员内部类、局部内部类、匿名内部类和静态内部类**。</span><br></pre></td></tr></tbody></table></figure>
<h5 id="静态内部类"><a class="markdownIt-Anchor" href="#静态内部类"></a> 静态内部类</h5>
<ul>
<li>
<p>定义在类内部的静态类，就是静态内部类。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> radius = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StaticInner</span> {</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span>()</span> {</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，<code>new 外部类.静态内部类()</code>，如下：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span>.StaticInner <span class="keyword">inner</span> = <span class="built_in">new</span> <span class="keyword">Outer</span>.StaticInner();</span><br><span class="line"><span class="keyword">inner</span>.visit();复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="成员内部类"><a class="markdownIt-Anchor" href="#成员内部类"></a> 成员内部类</h5>
<ul>
<li>
<p>定义在类内部，成员位置上的非静态类，就是成员内部类。</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="built_in">int</span> radius = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> <span class="keyword">count</span> =<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Inner</span> {</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> visit() {</span><br><span class="line">            System.out.println(<span class="string">"visit outer static  variable:"</span> + radius);</span><br><span class="line">            System.out.println(<span class="string">"visit outer   variable:"</span> + <span class="keyword">count</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式<code>外部类实例.new 内部类()</code>，如下：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Outer</span> <span class="keyword">outer</span> = <span class="built_in">new</span> <span class="keyword">Outer</span>();</span><br><span class="line"><span class="keyword">Outer</span>.<span class="keyword">Inner</span> <span class="keyword">inner</span> = <span class="keyword">outer</span>.<span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line"><span class="keyword">inner</span>.visit();</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="局部内部类"><a class="markdownIt-Anchor" href="#局部内部类"></a> 局部内部类</h5>
<ul>
<li>
<p>定义在方法中的内部类，就是局部内部类。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="built_in">int</span> out_a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> STATIC_b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFunctionClass</span>()</span>{</span><br><span class="line">        <span class="built_in">int</span> inner_c =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span>()</span>{</span><br><span class="line">                System.<span class="keyword">out</span>.println(out_a);</span><br><span class="line">                System.<span class="keyword">out</span>.println(STATIC_b);</span><br><span class="line">                System.<span class="keyword">out</span>.println(inner_c);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticFunctionClass</span>()</span>{</span><br><span class="line">        <span class="built_in">int</span> d =<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fun</span>()</span>{</span><br><span class="line">                <span class="comment">// System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量</span></span><br><span class="line">                System.<span class="keyword">out</span>.println(STATIC_b);</span><br><span class="line">                System.<span class="keyword">out</span>.println(d);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        Inner  inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.fun();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，<code>new 内部类()</code>，如下：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> testStaticFunctionClass(){</span><br><span class="line">    <span class="keyword">class</span> <span class="keyword">Inner</span> {</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">Inner</span>  <span class="keyword">inner</span> = <span class="built_in">new</span> <span class="keyword">Inner</span>();</span><br><span class="line"> }</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h5 id="匿名内部类"><a class="markdownIt-Anchor" href="#匿名内部类"></a> 匿名内部类</h5>
<ul>
<li>
<p>匿名内部类就是没有名字的内部类，日常开发中使用的比较多。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span>(<span class="params">final <span class="built_in">int</span> i</span>)</span> {</span><br><span class="line">        <span class="keyword">new</span> Service() {</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span>()</span> {</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; i; j++) {</span><br><span class="line">                    System.<span class="keyword">out</span>.println(<span class="string">"匿名内部类"</span> );</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.method();</span><br><span class="line">    }</span><br><span class="line"> }</span><br><span class="line"> <span class="comment">//匿名内部类必须继承或实现一个已有的接口 </span></span><br><span class="line"> <span class="keyword">interface</span> <span class="title">Service</span>{</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method</span>()</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>除了没有名字，匿名内部类还有以下特点：</p>
<ul>
<li>匿名内部类必须继承一个抽象类或者实现一个接口。</li>
<li>匿名内部类不能定义任何静态成员和静态方法。</li>
<li>当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。</li>
<li>匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。</li>
</ul>
</li>
<li>
<p>匿名内部类创建方式：</p>
<figure class="highlight haxe"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type"></span>类/接口{ </span><br><span class="line">  <span class="comment">//匿名内部类实现部分</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="内部类的优点"><a class="markdownIt-Anchor" href="#内部类的优点"></a> 内部类的优点</h4>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们为什么要使用内部类呢？因为它有以下优点：</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！</li>
<li>内部类不为同一包的其他类所见，具有很好的封装性；</li>
<li>内部类有效实现了“多重继承”，优化 java 单继承的缺陷。</li>
<li>匿名内部类可以很方便的定义回调。</li>
</ul>
<h4 id="内部类有哪些应用场景"><a class="markdownIt-Anchor" href="#内部类有哪些应用场景"></a> 内部类有哪些应用场景</h4>
<ol>
<li>一些多算法场合</li>
<li>解决一些非面向对象的语句块。</li>
<li>适当使用内部类，使得代码更加灵活和富有扩展性。</li>
<li>当某个类除了它的外部类，不再被其他的类使用时。</li>
</ol>
<h4 id="局部内部类和匿名内部类访问局部变量的时候为什么变量必须要加上final"><a class="markdownIt-Anchor" href="#局部内部类和匿名内部类访问局部变量的时候为什么变量必须要加上final"></a> 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？</h4>
<ul>
<li>
<p>局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？先看这段代码：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">outMethod</span>()</span>{</span><br><span class="line">        final <span class="built_in">int</span> a =<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">            <span class="function"><span class="keyword">void</span> <span class="title">innerMethod</span>()</span>{</span><br><span class="line">                System.<span class="keyword">out</span>.println(a);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>以上例子，为什么要加final呢？是因为<strong>生命周期不一致</strong>， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。</p>
</li>
</ul>
<h4 id="内部类相关看程序说出运行结果"><a class="markdownIt-Anchor" href="#内部类相关看程序说出运行结果"></a> 内部类相关，看程序说出运行结果</h4>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Outer</span> {</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Inner</span> {</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">int</span> age = <span class="number">13</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span>()</span> {</span><br><span class="line">            <span class="built_in">int</span> age = <span class="number">14</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"局部变量："</span> + age);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"内部类变量："</span> + <span class="keyword">this</span>.age);</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"外部类变量："</span> + Outer.<span class="keyword">this</span>.age);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">        Outer.Inner <span class="keyword">in</span> = <span class="keyword">new</span> Outer().<span class="function"><span class="keyword">new</span> <span class="title">Inner</span>()</span>;</span><br><span class="line">        <span class="keyword">in</span>.print();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">局部变量：14</span><br><span class="line">内部类变量：13</span><br><span class="line">外部类变量：12复制代码</span><br></pre></td></tr></tbody></table></figure>
<h3 id="重写与重载"><a class="markdownIt-Anchor" href="#重写与重载"></a> 重写与重载</h3>
<h4 id="构造器constructor是否可被重写override"><a class="markdownIt-Anchor" href="#构造器constructor是否可被重写override"></a> 构造器（constructor）是否可被重写（override）</h4>
<ul>
<li>构造器不能被继承，因此不能被重写，但可以被重载。</li>
</ul>
<h4 id="重载overload和重写override的区别-重载的方法能否根据返回类型进行区分"><a class="markdownIt-Anchor" href="#重载overload和重写override的区别-重载的方法能否根据返回类型进行区分"></a> 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h4>
<ul>
<li>方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。</li>
<li>重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分</li>
<li>重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。</li>
</ul>
<h3 id="对象相等判断"><a class="markdownIt-Anchor" href="#对象相等判断"></a> 对象相等判断</h3>
<h4 id="和-equals-的区别是什么"><a class="markdownIt-Anchor" href="#和-equals-的区别是什么"></a> == 和 equals 的区别是什么</h4>
<ul>
<li>
<p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址)</p>
</li>
<li>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>
<p>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</p>
</li>
<li>
<p>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</p>
</li>
<li>
<p><strong>举个例子：</strong></p>
<figure class="highlight typescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> <span class="title function_">main</span>(<span class="params"><span class="built_in">String</span>[] args</span>) {</span><br><span class="line">        <span class="title class_">String</span> a = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        <span class="title class_">String</span> b = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"ab"</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        <span class="title class_">String</span> aa = <span class="string">"ab"</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        <span class="title class_">String</span> bb = <span class="string">"ab"</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"aa==bb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"a==b"</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.<span class="title function_">equals</span>(b)) <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"aEQb"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) { <span class="comment">// true</span></span><br><span class="line">            <span class="title class_">System</span>.<span class="property">out</span>.<span class="title function_">println</span>(<span class="string">"true"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>说明：</strong></p>
<ul>
<li>String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。</li>
<li>当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。</li>
</ul>
</li>
</ul>
<h4 id="hashcode-与-equals-重要"><a class="markdownIt-Anchor" href="#hashcode-与-equals-重要"></a> hashCode 与 equals (重要)</h4>
<ul>
<li>HashSet如何检查重复</li>
<li>两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？</li>
<li>hashCode和equals方法的关系</li>
<li>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</li>
</ul>
<p><strong>hashCode()介绍</strong></p>
<ul>
<li>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。</li>
<li>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</li>
</ul>
<p><strong>为什么要有 hashCode</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</li>
</ul>
<p><strong>hashCode()与equals()的相关规定</strong></p>
<ul>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等，对两个对象分别调用equals方法都返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</span><br><span class="line">hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</span><br></pre></td></tr></tbody></table></figure>
<h4 id="对象的相等与指向他们的引用相等两者有什么不同"><a class="markdownIt-Anchor" href="#对象的相等与指向他们的引用相等两者有什么不同"></a> 对象的相等与指向他们的引用相等，两者有什么不同？</h4>
<ul>
<li>对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。</li>
</ul>
<h3 id="值传递"><a class="markdownIt-Anchor" href="#值传递"></a> 值传递</h3>
<h4 id="当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递"><a class="markdownIt-Anchor" href="#当一个对象被当作参数传递到一个方法后此方法可改变这个对象的属性并可返回变化后的结果那么这里到底是值传递还是引用传递"></a> 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递</h4>
<ul>
<li>是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的</li>
</ul>
<h4 id="为什么-java-中只有值传递"><a class="markdownIt-Anchor" href="#为什么-java-中只有值传递"></a> 为什么 Java 中只有值传递</h4>
<ul>
<li>首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。<strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</li>
<li><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong>
<ul>
<li><strong>下面通过 3 个例子来给大家说明</strong></li>
</ul>
</li>
</ul>
<h5 id="example-1"><a class="markdownIt-Anchor" href="#example-1"></a> example 1</h5>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> static <span class="type">void</span> main(String[] args) {</span><br><span class="line">    <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    swap(num1, num2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("num1 = " + num1);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("num2 = " + num2);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">public</span> static <span class="type">void</span> swap(<span class="type">int</span> a, <span class="type">int</span> b) {</span><br><span class="line">    <span class="type">int</span> <span class="keyword">temp</span> = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = <span class="keyword">temp</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("a = " + a);</span><br><span class="line">    <span class="keyword">System</span>.<span class="keyword">out</span>.println("b = " + b);</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>结果：</p>
<p>a = 20 b = 10 num1 = 10 num2 = 20</p>
</li>
<li>
<p>解析：</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c436af3af1~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example.</span><br></pre></td></tr></tbody></table></figure>
<h5 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> example 2</h5>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> {</span><br><span class="line">    <span class="built_in">int</span>[] arr = { <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> };</span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]);</span><br><span class="line">    change(arr);</span><br><span class="line">    System.<span class="keyword">out</span>.println(arr[<span class="number">0</span>]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"><span class="built_in">int</span>[] array</span>)</span> {</span><br><span class="line">    <span class="comment">// 将数组的第一个元素变为0</span></span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>结果：</p>
<p>1 0</p>
</li>
<li>
<p>解析：</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c4372f6ac8~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</span><br><span class="line">很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。</span><br></pre></td></tr></tbody></table></figure>
<h5 id="example-3"><a class="markdownIt-Anchor" href="#example-3"></a> example 3</h5>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">public</span> <span class="keyword">class</span> Test {</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> main(String[] args) {</span><br><span class="line">        // TODO Auto-<span class="keyword">generated</span> <span class="keyword">method</span> stub</span><br><span class="line">        Student s1 = <span class="built_in">new</span> Student("小张");</span><br><span class="line">        Student s2 = <span class="built_in">new</span> Student("小李");</span><br><span class="line">        Test.swap(s1, s2);</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("s1:" + s1.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("s2:" + s2.getName());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">public</span> static <span class="type">void</span> swap(Student x, Student y) {</span><br><span class="line">        Student <span class="keyword">temp</span> = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = <span class="keyword">temp</span>;</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("x:" + x.getName());</span><br><span class="line">        <span class="keyword">System</span>.<span class="keyword">out</span>.println("y:" + y.getName());</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>结果：</p>
<p>x:小李 y:小张 s1:小张 s2:小李</p>
</li>
<li>
<p>解析：</p>
</li>
<li>
<p>交换之前：</p>
</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c445af6270~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>交换之后：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c45facc688~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>通过上面两张图可以很清晰的看出：<code>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</code></li>
<li>总结
<ul>
<li><code>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</code></li>
</ul>
</li>
<li>下面再总结一下Java中方法参数的使用情况：
<ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
</li>
</ul>
<h4 id="值传递和引用传递有什么区别"><a class="markdownIt-Anchor" href="#值传递和引用传递有什么区别"></a> 值传递和引用传递有什么区别</h4>
<ul>
<li>值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。</li>
<li>引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。</li>
</ul>
<h3 id="java包"><a class="markdownIt-Anchor" href="#java包"></a> Java包</h3>
<h4 id="jdk-中常用的包有哪些"><a class="markdownIt-Anchor" href="#jdk-中常用的包有哪些"></a> JDK 中常用的包有哪些</h4>
<ul>
<li>java.lang：这个是系统的基础类；</li>
<li><a target="_blank" rel="noopener" href="http://java.io">java.io</a>：这里面是所有输入输出有关的类，比如文件操作等；</li>
<li>java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包；</li>
<li><a target="_blank" rel="noopener" href="http://java.net">java.net</a>：这里面是与网络有关的类；</li>
<li>java.util：这个是系统辅助类，特别是集合类；</li>
<li>java.sql：这个是数据库操作的类。</li>
</ul>
<h4 id="import-java和javax有什么区别"><a class="markdownIt-Anchor" href="#import-java和javax有什么区别"></a> import java和javax有什么区别</h4>
<ul>
<li>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以，实际上java和javax没有区别。这都是一个名字。</span><br></pre></td></tr></tbody></table></figure>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2>
<h3 id="java-中-io-流分为几种"><a class="markdownIt-Anchor" href="#java-中-io-流分为几种"></a> java 中 IO 流分为几种?</h3>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作方式分类结构图：</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c4799a7a74~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按操作对象分类结构图：</span><br></pre></td></tr></tbody></table></figure>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/14/171744c479a04121~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<h3 id="bionioaio-有什么区别"><a class="markdownIt-Anchor" href="#bionioaio-有什么区别"></a> BIO,NIO,AIO 有什么区别?</h3>
<ul>
<li>简答
<ul>
<li>BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。</li>
<li>NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。</li>
<li>AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。</li>
</ul>
</li>
<li>详细回答
<ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (New I/O):</strong> NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。 NIO提供了与传统BIO模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
</li>
</ul>
<h3 id="files的常用方法都有哪些"><a class="markdownIt-Anchor" href="#files的常用方法都有哪些"></a> Files的常用方法都有哪些？</h3>
<ul>
<li>Files. exists()：检测文件路径是否存在。</li>
<li>Files. createFile()：创建文件。</li>
<li>Files. createDirectory()：创建文件夹。</li>
<li>Files. delete()：删除一个文件或目录。</li>
<li>Files. copy()：复制文件。</li>
<li>Files. move()：移动文件。</li>
<li>Files. size()：查看文件个数。</li>
<li>Files. read()：读取文件。</li>
<li>Files. write()：写入文件。</li>
</ul>
<h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2>
<h3 id="什么是反射机制"><a class="markdownIt-Anchor" href="#什么是反射机制"></a> 什么是反射机制？</h3>
<ul>
<li>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</li>
<li>静态编译和动态编译
<ul>
<li>静态编译：在编译时确定类型，绑定对象</li>
<li>动态编译：运行时确定类型，绑定对象</li>
</ul>
</li>
</ul>
<h3 id="反射机制优缺点"><a class="markdownIt-Anchor" href="#反射机制优缺点"></a> 反射机制优缺点</h3>
<ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h3 id="反射机制的应用场景有哪些"><a class="markdownIt-Anchor" href="#反射机制的应用场景有哪些"></a> 反射机制的应用场景有哪些？</h3>
<ul>
<li>反射是框架设计的灵魂。</li>
<li>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</li>
<li>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</li>
</ul>
<h3 id="java获取反射的三种方法"><a class="markdownIt-Anchor" href="#java获取反射的三种方法"></a> Java获取反射的三种方法</h3>
<p>1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制</p>
<figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Student {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">boolean</span> sex;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">float</span> score;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Get {</span><br><span class="line">    <span class="comment">//获取反射机制三种方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">        <span class="comment">//方式一(通过建立对象)</span></span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">Class</span> classobj1 = stu.getClass();</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj1.getName());</span><br><span class="line">        <span class="comment">//方式二（所在通过路径-相对路径）</span></span><br><span class="line">        <span class="keyword">Class</span> classobj2 = <span class="keyword">Class</span>.forName(<span class="string">"fanshe.Student"</span>);</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj2.getName());</span><br><span class="line">        <span class="comment">//方式三（通过类名）</span></span><br><span class="line">        <span class="keyword">Class</span> classobj3 = Student.<span class="keyword">class</span>;</span><br><span class="line">        System.out.<span class="keyword">println</span>(classobj3.getName());</span><br><span class="line">    }</span><br><span class="line">}复制代码</span><br></pre></td></tr></tbody></table></figure>
<h2 id="常用api"><a class="markdownIt-Anchor" href="#常用api"></a> 常用API</h2>
<h3 id="string相关"><a class="markdownIt-Anchor" href="#string相关"></a> String相关</h3>
<h4 id="字符型常量和字符串常量的区别"><a class="markdownIt-Anchor" href="#字符型常量和字符串常量的区别"></a> 字符型常量和字符串常量的区别</h4>
<ol>
<li>形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志)</li>
</ol>
<h4 id="什么是字符串常量池"><a class="markdownIt-Anchor" href="#什么是字符串常量池"></a> 什么是字符串常量池？</h4>
<ul>
<li>字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。</li>
</ul>
<h4 id="string-是最基本的数据类型吗"><a class="markdownIt-Anchor" href="#string-是最基本的数据类型吗"></a> String 是最基本的数据类型吗</h4>
<ul>
<li>不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char\[\] chars = {‘你’,‘好’};</span><br><span class="line">但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。</span><br></pre></td></tr></tbody></table></figure>
<h4 id="string有哪些特性"><a class="markdownIt-Anchor" href="#string有哪些特性"></a> String有哪些特性</h4>
<ul>
<li>不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。</li>
<li>常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。</li>
<li>final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。</li>
</ul>
<h4 id="string为什么是不可变的吗"><a class="markdownIt-Anchor" href="#string为什么是不可变的吗"></a> String为什么是不可变的吗？</h4>
<ul>
<li>
<p>简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以：</p>
<p>/** The value is used for character storage. */ private final char value[];</p>
</li>
</ul>
<h4 id="string真的是不可变的吗"><a class="markdownIt-Anchor" href="#string真的是不可变的吗"></a> String真的是不可变的吗？</h4>
<ul>
<li>我觉得如果别人问这个问题的话，回答不可变就可以了。 下面只是给大家看两个有代表性的例子：</li>
</ul>
<p><strong>1 String不可变但不代表引用不可以变</strong></p>
<figure class="highlight processing"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> <span class="built_in">str</span> = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">str</span> + <span class="string">" World"</span>;</span><br><span class="line">System.<span class="property">out</span>.<span class="property">println</span>(<span class="string">"str="</span> + <span class="built_in">str</span>);复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>结果：</p>
<p>str=Hello World</p>
</li>
<li>
<p>解析：</p>
</li>
<li>
<p>实际上，原来String的内容是不变的，只是str由原来指向"Hello"的内存地址转为指向"Hello World"的内存地址而已，也就是说多开辟了一块内存区域给"Hello World"字符串。</p>
</li>
</ul>
<p><strong>2.通过反射是可以修改所谓的“不可变”对象</strong></p>
<figure class="highlight awk"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 创建字符串<span class="string">"Hello World"</span>， 并赋给引用s</span><br><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="regexp">//</span> Hello World</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 获取String类中的value字段</span><br><span class="line">Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 改变value属性的访问权限</span><br><span class="line">valueFieldOfString.setAccessible(true);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 获取s对象上的value属性的值</span><br><span class="line">char[] value = (char[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> 改变value所引用的数组中的第<span class="number">5</span>个字符</span><br><span class="line">value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s); <span class="regexp">//</span> Hello_World复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>
<p>结果：</p>
<p>s = Hello World s = Hello_World</p>
</li>
<li>
<p>解析：</p>
</li>
<li>
<p>用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。</p>
</li>
</ul>
<h4 id="是否可以继承-string-类"><a class="markdownIt-Anchor" href="#是否可以继承-string-类"></a> 是否可以继承 String 类</h4>
<ul>
<li>String 类是 final 类，不可以被继承。</li>
</ul>
<h4 id="string-stri与-string-strnew-stringi一样吗"><a class="markdownIt-Anchor" href="#string-stri与-string-strnew-stringi一样吗"></a> String str="i"与 String str=new String(“i”)一样吗？</h4>
<ul>
<li>不一样，因为内存的分配方式不一样。String str="i"的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。</li>
</ul>
<h4 id="string-s-new-stringxyz创建了几个字符串对象"><a class="markdownIt-Anchor" href="#string-s-new-stringxyz创建了几个字符串对象"></a> String s = new String(“xyz”);创建了几个字符串对象</h4>
<ul>
<li>
<p>两个对象，一个是静态区的"xyz"，一个是用new创建在堆上的对象。</p>
<p>String str1 = “hello”; //str1指向静态区 String str2 = new String(“hello”);  //str2指向堆上的对象 String str3 = “hello”; String str4 = new String(“hello”); System.out.println(str1.equals(str2)); //true System.out.println(str2.equals(str4)); //true System.out.println(str1 == str3); //true System.out.println(str1 == str2); //false System.out.println(str2 == str4); //false System.out.println(str2 == “hello”); //false str2 = str1; System.out.println(str2 == “hello”); //true</p>
</li>
</ul>
<h4 id="如何将字符串反转"><a class="markdownIt-Anchor" href="#如何将字符串反转"></a> 如何将字符串反转？</h4>
<ul>
<li>
<p>使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。</p>
</li>
<li>
<p>示例代码：</p>
<p>// StringBuffer reverse StringBuffer stringBuffer = new StringBuffer(); stringBuffer. append(“abcdefg”); System. out. println(stringBuffer. reverse()); // gfedcba // StringBuilder reverse StringBuilder stringBuilder = new StringBuilder(); stringBuilder. append(“abcdefg”); System. out. println(stringBuilder. reverse()); // gfedcba</p>
</li>
</ul>
<h4 id="数组有没有-length方法string-有没有-length方法"><a class="markdownIt-Anchor" href="#数组有没有-length方法string-有没有-length方法"></a> 数组有没有 length()方法？String 有没有 length()方法</h4>
<ul>
<li>数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。</li>
</ul>
<h4 id="string-类的常用方法都有那些"><a class="markdownIt-Anchor" href="#string-类的常用方法都有那些"></a> String 类的常用方法都有那些？</h4>
<ul>
<li>indexOf()：返回指定字符的索引。</li>
<li>charAt()：返回指定索引处的字符。</li>
<li>replace()：字符串替换。</li>
<li>trim()：去除字符串两端空白。</li>
<li>split()：分割字符串，返回一个分割后的字符串数组。</li>
<li>getBytes()：返回字符串的 byte 类型数组。</li>
<li>length()：返回字符串长度。</li>
<li>toLowerCase()：将字符串转成小写字母。</li>
<li>toUpperCase()：将字符串转成大写字符。</li>
<li>substring()：截取字符串。</li>
<li>equals()：字符串比较。</li>
</ul>
<h4 id="在使用-hashmap-的时候用-string-做-key-有什么好处"><a class="markdownIt-Anchor" href="#在使用-hashmap-的时候用-string-做-key-有什么好处"></a> 在使用 HashMap 的时候，用 String 做 key 有什么好处？</h4>
<ul>
<li>HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为<font color="red">字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快</font>。</li>
</ul>
<h4 id="string和stringbuffer-stringbuilder的区别是什么string为什么是不可变的"><a class="markdownIt-Anchor" href="#string和stringbuffer-stringbuilder的区别是什么string为什么是不可变的"></a> String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的</h4>
<p><strong>可变性</strong></p>
<ul>
<li>String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。</li>
</ul>
<p><strong>线程安全性</strong></p>
<ul>
<li>String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
<p><strong>性能</strong></p>
<ul>
<li>每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</li>
</ul>
<p><strong>对于三者使用的总结</strong></p>
<ul>
<li>如果要操作少量的数据用 = String</li>
<li>单线程操作字符串缓冲区 下操作大量数据 = StringBuilder</li>
<li>多线程操作字符串缓冲区 下操作大量数据 = StringBuffer</li>
</ul>
<h3 id="date相关"><a class="markdownIt-Anchor" href="#date相关"></a> Date相关</h3>
<h3 id="包装类相关"><a class="markdownIt-Anchor" href="#包装类相关"></a> 包装类相关</h3>
<h4 id="自动装箱与拆箱"><a class="markdownIt-Anchor" href="#自动装箱与拆箱"></a> 自动装箱与拆箱</h4>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h4 id="int-和-integer-有什么区别"><a class="markdownIt-Anchor" href="#int-和-integer-有什么区别"></a> int 和 Integer 有什么区别</h4>
<ul>
<li>Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</li>
<li>Java 为每个原始类型提供了包装类型：
<ul>
<li>原始类型: boolean，char，byte，short，int，long，float，double</li>
<li>包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double</li>
</ul>
</li>
</ul>
<h4 id="integer-a-127-与-integer-b-127相等吗"><a class="markdownIt-Anchor" href="#integer-a-127-与-integer-b-127相等吗"></a> Integer a= 127 与 Integer b = 127相等吗</h4>
<ul>
<li>对于对象引用类型：==比较的是对象的内存地址。</li>
<li>对于基本数据类型：==比较的是值。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false</span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">    Integer a = new Integer(3);</span><br><span class="line">    Integer b = 3;  // 将3自动装箱成Integer类型</span><br><span class="line">    int c = 3;</span><br><span class="line">    System.out.println(a == b); // false 两个引用没有引用同一对象</span><br><span class="line">    System.out.println(a == c); // true a自动拆箱成int类型再和c比较</span><br><span class="line">    System.out.println(b == c); // true</span><br><span class="line"></span><br><span class="line">    Integer a1 = 128;</span><br><span class="line">    Integer b1 = 128;</span><br><span class="line">    System.out.println(a1 == b1); // false</span><br><span class="line"></span><br><span class="line">    Integer a2 = 127;</span><br><span class="line">    Integer b2 = 127;</span><br><span class="line">    System.out.println(a2 == b2); // true</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>作者：小杰要吃蛋<br>
链接：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127059738631">https://juejin.cn/post/6844904127059738631</a><br>
来源：稀土掘金<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/18/interview/java%E6%A0%B8%E5%BF%83%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95/" data-id="clihlibpk003nu4v6eei513n3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/java集合面试" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/18/interview/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/" class="article-date">
  <time class="post-time" datetime="2023-02-18T01:49:10.870Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">18</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/18/interview/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/">java集合面试</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-集合容器概述"><a class="markdownIt-Anchor" href="#1-集合容器概述"></a> 1. 集合容器概述</h1>
<h3 id="什么是集合"><a class="markdownIt-Anchor" href="#什么是集合"></a> 什么是集合</h3>
<ul>
<li>集合就是一个放数据的容器，准确的说是放数据对象引用的容器</li>
<li>集合类存放的都是对象的引用，而不是对象的本身</li>
<li>集合类型主要有3种：set(集）、list(列表）和map(映射)。</li>
</ul>
<h3 id="集合的特点"><a class="markdownIt-Anchor" href="#集合的特点"></a> 集合的特点</h3>
<ul>
<li>集合的特点主要有如下两点：
<ul>
<li>集合用于存储对象的容器，对象是用来封装数据，对象多了也需要存储集中式管理。</li>
<li>和数组对比对象的大小不确定。因为集合是可变长度的。数组需要提前定义大小</li>
</ul>
</li>
</ul>
<h3 id="集合和数组的区别"><a class="markdownIt-Anchor" href="#集合和数组的区别"></a> 集合和数组的区别</h3>
<ul>
<li>数组是固定长度的；集合可变长度的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；<strong>集合 只能存储 引用数据类型</strong>。</li>
<li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li>
</ul>
<h3 id="使用集合框架的好处"><a class="markdownIt-Anchor" href="#使用集合框架的好处"></a> 使用集合框架的好处</h3>
<ol>
<li>容量自增长；</li>
<li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li>
<li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li>
<li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li>
</ol>
<h3 id="常用的集合类有哪些"><a class="markdownIt-Anchor" href="#常用的集合类有哪些"></a> 常用的集合类有哪些？</h3>
<ul>
<li>Map接口和Collection接口是所有集合框架的父接口：</li>
</ul>
<ol>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ol>
<h3 id="listsetmap三者的区别"><a class="markdownIt-Anchor" href="#listsetmap三者的区别"></a> List，Set，Map三者的区别？</h3>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e70de4bd~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<ul>
<li>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</li>
<li>Collection集合主要有List和Set两大接口
<ul>
<li>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
</ul>
</li>
<li>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。
<ul>
<li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li>
</ul>
</li>
</ul>
<h3 id="集合框架底层数据结构"><a class="markdownIt-Anchor" href="#集合框架底层数据结构"></a> 集合框架底层数据结构</h3>
<ul>
<li>Collection
<ol>
<li>List
<ul>
<li>Arraylist： Object数组</li>
<li>Vector： Object数组</li>
<li>LinkedList： 双向循环链表</li>
</ul>
</li>
<li>Set
<ul>
<li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li>
</ul>
</li>
</ol>
</li>
<li>Map
<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，<strong>链表则是主要为了解决哈希冲突而存在的</strong>（“<strong>拉链法</strong>”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于<strong>拉链式散列结构</strong>即由<strong>数组</strong>和<strong>链表</strong>或<strong>红黑树</strong>组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li>TreeMap： <strong>红黑树</strong>（自平衡的排序二叉树）</li>
</ul>
</li>
</ul>
<h3 id="哪些集合类是线程安全的"><a class="markdownIt-Anchor" href="#哪些集合类是线程安全的"></a> 哪些集合类是线程安全的？</h3>
<ul>
<li>Vector：就比Arraylist多了个 synchronized （线程安全），因为效率较低，现在已经不太建议使用。</li>
<li>hashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li>
<li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由<strong>Segment数组结构</strong>和<strong>HashEntry数组结构</strong>组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。<strong>一个ConcurrentHashMap里包含一个Segment数组</strong>，Segment的结构和HashMap类似，是一种数组和链表结构；<strong>一个Segment里包含一个HashEntry数组</strong>，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）</li>
<li>…</li>
</ul>
<h3 id="java集合的快速失败机制-fail-fast"><a class="markdownIt-Anchor" href="#java集合的快速失败机制-fail-fast"></a> Java集合的快速失败机制 “fail-fast”？</h3>
<ul>
<li>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生 fail-fast 机制。</li>
<li>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</li>
<li>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</li>
<li>解决办法：
<ol>
<li>在遍历过程中，所有涉及到改变modCount值得地方全部加上<strong>synchronized</strong>。</li>
<li>使用<strong>CopyOnWriteArrayList</strong>来替换ArrayList</li>
</ol>
</li>
</ul>
<h3 id="怎么确保一个集合不能被修改"><a class="markdownIt-Anchor" href="#怎么确保一个集合不能被修改"></a> 怎么确保一个集合不能被修改？</h3>
<ul>
<li>
<p>可以使用 Collections. unmodifiableCollection(Collection c) 方法来创建一个只读集合，这样改变集合的任何操作都会抛出 Java. lang. UnsupportedOperationException 异常。</p>
</li>
<li>
<p>示例代码如下：</p>
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">list. <span class="built_in">add</span>("x");</span><br><span class="line">Collection&lt;String&gt; clist = Collections. <span class="built_in">unmodifiableCollection</span>(list);</span><br><span class="line">clist. <span class="built_in">add</span>("y"); <span class="comment">// 运行时此行报错</span></span><br><span class="line">System. out. <span class="built_in">println</span>(list. size());</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h1 id="2-collection接口"><a class="markdownIt-Anchor" href="#2-collection接口"></a> 2. Collection接口</h1>
<h3 id="list接口"><a class="markdownIt-Anchor" href="#list接口"></a> List接口</h3>
<h4 id="迭代器-iterator-是什么"><a class="markdownIt-Anchor" href="#迭代器-iterator-是什么"></a> 迭代器 Iterator 是什么？</h4>
<ul>
<li>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。</li>
<li>因为所有Collection接继承了Iterator迭代器</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e6f6342b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<h4 id="iterator-怎么使用有什么特点"><a class="markdownIt-Anchor" href="#iterator-怎么使用有什么特点"></a> Iterator 怎么使用？有什么特点？</h4>
<ul>
<li>
<p>Iterator 使用代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">Iterator&lt;String&gt; it = list. iterator();</span><br><span class="line"><span class="keyword">while</span>(it. hasNext()){</span><br><span class="line">  <span class="type">String</span> <span class="variable">obj</span> <span class="operator">=</span> it. next();</span><br><span class="line">  System. out. println(obj);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>Iterator 的特点是只能单向遍历，但是更加安全，因为它可以确保，在当前遍历的集合元素被更改的时候，就会抛出 ConcurrentModificationException 异常。</p>
</li>
</ul>
<h4 id="如何边遍历边移除-collection-中的元素"><a class="markdownIt-Anchor" href="#如何边遍历边移除-collection-中的元素"></a> 如何边遍历边移除 Collection 中的元素？</h4>
<ul>
<li>
<p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Integer&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()){</span><br><span class="line">   *<span class="comment">// do something*</span></span><br><span class="line">   it.remove();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p>一种最常见的<strong>错误</strong>代码如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Integer i : list){</span><br><span class="line">   list.remove(i)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>运行以上错误代码会报 <strong>ConcurrentModificationException 异常</strong>。这是因为当使用 foreach(for(Integer i : list)) 语句时，会自动生成一个iterator 来遍历该 list，但同时该 list 正在被 Iterator.remove() 修改。Java 一般不允许一个线程在遍历 Collection 时另一个线程修改它。</li>
</ul>
<h4 id="iterator-和-listiterator-有什么区别"><a class="markdownIt-Anchor" href="#iterator-和-listiterator-有什么区别"></a> Iterator 和 ListIterator 有什么区别？</h4>
<ul>
<li>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。</li>
<li>Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。</li>
<li>ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</li>
</ul>
<h4 id="遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么"><a class="markdownIt-Anchor" href="#遍历一个-list-有哪些不同的方式每种方法的实现原理是什么java-中-list-遍历的最佳实践是什么"></a> 遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List 遍历的最佳实践是什么？</h4>
<ul>
<li>遍历方式有以下几种：
<ol>
<li>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素，当读取到最后一个元素后停止。</li>
<li>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</li>
<li>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明 Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</li>
</ol>
</li>
<li>最佳实践：Java Collections 框架中提供了一个 <strong>RandomAccess</strong> 接口，用来标记 List 实现是否支持 Random Access。
<ul>
<li><strong>如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)</strong>，如ArrayList。</li>
<li>如果没有实现该接口，表示不支持 Random Access，如LinkedList。</li>
<li>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或 foreach 遍历。</li>
</ul>
</li>
</ul>
<h4 id="说一下-arraylist-的优缺点"><a class="markdownIt-Anchor" href="#说一下-arraylist-的优缺点"></a> 说一下 ArrayList 的优缺点</h4>
<ul>
<li>ArrayList的优点如下：
<ul>
<li>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</li>
<li>ArrayList 在顺序添加一个元素的时候非常方便。</li>
</ul>
</li>
<li>ArrayList 的缺点如下：
<ul>
<li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li>
<li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li>
</ul>
</li>
<li>ArrayList 比较适合顺序添加、随机访问的场景。</li>
</ul>
<h4 id="如何实现数组和-list-之间的转换"><a class="markdownIt-Anchor" href="#如何实现数组和-list-之间的转换"></a> 如何实现数组和 List 之间的转换？</h4>
<ul>
<li>
<p>数组转 List：使用 Arrays. asList(array) 进行转换。</p>
</li>
<li>
<p>List 转数组：使用 List 自带的 toArray() 方法。</p>
</li>
<li>
<p>代码示例：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// list to array</span></span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"123"</span>);</span><br><span class="line">list.add(<span class="string">"456"</span>);</span><br><span class="line">list.toArray();</span><br><span class="line"></span><br><span class="line"><span class="comment">// array to list</span></span><br><span class="line">String[] array = <span class="keyword">new</span> <span class="title class_">String</span>[]{<span class="string">"123"</span>,<span class="string">"456"</span>};</span><br><span class="line">Arrays.asList(array);</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="arraylist-和-linkedlist-的区别是什么"><a class="markdownIt-Anchor" href="#arraylist-和-linkedlist-的区别是什么"></a> ArrayList 和 LinkedList 的区别是什么？</h4>
<ul>
<li>
<p>数据结构实现：ArrayList 是<strong>动态数组</strong>的数据结构实现，而 LinkedList 是<strong>双向链表</strong>的数据结构实现。</p>
</li>
<li>
<p>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</p>
</li>
<li>
<p>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为 ArrayList 增删操作要影响数组内的其他数据的下标。</p>
</li>
<li>
<p>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</p>
</li>
<li>
<p>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</p>
</li>
<li>
<p>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</p>
</li>
<li>
<p>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</p>
</li>
</ul>
<h4 id="arraylist-和-vector-的区别是什么"><a class="markdownIt-Anchor" href="#arraylist-和-vector-的区别是什么"></a> ArrayList 和 Vector 的区别是什么？</h4>
<ul>
<li>这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合
<ul>
<li>线程安全：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。</li>
<li>性能：ArrayList 在性能方面要优于 Vector。</li>
<li>扩容：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。</li>
</ul>
</li>
<li>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</li>
<li>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</li>
</ul>
<h4 id="插入数据时arraylist-linkedlist-vector谁速度较快阐述-arraylist-vector-linkedlist-的存储性能和特性"><a class="markdownIt-Anchor" href="#插入数据时arraylist-linkedlist-vector谁速度较快阐述-arraylist-vector-linkedlist-的存储性能和特性"></a> 插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述 ArrayList、Vector、LinkedList 的存储性能和特性？</h4>
<ul>
<li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li>
<li>Vector 中的方法由于加了 synchronized 修饰，因此 <strong>Vector</strong> <strong>是线程安全容器，但性能上较ArrayList差</strong>。</li>
<li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 <strong>LinkedList</strong> <strong>插入速度较快</strong>。</li>
</ul>
<h4 id="多线程场景下如何使用-arraylist"><a class="markdownIt-Anchor" href="#多线程场景下如何使用-arraylist"></a> 多线程场景下如何使用 ArrayList？</h4>
<ul>
<li>
<p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; synchronizedList = Collections.synchronizedList(list);</span><br><span class="line">synchronizedList.add(<span class="string">"aaa"</span>);</span><br><span class="line">synchronizedList.add(<span class="string">"bbb"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; synchronizedList.size(); i++) {</span><br><span class="line">    System.out.println(synchronizedList.get(i));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h4 id="为什么-arraylist-的-elementdata-加上-transient-修饰"><a class="markdownIt-Anchor" href="#为什么-arraylist-的-elementdata-加上-transient-修饰"></a> 为什么 ArrayList 的 elementData 加上 transient 修饰？</h4>
<ul>
<li>
<p>ArrayList 中的数组定义如下：</p>
<p>private transient Object[] elementData;</p>
</li>
<li>
<p>再看一下 ArrayList 的定义：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">AbstractList</span>&lt;E&gt;</span><br><span class="line">     <span class="keyword">implements</span> <span class="title class_">List</span>&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>可以看到 ArrayList 实现了 Serializable 接口，这意味着 ArrayList 支持序列化。<mark><strong>transient</strong> 的作用是说不希望 elementData 数组被序列化，重写了 writeObject 实现</mark>：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span> <span class="keyword">throws</span> java.io.IOException{</span><br><span class="line">    *<span class="comment">// Write out element count, and any hidden stuff*</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">expectedModCount</span> <span class="operator">=</span> modCount;</span><br><span class="line">    s.defaultWriteObject();</span><br><span class="line">    *<span class="comment">// Write out array length*</span></span><br><span class="line">        s.writeInt(elementData.length);</span><br><span class="line">    *<span class="comment">// Write out all elements in the proper order.*</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            s.writeObject(elementData[i]);</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ConcurrentModificationException</span>();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>每次序列化时，先调用 defaultWriteObject() 方法序列化 ArrayList 中的非 transient 元素，然后遍历 elementData，只序列化已存入的元素，这样既加快了序列化的速度，又减小了序列化之后的文件大小。</p>
</li>
</ul>
<h4 id="list-和-set-的区别"><a class="markdownIt-Anchor" href="#list-和-set-的区别"></a> List 和 Set 的区别</h4>
<ul>
<li>List , Set 都是继承自Collection 接口</li>
<li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li>
<li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</li>
<li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li>
<li>Set和List对比
<ul>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变</li>
</ul>
</li>
</ul>
<h3 id="set接口"><a class="markdownIt-Anchor" href="#set接口"></a> Set接口</h3>
<h4 id="说一下-hashset-的实现原理"><a class="markdownIt-Anchor" href="#说一下-hashset-的实现原理"></a> 说一下 HashSet 的实现原理？</h4>
<ul>
<li>HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，HashSet 不允许重复的值。</li>
</ul>
<h4 id="hashset如何检查重复hashset是如何保证数据不可重复的"><a class="markdownIt-Anchor" href="#hashset如何检查重复hashset是如何保证数据不可重复的"></a> HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h4>
<ul>
<li>
<p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p>
</li>
<li>
<p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p>
</li>
<li>
<p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p>
</li>
<li>
<p>以下是HashSet 部分源码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">PRESENT</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">HashSet</span><span class="params">()</span> {</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> {</span><br><span class="line">    <span class="comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span></span><br><span class="line">	<span class="keyword">return</span> map.put(e, PRESENT)==<span class="literal">null</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p><strong>hashCode（）与equals（）的相关规定</strong>：</p>
<ol>
<li>如果两个对象相等，则hashcode一定也是相同的
<ul>
<li>hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li>
</ul>
</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li><strong>两个对象有相同的hashcode值，它们也不一定是相等的</strong></li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li>
</ol>
<p><strong>==与equals的区别</strong></p>
<ol>
<li>==是判断两个变量或实例是不是指向同一个<strong>内存空间</strong>；  equals是判断两个变量或实例所指向的**内存空间的<font color="red">值</font>**是不是相同</li>
<li>==是指对内存地址进行比较； equals()是对字符串的内容进行比较</li>
</ol>
<h4 id="hashset与hashmap的区别"><a class="markdownIt-Anchor" href="#hashset与hashmap的区别"></a> HashSet与HashMap的区别</h4>
<blockquote>
<table>
<thead>
<tr>
<th>HashMap</th>
<th>HashSet</th>
</tr>
</thead>
<tbody>
<tr>
<td>实现了Map接口</td>
<td>实现Set接口</td>
</tr>
<tr>
<td>存储键值对</td>
<td>仅存储对象</td>
</tr>
<tr>
<td>调用put（）向map中添加元素</td>
<td>调用add（）方法向Set中添加元素</td>
</tr>
<tr>
<td>HashMap使用键（Key）计算Hashcode</td>
<td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td>
</tr>
<tr>
<td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td>
<td>HashSet较HashMap来说比较慢</td>
</tr>
</tbody>
</table>
</blockquote>
<h1 id="3-map接口"><a class="markdownIt-Anchor" href="#3-map接口"></a> 3. Map接口</h1>
<h3 id="什么是hash算法"><a class="markdownIt-Anchor" href="#什么是hash算法"></a> 什么是Hash算法</h3>
<ul>
<li>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制<strong>值</strong>，这个较小的二进制值叫做哈希值。</li>
</ul>
<h3 id="什么是链表"><a class="markdownIt-Anchor" href="#什么是链表"></a> 什么是链表</h3>
<ul>
<li>
<p>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</p>
</li>
<li>
<p>链表大致分为单链表和双向链表</p>
<ol>
<li>
<p>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e72891e5~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
</li>
<li>
<p>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e73f80b0~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
<li>
<p>链表的优点</p>
<ul>
<li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li>
<li>内存利用率高，不会浪费内存（可以使用内存中细小的不连续空间（大于node节点的大小），并且在需要空间的时候才创建空间）</li>
<li>大小没有固定，拓展很灵活。</li>
</ul>
</li>
<li>
<p>链表的缺点</p>
<ul>
<li>不能随机查找，必须从第一个开始遍历，查找效率低</li>
</ul>
</li>
</ul>
<h3 id="说一下hashmap的实现原理"><a class="markdownIt-Anchor" href="#说一下hashmap的实现原理"></a> 说一下HashMap的实现原理？</h3>
<ul>
<li>
<p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p>
</li>
<li>
<p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p>
</li>
<li>
<p>HashMap 基于 Hash 算法实现的</p>
<ol>
<li>
<p>当我们往HashMap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</p>
</li>
<li>
<p>存储时，如果出现hash值相同的key，此时有两种情况。</p>
<p>​	(1)如果key相同，则覆盖原始值；</p>
<p>​	(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p>
</li>
<li>
<p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p>
</li>
<li>
<p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。</p>
</li>
</ol>
</li>
<li>
<p>需要注意<strong>Jdk 1.8中</strong>对HashMap的实现做了优化，<strong>当链表中的节点数据超过八个之后，该链表会转为<mark>红黑树</mark>来<mark>提高查询效率</mark></strong>，从原来的O(n)到O(logn)</p>
</li>
</ul>
<h3 id="hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现"><a class="markdownIt-Anchor" href="#hashmap在jdk17和jdk18中有哪些不同hashmap的底层实现"></a> HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3>
<ul>
<li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。**数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 <font color="red">拉链法</font> **的方式可以解决哈希冲突。</li>
</ul>
<h4 id="hashmap-jdk18之前"><a class="markdownIt-Anchor" href="#hashmap-jdk18之前"></a> HashMap JDK1.8之前</h4>
<ul>
<li>JDK1.8之前采用的是拉链法。<strong>拉链法</strong>：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e78f59a7~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<h4 id="hashmap-jdk18之后"><a class="markdownIt-Anchor" href="#hashmap-jdk18之后"></a> HashMap JDK1.8之后</h4>
<ul>
<li>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173551e7c6af15~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<h4 id="jdk17-vs-jdk18-比较"><a class="markdownIt-Anchor" href="#jdk17-vs-jdk18-比较"></a> JDK1.7 VS JDK1.8 比较</h4>
<ul>
<li>JDK1.8主要解决或优化了一下问题：
<ol>
<li>resize 扩容优化</li>
<li>引入了<strong>红黑树</strong>，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li>
<li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li>
</ol>
</li>
</ul>
<blockquote>
<table>
<thead>
<tr>
<th>不同</th>
<th>JDK 1.7</th>
<th>JDK 1.8</th>
</tr>
</thead>
<tbody>
<tr>
<td>存储结构</td>
<td>数组 + 链表</td>
<td>数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>初始化方式</td>
<td>单独函数：<code>inflateTable()</code></td>
<td>直接集成到了扩容函数<code>resize()</code>中</td>
</tr>
<tr>
<td>hash值计算方式</td>
<td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td>
<td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td>
</tr>
<tr>
<td>存放数据的规则</td>
<td>无冲突时，存放数组；冲突时，存放链表</td>
<td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt; 8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td>
</tr>
<tr>
<td>插入数据方式</td>
<td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td>
<td>尾插法（直接插入到链表尾部/红黑树）</td>
</tr>
<tr>
<td>扩容后存储位置的计算方式</td>
<td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td>
<td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td>
</tr>
</tbody>
</table>
</blockquote>
<h3 id="什么是红黑树"><a class="markdownIt-Anchor" href="#什么是红黑树"></a> 什么是红黑树</h3>
<h4 id="说道红黑树先讲什么是二叉树"><a class="markdownIt-Anchor" href="#说道红黑树先讲什么是二叉树"></a> 说道红黑树先讲什么是二叉树</h4>
<ul>
<li>
<p>二叉树简单来说就是 每一个节上可以关联俩个子节点</p>
<ul>
<li>
<pre class="highlight"><code class="css">大概就是这样子：
                       <span class="selector-tag">a</span>
                    /     \
                  <span class="selector-tag">b</span>          c
                / \         /  \
              d    e       f    g
            /  \  / \     / \   / \
           h   <span class="selector-tag">i</span>  j  k   l   m n   o
&lt;!<span class="attr">--code</span>￼<span class="number">9</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<ol>
<li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li>
<li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；</li>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；</li>
<li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向5；</li>
<li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。</li>
</ol>
<h3 id="hashmap的扩容操作是怎么实现的"><a class="markdownIt-Anchor" href="#hashmap的扩容操作是怎么实现的"></a> HashMap的扩容操作是怎么实现的？</h3>
<ol>
<li>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</li>
<li>每次扩展的时候，都是扩展2倍；</li>
<li>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。</li>
</ol>
<ul>
<li>
<p>在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() {</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;<span class="comment">//oldTab指向hash桶数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) {<span class="comment">//如果oldCap不为空的话，就是hash桶数组不为空</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) {<span class="comment">//如果大于最大容量了，就赋值为整数最大的阀值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;<span class="comment">//返回</span></span><br><span class="line">        }<span class="comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold 双倍扩容阀值threshold</span></span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化成最小2的n次幂</span></span><br><span class="line">    <span class="comment">// 直接将该值赋给新的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span></span><br><span class="line">    <span class="keyword">else</span> {               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 新的threshold = 新的cap * 0.75</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) {</span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    }</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="comment">// 计算出新的数组长度后赋给当前成员变量table</span></span><br><span class="line">    <span class="meta">@SuppressWarnings({"rawtypes","unchecked"})</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];<span class="comment">//新建hash桶数组</span></span><br><span class="line">    table = newTab;<span class="comment">//将新数组的值复制给旧的hash桶数组</span></span><br><span class="line">    <span class="comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使其均匀的分散</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) {</span><br><span class="line">        <span class="comment">// 遍历新数组的所有桶下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) {</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) {</span><br><span class="line">                <span class="comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无法被GC回收</span></span><br><span class="line">                oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">                <span class="comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">                    <span class="comment">// 用同样的hash映射算法把该元素加入新的数组</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span></span><br><span class="line">                <span class="keyword">else</span> { <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    <span class="comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表</span></span><br><span class="line">                    <span class="keyword">do</span> {             </span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) {</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e，e不一定是链表的第一个元素，初始化后loHead</span></span><br><span class="line">                                <span class="comment">// 代表下标保持不变的链表的头元素</span></span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span>                                </span><br><span class="line">                                <span class="comment">// loTail.next指向当前e</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            <span class="comment">// loTail指向当前的元素e</span></span><br><span class="line">                            <span class="comment">// 初始化后，loTail和loHead指向相同的内存，所以当loTail.next指向下一个元素时，</span></span><br><span class="line">                            <span class="comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span></span><br><span class="line">                            <span class="comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链表的元素。</span></span><br><span class="line">                            loTail = e;                           </span><br><span class="line">                        }</span><br><span class="line">                        <span class="keyword">else</span> {</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                <span class="comment">// 初始化head指向链表当前元素e, 初始化后hiHead代表下标更改的链表头元素</span></span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        }</span><br><span class="line">                    } <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，形成新的映射。</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) {</span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) {</span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<h3 id="hashmap是怎么解决哈希冲突的"><a class="markdownIt-Anchor" href="#hashmap是怎么解决哈希冲突的"></a> HashMap是怎么解决哈希冲突的？</h3>
<ul>
<li>答：在解决这个问题之前，我们首先需要知道<strong>什么是哈希冲突</strong>，而在了解哈希冲突之前我们还要知道<strong>什么是哈希</strong>才行；</li>
</ul>
<h4 id="什么是哈希"><a class="markdownIt-Anchor" href="#什么是哈希"></a> 什么是哈希？</h4>
<ul>
<li>Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</li>
</ul>
<h4 id="什么是哈希冲突"><a class="markdownIt-Anchor" href="#什么是哈希冲突"></a> 什么是哈希冲突？</h4>
<ul>
<li><strong>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）</strong>。</li>
</ul>
<h4 id="hashmap的数据结构"><a class="markdownIt-Anchor" href="#hashmap的数据结构"></a> HashMap的数据结构</h4>
<ul>
<li>在Java中，保存数据有两种比较简单的数据结构：数组和链表。
<ul>
<li>数组的特点是：寻址容易，插入和删除困难；</li>
<li>链表的特点是：寻址困难，但插入和删除容易；</li>
</ul>
</li>
<li>所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521c92dc84~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<ul>
<li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li>
<li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li>
<li><strong>但相比于hashCode返回的int类型，我们HashMap初始的容量大小<code>DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4</code>（即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表</strong>，所以我们还需要对hashCode作一定的优化</li>
</ul>
<h4 id="hash函数"><a class="markdownIt-Anchor" href="#hash函数"></a> hash()函数</h4>
<ul>
<li>
<p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于<strong>参与运算的只有hashCode的低位</strong>，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为<strong>扰动</strong>，在<strong>JDK 1.8</strong>中的hash()函数如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> {</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);<span class="comment">// 与自己右移16位进行异或运算（高低位异或）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>这比在<strong>JDK 1.7</strong>中，更为简洁，<strong>相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）</strong>；</p>
</li>
</ul>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<ul>
<li>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：
<ul>
<li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li>
<li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li>
</ul>
</li>
</ul>
<h3 id="能否使用任何类作为-map-的-key"><a class="markdownIt-Anchor" href="#能否使用任何类作为-map-的-key"></a> 能否使用任何类作为 Map 的 key？</h3>
<p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p>
<ul>
<li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li>
<li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li>
<li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li>
<li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li>
</ul>
<h3 id="为什么hashmap中string-integer这样的包装类适合作为k"><a class="markdownIt-Anchor" href="#为什么hashmap中string-integer这样的包装类适合作为k"></a> 为什么HashMap中String、Integer这样的包装类适合作为K？</h3>
<ul>
<li>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率
<ul>
<li>都是<strong>final类型</strong>，即<strong>不可变性</strong>，保证key的不可更改性，不会存在获取hash值不同的情况</li>
<li>内部已重写了<code>equals()</code>、<code>hashCode()</code>等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li>
</ul>
</li>
</ul>
<h3 id="如果使用object作为hashmap的key应该怎么办呢"><a class="markdownIt-Anchor" href="#如果使用object作为hashmap的key应该怎么办呢"></a> 如果使用Object作为HashMap的Key，应该怎么办呢？</h3>
<ul>
<li>
<p>答：重写</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashCode()</span><br></pre></td></tr></tbody></table></figure>
<p>和</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">equals()</span><br></pre></td></tr></tbody></table></figure>
<p>方法</p>
<ol>
<li><strong>重写<code>hashCode()</code>是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li>
<li><strong>重写<code>equals()</code>方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用值x，x.equals(null)必须返回false的这几个特性，<strong>目的是为了保证key在哈希表中的唯一性</strong>；</li>
</ol>
</li>
</ul>
<h3 id="hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标"><a class="markdownIt-Anchor" href="#hashmap为什么不直接使用hashcode处理后的哈希值直接作为table的下标"></a> HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h3>
<ul>
<li>答：<code>hashCode()</code>方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过<code>hashCode()</code>计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li>
<li><strong>那怎么解决呢？</strong>
<ol>
<li>HashMap自己实现了自己的<code>hash()</code>方法，通过两次扰动使得它自己的哈希值高低位自行进行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li>
<li>在保证数组长度为2的幂次方的时候，使用<code>hash()</code>运算之后的值与运算（&amp;）（数组长度 - 1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大小范围不匹配”的问题；</li>
</ol>
</li>
</ul>
<h3 id="hashmap-的长度为什么是2的幂次方"><a class="markdownIt-Anchor" href="#hashmap-的长度为什么是2的幂次方"></a> HashMap 的长度为什么是2的幂次方</h3>
<ul>
<li>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</li>
<li><strong>这个算法应该如何设计呢？</strong>
<ul>
<li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li>
</ul>
</li>
<li><strong>那为什么是两次扰动呢？</strong>
<ul>
<li>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li>
</ul>
</li>
</ul>
<h3 id="hashmap-与-hashtable-有什么区别"><a class="markdownIt-Anchor" href="#hashmap-与-hashtable-有什么区别"></a> HashMap 与 HashTable 有什么区别？</h3>
<ol>
<li><strong>线程安全</strong>： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 <code>synchronized</code> 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li><strong>效率</strong>： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li>
<li><strong>对Null key 和Null value的支持</strong>： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li>
<li>初始容量大小和每次扩充容量大小的不同：
<ol>
<li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为<strong>11</strong>，之后每次扩充，容量变为原来的<strong>2n+1</strong>。HashMap 默认的初始化大小为<strong>16</strong>。之后每次扩充，容量变为原来的<strong>2倍</strong>。</li>
<li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小（为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同）。</li>
</ol>
</li>
<li><strong>底层数据结构</strong>： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
<li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，如果需要多线程使用则用 ConcurrentHashMap 替代。</li>
</ol>
<h3 id="什么是treemap-简介"><a class="markdownIt-Anchor" href="#什么是treemap-简介"></a> 什么是TreeMap 简介</h3>
<ul>
<li>TreeMap 是一个<strong>有序的key-value集合</strong>，它是通过红黑树实现的。</li>
<li>TreeMap基于<strong>红黑树（Red-Black tree）实现</strong>。该映射根据<strong>其键的自然顺序进行排序</strong>，或者根据<strong>创建映射时提供的 Comparator 进行排序</strong>，具体取决于使用的构造方法。</li>
<li>TreeMap是线程<strong>非同步</strong>的。</li>
</ul>
<h3 id="如何决定使用-hashmap-还是-treemap"><a class="markdownIt-Anchor" href="#如何决定使用-hashmap-还是-treemap"></a> 如何决定使用 HashMap 还是 TreeMap？</h3>
<ul>
<li>对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，<strong>将map换为TreeMap进行有序key的遍历</strong>。</li>
</ul>
<h3 id="hashmap-和-concurrenthashmap-的区别"><a class="markdownIt-Anchor" href="#hashmap-和-concurrenthashmap-的区别"></a> HashMap 和 ConcurrentHashMap 的区别</h3>
<ol>
<li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li>
<li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li>
</ol>
<h3 id="concurrenthashmap-和-hashtable-的区别"><a class="markdownIt-Anchor" href="#concurrenthashmap-和-hashtable-的区别"></a> ConcurrentHashMap 和 Hashtable 的区别？</h3>
<ul>
<li>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。
<ul>
<li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li>实现线程安全的方式：
<ol>
<li><strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</li>
<li>② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ol>
</li>
</ul>
</li>
<li><strong>两者的对比图</strong>：</li>
</ul>
<h5 id="1-hashtable"><a class="markdownIt-Anchor" href="#1-hashtable"></a> 1、HashTable:</h5>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521ca71b79~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<h5 id="2-jdk17的concurrenthashmap"><a class="markdownIt-Anchor" href="#2-jdk17的concurrenthashmap"></a> 2、 JDK1.7的ConcurrentHashMap：</h5>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735521de4886d~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<h5 id="3-jdk18的concurrenthashmaptreebin-红黑二叉树节点-node-链表节点"><a class="markdownIt-Anchor" href="#3-jdk18的concurrenthashmaptreebin-红黑二叉树节点-node-链表节点"></a> 3、JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</h5>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735522b19186a~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<ul>
<li>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</li>
</ul>
<h3 id="concurrenthashmap-底层具体实现知道吗实现原理是什么"><a class="markdownIt-Anchor" href="#concurrenthashmap-底层具体实现知道吗实现原理是什么"></a> ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h3>
<h4 id="jdk17"><a class="markdownIt-Anchor" href="#jdk17"></a> JDK1.7</h4>
<ul>
<li>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</li>
<li>在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：</li>
<li>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735524c5089b8~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<ol>
<li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li>
<li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li>
</ol>
<h4 id="jdk18"><a class="markdownIt-Anchor" href="#jdk18"></a> JDK1.8</h4>
<ul>
<li>在<strong>JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现</strong>，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</li>
<li>结构如下：</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/17173552564c22be~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="在这里插入图片描述"></p>
<ul>
<li>
<p><strong>附加源码，有需要的可以看看</strong></p>
</li>
<li>
<p>插入元素过程（建议去看看源码）：</p>
</li>
<li>
<p>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="literal">null</span>) {</span><br><span class="line">    <span class="keyword">if</span> (casTabAt(tab, i, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>)))</span><br><span class="line">        <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) {</span><br><span class="line">    binCount = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) {</span><br><span class="line">        K ek;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((ek = e.key) == key ||</span><br><span class="line">             (ek != <span class="literal">null</span> &amp;&amp; key.equals(ek)))) {</span><br><span class="line">            oldVal = e.val;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                e.val = value;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        Node&lt;K,V&gt; pred = e;</span><br><span class="line">        <span class="keyword">if</span> ((e = e.next) == <span class="literal">null</span>) {</span><br><span class="line">            pred.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;K,V&gt;(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<ol>
<li>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</li>
<li>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</li>
</ol>
<h1 id="4-辅助工具类"><a class="markdownIt-Anchor" href="#4-辅助工具类"></a> 4. 辅助工具类</h1>
<h3 id="array-和-arraylist-有何区别"><a class="markdownIt-Anchor" href="#array-和-arraylist-有何区别"></a> Array 和 ArrayList 有何区别？</h3>
<ul>
<li>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</li>
<li>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</li>
<li>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList 有。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="如何实现-array-和-list-之间的转换"><a class="markdownIt-Anchor" href="#如何实现-array-和-list-之间的转换"></a> 如何实现 Array 和 List 之间的转换？</h3>
<ul>
<li>Array 转 List： Arrays. asList(array) ；</li>
<li>List 转 Array：List 的 toArray() 方法。</li>
</ul>
<h3 id="comparable-和-comparator的区别"><a class="markdownIt-Anchor" href="#comparable-和-comparator的区别"></a> comparable 和 comparator的区别？</h3>
<ul>
<li>
<p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p>
</li>
<li>
<p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p>
</li>
<li>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>
</li>
</ul>
<h3 id="collection-和-collections-有什么区别"><a class="markdownIt-Anchor" href="#collection-和-collections-有什么区别"></a> Collection 和 Collections 有什么区别？</h3>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素"><a class="markdownIt-Anchor" href="#treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素"></a> TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3>
<ul>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li>
<li>Collections 工具类的 sort 方法有两种重载的形式，</li>
<li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li>
</ul>
<p>？</p>
<ul>
<li>
<p>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</p>
</li>
<li>
<p>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序</p>
</li>
<li>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</p>
</li>
</ul>
<h3 id="collection-和-collections-有什么区别-2"><a class="markdownIt-Anchor" href="#collection-和-collections-有什么区别-2"></a> Collection 和 Collections 有什么区别？</h3>
<ul>
<li>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。</li>
<li>Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</li>
</ul>
<h3 id="treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素-2"><a class="markdownIt-Anchor" href="#treemap-和-treeset-在排序时如何比较元素collections-工具类中的-sort方法如何比较元素-2"></a> TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3>
<ul>
<li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的 compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li>
<li>Collections 工具类的 sort 方法有两种重载的形式，
<ul>
<li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li>
<li>第二种不强制性的要求容器中的元素必须可比较，但是要求传入第二个参数，参数是Comparator 接口的子类型（需要重写 compare 方法实现元素的比较），相当于一个临时定义的排序规则，其实就是通过接口注入比较元素大小的算法，也是对回调模式的应用（Java 中对函数式编程的支持）。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/18/interview/java%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/" data-id="clihlibpo003uu4v6ctdffwp4" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-interview/mysql面试题" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/02/17/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" class="article-date">
  <time class="post-time" datetime="2023-02-17T05:23:49.183Z" itemprop="datePublished">
    <span class="post-month">2月</span><br/>
    <span class="post-day">17</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/02/17/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">Mysql面试题</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/">面试题</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>CSDN的博文：<a target="_blank" rel="noopener" href="https://blog.csdn.net/adminpd/article/details/122910606">(9条消息) MySQL数据库面试题总结（2022最新版）_程序猿周周的博客-CSDN博客_mysql 面试题</a></p>
<p>稀土掘金的博文：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904127047139335#heading-17">MySQL面试题（总结最全面的面试题） - 掘金 (juejin.cn)</a></p>
<h1 id="0-基本概念"><a class="markdownIt-Anchor" href="#0-基本概念"></a> 0. 基本概念</h1>
<h2 id="1-mysql有哪些数据库类型"><a class="markdownIt-Anchor" href="#1-mysql有哪些数据库类型"></a> 1、MySQL有哪些数据库类型？</h2>
<h3 id="数值类型"><a class="markdownIt-Anchor" href="#数值类型"></a> 数值类型</h3>
<p>有包括 TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示 1 字节、2 字节、3 字节、4 字节、8 字节的整数类型。</p>
<p>1）任何整数类型都可以加上 UNSIGNED 属性，表示无符号整数。</p>
<p>2）任何整数类型都可以指定长度，但它不会限制数据的合法长度，仅仅限制了显示长度。</p>
<p>还有包括 FLOAT、DOUBLE、DECIMAL 在内的小数类型。</p>
<h3 id="字符串类型"><a class="markdownIt-Anchor" href="#字符串类型"></a> 字符串类型</h3>
<p>包括 VARCHAR、CHAR、TEXT、BLOB。</p>
<p>注意：VARCHAR(n) 和 CHAR(n) 中的 n 并不代表字节个数，而是代表字符的个数。</p>
<h3 id="日期和时间类型"><a class="markdownIt-Anchor" href="#日期和时间类型"></a> 日期和时间类型</h3>
<p>常用于表示日期和时间类型为 DATETIME、DATE 和 TIMESTAMP。</p>
<p>尽量使用 TIMESTAMP，空间效率高于 DATETIME。</p>
<p>ref MySQL 数据类型</p>
<h2 id="2-char-和-varchar-区别"><a class="markdownIt-Anchor" href="#2-char-和-varchar-区别"></a> 2、CHAR 和 VARCHAR 区别？</h2>
<p>1）首先可以明确的是 CHAR 是定长的，而 VARCHAR 是可以变长。</p>
<p>CHAR 会根据声明的字符串长度分配空间，并会使用空格对字符串右边进行尾部填充。所以在检索 CHAR 类型数据时尾部空格会被删除，如保存的是字符串 'char '，但最后查询到的是 ‘char’。又因为长度固定，所以存储效率高于 VARCHAR 类型。</p>
<p>VARCHAR 在 MySQL 5.0 之后长度支持到 65535 字节，但会在数据开头使用额外 1~2 个字节存储字符串长度（列长度小于 255 字节时使用 1 字节表示，否则 2 字节），在结尾使用 1 字节表示字符串结束。</p>
<p>2）再者，在存储方式上，CHAR 对英文字符（ASCII）占用 1 字节，对一个汉字使用用 2 字节。而 VARCHAR 对每个字符均使用 2 字节。</p>
<p>虽然 VARCHAR 是根据字符串长度分配存储空间的，但在内存中依旧使用声明长度进行排序等作业，故在使用时仍需综合考量字段长度。</p>
<h2 id="3-char-和-varchar-如何选择"><a class="markdownIt-Anchor" href="#3-char-和-varchar-如何选择"></a> 3、CHAR 和 VARCHAR 如何选择？</h2>
<p>1）对于经常变更的数据来说，CHAR 比 VARCHAR更好，因为 CHAR 不容易产生碎片。</p>
<p>2）对于非常短的列或固定长度的数据（如 MD5），CHAR 比 VARCHAR 在存储空间上更有效率。</p>
<p>4）使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。</p>
<p>4）尽量避免使用 TEXT/BLOB 类型，查询时会使用临时表，导致严重的性能开销。</p>
<h2 id="4-charvarchar-和-text-的区别"><a class="markdownIt-Anchor" href="#4-charvarchar-和-text-的区别"></a> 4、CHAR，VARCHAR 和 Text 的区别？</h2>
<p>1）长度区别</p>
<p>Char 范围是 0～255。</p>
<p>Varchar 最长是 64k（注意这里的 64k 是整个 row 的长度，要考虑到其它的 column，还有如果存在 not null 的时候也会占用一位，对不同的字符集，有效长度还不一样，比如 utf-8 的，最多 21845，还要除去别的column），但 Varchar 在一般情况下存储都够用了。</p>
<p>如果遇到了大文本，考虑使用 Text，最大能到 4G（其中 TEXT 长度 65,535 bytes，约 64kb；MEDIUMTEXT 长度 16,777,215 bytes，约 16 Mb；而 LONGTEXT 长度 4,294,967,295 bytes，约 4Gb）。</p>
<p>2）效率区别</p>
<p>效率来说基本是 Char &gt; Varchar &gt; Text，但是如果使用的是 Innodb 引擎的话，推荐使用 Varchar 代替 Char。</p>
<p>3）默认值区别</p>
<p>Char 和 Varchar 支持设置默认值，而 Text 不能指定默认值。</p>
<h1 id="1-数据库三大范式是什么"><a class="markdownIt-Anchor" href="#1-数据库三大范式是什么"></a> 1. 数据库三大范式是什么？</h1>
<p><strong>什么是范式？</strong><br>
范式是数据库设计时遵循的一种规范，不同的规范要求遵循不同的范式。</p>
<p><strong>最常用的三大范式</strong></p>
<ul>
<li>
<p>第一范式(1NF)：<strong>属性不可分割</strong>，即每个属性都是不可分割的原子项。(实体的属性即表中的列)</p>
</li>
<li>
<p>第二范式(2NF)：<strong>满足第一范式；且不存在部分依赖</strong>，即非主属性必须完全依赖于主属性。(主属性即主键；完全依赖是针对于联合主键的情况，非主键列不能只依赖于主键的一部分)</p>
</li>
<li>
<p>第三范式(3NF)：<strong>满足第二范式；且不存在传递依赖</strong>，即非主属性不能与非主属性之间有依赖关系，非主属性必须直接依赖于主属性，不能间接依赖主属性。（A -&gt; B, B -&gt;C, A -&gt; C）</p>
</li>
</ul>
<p><strong>举例说明3NF：</strong><br>
<strong>1NF</strong><br>
属性不可再分，即表中的每个列都不可以再进行拆分。</p>
<p>如下学生信息表(student)：</p>
<p>id、name(姓名)、sex_code(性别代号)、sex_desc(性别描述)、contact(联系方式)</p>
<p>primary key(id)</p>
<p><img src="../../images/image-20230217143546366.png" alt="image-20230217143546366"><br>
如果在查询学生表时经常用到学生的电话号，则应该将联系方式(contact)这一列分为电话号(phone)和地址(address)两列，这样才符合第一范式。</p>
<p>修改使表满足1NF后：</p>
<p><img src="../../images/image-20230217143559491.png" alt="image-20230217143559491"><br>
判断表是否符合第一范式，列是否可以再分，得看需求，如果将电话号和地址分开才能满足查询等需求时，那之前的表设计就是不满足1NF的，如果电话号和地址拼接作为一个字段也可以满足查询、存储等需求时，那它就满足1NF。</p>
<p><strong>2NF</strong><br>
在满足1NF的前提下，表中不存在部分依赖，非主键列要完全依赖于主键。(主要是说在联合主键的情况下，非主键列不能只依赖于主键的一部分)</p>
<p>如下学生成绩表(score)：</p>
<p>stu_id(学生id)、kc_id(课程id)、score(分数)、kc_name(课程名)</p>
<p>primary key(stu_id, kc_id)</p>
<p><img src="../../images/image-20230217143616904.png" alt="image-20230217143616904"><br>
表中主键为stu_id和kc_id组成的联合主键。满足1NF；非主键列score完全依赖于主键，stu_id和kc_id两个值才能决定score的值；而kc_name只依赖于kc_id，与stu_id没有依赖关系，它不完全依赖于主键，只依赖于主键的一部分，不符合2NF。</p>
<p>修改使表满足2NF后：</p>
<p>成绩表(score)   primary key(stu_id)</p>
<p><img src="../../images/image-20230217143630898.png" alt="image-20230217143630898"><br>
课程表(kc)   primary key(kc_id)</p>
<p><img src="../../images/image-20230217143724321.png" alt="image-20230217143724321"><br>
将原来的成绩表(score)拆分为成绩表(score)和课程表(kc)，而且两个表都符合2NF。</p>
<p><strong>3NF：</strong><br>
在满足2NF的前提下，不存在传递依赖。(A -&gt; B, B -&gt; C, A-&gt;C)</p>
<p>如下学生信息表(student)：</p>
<p>primary key(id)</p>
<p><img src="../../images/image-20230217143739281.png" alt="image-20230217143739281"><br>
表中sex_desc依赖于sex_code，而sex_code依赖于id(主键)，从而推出sex_desc依赖于id(主键)；sex_desc不直接依赖于主键，而是通过依赖于非主键列而依赖于主键，属于传递依赖，不符合3NF。</p>
<p>修改表使满足3NF后：</p>
<p>学生表(student)   primary key(id)</p>
<p><img src="../../images/image-20230217143753961.png" alt="image-20230217143753961"><br>
性别代码表(sexcode)   primary key(sex_code)</p>
<p><img src="../../images/image-20230217143810165.png" alt="image-20230217143810165"><br>
将原来的student表进行拆分后，两个表都满足3NF。</p>
<p><strong>什么样的表越容易符合3NF？</strong><br>
非主键列越少的表。(1NF强调列不可再分；2NF和3NF强调非主属性列和主属性列之间的关系)</p>
<p>如代码表(sexcode)，非主键列只有一个sex_desc；</p>
<p>或者将学生表的主键设计为primary key(id,name,sex_code,phone)，这样非主键列只有address，更容易符合3NF。</p>
<p><strong>ps:</strong></p>
<p><strong>除了三大范式外，还有BC范式和第四范式，但其规范过于严苛，在生产中往往使用不到。</strong></p>
<h1 id="2-什么是范式和反范式以及各自优缺点"><a class="markdownIt-Anchor" href="#2-什么是范式和反范式以及各自优缺点"></a> 2. 什么是范式和反范式，以及各自优缺点？</h1>
<p>范式是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。</p>
<p><img src="../../images/image-20230217144222018.png" alt="image-20230217144222018"><br>
所以在平时工作中，我们通常是将范式和反范式相互结合使用。</p>
<h1 id="3-索引"><a class="markdownIt-Anchor" href="#3-索引"></a> 3. 索引</h1>
<h2 id="1-索引的几种类型或分类"><a class="markdownIt-Anchor" href="#1-索引的几种类型或分类"></a> 1、索引的几种类型或分类？</h2>
<ul>
<li>
<p>从<strong>物理结构</strong>上可以分为聚集索引和非聚集索引两类：</p>
<ul>
<li><strong>聚簇索引</strong>指索引的键值的逻辑顺序与表中相应行的物理顺序一致，即每张表只能有一个聚簇索引，也就是我们常说的<strong>主键索引</strong>；</li>
<li>非聚簇索引的逻辑顺序则与数据行的物理顺序不一致。</li>
</ul>
</li>
<li>
<p>从<strong>应用</strong>上可以划分为一下几类：</p>
<ul>
<li><strong>普通索引</strong>：MySQL 中的基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了提高查询效率。通过<mark> ALTER TABLE table_name ADD INDEX index_name (column) </mark>创建；</li>
<li><strong>唯一索引</strong>：索引列中的值必须是唯一的，但是允许为空值。通过 <mark>ALTER TABLE table_name ADD UNIQUE index_name (column)</mark> 创建；</li>
<li><strong>主键索引</strong>：特殊的唯一索引，也成聚簇索引，不允许有空值，并由数据库帮我们自动创建；</li>
<li><strong>组合索引</strong>：组合表中多个字段创建的索引，遵守最左前缀匹配规则；</li>
<li><strong>全文索引</strong>：只有在 MyISAM 引擎上才能使用，同时只支持 CHAR、VARCHAR、TEXT 类型字段上使用。</li>
</ul>
</li>
</ul>
<h2 id="2-索引的优缺点"><a class="markdownIt-Anchor" href="#2-索引的优缺点"></a> 2、索引的优缺点？</h2>
<p>先来说说**优点：**创建索引可以大大提高系统的性能。</p>
<ul>
<li>
<p>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p>
</li>
<li>
<p>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p>
</li>
<li>
<p>可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p>
</li>
<li>
<p>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p>
</li>
<li>
<p>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p>
</li>
</ul>
<p>既然增加索引有如此多的优点，为什么不对表中的每一个列都创建一个索引呢？这是因为索引也是有<strong>缺点</strong>的：</p>
<ul>
<li>
<p>创建和维护索引需要耗费时间，这种时间随着数据量的增加而增加，这样就降低了数据的维护速度。</p>
</li>
<li>
<p>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</p>
</li>
</ul>
<h2 id="3-索引设计的原则"><a class="markdownIt-Anchor" href="#3-索引设计的原则"></a> 3. 索引设计的原则</h2>
<ul>
<li>
<p><strong>选择唯一性索引；</strong></p>
<ul>
<li>唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</li>
</ul>
</li>
<li>
<p><strong>为常作为查询条件的字段建立索引；</strong></p>
<ul>
<li>如果某个字段经常用来做查询条件，那么该字段的查询速度会影响整个表的查询速度。因此，为这样的字段建立索引，可以提高整个表的查询速度。</li>
</ul>
</li>
<li>
<p><strong>为经常需要排序、分组和联合操作的字段建立索引；</strong></p>
<ul>
<li>经常需要 ORDER BY、GROUP BY、DISTINCT 和 UNION 等操作的字段，排序操作会浪费很多时间。如果为其建立索引，可以有效地避免排序操作。</li>
</ul>
</li>
<li>
<p><strong>限制索引的数目；</strong></p>
<ul>
<li>每个索引都需要占用磁盘空间，索引越多，需要的磁盘空间就越大，修改表时，对索引的重构和更新很麻烦。</li>
</ul>
</li>
<li>
<p><strong>小表不建议索引（如数量级在百万以内）；</strong></p>
<ul>
<li>由于数据较小，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。</li>
</ul>
</li>
<li>
<p><strong>尽量使用数据量少的索引；</strong></p>
<ul>
<li>如果索引的值很长，那么查询的速度会受到影响。此时尽量使用前缀索引。</li>
</ul>
</li>
<li>
<p><strong>删除不再使用或者很少使用的索引。</strong></p>
</li>
</ul>
<h2 id="4-索引的数据结构"><a class="markdownIt-Anchor" href="#4-索引的数据结构"></a> 4. 索引的数据结构？</h2>
<p>索引的数据结构和具体存储引擎的实现有关，MySQL中常用的是 <strong>Hash</strong> 和 <strong>B+树</strong> 索引。</p>
<ul>
<li><strong>Hash 索引</strong>底层就是 Hash 表，进行查询时调用 Hash 函数获取到相应的键值（对应地址），然后回表查询获得实际数据.</li>
<li><strong>B+ 树索引</strong>底层实现原理是多路平衡查找树，对于每一次的查询都是从根节点出发，查询到叶子节点方可以获得所查键值，最后查询判断是否需要回表查询.</li>
</ul>
<h4 id="hash-和-b-树索引的区别"><a class="markdownIt-Anchor" href="#hash-和-b-树索引的区别"></a> Hash 和 B+ 树索引的区别</h4>
<ul>
<li>
<p>Hash</p>
<ul>
<li>Hash 进行等值查询更快，但无法进行范围查询。因为经过 Hash 函数建立索引之后，索引的顺序与原顺序无法保持一致，故不能支持范围查询。同理，也不支持使用索引进行排序。</li>
<li>Hash 不支持模糊查询以及多列索引的最左前缀匹配,因为 Hash 函数的值不可预测，如 AA 和 AB 的算出的值没有相关性。</li>
<li>Hash 任何时候都避免不了回表查询数据.</li>
<li>虽然在等值上查询效率高，但性能不稳定，因为当某个键值存在大量重复时，产生 Hash 碰撞，此时查询效率反而可能降低。</li>
</ul>
</li>
<li>
<p>B+ Tree</p>
<ul>
<li>B+ 树本质是一棵查找树，自然支持范围查询和排序。</li>
<li>在符合某些条件（聚簇索引、覆盖索引等）时候可以只通过索引完成查询，不需要回表。</li>
<li>查询效率比较稳定，因为每次查询都是从根节点到叶子节点，且为树的高度。</li>
</ul>
</li>
</ul>
<h2 id="5-为何使用-b-树而非-b-树做索引"><a class="markdownIt-Anchor" href="#5-为何使用-b-树而非-b-树做索引"></a> 5. 为何使用 B+ 树而非 B 树做索引？</h2>
<h4 id="51-先来了解一下-b-树和-b-树的区别"><a class="markdownIt-Anchor" href="#51-先来了解一下-b-树和-b-树的区别"></a> 5.1.  先来了解一下 B+ 树和 B 树的区别：</h4>
<ul>
<li>
<p>B 树非叶子结点和叶子结点都存储数据，因此查询数据时，时间复杂度最好为 O(1)，最坏为 O(log n)。而 <strong>B+ 树只在叶子结点存储数据，非叶子结点存储关键字</strong>，且不同非叶子结点的关键字可能重复，因此查询数据时，时间复杂度固定为 O(log n)。</p>
</li>
<li>
<p>B+ 树叶子结点之间用<strong>链表</strong>相互连接，因而只需扫描叶子结点的链表就可以完成一次遍历操作，B 树只能通过中序遍历。</p>
</li>
</ul>
<h4 id="52-为什么-b-树比-b-树更适合应用于数据库索引"><a class="markdownIt-Anchor" href="#52-为什么-b-树比-b-树更适合应用于数据库索引"></a> 5.2. 为什么 B+ 树比 B 树更适合应用于数据库索引？</h4>
<ul>
<li>
<p>B+ 树减少了 IO 次数。</p>
<ul>
<li>由于索引文件很大因此索引文件存储在磁盘上，B+ 树的非叶子结点只存关键字不存数据，因而单个页可以存储更多的关键字，即一次性读入内存的需要查找的关键字也就越多，磁盘的随机 I/O 读取次数相对就减少了。</li>
</ul>
</li>
<li>
<p>B+ 树查询效率更稳定</p>
<ul>
<li>由于数据只存在在叶子结点上，所以查找效率固定为 O(log n)，所以 B+ 树的查询效率相比B树更加稳定。</li>
</ul>
</li>
<li>
<p>B+ 树更加适合范围查找</p>
<ul>
<li>B+ 树叶子结点之间用链表有序连接，所以扫描全部数据只需扫描一遍叶子结点，利于扫库和范围查询；B 树由于非叶子结点也存数据，所以只能通过中序遍历按序来扫。也就是说，对于范围查询和有序遍历而言，B+ 树的效率更高。</li>
</ul>
</li>
</ul>
<h2 id="6-什么是覆盖索引"><a class="markdownIt-Anchor" href="#6-什么是覆盖索引"></a> 6. 什么是覆盖索引？</h2>
<p>覆盖索引（covering index）指<strong>一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取</strong>。 也可以称之为实现了索引覆盖。 如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。 <strong>当一条查询语句符合覆盖索引条件时，sql只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率</strong></p>
<h2 id="7-什么是索引下推"><a class="markdownIt-Anchor" href="#7-什么是索引下推"></a> 7. 什么是索引下推？</h2>
<p><strong>索引下推（Index condition pushdown）</strong> 简称 ICP，在 Mysql 5.6 版本上推出的一项用于<mark>优化查询</mark>的技术。</p>
<p>在不使用索引下推的情况下，在使用非主键索引进行查询时，存储引擎通过索引检索到数据，然后返回给 MySQL 服务器，服务器判断数据是否符合条件。</p>
<p>而有了索引下推之后，如果存在某些被索引列的判断条件时，MySQL 服务器将这一部分判断条件传递给存储引擎，然后由存储引擎通过判断索引是否符合 MySQL 服务器传递的条件，只有当索引符合条件时才会将数据检索出来返回给 MySQL 服务器。</p>
<p><strong>索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少 MySQL 服务器从存储引擎接收数据的次数。</strong></p>
<h1 id="4-存储"><a class="markdownIt-Anchor" href="#4-存储"></a> 4. 存储</h1>
<h2 id="41-有哪些常见的存储引擎"><a class="markdownIt-Anchor" href="#41-有哪些常见的存储引擎"></a> 4.1. 有哪些常见的存储引擎？</h2>
<ol>
<li>MyISAM：这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。</li>
<li>MyISAM Merge引擎：这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。</li>
<li><strong>InnoDB</strong>：InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能，也是目前<strong>MySQL 默认 的存储引擎。</strong></li>
<li>Memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。</li>
<li>archive：这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。</li>
</ol>
<h2 id="42-myisam-和-innodb-的区别"><a class="markdownIt-Anchor" href="#42-myisam-和-innodb-的区别"></a> 4.2.  MyISAM 和 InnoDB 的区别？</h2>
<p>1）InnoDB 支持事务，而 MyISAM 不支持。</p>
<p>2）InnoDB 支持外键，而 MyISAM 不支持。因此将一个含有外键的 InnoDB 表 转为 MyISAM 表会失败。</p>
<p>3）InnoDB 和 MyISAM 均支持 B+ Tree 数据结构的索引。但 InnoDB 是聚集索引，而 MyISAM 是非聚集索引。</p>
<p>4）InnoDB 不保存表中数据行数，执行 select count(*) from table 时需要全表扫描。而 MyISAM 用一个变量记录了整个表的行数，速度相当快（注意不能有 WHERE 子句）。</p>
<p>**那为什么 InnoDB 没有使用这样的变量呢？**因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的。</p>
<p>5）InnoDB 支持表、行（默认）级锁，而 MyISAM 支持表级锁。</p>
<p>InnoDB 的行锁是基于索引实现的，而不是物理行记录上。即访问如果没有命中索引，则也无法使用行锁，将要退化为表锁。</p>
<p>6）InnoDB 必须有唯一索引（如主键），如果没有指定，就会自动寻找或生产一个隐藏列 Row_id 来充当默认主键，而 Myisam 可以没有主键。</p>
<h2 id="43-innodb引擎四大特性"><a class="markdownIt-Anchor" href="#43-innodb引擎四大特性"></a> 4.3. InnoDB引擎四大特性</h2>
<ul>
<li>插入缓冲insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
<h2 id="44-innodb为何推荐使用自增主键"><a class="markdownIt-Anchor" href="#44-innodb为何推荐使用自增主键"></a> 4.4. InnoDB为何推荐使用自增主键？</h2>
<p>自增 ID 可以保证每次插入时 B+ 树索引是从右边扩展的，因此相比自定义 ID （如 UUID）可以避免 B+ 树的频繁合并和分裂。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。</p>
<h2 id="45-存储结构"><a class="markdownIt-Anchor" href="#45-存储结构"></a> 4.5. 存储结构</h2>
<h3 id="451-什么是-innodb-的页-区-段"><a class="markdownIt-Anchor" href="#451-什么是-innodb-的页-区-段"></a> 4.5.1. 什么是 InnoDB 的页、区、段？</h3>
<ul>
<li>
<p><strong>页（Page）</strong></p>
<ul>
<li>首先，InnoDB 将物理磁盘划分为页（page），每页的大小默认为 16 KB，页是最小的存储单位。页根据上层应用的需要，如索引、日志等，分为很多的格式。我们主要说数据页，也就是存储实际数据的页。</li>
</ul>
</li>
<li>
<p><strong>区（Extent）</strong></p>
<ul>
<li>如果只有页这一个层次的话，页的个数是非常多的，存储空间的分配和回收都会很麻烦，因为要维护这么多的页的状态是非常麻烦的。</li>
<li>所以，InnoDB 又引入了区（Extent) 的概念。一个区默认是 64 个连续的页组成的，也就是 1MB。通过 Extent 对存储空间的分配和回收就比较容易了。</li>
</ul>
</li>
<li>
<p><strong>段（Segment）</strong></p>
<ul>
<li>为什么要引入段呢，这要从索引说起。我们都知道索引的目的是为了加快查找速度，是一种典型的用空间换时间的方法。</li>
<li>B+ 树的叶子节点存放的是我们的具体数据，非叶子结点是索引页。所以 B+ 树将数据分为了两部分，叶子节点部分和非叶子节点部分，也就我们要介绍的段 Segment，也就是说 InnoBD 中每一个索引都会创建两个 Segment 来存放对应的两部分数据。</li>
<li>Segment 是一种逻辑上的组织，其层次结构从上到下一次为 Segment、Extent、Page。</li>
</ul>
</li>
</ul>
<h1 id="5-事务"><a class="markdownIt-Anchor" href="#5-事务"></a> 5. 事务</h1>
<h2 id="51-什么是事务的四大特性acid"><a class="markdownIt-Anchor" href="#51-什么是事务的四大特性acid"></a> 5.1.  什么是事务的四大特性（ACID）？</h2>
<ul>
<li>Atomicity（<strong>原子性</strong>）：一个事务（transaction）中的所有操作，<strong>要么全部完成，要么全部不完成</strong>，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</li>
<li>Consistency（<strong>一致性</strong>）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</li>
<li>Isolation（<strong>隔离性</strong>）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。</li>
<li>Durability（<strong>持久性</strong>）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li>
</ul>
<h3 id="52-事务的并发问题"><a class="markdownIt-Anchor" href="#52-事务的并发问题"></a> 5.2. 事务的并发问题？</h3>
<p>脏读、幻读、不可重复读。</p>
<h3 id="53-什么是脏读-幻读和不可重复读"><a class="markdownIt-Anchor" href="#53-什么是脏读-幻读和不可重复读"></a> 5.3. 什么是脏读、幻读和不可重复读</h3>
<ul>
<li>
<p><strong>脏读</strong>：一个事务读取到另一个事务<strong>尚未提交</strong>的数据。 事务 A 读取事务 B 更新的数据，然后 B 回滚操作，那么 A 读取到的数据是脏数据。</p>
</li>
<li>
<p><strong>不可重复读</strong>：一个事务中两次读取的数据的<strong>内容</strong>不一致。 事务 A 多次读取同一数据，事务 B 在事务 A 多次读取的过程中，对数据作了更新并提交，导致事务 A 多次读取同一数据时，结果 不一致。</p>
</li>
<li>
<p><strong>幻读</strong>：一个事务中两次读取的<strong>数据量</strong>不一致。 系统管理员 A 将数据库中所有学生的成绩从具体分数改为 ABCDE 等级，但是系统管理员 B 就在这个时候插入了一条具体分数的记录，当系统管理员 A 改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。</p>
</li>
</ul>
<p><strong>不可重复读和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除</strong>。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p>
<h3 id="54-事务的隔离级别有哪些"><a class="markdownIt-Anchor" href="#54-事务的隔离级别有哪些"></a> 5.4. 事务的隔离级别有哪些？</h3>
<p><img src="../../images/image-20230217192636216.png" alt="image-20230217192636216"></p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong>： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong>： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong>： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<p>串行化的隔离级别最高，读未提交的级别最低，级别越高，则执行效率就越低，所以在选择隔离级别时应该结合实际情况。</p>
<p>MySQL 支持以上四种隔离级别，<strong>默认</strong>为 Repeatable read (可重复读)；而 Oracle 只支持 Serializeble(串行化) 级别和 Read committed(读已提交) 两种，其中默认为读已提交。</p>
<h1 id="6-锁"><a class="markdownIt-Anchor" href="#6-锁"></a> 6. 锁</h1>
<h2 id="61-数据库锁的作用以及有哪些锁"><a class="markdownIt-Anchor" href="#61-数据库锁的作用以及有哪些锁"></a> 6.1. 数据库锁的作用以及有哪些锁？</h2>
<p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。即锁的作用是解决并发问题。</p>
<ul>
<li>
<p>从<strong>锁的粒度</strong>划分，可以将锁分为表锁、行锁以及页锁。</p>
<ul>
<li>
<p><strong>行级锁</strong>：是锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。<br>
行级锁开销大，加锁慢，且会出现死锁。但锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>
</li>
<li>
<p><strong>表级锁</strong>：是粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。</p>
</li>
<li>
<p><strong>页级锁</strong>：是粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折中的页级，一次锁定相邻的一组记录。开销和加锁时间界于表锁和行锁之间，会出现死锁。锁定粒度界于表锁和行锁之间，并发度一般。</p>
</li>
</ul>
</li>
<li>
<p>从<strong>使用性质</strong>划分，可以分为共享锁、排它锁以及更新锁。</p>
<ul>
<li>
<p><strong>共享锁</strong>（Share Lock）：<strong>S 锁</strong>，又称<strong>读锁</strong>（read lock），用于所有的只读数据操作。<br>
S 锁并非独占，允许多个并发事务对同一资源加锁，但加 S 锁的同时不允许加 X 锁，即资源不能被修改。S 锁通常读取结束后立即释放，无需等待事务结束。</p>
</li>
<li>
<p><strong>排他锁</strong>（Exclusive Lock）：<strong>X 锁</strong>，又称<strong>写锁</strong>（write lock），表示对数据进行写操作。<br>
X 锁仅允许一个事务对同一资源加锁，且直到事务结束才释放，其他任何事务必须等到 X 锁被释放才能对该页进行访问。使用 <font color="red">select * from table_name <strong>for update</strong>;</font> 语句产生 X 锁。</p>
</li>
<li>
<p><strong>更新锁</strong>：U 锁，用来预定要对资源施加 X 锁，允许其他事务读，但不允许再施加 U 锁或 X 锁。<br>
当被读取的页将要被更新时，则升级为 X 锁，U 锁一直到事务结束时才能被释放。故 U 锁用来避免使用共享锁造成的死锁现象。</p>
<p><img src="../../images/image-20230305131221507.png" alt="image-20230305131221507"></p>
</li>
</ul>
</li>
<li>
<p>从<strong>主观</strong>上划分，又可以分为乐观锁和悲观锁。</p>
<ul>
<li><strong>乐观锁</strong>（Optimistic Lock）：顾名思义，从主观上认定资源是不会被修改的，所以不加锁读取数据，仅当更新时用版本号机制等确认资源是否被修改。乐观锁也是CAS的使用场景之一。<br>
乐观锁适用于多读的应用类型，可以系统提高吞吐量。</li>
<li><strong>悲观锁</strong>（Pessimistic Lock）：正如其名，具有强烈的独占和排它特性，每次读取数据时都会认为会被其它事务修改，所以每次操作都需要加上锁</li>
</ul>
</li>
</ul>
<h3 id="62-隔离级别和锁的关系"><a class="markdownIt-Anchor" href="#62-隔离级别和锁的关系"></a> 6.2. 隔离级别和锁的关系？</h3>
<p>1）在 Read Uncommitted 级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突；</p>
<p>2）在 Read Committed 级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>
<p>3）在 Repeatable Read 级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；</p>
<p>4）在 SERIALIZABLE 级别下，限制性最强，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</p>
<h3 id="63-innodb-中的锁算法"><a class="markdownIt-Anchor" href="#63-innodb-中的锁算法"></a> 6.3. InnoDB 中的锁算法？</h3>
<ul>
<li><strong>Record lock</strong>：记录锁，单个行记录上的锁</li>
<li><strong>Gap lock</strong>：间隙锁，锁定一个范围，不包括记录本身</li>
<li><strong>Next-key lock</strong>：record + gap 锁定一个范围，包含记录本身</li>
</ul>
<h3 id="64-什么是快照读和当前读"><a class="markdownIt-Anchor" href="#64-什么是快照读和当前读"></a> 6.4. 什么是快照读和当前读？</h3>
<p><strong>快照读</strong> 就是读取的是快照数据，不加锁的简单 Select 都属于快照读。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br></pre></td></tr></tbody></table></figure>
<p><strong>当前读</strong> 就是读的是最新数据，而不是历史的数据。加锁的 SELECT，或者对数据进行增删改都会进行当前读。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player LOCK <span class="keyword">IN</span> SHARE MODE;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">FROM</span> player <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> player <span class="keyword">values</span> ...</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> ...</span><br><span class="line"><span class="keyword">UPDATE</span> player <span class="keyword">SET</span> ...</span><br></pre></td></tr></tbody></table></figure>
<h3 id="65-什么是mvcc以及实现"><a class="markdownIt-Anchor" href="#65-什么是mvcc以及实现"></a> 6.5. 什么是MVCC以及实现？</h3>
<p>MVCC 的英文全称是 Multiversion Concurrency Control，中文意思是多版本并发控制，可以做到读写互相不阻塞，主要用于解决不可重复读和幻读问题时提高并发效率。</p>
<p>其原理是通过数据行的多个版本管理来实现数据库的并发控制，简单来说就是保存数据的历史版本。可以通过比较版本号决定数据是否显示出来。读取数据的时候不需要加锁可以保证事务的隔离效果。</p>
<h1 id="7-视图"><a class="markdownIt-Anchor" href="#7-视图"></a> 7. 视图</h1>
<h3 id="71-为什么要使用视图什么是视图"><a class="markdownIt-Anchor" href="#71-为什么要使用视图什么是视图"></a> 7.1. 为什么要使用视图？什么是视图？</h3>
<ul>
<li>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</li>
<li>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</li>
</ul>
<h3 id="72-视图有哪些特点"><a class="markdownIt-Anchor" href="#72-视图有哪些特点"></a> 7.2. 视图有哪些特点？</h3>
<p><strong>视图的特点如下:</strong></p>
<ul>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
</ul>
<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>
<h3 id="73-视图的使用场景有哪些"><a class="markdownIt-Anchor" href="#73-视图的使用场景有哪些"></a> 7.3. 视图的使用场景有哪些？</h3>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</span><br></pre></td></tr></tbody></table></figure>
<p><strong>下面是视图的常见使用场景：</strong></p>
<ul>
<li>重用SQL语句；</li>
<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ul>
<h3 id="74-视图的优点"><a class="markdownIt-Anchor" href="#74-视图的优点"></a> 7.4. 视图的优点</h3>
<ol>
<li>查询简单化。视图能简化用户的操作</li>
<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h3 id="75-视图的缺点"><a class="markdownIt-Anchor" href="#75-视图的缺点"></a> 7.5. 视图的缺点</h3>
<ol>
<li>
<p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>
</li>
<li>
<p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>
<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\SUM\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>
</li>
</ol>
<h3 id="76-什么是游标"><a class="markdownIt-Anchor" href="#76-什么是游标"></a> 7.6. 什么是游标？</h3>
<ul>
<li>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</li>
</ul>
<h1 id="8-存储过程与函数"><a class="markdownIt-Anchor" href="#8-存储过程与函数"></a> 8. 存储过程与函数</h1>
<h2 id="什么是存储过程"><a class="markdownIt-Anchor" href="#什么是存储过程"></a> 什么是存储过程？</h2>
<ul>
<li>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</li>
</ul>
<h2 id="有哪些优缺点"><a class="markdownIt-Anchor" href="#有哪些优缺点"></a> 有哪些优缺点？</h2>
<p><strong>优点</strong></p>
<ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</li>
<li>移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</li>
</ol>
<h1 id="9-触发器"><a class="markdownIt-Anchor" href="#9-触发器"></a> 9. 触发器</h1>
<h3 id="什么是触发器触发器的使用场景有哪些"><a class="markdownIt-Anchor" href="#什么是触发器触发器的使用场景有哪些"></a> 什么是触发器？触发器的使用场景有哪些？</h3>
<ul>
<li>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。<strong>触发器是指一段代码，当触发某个事件时，自动执行这些代码。</strong></li>
</ul>
<p><strong>使用场景</strong></p>
<ul>
<li>可以通过数据库中的相关表实现级联更改。</li>
<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>
<li>例如可以生成某些业务的编号。</li>
<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>
<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>
</ul>
<h3 id="mysql中都有哪些触发器"><a class="markdownIt-Anchor" href="#mysql中都有哪些触发器"></a> MySQL中都有哪些触发器？</h3>
<p><strong>在MySQL数据库中有如下六种触发器：</strong></p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h1 id="10-常用的sql语句"><a class="markdownIt-Anchor" href="#10-常用的sql语句"></a> 10. 常用的SQL语句</h1>
<h3 id="sql语句主要分为哪几类"><a class="markdownIt-Anchor" href="#sql语句主要分为哪几类"></a> SQL语句主要分为哪几类</h3>
<ul>
<li>
<p>数据<strong>定义</strong>语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>
<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>
</li>
<li>
<p>数据<strong>查询</strong>语言DQL（Data Query Language）SELECT</p>
<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>
</li>
<li>
<p>数据<strong>操纵</strong>语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>
<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>
</li>
<li>
<p>数据<strong>控制</strong>功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>
<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>
</li>
</ul>
<h3 id="sql语句的语法顺序"><a class="markdownIt-Anchor" href="#sql语句的语法顺序"></a> SQL语句的语法顺序：</h3>
<ol>
<li>
<p>SELECT</p>
</li>
<li>
<p>FROM</p>
</li>
<li>
<p>JOIN</p>
</li>
<li>
<p>ON</p>
</li>
<li>
<p>WHERE</p>
</li>
<li>
<p>GROUP BY</p>
</li>
<li>
<p>HAVING</p>
</li>
<li>
<p>UNION : 将多个查询结果合并（默认去掉重复的记录）</p>
</li>
<li>
<p>ORDER BY</p>
</li>
<li>
<p>LIMIT</p>
<p><img src="../../images/image-20230217214658212.png" alt="image-20230217214658212"></p>
</li>
</ol>
<h3 id="超键-候选键-主键-外键分别是什么"><a class="markdownIt-Anchor" href="#超键-候选键-主键-外键分别是什么"></a> 超键、候选键、主键、外键分别是什么？</h3>
<ul>
<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li>候选键：是最小超键，即没有冗余元素的超键。</li>
<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h3 id="sql-约束有哪几种"><a class="markdownIt-Anchor" href="#sql-约束有哪几种"></a> SQL 约束有哪几种？</h3>
<blockquote>
<p>SQL 约束有哪几种？</p>
</blockquote>
<ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a class="markdownIt-Anchor" href="#六种关联查询"></a> 六种关联查询</h3>
<ul>
<li>
<p>交叉连接（CROSS JOIN）</p>
</li>
<li>
<p>内连接（INNER JOIN）</p>
</li>
<li>
<p>外连接（LEFT JOIN/RIGHT JOIN）</p>
</li>
<li>
<p>联合查询（UNION与UNION ALL）</p>
</li>
<li>
<p>全连接（FULL JOIN）</p>
</li>
<li>
<p>交叉连接（CROSS JOIN）</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B(,C)或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">CROSS</span> <span class="keyword">JOIN</span> B (<span class="keyword">CROSS</span> <span class="keyword">JOIN</span> C)</span><br><span class="line">#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（<span class="keyword">INNER</span> <span class="keyword">JOIN</span>）<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A,B <span class="keyword">WHERE</span> A.id<span class="operator">=</span>B.id或者<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id<span class="operator">=</span>B.id多表中同时符合某种条件的数据记录的集合，<span class="keyword">INNER</span> <span class="keyword">JOIN</span>可以缩写为<span class="keyword">JOIN</span>复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<p><strong>内连接分为三类</strong></p>
<ul>
<li>等值连接：ON <a target="_blank" rel="noopener" href="http://A.id=B.id">A.id=B.id</a></li>
<li>不等值连接：ON <a target="_blank" rel="noopener" href="http://A.id">A.id</a> &gt; <a target="_blank" rel="noopener" href="http://B.id">B.id</a></li>
<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>
</ul>
<p><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></p>
<ul>
<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>
<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>
</ul>
<p><strong>联合查询（UNION与UNION ALL）</strong></p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> A <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> B <span class="keyword">UNION</span> </span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>
<li>如果使用UNION ALL，不会合并重复的记录行</li>
<li>效率 UNION 高于 UNION ALL</li>
</ul>
<p><strong>全连接（FULL JOIN）</strong></p>
<figure class="highlight n1ql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> A <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id UNIONSELECT * <span class="keyword">FROM</span> A <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> B <span class="keyword">ON</span> A.id=B.id复制代码</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>MySQL不支持全连接</li>
<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>
</ul>
<h1 id="11-主从复制"><a class="markdownIt-Anchor" href="#11-主从复制"></a> 11. 主从复制</h1>
<h2 id="1-什么是主从复制"><a class="markdownIt-Anchor" href="#1-什么是主从复制"></a> 1、什么是主从复制？</h2>
<p><strong>主从复制</strong>是用来建立一个与主数据库完全一样的数据库环境，即从数据库。主数据库一般是准实时的业务数据库。</p>
<h2 id="2-主从复制的作用"><a class="markdownIt-Anchor" href="#2-主从复制的作用"></a> 2、主从复制的作用？</h2>
<ul>
<li>读写分离，使数据库能支撑更大的并发。</li>
<li>高可用，做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。</li>
</ul>
<h2 id="3-主从复制的架构"><a class="markdownIt-Anchor" href="#3-主从复制的架构"></a> 3、主从复制的架构？</h2>
<ul>
<li>
<p><strong>一主一从或一主多从</strong><br>
在主库的请求压力非常大时，可通过配置一主多从复制架构实现读写分离，把大量对实时性要求不是很高的请求通过负载均衡分发到多个从库上去读取数据，降低主库的读取压力。而且在主库出现宕机时，可将一个从库切换为主库继续提供服务。</p>
</li>
<li>
<p><strong>主主复制</strong><br>
双主复制架构适用于需要进行主从切换的场景。 两个数据库互为主从，当主库宕机恢复后，由于它还是原来从库（现在主库）的从机，所以它还是会复制新的主库上的数据。那么无论主库的角色怎么切换，原来的主库都不会脱离复制环境。</p>
</li>
<li>
<p>**多主一从（**5.7 开始支持）</p>
</li>
<li>
<p><strong>联级复制</strong><br>
因为每个从库在主库上都会有一个独立的 Binlog Dump 线程来推送 binlog 日志，所以随着从库数量的增加，主库的 IO 压力和网络压力也会随之增加，这时，联级复制架构应运而生。</p>
</li>
</ul>
<p>联级复制架构只是在一主多从的基础上，再主库和各个从库之间增加了一个二级主库 Master2，这个二级主库仅仅用来将一级主库推送给它的 Binlog 日志再推送给各个从库，以此来减轻一级主库的推送压力。</p>
<p><img src="../../images/image-20230217214224766.png" alt="image-20230217214224766"></p>
<h2 id="4-主从复制的实现原理"><a class="markdownIt-Anchor" href="#4-主从复制的实现原理"></a> 4、主从复制的实现原理？</h2>
<p>数据库有个 binlog 二进制文件，记录了数据可执行的所有 SQL 语句。主从同步的目标就是把主数据库的 binlog 文件中的 SQL 语句复制到从数据库，让其在从数据的 relaylog 文件中再执行一次这些 SQL 语句即可。</p>
<p><strong>具体实现需要三个线程：</strong></p>
<ul>
<li>
<p><strong>binlog 输出线程</strong>：每当有从库连接到主库的时候，主库都会创建一个线程然后发送 binlog内 容到从库。<br>
在从库里，当复制开始的时候，从库就会创建两个线程进行处理：</p>
</li>
<li>
<p><strong>从库 IO 线程</strong>：当 START SLAVE 语句在从库开始执行之后，从库创建一个 IO 线程，该线程连接到主库并请求主库发送 binlog 里面的更新记录到从库上。从库 IO 线程读取主库的 binlog 输出线程发送的更新并拷贝这些更新到本地文件，其中包括 relaylog 文件。</p>
</li>
<li>
<p><strong>从库 SQL 线程</strong>：从库创建一个 SQL 线程，这个线程读取从库 IO 线程写到 relaylog 的更新事件并执行。</p>
</li>
</ul>
<h2 id="5-什么是异步复制和半同步"><a class="markdownIt-Anchor" href="#5-什么是异步复制和半同步"></a> 5、什么是异步复制和半同步？</h2>
<p>MySQL 的主从复制有两种复制方式，分别是 <strong>异步复制</strong> 和 <strong>半同步复制</strong>：</p>
<ul>
<li>
<p><strong>异步复制</strong><br>
MySQL <strong>默认</strong>的主从复制方式就是异步复制，因为 Master 根本不考虑数据是否达到了 Slave，或 Slave 是否成功执行。</p>
<p>如过需要实现完全同步方式，即 Master 需要等待一个或所有 Slave 执行成功后才响应成功，那集群效率可想而知。故 MySQL 5.6 之后出现了一种折中的方式——半同步。</p>
</li>
<li>
<p><strong>半同步复制</strong><br>
一主一从，一主多从情况下，Master 节点只要确认至少有一个 Slave 接受到了事务，即可向发起请求的客户端返回执行成功的操作。同时 Master 是不需要等待 Slave 成功执行完这个事务，<strong>Slave 节点接受到这个事务，并成功写入到本地 relay 日志中就算成功</strong>。</p>
</li>
</ul>
<p>另外，在半同步复制时，如果主库的一个事务提交成功了，在推送到从库的过程当中，从库宕机了或网络故障，导致从库并没有接收到这个事务的Binlog，此时主库会等待一段时间（这个时间由rpl_semi_sync_master_timeout的毫秒数决定），如果这个时间过后还无法推送到从库，<strong>那 MySQL 会自动从半同步复制切换为异步复制，当从库恢复正常连接到主库后，主库又会自动切换回半同步复制。</strong></p>
<p>半同步复制的“半”体现在，虽然主从库的Binlog是同步的，但主库不会等待从库执行完Relay-log后才返回，而是确认从库接收到Binlog，达到主从Binlog同步的目的后就返回了，所以从库的数据对于主库来说还是有延时的，这个延时就是从库执行Relay-log的时间。所以只能称为半同步。</p>
<h2 id="6-主从中常见问题以及解决"><a class="markdownIt-Anchor" href="#6-主从中常见问题以及解决"></a> 6、主从中常见问题以及解决？</h2>
<p><strong>问题 :</strong><br>
1）主库宕机后，数据可能丢失。</p>
<p>​	2）从库只有一个sql Thread，主库写压力大，复制很可能延时。</p>
<p>**解决: **<br>
1）半同步复制：确保事务提交后 binlog 至少传输到一个从库 ，解决数据丢失的问题。</p>
<p>​	2）并行复制：从库多线程apply binlog，解决从库复制延迟的问题。</p>
<h1 id="12-font-colorred调优font"><a class="markdownIt-Anchor" href="#12-font-colorred调优font"></a> 12. <font color="red">调优</font></h1>
<h3 id="说出一些数据库优化方面的经验"><a class="markdownIt-Anchor" href="#说出一些数据库优化方面的经验"></a> 说出一些数据库优化方面的经验?</h3>
<ol>
<li>有外键约束的话会影响增删改的性能，如果应用程序可以保证数据库的完整性那就去除外键</li>
<li>Sql语句全部大写，特别是列名大写，因为数据库的机制是这样的，sql语句发送到数据库服务器，数据库首先就会把sql编译成大写在执行，如果一开始就编译成大写就不需要了把sql编译成大写这个步骤了</li>
<li>如果应用程序可以保证数据库的完整性，可以不需要按照三大范式来设计数据库</li>
<li>其实可以不必要创建很多索引，索引可以加快查询速度，但是索引会消耗磁盘空间</li>
<li>如果是jdbc的话，使用PreparedStatement不使用Statement，来创建SQl，PreparedStatement的性能比Statement的速度要快，使用PreparedStatement对象SQL语句会预编译在此对象中，PreparedStatement对象可以多次高效的执行</li>
</ol>
<h3 id="怎么优化sql查询语句吗"><a class="markdownIt-Anchor" href="#怎么优化sql查询语句吗"></a> 怎么优化SQL查询语句吗</h3>
<ol>
<li>对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引</li>
<li>用索引可以提高查询</li>
<li>SELECT子句中避免使用*号，尽量全部大写SQL</li>
<li>应尽量避免在 where 子句中对字段进行 is null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，使用 IS NOT NULL</li>
<li>where 子句中使用 or 来连接条件，也会导致引擎放弃使用索引而进行全表扫描</li>
<li>in 和 not in 也要慎用，否则会导致全表扫描</li>
</ol>
<h3 id="你怎么知道sql语句性能是高还是低"><a class="markdownIt-Anchor" href="#你怎么知道sql语句性能是高还是低"></a> 你怎么知道SQL语句性能是高还是低</h3>
<ol>
<li>查看SQL的执行时间</li>
<li>使用explain关键字可以模拟优化器执行SQL查询语句，从而知道MYSQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。</li>
</ol>
<h3 id="大表数据查询怎么优化"><a class="markdownIt-Anchor" href="#大表数据查询怎么优化"></a> 大表数据查询，怎么优化</h3>
<ol>
<li>优化shema、sql语句+索引；</li>
<li>第二加缓存，memcached, redis；</li>
<li>主从复制，读写分离；</li>
<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>
<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>
</ol>
<h3 id="超大分页怎么处理"><a class="markdownIt-Anchor" href="#超大分页怎么处理"></a> 超大分页怎么处理？</h3>
<p><strong>超大的分页一般从两个方向上来解决.</strong></p>
<ul>
<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于<code>select * from table where age &gt; 20 limit 1000000,10</code>这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为<code>select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</code>.这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以<code>select * from table where id &gt; 1000000 limit 10</code>,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>
<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>
</ul>
<p><strong>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可</strong></p>
<h3 id="为什么要尽量设定一个主键"><a class="markdownIt-Anchor" href="#为什么要尽量设定一个主键"></a> 为什么要尽量设定一个主键？</h3>
<ul>
<li>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</li>
</ul>
<h3 id="主键使用自增id还是uuid"><a class="markdownIt-Anchor" href="#主键使用自增id还是uuid"></a> 主键使用自增ID还是UUID？</h3>
<ul>
<li>推荐使用自增ID，不要使用UUID。</li>
<li>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</li>
</ul>
<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。<br>
关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>
<h3 id="如果要存储用户的密码散列应该使用什么字段进行存储"><a class="markdownIt-Anchor" href="#如果要存储用户的密码散列应该使用什么字段进行存储"></a> 如果要存储用户的密码散列，应该使用什么字段进行存储？</h3>
<ul>
<li>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</li>
</ul>
<h3 id="如何优化查询过程中的数据访问"><a class="markdownIt-Anchor" href="#如何优化查询过程中的数据访问"></a> 如何优化查询过程中的数据访问</h3>
<ul>
<li>访问数据太多导致查询性能下降</li>
<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>
<li>确认MySQL服务器是否在分析大量不必要的数据行</li>
<li>避免犯如下SQL语句错误</li>
<li>避免查询不需要的数据。解决办法：使用limit解决</li>
<li>多表关联返回全部列。解决办法：指定列名</li>
<li>总是返回全部列。解决办法：避免使用SELECT *</li>
<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>
<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>
<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>
<li>改变数据库和表的结构，修改数据表范式</li>
<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>
</ul>
<h3 id="如何优化长难的查询语句"><a class="markdownIt-Anchor" href="#如何优化长难的查询语句"></a> 如何优化长难的查询语句</h3>
<ul>
<li>分析是一个复杂查询还是多个简单查询速度快</li>
<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>
<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>
<li>将一个大的查询分为多个小的相同的查询</li>
<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>
<li>分解关联查询，让缓存的效率更高。</li>
<li>执行单个查询可以减少锁的竞争。</li>
<li>在应用层做关联更容易对数据库进行拆分。</li>
<li>查询效率会有大幅提升。</li>
<li>较少冗余记录的查询。</li>
</ul>
<h3 id="优化特定类型的查询语句"><a class="markdownIt-Anchor" href="#优化特定类型的查询语句"></a> 优化特定类型的查询语句</h3>
<ul>
<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>
<li>MyISAM中，没有任何where条件的count(*)非常快。</li>
<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>
<li>可以使用explain查询近似值，用近似值替代count(*)</li>
<li>增加汇总表</li>
<li>使用缓存</li>
</ul>
<h3 id="优化关联查询"><a class="markdownIt-Anchor" href="#优化关联查询"></a> 优化关联查询</h3>
<ul>
<li>确定ON或者USING子句中是否有索引。</li>
<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>
</ul>
<h3 id="优化子查询"><a class="markdownIt-Anchor" href="#优化子查询"></a> 优化子查询</h3>
<ul>
<li>用关联查询替代</li>
<li>优化GROUP BY和DISTINCT</li>
<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>
<li>关联查询中，使用标识列分组的效率更高</li>
<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>
<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>
</ul>
<h3 id="优化limit分页"><a class="markdownIt-Anchor" href="#优化limit分页"></a> 优化LIMIT分页</h3>
<ul>
<li>LIMIT偏移量大的时候，查询效率较低</li>
<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>
</ul>
<h3 id="优化union查询"><a class="markdownIt-Anchor" href="#优化union查询"></a> 优化UNION查询</h3>
<ul>
<li>UNION ALL的效率高于UNION</li>
</ul>
<h3 id="优化where子句"><a class="markdownIt-Anchor" href="#优化where子句"></a> 优化WHERE子句</h3>
<ul>
<li>多数数据库都是从左往右的顺序处理条件的，把能够过滤更多数据的条件放到前面，把过滤少的条件放在后面</li>
</ul>
<h3 id="sql语句优化的一些方法"><a class="markdownIt-Anchor" href="#sql语句优化的一些方法"></a> SQL语句优化的一些方法</h3>
<ul>
<li>
<p>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p>
</li>
<li>
<p>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight axapta"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">is</span> <span class="literal">null</span></span><br><span class="line">-- 可以在num上设置默认值<span class="number">0</span>，确保表中num列没有<span class="literal">null</span>值，然后这样查询：</span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">0</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</p>
</li>
<li>
<p>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">or</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line"><span class="comment">-- 可以这样查询：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">10</span> <span class="keyword">union</span> <span class="keyword">all</span> <span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="number">20</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p><a target="_blank" rel="noopener" href="http://5.in">5.in</a> 和 not in 也要慎用，否则会导致全表扫描，如：</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">in</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) </span><br><span class="line"><span class="comment">-- 对于连续的数值，能用 between 就不要用 in 了：</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num <span class="keyword">between</span> <span class="number">1</span> <span class="keyword">and</span> <span class="number">3</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</p>
</li>
<li>
<p>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line"><span class="comment">-- 可以改为强制查询使用索引：</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">with</span>(index(索引名)) <span class="keyword">where</span> num<span class="operator">=</span><span class="variable">@num</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num/<span class="number">2</span>=<span class="number">100</span></span><br><span class="line"><span class="comment">-- 应改为:</span></span><br><span class="line">select <span class="built_in">id</span> <span class="keyword">from</span> t <span class="keyword">where</span> num=<span class="number">100</span>*<span class="number">2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p>
<figure class="highlight pgsql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> substring(<span class="type">name</span>,<span class="number">1</span>,<span class="number">3</span>)=’abc’</span><br><span class="line"><span class="comment">-- name以abc开头的id应改为:</span></span><br><span class="line"><span class="keyword">select</span> id <span class="keyword">from</span> t <span class="keyword">where</span> <span class="type">name</span> <span class="keyword">like</span> ‘abc%’</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
</li>
<li>
<p>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p>
</li>
</ul>
<h2 id="数据库优化"><a class="markdownIt-Anchor" href="#数据库优化"></a> 数据库优化</h2>
<h3 id="为什么要优化"><a class="markdownIt-Anchor" href="#为什么要优化"></a> 为什么要优化</h3>
<ul>
<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>
<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>
<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="数据库结构优化"><a class="markdownIt-Anchor" href="#数据库结构优化"></a> 数据库结构优化</h3>
<ul>
<li>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</li>
<li>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</li>
</ul>
<p><strong>将字段很多的表分解成多个表</strong></p>
<ul>
<li>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</li>
<li>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</li>
</ul>
<p><strong>增加中间表</strong></p>
<ul>
<li>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</li>
<li>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</li>
</ul>
<p><strong>增加冗余字段</strong></p>
<ul>
<li>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</li>
<li>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</li>
</ul>
<p><strong>注意：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</span><br></pre></td></tr></tbody></table></figure>
<h3 id="mysql数据库cpu飙升到500的话他怎么处理"><a class="markdownIt-Anchor" href="#mysql数据库cpu飙升到500的话他怎么处理"></a> MySQL数据库cpu飙升到500%的话他怎么处理？</h3>
<ul>
<li>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</li>
<li>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</li>
<li>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</li>
<li>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</li>
</ul>
<h3 id="大表怎么优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"><a class="markdownIt-Anchor" href="#大表怎么优化分库分表了是怎么做的分表分库了有什么问题有用到中间件么他们的原理知道么"></a> 大表怎么优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3>
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<ol>
<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>
<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>
<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>
</ol>
<p><strong>还有就是通过分库分表的方式进行优化，主要有垂直分区、垂直分表和水平分区、水平分表</strong></p>
<h4 id="1-垂直分区"><a class="markdownIt-Anchor" href="#1-垂直分区"></a> 1、垂直分区</h4>
<ul>
<li><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</li>
<li><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7259992ab~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</li>
<li><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</li>
</ul>
<h4 id="2-垂直分表"><a class="markdownIt-Anchor" href="#2-垂直分表"></a> 2、垂直分表</h4>
<ul>
<li>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c725b21e8e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、如果一个表中某些列常用，另外一些列不常用</li>
<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>
<li>对于应用层来说，逻辑算法增加开发成本</li>
<li>管理冗余列，查询所有数据需要join操作</li>
</ul>
<h4 id="3-水平分区"><a class="markdownIt-Anchor" href="#3-水平分区"></a> 3、水平分区</h4>
<ul>
<li><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></li>
<li>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c7300b465e~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<ul>
<li>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</li>
<li>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</li>
</ul>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</span><br></pre></td></tr></tbody></table></figure>
<h4 id="4-水平分表"><a class="markdownIt-Anchor" href="#4-水平分表"></a> 4、水平分表：</h4>
<ul>
<li>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</li>
</ul>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c744498a9a~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
<p><strong>适用场景</strong></p>
<ul>
<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>
<li>2、需要把数据存放在多个介质上。</li>
</ul>
<p><strong>水平切分的缺点</strong></p>
<ul>
<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>
<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>
</ul>
<h4 id="数据库分片的两种常见方案"><a class="markdownIt-Anchor" href="#数据库分片的两种常见方案"></a> 数据库分片的两种常见方案：</h4>
<ul>
<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>
<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<h4 id="分库分表后面临的问题"><a class="markdownIt-Anchor" href="#分库分表后面临的问题"></a> 分库分表后面临的问题</h4>
<ul>
<li>
<p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>
</li>
<li>
<p><strong>跨库join</strong></p>
<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>
</li>
<li>
<p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>
</li>
<li>
<p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>
</li>
<li>
<p><strong>ID问题</strong></p>
</li>
<li>
<p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>
<ul>
<li>UUID 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</li>
</ul>
</li>
<li>
<p><strong>跨分片的排序分页问题</strong></p>
<p>一般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>
<p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/13/171735c750f5b2cc~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="在这里插入图片描述"></p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/02/17/interview/mysql%E9%9D%A2%E8%AF%95%E9%A2%98/" data-id="clihlibpu0045u4v60xhz7adz" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Mysql/" rel="tag">Mysql</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" rel="tag">面试题</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/4/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>172</strong><br>文章</div></a>
      <a href="/categories"><div><strong>76</strong><br>分类</div></a>
      <a href="/tags"><div><strong>57</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
</body>
</html>