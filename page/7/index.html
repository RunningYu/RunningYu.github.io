<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>179</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-JVM/JVM下篇：性能监控与调优篇/1-概述篇" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/1-%E6%A6%82%E8%BF%B0%E7%AF%87/" class="article-date">
  <time class="post-time" datetime="2023-01-12T13:40:28.651Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/1-%E6%A6%82%E8%BF%B0%E7%AF%87/">1-概述篇</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/">JVM下篇：性能监控与调优篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="1-概述篇"><a href="#1-概述篇" class="headerlink" title="1. 概述篇"></a>1. 概述篇</h1><h2 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h2><blockquote>
<p><mark>支付宝：</mark></p>
<p>支付宝三面：JVM 性能调优都做了什么？</p>
<p><mark>小米：</mark></p>
<p>有做过 JVM 内存优化吗？</p>
<p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p>
<p><mark>蚂蚁金服：</mark></p>
<p>JVM 的编译优化</p>
<p>jvm 性能调优都做了什么</p>
<p>JVM 诊断调优工具用过哪些？</p>
<p>二面：jvm 怎样调优，堆内存、栈空间设置多少合适</p>
<p>三面：JVM 相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p>
<p><mark>阿里：</mark></p>
<p>如何进行 JVM 调优？有哪些方法？</p>
<p>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</p>
<p><mark>字节跳动：</mark></p>
<p>三面：JVM 如何调优、参数怎么调？</p>
<p><mark>拼多多：</mark></p>
<p>从 SQL、JVM、架构、数据库四个方面讲讲优化思路</p>
<p><mark>京东：</mark></p>
<p>JVM 诊断调优工具用过哪些？</p>
<p>每秒几十万并发的秒杀系统为什么会频繁发生 GC？</p>
<p>日均百万级交易系统如何优化 JVM？</p>
<p>线上生产系统 OOM 如何监控及定位与解决？</p>
<p>高并发系统如何基于 G1 垃圾回收器优化性能？</p>
</blockquote>
<h2 id="1-2-背景说明"><a href="#1-2-背景说明" class="headerlink" title="1.2. 背景说明"></a>1.2. 背景说明</h2><p><strong>生产环境中的问题</strong></p>
<ul>
<li>生产环境发生了内存溢出该如何处理？</li>
<li>生产环境应该给服务器分配多少内存合适？</li>
<li>如何对垃圾回收器的性能进行调优？</li>
<li>生产环境 CPU 负载飙高该如何处理？</li>
<li>生产环境应该给应用分配多少线程合适？</li>
<li>不加 log，如何确定请求是否执行了某一行代码？</li>
<li>不加 log，如何实时查看某个方法的入参与返回值？</li>
</ul>
<p><strong>为什么要调优</strong></p>
<ul>
<li>防止出现 OOM</li>
<li>解决 OOM</li>
<li>减少 Full GC 出现的频率</li>
</ul>
<p><strong>不同阶段的考虑</strong></p>
<ul>
<li>上线前</li>
<li>项目运行阶段</li>
<li>线上出现 OOM</li>
</ul>
<h2 id="1-3-调优概述"><a href="#1-3-调优概述" class="headerlink" title="1.3. 调优概述"></a>1.3. 调优概述</h2><p><strong>监控的依据</strong></p>
<ul>
<li>运行日志</li>
<li>异常堆栈</li>
<li>GC 日志</li>
<li>线程快照</li>
<li>堆转储快照</li>
</ul>
<p><strong>调优的大方向</strong></p>
<ul>
<li>合理地编写代码</li>
<li>充分并合理的使用硬件资源</li>
<li>合理地进行 JVM 调优</li>
</ul>
<h2 id="1-4-性能优化的步骤"><a href="#1-4-性能优化的步骤" class="headerlink" title="1.4. 性能优化的步骤"></a>1.4. 性能优化的步骤</h2><p><strong>第 1 步：性能监控</strong></p>
<p><img src="/../../../images/image-20230112214518042.png" alt="image-20230112214518042"></p>
<ul>
<li>GC 频繁</li>
<li>cpu load 过高</li>
<li>OOM</li>
<li>内存泄露</li>
<li>死锁</li>
<li>程序响应时间较长</li>
</ul>
<p><strong>第 2 步：性能分析</strong></p>
<p><img src="/../../../images/image-20230112214643733.png" alt="image-20230112214643733"></p>
<ul>
<li>打印 GC 日志，通过 GCviewer 或者 <a target="_blank" rel="noopener" href="http://gceasy.io/">http://gceasy.io</a> 来分析异常信息</li>
<li>灵活运用命令行工具、jstack、jmap、jinfo 等</li>
<li>dump 出堆文件，使用内存分析工具分析文件</li>
<li>使用阿里 Arthas、jconsole、JVisualVM 来实时查看 JVM 状态</li>
<li>jstack 查看堆栈信息</li>
</ul>
<p><strong>第 3 步：性能调优</strong></p>
<p><img src="/../../../images/image-20230112214713212.png" alt="image-20230112214713212"></p>
<ul>
<li>适当增加内存，根据业务背景选择垃圾回收器</li>
<li>优化代码，控制内存使用</li>
<li>增加机器，分散节点压力</li>
<li>合理设置线程池线程数量</li>
<li>使用中间件提高程序效率，比如缓存、消息队列等</li>
<li>其他……</li>
</ul>
<h2 id="1-5-性能评价-x2F-测试指标"><a href="#1-5-性能评价-x2F-测试指标" class="headerlink" title="1.5. 性能评价/测试指标"></a>1.5. 性能评价/测试指标</h2><p><font color="red"><strong>（1）停顿时间（或响应时间）</strong></font></p>
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p>
<table>
<thead>
<tr>
<th align="left">操作</th>
<th align="left">响应时间</th>
</tr>
</thead>
<tbody><tr>
<td align="left">打开一个站点</td>
<td align="left">几秒</td>
</tr>
<tr>
<td align="left">数据库查询一条记录（有索引）</td>
<td align="left">十几毫秒</td>
</tr>
<tr>
<td align="left">机械磁盘一次寻址定位</td>
<td align="left">4 毫秒</td>
</tr>
<tr>
<td align="left">从机械磁盘顺序读取 1M 数据</td>
<td align="left">2 毫秒</td>
</tr>
<tr>
<td align="left">从 SSD 磁盘顺序读取 1M 数据</td>
<td align="left">0.3 毫秒</td>
</tr>
<tr>
<td align="left">从远程分布式换成 Redis 读取一个数据</td>
<td align="left">0.5 毫秒</td>
</tr>
<tr>
<td align="left">从内存读取 1M 数据</td>
<td align="left">十几微妙</td>
</tr>
<tr>
<td align="left">Java 程序本地方法调用</td>
<td align="left">几微妙</td>
</tr>
<tr>
<td align="left">网络传输 2Kb 数据</td>
<td align="left">1 微妙</td>
</tr>
</tbody></table>
<p>在垃圾回收环节中：</p>
<ul>
<li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li>
<li>-XX:MaxGCPauseMillis</li>
</ul>
<p><font color="red"><strong>（2）吞吐量</strong></font></p>
<ul>
<li>对单位时间内完成的工作量（请求）的量度</li>
<li>在 GC 中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li>
<li><font color="red">吞吐量为 1-1/(1+n)，其中-XX::GCTimeRatio=n</font></li>
</ul>
<p><strong>（3）并发数</strong></p>
<ul>
<li>同一时刻，对服务器有实际交互的请求数</li>
</ul>
<p><strong>（4）内存占用</strong></p>
<ul>
<li>Java 堆区所占的内存大小</li>
</ul>
<p><strong>（5）相互间的关系</strong></p>
<p>以高速公路通行状况为例</p>
<ul>
<li>吞吐量：每天通过高速公路收费站的车辆的数据</li>
<li>并发数：高速公路上正在行驶的车辆的数目</li>
<li>响应时间：车速</li>
</ul>
<hr>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/1-%E6%A6%82%E8%BF%B0%E7%AF%87/" data-id="clkr14xw1008ts4v68xf88ajs" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/" rel="tag">JVM下篇：性能监控与调优篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM下篇：性能监控与调优篇/补充：使用OQL语言查询对象信息" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/" class="article-date">
  <time class="post-time" datetime="2023-01-12T13:39:31.851Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/">使用OQL语言查询对象信息</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/">JVM下篇：性能监控与调优篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="补充：使用-OQL-语言查询对象信息"><a href="#补充：使用-OQL-语言查询对象信息" class="headerlink" title="补充：使用 OQL 语言查询对象信息"></a>补充：使用 OQL 语言查询对象信息</h1><p>MAT 支持一种类似于 SQL 的查询语言 OQL（Object Query Language）。OQL 使用类 SQL 语法，可以在堆中进行对象的查找和筛选。</p>
<h2 id="1-SELECT-子句"><a href="#1-SELECT-子句" class="headerlink" title="1. SELECT 子句"></a>1. SELECT 子句</h2><p>在 MAT 中，Select 子句的格式与 SQL 基本一致，用于指定要显示的列。Select 子句中可以使用“＊”，查看结果对象的引用实例（相当于 outgoing references）。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></tbody></table></figure>

<p>使用“OBJECTS”关键字，可以将返回结果集中的项以对象的形式显示。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> objects v.elementData <span class="keyword">FROM</span> java.util.Vector v</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> OBJECTS s.value <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure>

<p>在 Select 子句中，使用“AS RETAINED SET”关键字可以得到所得对象的保留集。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AS</span> RETAINED <span class="keyword">SET</span> <span class="operator">*</span><span class="keyword">FROM</span> com.atguigu.mat.Student</span><br></pre></td></tr></tbody></table></figure>

<p>“DISTINCT”关键字用于在结果集中去除重复对象。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> OBJECTS classof(s) <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure>



<h2 id="2-FROM-子句"><a href="#2-FROM-子句" class="headerlink" title="2. FROM 子句"></a>2. FROM 子句</h2><p>From 子句用于指定查询范围，它可以指定类名、正则表达式或者对象地址。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure>

<p>使用正则表达式，限定搜索范围，输出所有 com.atguigu 包下所有类的实例</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> "com\.atguigu\..*"</span><br></pre></td></tr></tbody></table></figure>

<p>使用类的地址进行搜索。使用类的地址的好处是可以区分被不同 ClassLoader 加载的同一种类型。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="number">0x37a0b4d</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-WHERE-子句"><a href="#3-WHERE-子句" class="headerlink" title="3. WHERE 子句"></a>3. WHERE 子句</h2><p>Where 子句用于指定 OQL 的查询条件。OQL 查询将只返回满足 Where 子句指定条件的对象。Where 子句的格式与传统 SQL 极为相似。</p>
<p>返回长度大于 10 的 char 数组。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span><span class="keyword">FROM</span> Ichar[] s <span class="keyword">WHERE</span> s.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>

<p>返回包含“java”子字符串的所有字符串，使用“LIKE”操作符，“LIKE”操作符的操作参数为正则表达式。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">WHERE</span> toString(s) <span class="keyword">LIKE</span> ".*java.*"</span><br></pre></td></tr></tbody></table></figure>

<p>返回所有 value 域不为 null 的字符串，使用“＝”操作符。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.lang.String s <span class="keyword">where</span> s.value<span class="operator">!=</span><span class="keyword">null</span></span><br></pre></td></tr></tbody></table></figure>

<p>返回数组长度大于 15，并且深堆大于 1000 字节的所有 Vector 对象。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> java.util.Vector v <span class="keyword">WHERE</span> v.elementData.<span class="variable">@length</span><span class="operator">&gt;</span><span class="number">15</span> <span class="keyword">AND</span> v.<span class="variable">@retainedHeapSize</span><span class="operator">&gt;</span><span class="number">1000</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-内置对象与方法"><a href="#4-内置对象与方法" class="headerlink" title="4. 内置对象与方法"></a>4. 内置对象与方法</h2><p>OQL 中可以访问堆内对象的属性，也可以访问堆内代理对象的属性。访问堆内对象的属性时，格式如下，其中 alias 为对象名称：</p>
<p>[ &lt;alias&gt;. ] &lt;field&gt; . &lt;field&gt;. &lt;field&gt;</p>
<p>访问 java.io.File 对象的 path 属性，并进一步访问 path 的 value 属性：</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> toString(f.path.value) <span class="keyword">FROM</span> java.io.File f</span><br></pre></td></tr></tbody></table></figure>

<p>显示 String 对象的内容、objectid 和 objectAddress。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s.toString(),s.<span class="variable">@objectId</span>, s.<span class="variable">@objectAddress</span> <span class="keyword">FROM</span> java.lang.String s</span><br></pre></td></tr></tbody></table></figure>

<p>显示 java.util.Vector 内部数组的长度。</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> v.elementData.<span class="variable">@length</span> <span class="keyword">FROM</span> java.util.Vector v</span><br></pre></td></tr></tbody></table></figure>

<p>显示所有的 java.util.Vector 对象及其子类型</p>
<figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> INSTANCEOF java.util.Vector</span><br></pre></td></tr></tbody></table></figure>



<p><img src="/../../../images/image-20230116162222206.png" alt="image-20230116162222206"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E4%BD%BF%E7%94%A8OQL%E8%AF%AD%E8%A8%80%E6%9F%A5%E8%AF%A2%E5%AF%B9%E8%B1%A1%E4%BF%A1%E6%81%AF/" data-id="clkr14xw60096s4v629ui4p5e" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/" rel="tag">JVM下篇：性能监控与调优篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-刷题笔记/刷题记录/leetcode-127. 单词接龙" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/12/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/" class="article-date">
  <time class="post-time" datetime="2023-01-12T13:20:50.194Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/12/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/">leetcode-127.单词接龙</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>,<a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/leetcode/">leetcode</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="127-单词接龙"><a href="#127-单词接龙" class="headerlink" title="127. 单词接龙"></a><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/word-ladder/">127. 单词接龙</a></h4><p>难度	 <font color="red">困难</font></p>
<p>字典 <code>wordList</code> 中从单词 <code>beginWord</code> 和 <code>endWord</code> 的 <strong>转换序列</strong> 是一个按下述规格形成的序列 <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code>：</p>
<ul>
<li>每一对相邻的单词只差一个字母。</li>
<li>对于 <code>1 &lt;= i &lt;= k</code> 时，每个 <code>si</code> 都在 <code>wordList</code> 中。注意， <code>beginWord</code> 不需要在 <code>wordList</code> 中。</li>
<li><code>sk == endWord</code></li>
</ul>
<p>给你两个单词 <code>beginWord</code> 和 <code>endWord</code> 和一个字典 <code>wordList</code> ，返回 <em>从 <code>beginWord</code> 到 <code>endWord</code> 的 <strong>最短转换序列</strong> 中的 <strong>单词数目</strong></em> 。如果不存在这样的转换序列，返回 <code>0</code> 。</p>
<p><strong>示例 1：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log","cog"]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 "hit" -&gt; "hot" -&gt; "dot" -&gt; "dog" -&gt; "cog", 返回它的长度 5。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = "hit", endWord = "cog", wordList = ["hot","dot","dog","lot","log"]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord "cog" 不在字典中，所以无法进行转换。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= beginWord.length &lt;= 10</code></li>
<li><code>endWord.length == beginWord.length</code></li>
<li><code>1 &lt;= wordList.length &lt;= 5000</code></li>
<li><code>wordList[i].length == beginWord.length</code></li>
<li><code>beginWord</code>、<code>endWord</code> 和 <code>wordList[i]</code> 由小写英文字母组成</li>
<li><code>beginWord != endWord</code></li>
<li><code>wordList</code> 中的所有字符串 <strong>互不相同</strong></li>
</ul>
<p>超时代码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超出时间限制</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    Map&lt; String, Integer &gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] flag = <span class="keyword">new</span> <span class="title class_">int</span>[ wordList.size() ];</span><br><span class="line">        Map&lt;String, Integer&gt; t = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( String s : wordList ) {</span><br><span class="line">            t.put(s, <span class="number">0</span>);</span><br><span class="line">        }  </span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordList.size(); i ++ ) {</span><br><span class="line">            <span class="keyword">if</span>( nextWord( beginWord,  wordList.get( i ) ) ) {</span><br><span class="line">                bfs( wordList.get( i ), endWord, wordList, i, <span class="number">2</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(t) );</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> min == Integer.MAX_VALUE ? <span class="number">0</span> : min;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bfs</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList, <span class="type">int</span> index, <span class="type">int</span> count, Map&lt;String, Integer&gt; t )</span> {</span><br><span class="line">        <span class="keyword">if</span> ( count &gt;= min )</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        t.put( beginWord, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( beginWord.equals( endWord ) ) {</span><br><span class="line">            <span class="comment">// System.out.println("===================================    " + count);</span></span><br><span class="line">            min = count &lt; min ? count : min;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( map.containsKey( beginWord + <span class="string">" "</span> + endWord ) ) {</span><br><span class="line">            <span class="keyword">if</span> ( count &gt;= min )</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; wordList.size(); i ++ ) {</span><br><span class="line">            <span class="keyword">if</span> ( t.get( wordList.get(i) ) == <span class="number">0</span> &amp;&amp; nextWord( beginWord,  wordList.get( i ) ) ) {</span><br><span class="line">                bfs( wordList.get( i ), endWord, wordList, i, count + <span class="number">1</span>, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;( t ) );</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        map.put( beginWord + <span class="string">" "</span> + endWord, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">nextWord</span><span class="params">( String beginWord, String word )</span> {</span><br><span class="line">        <span class="keyword">if</span> ( beginWord.equals( word ) || beginWord.length() != word.length() ) {</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; beginWord.length(); i ++ ) {</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(  beginWord.charAt( i ) != word.charAt( i ) ) {</span><br><span class="line">                n ++;</span><br><span class="line">                <span class="keyword">if</span> ( n &gt; <span class="number">1</span> ) {</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>



<p>正解：广度优先搜索</p>
<p>思路：</p>
<p>分析题意：</p>
<p>「转换」意即：两个单词对应位置只有一个字符不同，例如 “hit” 与 “hot”，这种转换是可以逆向的，因此，根据题目给出的单词列表，可以构建出一个无向（无权）图；</p>
<p><img src="https://pic.leetcode-cn.com/ec8f7e4f40134b932a9ff2e306d885e427bd8ee912801361849d92ddae6226f3-image.png" alt="image.png"></p>
<p>如果一开始就构建图，每一个单词都需要和除它以外的另外的单词进行比较，复杂度是 O(NwordLen)，这里 NN 是单词列表的长度；<br>为此，我们在遍历一开始，把所有的单词列表放进一个哈希表中，然后在遍历的时候构建图，每一次得到在单词列表里可以转换的单词，复杂度是 O(26×wordLen)，借助哈希表，找到邻居与 N 无关；<br>使用 BFS 进行遍历，需要的辅助数据结构是：<br>队列；<br>visited 集合。说明：可以直接在 wordSet (由 wordList 放进集合中得到)里做删除。但更好的做法是新开一个哈希表，遍历过的字符串放进哈希表里。这种做法具有普遍意义。绝大多数在线测评系统和应用场景都不会在意空间开销。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> {</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于更快地（相对于链表）判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) {</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">                <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) {</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            step++;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> {</span><br><span class="line">        <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) {</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">'a'</span>; k &lt;= <span class="string">'z'</span>; k++) {</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) {</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="comment">// 修改一个字母</span></span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                <span class="comment">// char[] --&gt; String</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) {</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) {</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    }</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) {</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>








      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-127.%20%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99/" data-id="clkr14xyv00d9s4v6hbbeaylw" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM下篇：性能监控与调优篇/补充：浅堆深堆与内存泄露" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" class="article-date">
  <time class="post-time" datetime="2023-01-12T02:41:36.361Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/">浅堆深堆与内存泄露</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/">JVM下篇：性能监控与调优篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="补充：浅堆深堆与内存泄露"><a href="#补充：浅堆深堆与内存泄露" class="headerlink" title="补充：浅堆深堆与内存泄露"></a>补充：浅堆深堆与内存泄露</h1><h2 id="1-浅堆（Shallow-Heap）"><a href="#1-浅堆（Shallow-Heap）" class="headerlink" title="1. 浅堆（Shallow Heap）"></a>1. 浅堆（Shallow Heap）</h2><p>浅堆是指一个对象所消耗的内存。在 32 位系统中，一个对象引用会占据 4 个字节，一个 int 类型会占据 4 个字节，long 型变量会占据 8 个字节，每个对象头需要占用 8 个字节。根据堆快照格式不同，对象的大小可能会同 8 字节进行对齐。</p>
<p>以 String 为例：2 个 int 值共占 8 字节，对象引用占用 4 字节，对象头 8 字节，合计 20 字节，向 8 字节对齐，故占 24 字节。（jdk7 中）</p>
<table>
<thead>
<tr>
<th>int</th>
<th>hash32</th>
<th>0</th>
</tr>
</thead>
<tbody><tr>
<td><strong>int</strong></td>
<td><strong>hash</strong></td>
<td><strong>0</strong></td>
</tr>
<tr>
<td><strong>ref</strong></td>
<td><strong>value</strong></td>
<td><strong>C:\Users\Administrat</strong></td>
</tr>
</tbody></table>
<p>这 24 字节为 String 对象的浅堆大小。它与 String 的 value 实际取值无关，无论字符串长度如何，浅堆大小始终是 24 字节。</p>
<h2 id="2-保留集（Retained-Set）"><a href="#2-保留集（Retained-Set）" class="headerlink" title="2. 保留集（Retained Set）"></a>2. 保留集（Retained Set）</h2><p>对象 A 的保留集指当对象 A 被垃圾回收后，可以被释放的所有的对象集合（包括对象 A 本身），即对象 A 的保留集可以被认为是只能通过对象 A 被直接或间接访问到的所有对象的集合。通俗地说，就是指仅被对象 A 所持有的对象的集合。</p>
<h2 id="3-深堆（Retained-Heap）"><a href="#3-深堆（Retained-Heap）" class="headerlink" title="3. 深堆（Retained Heap）"></a>3. 深堆（Retained Heap）</h2><p>深堆是指对象的保留集中所有的对象的浅堆大小之和。</p>
<p>注意：浅堆指对象本身占用的内存，不包括其内部引用对象的大小。一个对象的深堆指只能通过该对象访问到的（直接或间接）所有对象的浅堆之和，即对象被回收后，可以释放的真实空间。</p>
<h2 id="4-对象的实际大小"><a href="#4-对象的实际大小" class="headerlink" title="4. 对象的实际大小"></a>4. 对象的实际大小</h2><p>这里，对象的实际大小定义为一个对象所能触及的所有对象的浅堆大小之和，也就是通常意义上我们说的对象大小。与深堆相比，似乎这个在日常开发中更为直观和被人接受，但实际上，这个概念和垃圾回收无关。</p>
<p>下图显示了一个简单的对象引用关系图，对象 A 引用了 C 和 D，对象 B 引用了 C 和 E。那么对象 A 的浅堆大小只是 A 本身，不含 C 和 D，而 A 的实际大小为 A、C、D 三者之和。而 A 的深堆大小为 A 与 D 之和，由于对象 C 还可以通过对象 B 访问到，因此不在对象 A 的深堆范围内。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ecc35ddfcfd13200bbc881333d38ac93.png" alt="image-20210505151123427"></p>
<h2 id="5-支配树（Dominator-Tree）"><a href="#5-支配树（Dominator-Tree）" class="headerlink" title="5. 支配树（Dominator Tree）"></a>5. 支配树（Dominator Tree）</h2><p>支配树的概念源自图论。MAT 提供了一个称为支配树（Dominator Tree）的对象图。支配树体现了对象实例间的支配关系。在对象引用图中，所有指向对象 B 的路径都经过对象 A，则认为对象 A 支配对象 B。如果对象 A 是离对象 B 最近的一个支配对象，则认为对象 A 为对象 B 的直接支配者。支配树是基于对象间的引用图所建立的，它有以下基本性质：</p>
<ul>
<li>对象 A 的子树（所有被对象 A 支配的对象集合）表示对象 A 的保留集（retained set），即深堆。</li>
<li>如果对象 A 支配对象 B，那么对象 A 的直接支配者也支配对象 B。</li>
<li>支配树的边与对象引用图的边不直接对应。</li>
</ul>
<p>如下图所示：左图表示对象引用图，右图表示左图所对应的支配树。对象 A 和 B 由根对象直接支配，由于在到对象 C 的路径中，可以经过 A，也可以经过 B，因此对象 C 的直接支配者也是根对象。对象 F 与对象 D 相互引用，因为到对象 F 的所有路径必然经过对象 D，因此，对象 D 是对象 F 的直接支配者。而到对象 D 的所有路径中，必然经过对象 C，即使是从对象 F 到对象 D 的引用，从根节点出发，也是经过对象 C 的，所以，对象 D 的直接支配者为对象 C。同理，对象 E 支配对象 G。到达对象 H 的可以通过对象 D，也可以通过对象 E，因此对象 D 和 E 都不能支配对象 H，而经过对象 C 既可以到达 D 也可以到达 E，因此对象 C 为对象 H 的直接支配者。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4aea560be1feff266c7cb79c6a3a27ec.png" alt="image-20210505151951136"></p>
<h2 id="6-内存泄漏（memory-leak）"><a href="#6-内存泄漏（memory-leak）" class="headerlink" title="6. 内存泄漏（memory leak）"></a>6. 内存泄漏（memory leak）</h2><p>可达性分析算法来判断对象是否是不再使用的对象，本质都是判断一个对象是否还被引用。那么对于这种情况下，由于代码的实现不同就会出现很多种内存泄漏问题（让 JVM 误以为此对象还在引用中，无法回收，造成内存泄漏）。</p>
<p>＞ 是否还被使用？是</p>
<p>＞ 是否还被需要？否</p>
<p>（ 上面 ：【是，是】不是内存泄漏；但【是，否】就有问题了，属于内存泄漏，比如下图右边的 <strong>Fogotten Reference-&gt;Memory Leak</strong> ）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d5715ef16f3d967f6a79c82909877c15.png" alt="image-20210505152542224"></p>
<p><font color="red">严格来说，</font><strong>只有对象不会再被程序用到了，但是 GC 又不能回收他们的情况，才叫内存泄漏。</strong></p>
<p>但实际情况很多时候一些不太好的实践（或疏忽）会导致对象的<strong>生命周期变得很长甚至导致 00M</strong>，也可以叫做<font color="red">宽泛意义上的“内存泄漏”。</font></p>
<p>如下图，对象X引用对象Y，X的生命周期比Y的生命周期长，当 Y 生命周期结束的时候，X 依然引用着 Y，这时候，垃圾回收期是不会回收对象 Y 的；如果对象 X 还引用着生命周期比较短的 A、B、C，对象 A 又引用着对象 a、b、c，这样就可能造成大量无用的对象不能被回收，进而占据了内存资源，造成内存泄漏，直到内存溢出。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/98ee5c3507d1b8b73f4e12789728c56c.png" alt="image-20210505152704141"></p>
<p>申请了内存用完了不释放，比如一共有 1024M 的内存，分配了 512M 的内存一直不回收，那么可以用的内存只有 512M 了，仿佛泄露掉了一部分；通俗一点讲的话，内存泄漏就是【占着茅坑不拉 shi】</p>
<p><img src="/../../../images/image-20230116112741682.png" alt="image-20230116112741682"></p>
<h2 id="7-内存溢出（out-of-memory）"><a href="#7-内存溢出（out-of-memory）" class="headerlink" title="7. 内存溢出（out of memory）"></a>7. 内存溢出（out of memory）</h2><p>申请内存时，没有足够的内存可以使用；通俗一点儿讲，一个厕所就三个坑，有两个站着茅坑不走的（内存泄漏），剩下最后一个坑，厕所表示接待压力很大，这时候一下子来了两个人，坑位（内存）就不够了，内存泄漏变成内存溢出了。可见，内存泄漏和内存溢出的关系：内存泄漏的增多，最终会导致内存溢出。</p>
<p><mark>泄漏的分类</mark></p>
<ul>
<li><strong>经常发生</strong>：发生内存泄露的代码会被多次执行，每次执行，泄露一块内存；</li>
<li><strong>偶然发生</strong>：在某些特定情况下才会发生（比如再程序中有些资源最后是需要关闭的，但可能因为前面一些异常而没有往下执行到 close关闭，导致资源没有关闭）</li>
<li><strong>一次性</strong>：发生内存泄露的方法只会执行一次；</li>
<li><strong>隐式泄漏</strong>：一直占着内存不释放，直到执行结束；严格的说这个不算内存泄漏，因为最终释放掉了，但是如果执行时间特别长，也可能会导致内存耗尽。</li>
</ul>
<h2 id="8-Java-中内存泄露的-8-种情况"><a href="#8-Java-中内存泄露的-8-种情况" class="headerlink" title="8. Java 中内存泄露的 8 种情况"></a>8. Java 中内存泄露的 8 种情况</h2><h3 id="8-1-静态集合类"><a href="#8-1-静态集合类" class="headerlink" title="8.1. 静态集合类"></a>8.1. 静态集合类</h3><p>静态集合类，如 HashMap、LinkedList 等等。如果这些容器为静态的，那么它们的生命周期与 JVM 程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MemoryLeak</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">oomTests</span><span class="params">()</span>{</span><br><span class="line">        Object obj＝<span class="keyword">new</span> <span class="title class_">Object</span>();<span class="comment">//局部变量</span></span><br><span class="line">        list.add(obj);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-2-单例模式"><a href="#8-2-单例模式" class="headerlink" title="8.2. 单例模式"></a>8.2. 单例模式</h3><p>单例模式，和静态集合导致内存泄露的原因类似，因为单例的静态特性，它的生命周期和 JVM 的生命周期一样长，所以如果单例对象如果持有外部对象的引用，那么这个外部对象也不会被回收，那么就会造成内存泄漏。</p>
<h3 id="8-3-内部类持有外部类"><a href="#8-3-内部类持有外部类" class="headerlink" title="8.3. 内部类持有外部类"></a>8.3. 内部类持有外部类</h3><p>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象。这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄漏。</p>
<h3 id="8-4-各种连接，如数据库连接、网络连接和-IO-连接等"><a href="#8-4-各种连接，如数据库连接、网络连接和-IO-连接等" class="headerlink" title="8.4. 各种连接，如数据库连接、网络连接和 IO 连接等"></a>8.4. 各种连接，如数据库连接、网络连接和 IO 连接等</h3><p>在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用 close 方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对 Connection、Statement 或 ResultSet 不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">        Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        conn =DriverManager.getConnection(<span class="string">"url"</span>,<span class="string">""</span>,<span class="string">""</span>);</span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span>conn.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span>stmt.executeQuery(<span class="string">"...."</span>);</span><br><span class="line">    } <span class="keyword">catch</span>（Exception e）{<span class="comment">//异常日志</span></span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="comment">// 1．关闭结果集 Statement</span></span><br><span class="line">        <span class="comment">// 2．关闭声明的对象 ResultSet</span></span><br><span class="line">        <span class="comment">// 3．关闭连接 Connection</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-5-变量不合理的作用域"><a href="#8-5-变量不合理的作用域" class="headerlink" title="8.5. 变量不合理的作用域"></a>8.5. 变量不合理的作用域</h3><p>变量不合理的作用域。一般而言，<strong>一个变量的定义的作用范围大于其使用范围</strong>，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为 null，很有可能导致内存泄漏的发生。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsingRandom</span> {</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveMsg</span><span class="params">()</span>{</span><br><span class="line">        readFromNet();<span class="comment">//从网络中接受数据保存到msg中</span></span><br><span class="line">        saveDB();<span class="comment">//把msg保存到数据库中</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>如上面这个伪代码，通过 readFromNet 方法把接受的消息保存在变量 msg 中，然后调用 saveDB 方法把 msg 的内容保存到数据库中，此时 msg 已经就没用了，由于 msg 的生命周期与对象的生命周期相同，此时 msg 还不能回收，因此造成了内存泄漏。实际上这个 msg 变量可以放在 receiveMsg 方法内部，当方法使用完，那么 msg 的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完 msg 后，把 msg 设置为 null，这样垃圾回收器也会回收 msg 的内存空间。</p>
<p>上面的代码应该改为：</p>
<p><img src="/../../../images/image-20230116153505713.png" alt="image-20230116153505713"></p>
<h3 id="8-6-改变哈希值"><a href="#8-6-改变哈希值" class="headerlink" title="8.6. 改变哈希值"></a>8.6. 改变哈希值</h3><p>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了。</p>
<p>否则，对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄漏。</p>
<p>这也是 String 为什么被设置成了不可变类型，我们可以放心地把 String 存入 HashSet，或者把 String 当做 HashMap 的 key 值；</p>
<p>当我们想把自己定义的类保存到散列表的时候，需要保证对象的 hashCode 不可变。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">HashSet</span> <span class="variable">set</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashSet</span>();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"AA"</span>);</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1002</span>, <span class="string">"BB"</span>);</span><br><span class="line"></span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line"></span><br><span class="line">        p1.name = <span class="string">"CC"</span>;<span class="comment">//导致了内存的泄漏</span></span><br><span class="line">        set.remove(p1); <span class="comment">//删除失败</span></span><br><span class="line"></span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"CC"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">1001</span>, <span class="string">"AA"</span>));</span><br><span class="line">        System.out.println(set);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> {</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(<span class="type">int</span> id, String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Person)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != person.id) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="literal">null</span> ? name.equals(person.name) : person.name == <span class="literal">null</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="literal">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person{"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 例2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChangeHashCode1</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        HashSet&lt;Point&gt; hs = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Point&gt;();</span><br><span class="line">        <span class="type">Point</span> <span class="variable">cc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Point</span>();</span><br><span class="line">        cc.setX(<span class="number">10</span>);<span class="comment">//hashCode = 41</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line"></span><br><span class="line">        cc.setX(<span class="number">20</span>);<span class="comment">//hashCode = 51  此行为导致了内存的泄漏</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"hs.remove = "</span> + hs.remove(cc));<span class="comment">//false</span></span><br><span class="line">        hs.add(cc);</span><br><span class="line">        System.out.println(<span class="string">"hs.size = "</span> + hs.size());<span class="comment">//size = 2</span></span><br><span class="line"></span><br><span class="line">        System.out.println(hs);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> {</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getX</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setX</span><span class="params">(<span class="type">int</span> x)</span> {</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">prime</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        result = prime * result + x;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> {</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (getClass() != obj.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">Point</span> <span class="variable">other</span> <span class="operator">=</span> (Point) obj;</span><br><span class="line">        <span class="keyword">if</span> (x != other.x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Point{"</span> +</span><br><span class="line">                <span class="string">"x="</span> + x +</span><br><span class="line">                <span class="string">'}'</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="8-7-缓存泄露"><a href="#8-7-缓存泄露" class="headerlink" title="8.7. 缓存泄露"></a>8.7. 缓存泄露</h3><p>内存泄漏的另一个常见来源是缓存，一旦你把对象引用放入到缓存中，他就很容易遗忘。比如：之前项目在一次上线的时候，应用启动极慢直到夯死，就是因为代码中会加载一个表中的数据到缓存（内存）中，测试环境只有几百条数据，但是生产环境有几百万的数据。</p>
<p>对于这个问题，可以使用 <mark><strong>WeakHashMap</strong> </mark>代表缓存，此种 Map 的特点是，当除了自身有对 key 的引用外，此 key 没有其他引用那么此 map 会自动丢弃此值。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MapTest</span> {</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">wMap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WeakHashMap</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">Map</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        init();</span><br><span class="line">        testWeakHashMap();</span><br><span class="line">        testHashMap();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct1"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct2"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct3"</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">ref4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"obejct4"</span>);</span><br><span class="line">        wMap.put(ref1, <span class="string">"cacheObject1"</span>);</span><br><span class="line">        wMap.put(ref2, <span class="string">"cacheObject2"</span>);</span><br><span class="line">        map.put(ref3, <span class="string">"cacheObject3"</span>);</span><br><span class="line">        map.put(ref4, <span class="string">"cacheObject4"</span>);</span><br><span class="line">        System.out.println(<span class="string">"String引用ref1，ref2，ref3，ref4 消失"</span>);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testWeakHashMap</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"WeakHashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : wMap.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testHashMap</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之前"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.gc();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"HashMap GC之后"</span>);</span><br><span class="line">        <span class="keyword">for</span> (Object o : map.entrySet()) {</span><br><span class="line">            System.out.println(o);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20230116154929699.png" alt="image-20230116154929699"></p>
<p>上面代码和图示主演演示 <strong>WeakHashMap 如何自动释放缓存对象</strong>，当 init 函数执行完成后，局部变量字符串引用 weakd1，weakd2，d1，d2 都会消失，此时只有静态 map 中保存中对字符串对象的引用，可以看到，调用 gc 之后，HashMap 的没有被回收，而 WeakHashMap 里面的缓存被回收了。</p>
<h3 id="8-8-监听器和其他回调"><a href="#8-8-监听器和其他回调" class="headerlink" title="8.8. 监听器和其他回调"></a>8.8. 监听器和其他回调</h3><p>内存泄漏第三个常见来源是监听器和其他回调，如果客户端在你实现的 API 中注册回调，却没有显示的取消，那么就会积聚。</p>
<p>需要确保回调立即被当作垃圾回收的最佳方法是只保存它的弱引用，例如将他们保存成为 WeakHashMap 中的键。</p>
<h2 id="9-内存泄露-案例分析"><a href="#9-内存泄露-案例分析" class="headerlink" title="9. 内存泄露 案例分析"></a>9. 内存泄露 案例分析</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Stack</span> {</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Stack</span><span class="params">()</span> {</span><br><span class="line">        elements = <span class="keyword">new</span> <span class="title class_">Object</span>[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(Object e)</span> { <span class="comment">//入栈</span></span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> { <span class="comment">//出栈</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">()</span> {</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>上述程序并没有明显的错误，但是这段程序有一个内存泄漏，随着 GC 活动的增加，或者内存占用的不断增加，程序性能的降低就会表现出来，严重时可导致内存泄漏，但是这种失败情况相对较少。</p>
<p>代码的主要问题在 pop 函数，下面通过这张图示展现。假设这个栈一直增长，增长后如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/36134d739f40208bf54a0b5c89a8f882.png" alt="image-20210505160114618"></p>
<p>当进行大量的 pop 操作时，由于引用未进行置空，gc 是不会释放的，如下图所示</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/52eed9c8a0279db4b1f07fd23c0d5eca.png" alt="image-20210505160158618"></p>
<p>从上图中看以看出，如果栈先增长，再收缩，那么从栈中弹出的对象将不会被当作垃圾回收，即使程序不再使用栈中的这些队象，他们也不会回收，因为栈中仍然保存这对象的引用，俗称<font color="red">过期引用</font>，这个内存泄露很隐蔽。</p>
<p>将代码中的 pop()方法变成如下方法：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">pop</span><span class="params">()</span> {</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">EmptyStackException</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> elements[--size];</span><br><span class="line">    elements[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> result;<span class="number">2</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>一旦引用过期，清空这些引用，将引用置空。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/513c31471d30b0458114859524c35adc.png" alt="image-20210505160423289"></p>
<hr>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/12/JVM/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/%E8%A1%A5%E5%85%85%EF%BC%9A%E6%B5%85%E5%A0%86%E6%B7%B1%E5%A0%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/" data-id="clkr14xw50094s4v6chdphinq" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%8B%E7%AF%87%EF%BC%9A%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E7%AF%87/" rel="tag">JVM下篇：性能监控与调优篇</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/5-再谈类的加载器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/11/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/5-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2023-01-11T06:50:31.162Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">11</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/11/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/5-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">5-再谈类的加载器</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM中篇：字节码与类的加载器</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>类加载器是JVM执行类加载机制的前提。</p>
<p><strong>ClassLoader的作用：</strong></p>
<p>ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fb51cabb2218d857a809a59918c5beec.png" alt="image-20210501102535142"></p>
<h2 id="1-1-大厂面试题"><a href="#1-1-大厂面试题" class="headerlink" title="1.1. 大厂面试题"></a>1.1. 大厂面试题</h2><blockquote>
<p><mark>蚂蚁金服：</mark></p>
<p>深入分析ClassLoader，双亲委派机制</p>
<p>类加载器的双亲委派模型是什么？一面：双亲委派机制及使用原因</p>
<p><mark>百度：</mark></p>
<p>都有哪些类加载器，这些类加载器都加载哪些文件？</p>
<p>手写一个类加载器Demo</p>
<p>Class的forName（“java.lang.String”）和Class的getClassLoader（）的Loadclass（“java.lang.String”）有什么区别？</p>
<p><mark>腾讯：</mark></p>
<p>什么是双亲委派模型？</p>
<p>类加载器有哪些？</p>
<p><mark>小米：</mark></p>
<p>双亲委派模型介绍一下</p>
<p><mark>滴滴：</mark></p>
<p>简单说说你了解的类加载器一面：讲一下双亲委派模型，以及其优点</p>
<p><mark>字节跳动：</mark></p>
<p>什么是类加载器，类加载器有哪些？</p>
<p><mark>京东：</mark></p>
<p>类加载器的双亲委派模型是什么？</p>
<p>双亲委派机制可以打破吗？为什么</p>
</blockquote>
<h2 id="1-2-类加载器的分类"><a href="#1-2-类加载器的分类" class="headerlink" title="1.2. 类加载器的分类"></a>1.2. 类加载器的分类</h2><p>类的加载分类：显式加载 vs 隐式加载</p>
<p>class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。</p>
<ul>
<li>显式加载指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。</li>
<li>隐式加载则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。</li>
</ul>
<p>在日常开发以上两种方式一般会混合使用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//隐式加载</span></span><br><span class="line">User user=<span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line"><span class="comment">//显式加载，并初始化</span></span><br><span class="line">Class clazz=Class.forName(<span class="string">"com.test.java.User"</span>);</span><br><span class="line"><span class="comment">//显式加载，但不初始化</span></span><br><span class="line">ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.test.java.Parent"</span>); </span><br></pre></td></tr></tbody></table></figure>

<h2 id="1-3-类加载器的必要性"><a href="#1-3-类加载器的必要性" class="headerlink" title="1.3. 类加载器的必要性"></a>1.3. 类加载器的必要性</h2><p>一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。从以下几个方面说：</p>
<ul>
<li>避免在开发中遇到java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的 加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题</li>
<li>需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。</li>
<li>开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。</li>
</ul>
<h2 id="1-4-命名空间"><a href="#1-4-命名空间" class="headerlink" title="1.4. 命名空间"></a>1.4. 命名空间</h2><p><strong>何为类的唯一性？</strong></p>
<p><font color="red">对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。</font>每一个类加载器，都拥有一个独立的类名称空间：<font color="red">比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。</font>否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。</p>
<p><strong>命名空间</strong></p>
<ul>
<li><p>每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成</p>
</li>
<li><p>在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类</p>
</li>
<li><p>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类</p>
</li>
</ul>
<p>在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。</p>
<p><img src="/../../../images/image-20230111151013926.png" alt="image-20230111151013926"></p>
<h2 id="1-5-类加载机制的基本特征"><a href="#1-5-类加载机制的基本特征" class="headerlink" title="1.5. 类加载机制的基本特征"></a>1.5. 类加载机制的基本特征</h2><p>双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。</p>
<p><mark>可见性</mark>，子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。</p>
<p><mark>单一性</mark>，由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。</p>
<h2 id="1-6-类加载器之间的关系"><a href="#1-6-类加载器之间的关系" class="headerlink" title="1.6. 类加载器之间的关系"></a>1.6. 类加载器之间的关系</h2><p>Launcher类核心代码</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Launcher.ExtClassLoader var1;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">} <span class="keyword">catch</span> (IOException var10) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">    <span class="built_in">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">} <span class="keyword">catch</span> (IOException var9) {</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InternalError</span>(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Thread.currentThread().setContextClassLoader(<span class="built_in">this</span>.loader);</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><p><strong>ExtClassLoader的Parent类是null</strong></p>
</li>
<li><p><strong>AppClassLoader的Parent类是ExtClassLoader</strong></p>
</li>
<li><p><strong>当前线程的ClassLoader是AppClassLoader</strong></p>
</li>
</ul>
<p><font color="red">注意，这里的Parent类并不是Java语言意义上的继承关系，而是一种包含关系</font></p>
<hr>

<h1 id="2-类的加载器分类"><a href="#2-类的加载器分类" class="headerlink" title="2. 类的加载器分类"></a>2. 类的加载器分类</h1><p><img src="/../../../images/image-20230111152254983.png" alt="image-20230111152254983"></p>
<p>JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。</p>
<p>从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。无论类加载器的类型如何划分，在程序中我们最常见的类加载器结构主要是如下情况：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/0c43fb4a7da20038c8f56b42a1ddf802.png" alt="image-20210501164413665"></p>
<ul>
<li>除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加戟器。</li>
<li>不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。</li>
</ul>
<p>父类加载器和子类加载器的关系：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    ClassLoader parent;<span class="comment">//父类加载器</span></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ClassLoader</span><span class="params">(ClassLoader parent)</span>{</span><br><span class="line">        <span class="built_in">this</span>.parent = parent;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ParentClassLoader</span><span class="params">(ClassLoader parent)</span>{</span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ChildClassLoader</span><span class="params">(ClassLoader parent)</span>{ <span class="comment">//parent = new ParentClassLoader();</span></span><br><span class="line">        <span class="built_in">super</span>(parent);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>正是由于子类加载器中包含着父类加载器的引用，所以可以通过子类加载器的方法获取对应的父类加载器</p>
<p><strong>注意：</strong></p>
<p>启动类加载器通过C/C++语言编写，而自定义类加载器都是由Java语言编写的，虽然扩展类加载器和应用程序类加载器是被jdk开发人员使用java语言来编写的，但是也是由java语言编写的，所以也被称为自定义类加载器</p>
<h2 id="2-1-引导类加载器"><a href="#2-1-引导类加载器" class="headerlink" title="2.1. 引导类加载器"></a>2.1. 引导类加载器</h2><p><mark>启动类加载器（引导类加载器，Bootstrap ClassLoader）</mark></p>
<ul>
<li><p>这个类加载使用C/C++语言实现的，嵌套在JVM内部。</p>
</li>
<li><p>它用来加载Java的核心库（JAVAHOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。</p>
</li>
<li><p>并不继承自java.lang.ClassLoader，没有父加载器。</p>
</li>
<li><p>出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类</p>
</li>
<li><p>加载 扩展类和应用程序类加载器，并指定为他们的父类加载器。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/43431a1abff0e5f2bd7bfd20fe91e5f7.png" alt="image-20210501170011811"><br><img src="https://img-blog.csdnimg.cn/img_convert/5cd73234cd993408846ec7b4c2cb7238.png" alt="image-20210501170038212"><br>使用**-XX:+TraceClassLoading**参数得到。</p>
</li>
</ul>
<p>启动类加载器使用C++编写的？Yes！</p>
<ul>
<li>C/C++：指针函数&amp;函数指针、C++支持多继承、更加高效</li>
<li>Java：由C++演变而来，（C++）–版，单继承</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"＊＊＊＊＊＊＊＊＊＊启动类加载器＊＊＊＊＊＊＊＊＊＊"</span>);</span><br><span class="line"><span class="comment">// 获取BootstrapclassLoader能够加载的api的路径</span></span><br><span class="line">URL[] urLs = sun.misc.Launcher.getBootstrapcLassPath().getURLs();</span><br><span class="line"><span class="keyword">for</span> (URL element : urLs) {</span><br><span class="line">    System.out.println(element.toExternalForm());</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：引导类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> java.security.Provider.class.getClassLoader();</span><br><span class="line">System.out.println(classLoader);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>执行结果：</strong><br><img src="https://img-blog.csdnimg.cn/img_convert/c72286acf05c7f86d1ea24f74e0c2a1e.png" alt="image-20210501170425889"></p>
<h2 id="2-2-扩展类加载器"><a href="#2-2-扩展类加载器" class="headerlink" title="2.2. 扩展类加载器"></a>2.2. 扩展类加载器</h2><p><mark>扩展类加载器（Extension ClassLoader）</mark></p>
<ul>
<li><p>Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。</p>
</li>
<li><p>（间接）继承于ClassLoader类</p>
</li>
<li><p>父类加载器为启动类加载器</p>
</li>
<li><p>从  <strong>java.ext.dirs</strong> 系统属性所指定的目录中加载类库，或从JDK的安装目录的 <strong>jre/lib/ext</strong> 子目录下加载类库。如果用户创建的 <strong>JAR</strong> 放在此目录下，也会自动由扩展类加载器加载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ba54af96e744eb99a9248d13e55a7e3c.png" alt="在这里插入图片描述"></p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"＊＊＊＊＊＊＊＊＊＊＊扩展类加载器＊＊＊＊＊＊＊＊＊＊＊"</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">extDirs</span> <span class="operator">=</span>System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line"><span class="keyword">for</span> (String path :extDirs.split( regex:<span class="string">";"</span>)){</span><br><span class="line">    System.out.println(path);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从上面的路径中随意选择一个类，来看看他的类加载器是什么：扩展类加载器</span></span><br><span class="line"><span class="type">lassLoader</span> <span class="variable">classLoader1</span> <span class="operator">=</span> sun.security.ec.CurveDB.class.getClassLoader();</span><br><span class="line">System.out.print1n(classLoader1); <span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br></pre></td></tr></tbody></table></figure>

<p><strong>执行结果：</strong></p>
<p>  <img src="https://img-blog.csdnimg.cn/img_convert/b21313ee65acb4f01f1d03b88529e9f5.png" alt="img"></p>
<h2 id="2-3-系统类加载器"><a href="#2-3-系统类加载器" class="headerlink" title="2.3. 系统类加载器"></a>2.3. 系统类加载器</h2><p><mark>应用程序类加载器（系统类加载器，AppClassLoader）</mark>   （使用频率最高的加载器）</p>
<ul>
<li>java语言编写，由sun.misc.Launcher$AppClassLoader实现</li>
<li>继承于ClassLoader类</li>
<li>父类加载器 为 扩展类加载器</li>
<li>它负责加载环境变量classpath或系统属性java.class.path 指定路径下的类库</li>
<li><font color="red">应用程序中的类加载器默认是系统类加载器。</font></li>
<li>它是用户自定义类加载器的默认父加载器</li>
<li>通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/19dd9595afeb6543593ef14161fc1bb8.png" alt="image-20210501171206453"></p>
<h2 id="2-4-用户自定义类加载器"><a href="#2-4-用户自定义类加载器" class="headerlink" title="2.4. 用户自定义类加载器"></a>2.4. 用户自定义类加载器</h2><p><mark>用户自定义类加载器</mark></p>
<ul>
<li>在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。</li>
<li>体现Java语言强大生命力和巨大魅力的关键因素之一便是，<strong>Java开发者可以自定义类加载器来实现类库的动态加载</strong>，加载源可以是本地的JAR包，也可以是网络上的远程资源。</li>
<li><font color="red">通过类加载器可以实现非常绝妙的插件机制</font>，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。</li>
<li>同时，<font color="red">自定义加载器能够实现应用隔离}</font>，例如Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。</li>
<li>自定义类加载器通常需要继承于ClassLoader。</li>
</ul>
<hr>

<h1 id="3-测试不同的类的加载器"><a href="#3-测试不同的类的加载器" class="headerlink" title="3. 测试不同的类的加载器"></a>3. 测试不同的类的加载器</h1><p>每个Class对象都会包含一个定义它的ClassLoader的一个引用。<br><strong>获取ClassLoader的途径</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前类的ClassLoader</span></span><br><span class="line">clazz.getClassLoader()</span><br><span class="line"><span class="comment">// 获得当前线程上下文的ClassLoader</span></span><br><span class="line">Thread.currentThread().getContextClassLoader()</span><br><span class="line"><span class="comment">// 获得系统的ClassLoader</span></span><br><span class="line">ClassLoader.getSystemClassLoader()</span><br></pre></td></tr></tbody></table></figure>



<p><strong>说明：</strong></p>
<ul>
<li>站在程序的角度看，引导类加载器与另外两种类加载器（系统类加载器和扩展类加载器）并不是同一个层次意义上的加<br>载器，引导类加载器是使用C++语言编写而成的，而另外两种类加载器则是使用Java语言编写而成的。由于引导类加载<br>器压根儿就不是一个Java类，因此在Java程序中只能打印出空值。</li>
<li>数组类的Class对象，不是由类加载器去创建的，而是在Java运行期JVM根据需要自动创建的。对于数组类的类加载器<br>来说，是通过Class.getClassLoader()返回的，与数组当中元素类型的类加载器是一样的；如果数组当中的元素类型<br>是基本数据类型，数组类是没有类加载器的。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line">String[] strArr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">6</span>];</span><br><span class="line">System.out.println(strArr.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：sun．misc．Launcher＄AppCLassLoader＠18b4aac2</span></span><br><span class="line">ClassLoaderTest[] test=<span class="keyword">new</span> <span class="title class_">ClassLoaderTest</span>[<span class="number">1</span>];</span><br><span class="line">System.out.println(test.getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果：null</span></span><br><span class="line"><span class="type">int</span>[]ints =<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(ints.getClass().getClassLoader());</span><br></pre></td></tr></tbody></table></figure>

<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest1</span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="comment">//获取系统该类加载器</span></span><br><span class="line">        ClassLoader systemClassLoader=ClassLoader.getSystemCLassLoader();</span><br><span class="line">        System.out.print1n(systemClassLoader);<span class="comment">//sun.misc.Launcher$AppCLassLoader@18b4aac2</span></span><br><span class="line">        <span class="comment">//获取扩展类加载器</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">extClassLoader</span> <span class="operator">=</span>systemClassLoader.getParent();</span><br><span class="line">        System.out.println(extClassLoader);<span class="comment">//sun.misc. Launcher$ExtCLassLoader@1540e19d</span></span><br><span class="line">        <span class="comment">//试图获取引导类加载器：失败</span></span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">bootstrapClassLoader</span> <span class="operator">=</span>extClassLoader.getParent();</span><br><span class="line">        System.out.print1n(bootstrapClassLoader);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##################################</span></span><br><span class="line">        <span class="keyword">try</span>{</span><br><span class="line">            <span class="comment">// 获取到的是 引导类加载器</span></span><br><span class="line">            <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span>Class.forName(<span class="string">"java.lang.String"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader);  <span class="comment">// null</span></span><br><span class="line">            <span class="comment">//自定义的类默认使用系统类加载器</span></span><br><span class="line">            ClassLoader classLoader1=Class.forName(<span class="string">"com.atguigu.java.ClassLoaderTest1"</span>).getClassLoader();</span><br><span class="line">            System.out.println(classLoader1);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//关于数组类型的加载：使用的类的加载器与数组元素的类的加载器相同</span></span><br><span class="line">            String[] arrstr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arrstr.getClass().getClassLoader());<span class="comment">//null：表示使用的是引导类加载器</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 自定义的类的数据，还是默认使用系统类加载器</span></span><br><span class="line">            ClassLoaderTest1[] arr1 =<span class="keyword">new</span> <span class="title class_">ClassLoaderTest1</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr1.getClass().getClassLoader());<span class="comment">//sun.misc. Launcher$AppcLassLoader@18b4aac2</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 基本数据类型由虚拟机预先定义的（而引用数据类型则需要进行类的加载）</span></span><br><span class="line">            <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">            System.out.println(arr2.getClass().getClassLoader()); <span class="comment">//null: 不需要（或是说没有）类加载器</span></span><br><span class="line">        } <span class="keyword">catch</span> (ClassNotFoundException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<hr>

<h1 id="4-ClassLoader源码解析"><a href="#4-ClassLoader源码解析" class="headerlink" title="4. ClassLoader源码解析"></a>4. ClassLoader源码解析</h1><p><strong>ClassLoader与现有类的关系：</strong></p>
<p><img src="/../../../images/image-20230111212620186.png" alt="image-20230111212620186"></p>
<p>除了以上虚拟机自带的加载器外，用户还可以定制自己的类加载器。Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<h2 id="4-1-ClassLoader的主要方法"><a href="#4-1-ClassLoader的主要方法" class="headerlink" title="4.1. ClassLoader的主要方法"></a>4.1. ClassLoader的主要方法</h2><p>抽象类ClassLoader的主要方法：（内部没有抽象方法）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> ClassLoader <span class="title function_">getParent</span><span class="params">()</span></span><br></pre></td></tr></tbody></table></figure>

<p>返回该类加载器的超类加载器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></tbody></table></figure>

<p>加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException异常。<mark>该方法中的逻辑就是双亲委派模式的实现。</mark></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException</span><br></pre></td></tr></tbody></table></figure>

<p>查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。</p>
<ul>
<li><p>在JDK1.2之前，在自定义类加载时，总会去继承ClassLoader类并重写loadClass方法，从而实现自定义的类加载类。但是在JDK1.2之后已不再建议用户去覆盖loadClass()方法，而是建议把自定义的类加载逻辑写在findClass()方法中，从前面的分析可知，findClass()方法是在loadClass()方法中被调用的，当loadClass()方法中父加载器加载失败后，则会调用自己的findClass()方法来完成类加载，这样就可以保证自定义的类加载器也符合双亲委托模式。</p>
</li>
<li><p>需要注意的是ClassLoader类中并没有实现findClass()方法的具体代码逻辑，取而代之的是抛出ClassNotFoundException异常，同时应该知道的是findClass方法通常是和defineClass方法一起使用的。<font color="red">一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象。</font></p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="type">byte</span>[] b,<span class="type">int</span> off,<span class="type">int</span> len)</span><br></pre></td></tr></tbody></table></figure>

<p>根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。</p>
<ul>
<li><p>defineClass()方法是用来将byte字节流解析成JVM能够识别的Class对象（ClassLoader中已实现该方法逻辑），通过这个方法不仅能够通过class文件实例化class对象，也可以通过其他方式实例化class对象，如通过网络接收一个类的字节码，然后转换为byte字节流创建对应的Class对象。</p>
</li>
<li><p><font color="red">defineClass()方法通常与findClass()方法一起使用，一般情况下，在自定义类加载器时，会直接覆盖ClassLoader的findClass()方法并编写加载规则，取得要加载类的字节码后转换成流，然后调用defineClass()方法生成类的Class对象</font></p>
</li>
</ul>
<p><strong>简单举例：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException {</span><br><span class="line">    <span class="comment">// 获取类的字节数组</span></span><br><span class="line">    <span class="type">byte</span>[] classData =getClassData(name);</span><br><span class="line">    <span class="keyword">if</span> (classData == <span class="literal">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">    } <span class="keyword">else</span>{</span><br><span class="line">        <span class="comment">//使用defineClass生成class对象</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name,classData,θ,classData.length);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">resolveClass</span><span class="params">(Class&lt;?&gt; c)</span></span><br></pre></td></tr></tbody></table></figure>

<p>链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; findLoadedClass(String name)</span><br></pre></td></tr></tbody></table></figure>

<p>查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader parent;</span><br></pre></td></tr></tbody></table></figure>

<p>它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中，ClassLoader可能会将某些请求交予自己的双亲处理。</p>
<p><img src="/../../../images/image-20230111214619659.png" alt="image-20230111214619659"></p>
<p><img src="/../../../images/image-20230111214648047.png" alt="image-20230111214648047"></p>
<h2 id="4-2-SecureClassLoader与URLClassLoader"><a href="#4-2-SecureClassLoader与URLClassLoader" class="headerlink" title="4.2. SecureClassLoader与URLClassLoader"></a>4.2. SecureClassLoader与URLClassLoader</h2><p>接着SecureClassLoader扩展了ClassLoader，新增了几个与使用相关的代码源（对代码源的位置及其证书的验证）和权限定义类验证（主要指对class源码的访问权限）的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。</p>
<p>前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。<font color="red">在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类</font>，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/53f634bada23b3400a303bfcc6e11a31.png" alt="image-20210501174730756"></p>
<h2 id="4-3-ExtClassLoader与AppClassLoader"><a href="#4-3-ExtClassLoader与AppClassLoader" class="headerlink" title="4.3. ExtClassLoader与AppClassLoader"></a>4.3. ExtClassLoader与AppClassLoader</h2><p>了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。</p>
<p>sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a77b6bca10308e6b9be35b1b2dfc84bc.png" alt="img"></p>
<p>我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。</p>
<h2 id="4-4-Class-forName-与ClassLoader-loadClass"><a href="#4-4-Class-forName-与ClassLoader-loadClass" class="headerlink" title="4.4. Class.forName()与ClassLoader.loadClass()"></a>4.4. Class.forName()与ClassLoader.loadClass()</h2><p>( ps : 面试有可能会问这两者的区别 )</p>
<p><strong>Class.forName()</strong></p>
<ul>
<li><p>Class.forName()：是一个静态方法，最常用的是Class.forName(String className);</p>
</li>
<li><p>根据传入的类的全限定名返回一个Class对象。该方法在将Class文件加载到内存的同时，会执行类的初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.atguigu.java.Helloworld"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>ClassLoader.loadClass()</strong></p>
<ul>
<li><p>ClassLoader.loadClass()：这是一个实例方法，需要一个ClassLoader对象来调用该方法。</p>
</li>
<li><p>该方法将Class文件加载到内存时，并不会执行类的初始化，直到这个类第一次使用时才进行初始化。该方法因为需要得到一个ClassLoader对象，所以可以根据需要指定使用哪个类加载器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Classloader</span> <span class="variable">cl</span> <span class="operator">=</span> ......; cl.loadClass(<span class="string">"com.atguigu.java.Helloworld"</span>);</span><br></pre></td></tr></tbody></table></figure>

<hr></li>
</ul>
<h1 id="5-双亲委派模型"><a href="#5-双亲委派模型" class="headerlink" title="5. 双亲委派模型"></a>5. 双亲委派模型</h1><h2 id="5-1-定义与本质"><a href="#5-1-定义与本质" class="headerlink" title="5.1. 定义与本质"></a>5.1. 定义与本质</h2><p>类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。</p>
<p><strong>定义</strong></p>
<p><mark>如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务委托给父类加载器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。</mark></p>
<p><strong>本质</strong></p>
<p><font color="red">规定了<strong>类加载的顺序</strong>是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。</font></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/41cbfd9ba1da676a7f05dae0dac3abae.png" alt="image-20210501175529542"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c1526b63e95852b48551b4f136ebbd6f.png" alt="img"></p>
<h2 id="5-2-优势与劣势"><a href="#5-2-优势与劣势" class="headerlink" title="5.2. 优势与劣势"></a>5.2. 优势与劣势</h2><p><strong>双亲委派机制优势</strong></p>
<ul>
<li><p>避免类的重复加载，确保一个类的全局唯一性</p>
<p><font color="red">Java 类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</font></p>
</li>
<li><p>保护程序安全，防止核心API被随意篡改</p>
</li>
</ul>
<p><strong>代码支持</strong></p>
<p>双亲委派机制在java.lang.ClassLoader.loadClass(String，boolean)接口中体现。该接口的逻辑如下：</p>
<p>（1）先在当前加载器的缓存中查找有无目标类，如果有，直接返回。</p>
<p>（2）判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name，false)接口进行加载。</p>
<p>（3）反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassorNull(name)接口，让引导类加载器进行加载。</p>
<p>（4）如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。</p>
<p>双亲委派的模型就隐藏在这第2和第3步中。</p>
<p><img src="/../../../images/image-20230111220340860.png" alt="image-20230111220340860"></p>
<p><strong>举例</strong></p>
<p>假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当]VM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定查找不到该类，因此进入第2步。扩展类的父加载器是null，因此系统调用findClass（String），最终通过引导类加载器进行加载。</p>
<p><strong>思考</strong></p>
<p>如果在自定义的类加载器中重写java.lang.ClassLoader.loadClass(String)或java.lang.ClassLoader.loadclass(String，boolean)方法，抹去其中的双亲委派机制，仅保留上面这4步中的第l步与第4步，那么是不是就能够加载核心类库了呢？</p>
<p>这也不行！因为JDK还为核心类库提供了一层保护机制。不管是自定义的类加载器，还是系统类加载器抑或扩展类加载器，最终都必须调用 java.lang.ClassLoader.defineclass(String，byte[]，int，int，ProtectionDomain)方法，而该方法会执行preDefineClass()接口，该接口中提供了对JDK核心类库的保护。</p>
<p><strong>弊端</strong></p>
<p>检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。</p>
<p>通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，<font color="red">应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。</font>比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。</p>
<p><strong>结论</strong></p>
<p><font color="red">由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型，只是建议采用这种方式而已。</font>比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Serylet规范推荐的一种做法。</p>
<h2 id="5-3-破坏双亲委派机制"><a href="#5-3-破坏双亲委派机制" class="headerlink" title="5.3. 破坏双亲委派机制"></a>5.3. 破坏双亲委派机制</h2><p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<p>在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。</p>
<p><strong>第一次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前一—即JDK1.2面世以前的“远古”时代。</p>
<p>由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，<font color="red">为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性</font>，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<p><strong>第二次破坏双亲委派机制：线程上下文类加载器</strong></p>
<p>双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（<font color="red">越基础的类由越上层的加载器进行加载</font>），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有<font color="red">基础类型又要调用回用户的代码，那该怎么办呢？</font></p>
<p>这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，<font color="red">启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？</font><u>（SPI：在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI）</u></p>
<p>为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：<font color="red">线程上下文类加载器（Thread Context ClassLoader）</font>。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</p>
<p>有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，<font color="red">这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经<strong>违背了</strong>双亲委派模型的一般性原则</font>，但也是无可奈何的事情。 例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/814235dcce5471c2a527e82bafcf21c7.png" alt="img"></p>
<p>默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。</p>
<p><strong>第三次破坏双亲委派机制</strong></p>
<p>双亲委派模型的第三次“被破坏”是由于<strong>用户对程序动态性的追求而导致</strong>的。如：**代码热替换(Hot Swap)、模块热部署(Hot Deployment)**等</p>
<p>IBM公司主导的JSR-291(即OSGiR4.2)实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(osGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bund1e连同类加载器一起换掉以实现代码的热替换。在oSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的<font color="red">网状结构。</font></p>
<p>当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：</p>
<p>1）<font color="red">将以java.*开头的类，委派给父类加载器加载。</font></p>
<p>2）<font color="red">否则，将委派列表名单内的类，委派给父类加载器加载。</font></p>
<p>3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。</p>
<p>4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。</p>
<p>5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。</p>
<p>6）否则，查找Dynamic Import列表的Bundle，委派给对应Bund1e的类加载器加载。</p>
<p>7）否则，类查找失败。</p>
<p>说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的</p>
<p><strong>小结：这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并不一定是带有贬义的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。</strong></p>
<p>正如：OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为<strong>OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。</strong></p>
<h2 id="5-4-热替换的实现"><a href="#5-4-热替换的实现" class="headerlink" title="5.4. 热替换的实现"></a>5.4. 热替换的实现</h2><p>热替换是指在程序的运行过程中，不停止服务，只通过替换程序文件来修改程序的行为。<font color="red">热替换的关键需求在于服务不能中断，修改必须立即表现正在运行的系统之中。</font>基本上大部分脚本语言都是天生支持热替换的，比如：PHP，只要替换了PHP源文件，这种改动就会立即生效，而无需重启Web服务器。</p>
<p>但对Java来说，热替换并非天生就支持，如果一个类已经加载到系统中，通过修改类文件，并无法让系统再来加载并重定义这个类。因此，在Java中实现这一功能的一个可行的方法就是灵活运用ClassLoader。</p>
<p>注意：由不同ClassLoader加载的同名类属于不同的类型，不能相互转换和兼容。即两个不同的ClassLoader加载同一个类，在虚拟机内部，会认为这2个类是完全不同的。</p>
<p>根据这个特点，可以用来模拟热替换的实现，基本思路如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9ae876265c85af4e431932647993dab7.png" alt="image-20210501182003439"></p>
<hr>

<p><strong>代码举例：</strong></p>
<p><img src="/../../../images/image-20230111234030296.png" alt="image-20230111234030296"></p>
<p><img src="/../../../images/image-20230111233943314.png" alt="image-20230111233943314"></p>
<p><img src="/../../../images/image-20230111233655889.png" alt="image-20230111233655889"></p>
<p><img src="/../../../images/image-20230111233756937.png" alt="image-20230111233756937"></p>
<h1 id="6-沙箱安全机制"><a href="#6-沙箱安全机制" class="headerlink" title="6. 沙箱安全机制"></a>6. 沙箱安全机制</h1><p>沙箱安全机制</p>
<ul>
<li>保证程序安全</li>
<li>保护Java原生的JDK代码</li>
</ul>
<p><font color="red">Java安全模型的核心就是Java沙箱（sandbox）</font>。什么是沙箱？沙箱是一个限制程序运行的环境。</p>
<p>沙箱机制就是将Java代码<font color="red">限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问</font>。通过这样的措施来保证对代码的<strong>有限隔离</strong>，防止对本地系统造成破坏。</p>
<p>沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。</p>
<p>所有的Java程序运行都可以指定沙箱，可以定制安全策略。</p>
<h2 id="6-1-JDK1-0时期"><a href="#6-1-JDK1-0时期" class="headerlink" title="6.1. JDK1.0时期"></a>6.1. JDK1.0时期</h2><p>在Java中将执行程序分成本地代码和远程代码两种，本地代码默认视为可信任的，而远程代码则被看作是不受信的。对于授信的本地代码，可以访问一切本地资源。而对于非授信的远程代码在早期的Java实现中，安全依赖于<strong>沙箱（Sandbox）机制</strong>。如下图所示JDK1.0安全模型</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/71caf905a0ca13866e24419b7faa14ee.png" alt="image-20210501182608205"></p>
<h2 id="6-2-JDK1-1时期"><a href="#6-2-JDK1-1时期" class="headerlink" title="6.2. JDK1.1时期"></a>6.2. JDK1.1时期</h2><p>JDK1.0中如此严格的安全机制也给程序的功能扩展带来障碍，比如当用户希望远程代码访问本地系统的文件时候，就无法实现。</p>
<p>因此在后续的Java1.1版本中，针对安全机制做了改进，增加了<strong>安全策略</strong>。允许用户指定代码对本地资源的访问权限。</p>
<p>如下图所示JDK1.1安全模型</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b93f0829e8340131a49738f8843307e4.png" alt="image-20210501182626963"></p>
<h2 id="6-3-JDK1-2时期"><a href="#6-3-JDK1-2时期" class="headerlink" title="6.3. JDK1.2时期"></a>6.3. JDK1.2时期</h2><p>在Java1.2版本中，再次改进了安全机制，增加了<strong>代码签名</strong>。不论本地代码或是远程代码，都会按照用户的安全策略设定，由类加载器加载到虚拟机中权限不同的运行空间，来实现差异化的代码执行<strong>权限控制</strong>。如下图所示JDK1.2安全模型：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/81919ed70977f2b57ef5a11481c68abc.png" alt="image-20210501182652378"></p>
<h2 id="6-4-JDK1-6时期"><a href="#6-4-JDK1-6时期" class="headerlink" title="6.4. JDK1.6时期"></a>6.4. JDK1.6时期</h2><p>当前最新的安全机制实现，则引入了<strong>域（Domain）</strong>的概念。</p>
<p>虚拟机会把所有代码加载到不同的系统域和应用域。<font color="red"><strong>系统域</strong>部分专门负责与关键资源进行交互</font>，而各个应用域部分则通过系统域的部分代理来对各种需要的资源进行访问。虚拟机中不同的受保护域（Protected Domain），对应不一样的权限（Permission）。存在于不同域中的类文件就具有了当前域的全部权限，如下图所示，最新的安全模型（jdk1.6）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cf22059daec45f370ae3afb33b870c1f.png" alt="image-20210501182740197"></p>
<hr>

<h1 id="7-自定义类的加载器"><a href="#7-自定义类的加载器" class="headerlink" title="7. 自定义类的加载器"></a>7. 自定义类的加载器</h1><h2 id="7-1-为什么要自定义类加载器？"><a href="#7-1-为什么要自定义类加载器？" class="headerlink" title="7.1. 为什么要自定义类加载器？"></a>7.1. 为什么要自定义类加载器？</h2><ul>
<li><p><font color="red">隔离加载类</font></p>
<p>在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。比如:阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。再比如:Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。</p>
</li>
<li><p><font color="red">修改类加载的方式</font></p>
<p>类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载</p>
</li>
<li><p><font color="red">扩展加载源</font></p>
<p>比如从数据库、网络、甚至是电视机机顶盒进行加载</p>
</li>
<li><p><font color="red">防止源码泄漏</font></p>
<p>Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。</p>
</li>
</ul>
<p><strong>常见的场景</strong></p>
<ul>
<li>实现类似进程内隔离，类加载器实际上用作不同的命名空间，以提供类似容器、模块化的效果。例如，<strong>两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰</strong>。这个方面的集大成者是JavaEE和OSGI、JPMS等框架。</li>
<li>应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。</li>
</ul>
<p><strong>注意</strong>：</p>
<p>在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。<strong>在做 <mark>Java类型转换</mark> 时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。</strong></p>
<h2 id="7-2-实现方式"><a href="#7-2-实现方式" class="headerlink" title="7.2. 实现方式"></a>7.2. 实现方式</h2><p>Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。</p>
<p>在自定义ClassLoader的子类时候，我们常见的会有两种做法:</p>
<ul>
<li>方式一:重写loadClass()方法</li>
<li>方式二:重写findclass()方法  —&gt;推荐</li>
</ul>
<p><strong>对比</strong></p>
<ul>
<li>这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。</li>
<li>loadclass()这个方法是实现双亲委派模型逻辑的地方，擅自修改这个方法会导致模型被破坏，容易造成问题。<font color="red">因此我们最好是在双亲委派模型框架内进行小范围的改动，不破坏原有的稳定结构</font>。同时，也避免了自己重写loadClass()方法的过程中必须写双亲委托的重复代码，从代码的复用性来看，不直接修改这个方法始终是比较好的选择。</li>
<li>当编写好自定义类加载器后，便可以在程序中调用loadClass()方法来实现类加载操作。</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>其父类加载器是系统类加载器</li>
<li>JVM中的所有类加载都会使用java.lang.ClassLoader.loadClass(String)接口(自定义类加载器并重写java.lang.ClassLoader.loadClass(String)接口的除外)，连JDK的核心类库也不能例外。</li>
</ul>
<p>自定义类加载器：</p>
<p><img src="/../../../images/image-20230112100726579.png" alt="image-20230112100726579"></p>
<p>测试：</p>
<p><img src="/../../../images/image-20230112100837437.png" alt="image-20230112100837437"></p>
<hr>

<p><img src="/../../../images/image-20230112101138225.png" alt="image-20230112101138225"></p>
<h1 id="8-Java9新特性"><a href="#8-Java9新特性" class="headerlink" title="8. Java9新特性"></a>8. Java9新特性</h1><p>为了保证兼容性，JDK9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。</p>
<ol>
<li><p>扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器(platform class loader)。可以通过classLoader的新方法getPlatformClassLoader()来获取。</p>
<p>JDK9时基于模块化进行构建(原来的rt.jar和tools.jar被拆分成数十个JMOD文件)，其中的Java类库就已天然地满足了可扩展的需求，那自然无须再保留<java_home>\lib\ext目录，此前使用这个目录或者java.ext.dirs系统变量来扩展JDK功能的机制已经没有继续存在的价值了。</java_home></p>
</li>
<li><p>平台类加载器和应用程序类加载器都不再继承自java.net.URLClassLoader。</p>
<p>现在启动类加载器、平台类加载器、应用程序类加载器全都继承于jdk.internal.loader.BuiltinClassLoader。</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/323cfcda53f98034ed15372c0ea43685.png" alt="img"></p>
<p>​		如果有程序直接依赖了这种继承关系，或者依赖了URLClassLoader类的特定方法，那代码很可能会在JDK9及更高版本的JDK中崩溃。</p>
<ol start="3">
<li>在Java9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。</li>
<li>启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。</li>
<li>类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/cb23791a5fb1bf1a4c8a28d6a3179e84.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ef9b83abcdb9f54d0f0ec7d15f0adc44.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/192fda50804d35e7d1b44dc61a65ede1.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f07a455ec275a6503bfad070ae3d9ffb.png" alt="img"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoaderTest</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent());</span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getParent().getParent());  <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取系统类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getSystemClassLoader()); </span><br><span class="line">        <span class="comment">//获取平台类加载器</span></span><br><span class="line">        System.out.println(ClassLoader.getPlatformClassLoader());</span><br><span class="line">        <span class="comment">//获取类的加载器的名称</span></span><br><span class="line">        System.out.println(ClassLoaderTest.class.getClassLoader().getName());   <span class="comment">// app</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20230112102043394.png" alt="image-20230112102043394"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/11/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/5-%E5%86%8D%E8%B0%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" data-id="clkr14xwj009os4v6aj84devn" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="tag">JVM中篇：字节码与类的加载器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/4-类的加载过程（类的生命周期）详解" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/10/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time class="post-time" datetime="2023-01-10T14:08:57.478Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">10</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/10/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3/">4-类的加载过程（类的生命周期）详解</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM中篇：字节码与类的加载器</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p>在 Java 中数据类型分为基本数据类型和引用数据类型。<mark>基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。</mark></p>
<p>按照 Java 虚拟机规范，从 class 文件到加载到内存中的类，到类卸载出内存为止，它的整个生命周期包括如下 7 个阶段：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b73db20eea59665fa3de67e1dec6d4e5.png" alt="image-20210430215050746"></p>
<p>其中，验证、准备、解析 3 个部分统称为链接（Linking）</p>
<p>从程序中类的使用过程看</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c6e5a63339bb2574b9b52a9ed14ee9c5.png" alt="image-20210430215236716"></p>
<h2 id="大厂面试题"><a href="#大厂面试题" class="headerlink" title="大厂面试题"></a>大厂面试题</h2><blockquote>
<p><mark>蚂蚁金服：</mark></p>
<p>描述一下 JVM 加载 Class 文件的原理机制？</p>
<p>一面：类加载过程</p>
<p><mark>百度：</mark></p>
<p>类加载的时机</p>
<p>java 类加载过程？</p>
<p>简述 java 类加载机制？</p>
<p><mark>腾讯：</mark></p>
<p>JVM 中类加载机制，类加载过程？</p>
<p><mark>滴滴：</mark></p>
<p>JVM 类加载机制</p>
<p><mark>美团：</mark></p>
<p>Java 类加载过程</p>
<p>描述一下 jvm 加载 class 文件的原理机制</p>
<p><mark>京东：</mark></p>
<p>什么是类的加载？</p>
<p>哪些情况会触发类的加载？</p>
<p>讲一下 JVM 加载一个类的过程 JVM 的类加载机制是什么？</p>
</blockquote>
<hr>

<h1 id="2-过程一：Loading（加载）阶段"><a href="#2-过程一：Loading（加载）阶段" class="headerlink" title="2. 过程一：Loading（加载）阶段"></a>2. 过程一：Loading（加载）阶段</h1><h2 id="2-1-加载完成的操作"><a href="#2-1-加载完成的操作" class="headerlink" title="2.1. 加载完成的操作"></a>2.1. 加载完成的操作</h2><p><strong>加载的理解</strong></p>
<p><font color="red">所谓加载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象</font>。所谓类模板对象，其实就是 Java 类在]VM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样]VM 在运行期便能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。</p>
<p>反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法反射。</p>
<p><strong>加载完成的操作</strong></p>
<p><font color="red">加载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。</font></p>
<p>在加载类时，Java 虚拟机必须完成以下 3 件事情：</p>
<ul>
<li><p>通过类的全名，获取类的二进制数据流。</p>
</li>
<li><p>解析类的二进制数据流为方法区内的数据结构（Java 类模型）</p>
</li>
<li><p>创建 java.lang.Class 类的实例，表示该类型。作为方法区这个类的各种数据的访问入口</p>
</li>
</ul>
<h2 id="2-2-二进制流的获取方式"><a href="#2-2-二进制流的获取方式" class="headerlink" title="2.2. 二进制流的获取方式"></a>2.2. 二进制流的获取方式</h2><p>对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。<mark>（只要所读取的字节码符合 JVM 规范即可）</mark></p>
<ul>
<li>虚拟机可能通过文件系统读入一个 class 后缀的文件（最常见）</li>
<li>读入 jar、zip 等归档数据包，提取类文件。</li>
<li>事先存放在数据库中的类的二进制数据</li>
<li>使用类似于 HTTP 之类的协议通过网络进行加载</li>
<li>在运行时生成一段 class 的二进制信息等</li>
<li>在获取到类的二进制信息后，Java 虚拟机就会处理这些数据，并最终转为一个 java.lang.Class 的实例。</li>
</ul>
<p>如果输入数据不是 ClassFile 的结构，则会抛出 ClassFormatError。</p>
<h2 id="2-3-类模型与-Class-实例的位置"><a href="#2-3-类模型与-Class-实例的位置" class="headerlink" title="2.3. 类模型与 Class 实例的位置"></a>2.3. 类模型与 Class 实例的位置</h2><p><strong>类模型的位置</strong></p>
<p>加载的类在 JVM 中创建相应的类结构，类结构会存储在<strong>方法区</strong>（JDKl.8 之前：永久代；JDKl.8 及之后：元空间）。</p>
<p><strong>Class 实例的位置</strong></p>
<p>类将.class 文件加载至元空间后，会在<strong>堆</strong>中创建一个 Java.lang.Class 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型的对象。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/10969de50477655b954b23bfe550fb1d.png" alt="image-20210430221037898"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line"><span class="comment">//获取当前运行时类声明的所有方法</span></span><br><span class="line">Method[] ms = clazz.getDecla#FF0000Methods();</span><br><span class="line"><span class="keyword">for</span> (Method m : ms) {</span><br><span class="line">    <span class="comment">//获取方法的修饰符</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">mod</span> <span class="operator">=</span> Modifier.toString(m.getModifiers());</span><br><span class="line">    System.out.print(mod + <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//获取方法的返回值类型</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">returnType</span> <span class="operator">=</span> (m.getReturnType()).getSimpleName();</span><br><span class="line">    System.out.print(returnType + <span class="string">""</span>);</span><br><span class="line">    <span class="comment">//获取方法名</span></span><br><span class="line">    System.out.print(m.getName() + <span class="string">"("</span>);</span><br><span class="line">    <span class="comment">//获取方法的参数列表</span></span><br><span class="line">    Class&lt;?&gt;[] ps = m.getParameterTypes();</span><br><span class="line">    <span class="keyword">if</span> (ps.length == <span class="number">0</span>) {</span><br><span class="line">        System.out.print(<span class="string">')'</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ps.length; i++) {</span><br><span class="line">        <span class="type">char</span> <span class="variable">end</span> <span class="operator">=</span> (i == ps.length - <span class="number">1</span>) ? <span class="string">')'</span> : <span class="string">','</span>;</span><br><span class="line">        <span class="comment">//获取参教的类型</span></span><br><span class="line">        System.out.print(ps[i].getSimpleName() + end);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-4-数组类的加载"><a href="#2-4-数组类的加载" class="headerlink" title="2.4. 数组类的加载"></a>2.4. 数组类的加载</h2><p>创建数组类的情况稍微有些特殊，因为<mark>数组类本身并不是由类加载器负责创建</mark>，而是由 JVM 在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。创建数组类（下述简称 A）的过程：</p>
<ul>
<li>如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组 A 的元素类型；</li>
<li>JVM 使用指定的元素类型和数组维度来创建新的数组类。</li>
</ul>
<p>如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为 public。</p>
<hr>

<h1 id="3-过程二：Linking（链接）阶段"><a href="#3-过程二：Linking（链接）阶段" class="headerlink" title="3. 过程二：Linking（链接）阶段"></a>3. 过程二：Linking（链接）阶段</h1><h2 id="3-1-环节-1：链接阶段之-Verification（验证）"><a href="#3-1-环节-1：链接阶段之-Verification（验证）" class="headerlink" title="3.1. 环节 1：链接阶段之 Verification（验证）"></a>3.1. 环节 1：链接阶段之 Verification（验证）</h2><p>当类加载到系统后，就开始链接操作，验证是链接操作的第一步。</p>
<p><font color="red">它的目的是保证加载的字节码是合法、合理并符合规范的。</font></p>
<p>验证的步骤比较复杂，实际要验证的项目也很繁多，大体上 Java 虚拟机需要做以下检查，如图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/2309ce7d4bdbffb86ae462e967af5dc9.png" alt="image-20210430221736546"></p>
<p><strong>整体说明：</strong></p>
<p>验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。</p>
<ul>
<li><font color="red">其中格式验证会和加载阶段一起执行</font>。验证通过之后，类加载器才会成功将类的二进制数据信息加载到方法区中。</li>
<li><font color="red">格式验证之外的验证操作将会在<strong>方法区</strong>中进行</font>。</li>
</ul>
<p>链接阶段的验证虽然拖慢了加载速度，但是它避免了在字节码运行时还需要进行各种检查。（磨刀不误砍柴工）</p>
<p><strong>具体说明：</strong></p>
<ol>
<li><p><mark>格式验证</mark>：是否以魔数 0XCAFEBABE 开头，主版本和副版本号是否在当前 Java 虚拟机的支持范围内，数据中每一个项是否都拥有正确的长度等。</p>
</li>
<li><p><mark>语义检查</mark>：Java 虚拟机会进行字节码的语义检查，但凡在语义上不符合规范的，虚拟机也不会给予验证通过。比如：</p>
<ul>
<li>是否所有的类都有父类的存在（在 Java 里，除了 object 外，其他类都应该有父类）</li>
<li>是否一些被定义为 final 的方法或者类被重写或继承了（final的是不能被被重写或继承的）</li>
<li>非抽象类是否实现了所有抽象方法或者接口方法</li>
<li>是否存在不兼容的方法（比如方法的签名除了返回值不同，其它都一样，这种方法会让虚拟机无从下手调度；abstrac情况下的方法，就不能是final的了）</li>
</ul>
</li>
<li><p><mark>字节码验证</mark>：Java 虚拟机还会进行字节码验证，$\color{red}{字节码验证也是验证过程中最为复杂的一个过程}$。它试图通过对字节码流的分析，判断字节码是否可以被正确地执行。比如：</p>
<ul>
<li>在字节码的执行过程中，是否会跳转到一条不存在的指令</li>
<li>函数的调用是否传递了正确类型的参数</li>
<li>变量的赋值是不是给了正确的数据类型等</li>
</ul>
<p>栈映射帧（StackMapTable）就是在这个阶段，用于检测在特定的字节码处，其局部变量表和操作数栈是否有着正确的数据类型。但遗憾的是，100%准确地判断一段字节码是否可以被安全执行是无法实现的，因此，该过程只是尽可能地检查出可以预知的明显的问题。如果在这个阶段无法通过检查，虚拟机也不会正确装载这个类。但是，如果通过了这个阶段的检查，也不能说明这个类是完全没有问题的。</p>
<p><font color="red">在前面3次检查中，已经排除了文件格式错误、语义错误以及字节码的不正确性。但是依然不能确保类是没有问题的。</font></p>
</li>
<li><p><mark>符号引用的验证</mark>：校验器还将进符号引用的验证。Class 文件在其常量池会通过字符串记录自己将要使用的其他类或者方法。因此，在验证阶段，<font color="red">虚拟机就会检查这些类或者方法确实是存在的</font>，并且当前类有权限访问这些数据，如果一个需要使用类无法在系统中找到，则会抛出 NoClassDefFoundError，如果一个方法无法被找到，则会抛出 NoSuchMethodError。此阶段在解析环节才会执行。</p>
</li>
</ol>
<h2 id="3-2-环节-2：链接阶段之-Preparation（准备）"><a href="#3-2-环节-2：链接阶段之-Preparation（准备）" class="headerlink" title="3.2. 环节 2：链接阶段之 Preparation（准备）"></a>3.2. 环节 2：链接阶段之 Preparation（准备）</h2><p><font color="red">准备阶段（Preparation），简言之，为类的静态变分配内存，并将其初始化为默认值。</font></p>
<p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。Java 虚拟机为各类型变量默认的初始值如表所示。</p>
<table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">默认初始值</th>
</tr>
</thead>
<tbody><tr>
<td align="left">byte</td>
<td align="left">(byte)0</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">(short)0</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">0L</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">0.0f</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">0.0</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">\u0000</td>
</tr>
<tr>
<td align="left">boolean</td>
<td align="left">false</td>
</tr>
<tr>
<td align="left">reference</td>
<td align="left">null</td>
</tr>
</tbody></table>
<p>Java 并不支持 boolean 类型，对于 boolean 类型，内部实现是 int，由于 int 的默认值是 0，故对应的，boolean 的默认值就是 false。</p>
<p><strong>注意</strong></p>
<ul>
<li><p><font color="red">这里不包含基本数据类型的字段用static final修饰的情况，因为<strong>final 在编译的时候</strong>就会分配了，准备阶段会显式赋值。</font></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一般情况：static final修饰的基本数据类型、字符串类型字面量会在准备阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">"Hello world"</span>;</span><br><span class="line"><span class="comment">// 特殊情况：static final修饰的引用类型不会在准备阶段赋值，而是在初始化阶段赋值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"Hello world"</span>);</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p>注意这里不会为实例变量分配初始化，类变量会分配在方法区中，而实例变量是会随着对象一起分配到 Java 堆中。</p>
</li>
<li><p>在这个阶段并不会像初始化阶段中那样会有初始化或者代码被执行。</p>
</li>
</ul>
<p><img src="/../../../images/image-20230110232531406.png" alt="image-20230110232531406"></p>
<p>ps: 补充<strong>字面量</strong>的举例：<img src="/../../../images/image-20230110232617738.png" alt="image-20230110232617738"></p>
<h2 id="3-3-环节-3：链接阶段之-Resolution（解析）"><a href="#3-3-环节-3：链接阶段之-Resolution（解析）" class="headerlink" title="3.3. 环节 3：链接阶段之 Resolution（解析）"></a>3.3. 环节 3：链接阶段之 Resolution（解析）</h2><p>在准备阶段完成后，就进入了解析阶段。解析阶段（Resolution），简言之，将类、接口、字段和方法的 <strong>符号引用 转为 直接引用</strong>。</p>
<p><strong>具体描述</strong>：</p>
<p>符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在 Class 类文件中，通过常量池进行了大量的符号引用。但是<strong>在程序实际运行时，只有符号引用是不够的，比如当如下 println()方法被调用时，系统需要明确知道该方法的位置</strong>。</p>
<p><strong>举例</strong>：</p>
<p>输出操作 System.out.println()对应的字节码：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokevirtual #<span class="number">24</span> &lt;java/io/PrintStream.println&gt;</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/b223d288b413f0ed0732357023a1dc7e.png" alt="image-20210430225015932"></p>
<p>以方法为例，Java 虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法。<font color="red">通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。</font></p>
<p><img src="/../../../images/image-20230110234334621.png" alt="image-20230110234334621"></p>
<hr>





<h1 id="4-过程三：Initialization（初始化）阶段"><a href="#4-过程三：Initialization（初始化）阶段" class="headerlink" title="4. 过程三：Initialization（初始化）阶段"></a>4. 过程三：Initialization（初始化）阶段</h1><p><img src="/../../../images/image-20230111102047297.png" alt="image-20230111102047297"></p>
<p><img src="/../../../images/image-20230111101919211.png" alt="image-20230111101919211"></p>
<p><img src="/../../../images/image-20230111104107727.png" alt="image-20230111104107727"></p>
<h2 id="4-1-static-与-final-的搭配问题"><a href="#4-1-static-与-final-的搭配问题" class="headerlink" title="4.1. static 与 final 的搭配问题"></a>4.1. static 与 final 的搭配问题</h2><p><strong>说明</strong>：使用 static+ final 修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？</p>
<ul>
<li><p>情况 1：在链接阶段的准备环节赋值</p>
</li>
<li><p>情况 2：在初始化阶段&lt;clinit&gt;()中赋值</p>
</li>
</ul>
<p><strong>结论</strong>： 在链接阶段的准备环节赋值的情况：</p>
<ul>
<li><p>对于基本数据类型的字段来说，如果使用 static final 修饰，则显式赋值（直接赋值常量，而非调用方法）通常是在链接阶段的准备环节进行</p>
</li>
<li><p>对于 String 来说，如果使用字面量的方式赋值，使用 static final 修饰的话，则显式赋值通常是在链接阶段的准备环节进行</p>
</li>
<li><p>在初始化阶段&lt;clinit&gt;()中赋值的情况： 排除上述的在准备环节赋值的情况之外的情况。</p>
</li>
</ul>
<p><strong>最终结论</strong>：使用 static+final 修饰，且显示赋值中不涉及到方法或构造器调用的基本数据类到或 String 类型的显式财值，是在链接阶段的准备环节进行。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">INT_CONSTANT</span> <span class="operator">=</span> <span class="number">10</span>;                                <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">NUM1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);                  <span class="comment">// 在初始化阶段clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;                                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT1</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);     <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Integer</span> <span class="variable">INTEGER_CONSTANT2</span> <span class="operator">=</span> Integer.valueOf(<span class="number">100</span>);           <span class="comment">// 在初始化阶段&lt;clinit&gt;()中概值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s0</span> <span class="operator">=</span> <span class="string">"helloworld0"</span>;                            <span class="comment">// 在链接阶段的准备环节赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">"helloworld1"</span>);                <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">"hellowrold2"</span>;                                  <span class="comment">// 在初始化阶段&lt;clinit&gt;()中赋值</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="4-2-lt-clinit-gt-的线程安全性"><a href="#4-2-lt-clinit-gt-的线程安全性" class="headerlink" title="4.2. <clinit>()的线程安全性"></a>4.2. &lt;clinit&gt;()的线程安全性</h2><p>对于&lt;clinit&gt;()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。</p>
<p>虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit&gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit&gt;()方法完毕。</p>
<p>正是<font color="red">因为函数&lt;clinit&gt;()带锁线程安全的</font>，因此，如果在一个类的&lt;clinit&gt;()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。</p>
<p>如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行&lt;clinit&gt;()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。</p>
<h2 id="4-3-类的初始化情况：主动使用-vs-被动使用"><a href="#4-3-类的初始化情况：主动使用-vs-被动使用" class="headerlink" title="4.3. 类的初始化情况：主动使用 vs 被动使用"></a>4.3. 类的初始化情况：主动使用 vs 被动使用</h2><p>Java 程序对类的使用分为两种：主动使用和被动使用。</p>
<p><strong>主动使用</strong></p>
<p>Class 只有在必须要首次使用的时候才会被装载，Java 虚拟机不会无条件地装载 Class 类型。Java 虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用，主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。</p>
<ol>
<li><p><mark>实例化</mark>：当创建一个类的实例时，比如使用 new 关键字，或者通过反射、克隆、反序列化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class Order <span class="keyword">implements</span> <span class="title class_">Serializable</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Order类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 序列化</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"order.dat"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Order</span>());</span><br><span class="line">        <span class="comment">// 反序列化</span></span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">"order.dat"</span>));</span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">catch</span> (ClassNotFoundException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="literal">null</span>) {</span><br><span class="line">                oos.close();</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="literal">null</span>) {</span><br><span class="line">                ois.close();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">catch</span> (IOException e){</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><mark>静态方法</mark>：当调用类的静态方法时，即当使用了字节码 invokestatic 指令。</p>
</li>
<li><p><mark>静态字段</mark>：当使用类、接口的静态字段时（final 修饰特殊考虑），比如，使用 getstatic 或者 putstatic 指令。（对应访问变量、赋值变量操作）</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ActiveUse</span> {</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(User.num);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"User类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20230111112706051.png" alt="image-20230111112706051"></p>
</li>
<li><p><mark>反射</mark>：当使用 java.lang.reflect 包中的方法反射类的方法时。比如：Class.forName(“com.atguigu.java.Test”)</p>
<p><img src="/../../../images/image-20230111113501992.png" alt="image-20230111113501992"></p>
</li>
<li><p><mark>继承</mark>：当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</p>
<blockquote>
<p>当 Java 虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。</p>
<ul>
<li>在初始化一个类时，并不会先初始化它所实现的接口</li>
<li>在初始化一个接口时，并不会先初始化它的父接口</li>
<li>因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。<strong>只有当程序首次使用特定接口的静态字段时，才会导致该接口的初始化</strong>。</li>
</ul>
</blockquote>
<p><img src="/../../../images/image-20230111113710560.png" alt="image-20230111113710560"></p>
</li>
<li><p><mark>default 方法</mark>：如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Compare</span> {</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() {</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"Compare接口的初始化"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>{</span><br><span class="line">        System.out.println(<span class="string">"你好！"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><mark>main 方法</mark>：当虚拟机启动时，用户需要指定一个要执行的主类（包含 main()方法的那个类），虚拟机会先初始化这个主类。</p>
<blockquote>
<p>VM 启动的时候通过引导类加载器加载一个初始类。这个类在调用 public static void main(String[])方法之前被链接和初始化。这个方法的执行将依次导致所需的类的加载，链接和初始化。</p>
</blockquote>
</li>
<li><p><mark>MethodHandle</mark>：当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析 REF getStatic、REF_putStatic、REF invokeStatic 方法句柄对应的类）</p>
</li>
</ol>
<p><strong>被动使用</strong></p>
<p>除了以上的情况属于主动使用，其他的情况均属于被动使用。<font color="red">被动使用 不会 引起类的&lt;clinit&gt;()初始化。</font></p>
<p>也就是说：<font color="red">并不是在代码中出现的类，就一定会被加载或者初始化。</font>如果不符合主动使用的条件，类就不会初始化。</p>
<ol>
<li><p><mark>静态字段</mark>：当通过子类引用父类的静态变量，不会导致子类初始化，只有真正声明这个字段的类才会被初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> {</span><br><span class="line"> 	<span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> {</span><br><span class="line">        System.out.println(Child.num);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> <span class="keyword">extends</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Child类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> {</span><br><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">        System.out.println(<span class="string">"Parent类的初始化"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><mark>数组定义</mark>：通过数组定义类引用，不会触发此类的初始化</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Parent[] parents= <span class="keyword">new</span> <span class="title class_">Parent</span>[<span class="number">10</span>];</span><br><span class="line">System.out.println(parents.getClass());</span><br><span class="line"><span class="comment">// new的话才会初始化</span></span><br><span class="line">parents[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><mark>引用常量</mark>：引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PassiveUse</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        System.out.println(Serival.num);</span><br><span class="line">        <span class="comment">// 但引用其他类的话还是会初始化</span></span><br><span class="line">        System.out.println(Serival.num2);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Serival</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() {</span><br><span class="line">        {</span><br><span class="line">            System.out.println(<span class="string">"Serival初始化"</span>);</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">10</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
<li><p><mark>loadClass 方法</mark>：调用 ClassLoader 类的 loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader().loadClass(<span class="string">"com.test.java.Person"</span>);</span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>扩展</strong></p>
<blockquote>
<p>-XX:+TraceClassLoading：追踪打印类的加载信息</p>
</blockquote>
<hr>

<p><img src="/../../../images/image-20230111115825353.png" alt="image-20230111115825353"></p>
<h1 id="5-过程四：类的-Using（使用）"><a href="#5-过程四：类的-Using（使用）" class="headerlink" title="5. 过程四：类的 Using（使用）"></a>5. 过程四：类的 Using（使用）</h1><p><strong>任何一个类型在使用之前都必须经历过 完整的加载、链接和初始化 3 个类加载 步骤</strong>。一旦一个类型成功经历过这 3 个步骤之后，便 “厉事俱备只欠东风”，就等着开发者使用了。</p>
<p>开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用 new 关键字为其创建对象实例。</p>
<hr>

<h1 id="6-过程五：类的-Unloading（卸载）"><a href="#6-过程五：类的-Unloading（卸载）" class="headerlink" title="6. 过程五：类的 Unloading（卸载）"></a>6. 过程五：类的 Unloading（卸载）</h1><h2 id="6-1-类、类的加载器、类的实例之间的引用关系"><a href="#6-1-类、类的加载器、类的实例之间的引用关系" class="headerlink" title="6.1. 类、类的加载器、类的实例之间的引用关系"></a>6.1. 类、类的加载器、类的实例之间的引用关系</h2><p>在类加载器的内部实现中，用一个 Java 集合来存放所加载类的引用。另一方面，一个 Class 对象总是会引用它的类加载器，调用 Class 对象的 getClassLoader()方法，就能获得它的类加载器。由此可见，代表某个类的 Class 实例与其类的加载器之间为双向关联关系。</p>
<p>一个类的实例总是引用代表这个类的 Class 对象。在 Object 类中定义了 getClass()方法，这个方法返回代表对象所属类的 Class 对象的引用。此外，所有的 java 类都有一个静态属性 class，它引用代表这个类的 Class 对象。</p>
<h2 id="6-2-类的生命周期"><a href="#6-2-类的生命周期" class="headerlink" title="6.2.类的生命周期"></a>6.2.类的生命周期</h2><p>当 Sample 类被加载、链接和初始化后，它的生命周期就开始了。当代表 Sample 类的 Class 对象不再被引用，即<strong>不可触及</strong>时，Class 对象就会结束生命周期，Sample 类在方法区内的数据也会被卸载，从而结束 Sample 类的生命周期。</p>
<p><font color="red">一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</font></p>
<h2 id="6-3-具体例子"><a href="#6-3-具体例子" class="headerlink" title="6.3. 具体例子"></a>6.3. 具体例子</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/5aaa031ab1ffc8071fb92a32ead888ef.png" alt="image-20210430235455086"></p>
<p>loader1 变量和 obj 变量间接应用代表 Sample 类的 Class 对象，而 objClass 变量则直接引用它。</p>
<p>如果程序运行过程中，将上图左侧三个引用变量都置为 null，此时 Sample 对象结束生命周期，MyClassLoader 对象结束生命周期，代表 Sample 类的 Class 对象也结束生命周期，Sample 类在方法区内的二进制数据被卸载。</p>
<p>当再次有需要时，会检查 Sample 类的 Class 对象是否存在，如果存在会直接使用，不再重新加载；如果不存在 Sample 类会被重新加载，在 Java 虚拟机的堆区会生成一个新的代表 Sample 类的 Class 实例（可以通过哈希码查看是否是同一个实例）</p>
<h2 id="6-4-类的卸载"><a href="#6-4-类的卸载" class="headerlink" title="6.4. 类的卸载"></a>6.4. 类的卸载</h2><p>（1）启动类加载器加载的类型在整个运行期间是不可能被卸载的（jvm 和 jls 规范）</p>
<p>（2）被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到 unreachable 的可能性极小。</p>
<p>（3）被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中（比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能），被加载的类型在运行期间也是几乎不太可能被卸载的（至少卸载的时间是不确定的）。</p>
<p>综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。</p>
<h2 id="回顾：方法区的垃圾回收"><a href="#回顾：方法区的垃圾回收" class="headerlink" title="回顾：方法区的垃圾回收"></a>回顾：方法区的垃圾回收</h2><p>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。</p>
<p>HotSpot 虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。</p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再使用的类”的条件就比较苛刻了。需要同时满足下面三个条件：</p>
<ul>
<li><font color="blue">该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。</font></li>
<li><font color="blue">加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。</font></li>
<li><font color="blue">该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</font></li>
</ul>
<p>Java 虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。</p>
<hr>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/10/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/4-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%EF%BC%88%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%89%E8%AF%A6%E8%A7%A3/" data-id="clkr14xwi009ms4v66e98d2m3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="tag">JVM中篇：字节码与类的加载器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-刷题笔记/刷题记录/leetcode-134.加油站" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-134.%E5%8A%A0%E6%B2%B9%E7%AB%99/" class="article-date">
  <time class="post-time" datetime="2023-01-09T14:34:18.875Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-134.%E5%8A%A0%E6%B2%B9%E7%AB%99/">leetcode-134.加油站</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/">刷题</a>,<a class="article-category-link" href="/categories/%E5%88%B7%E9%A2%98/leetcode/">leetcode</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>在一条环路上有 <code>n</code> 个加油站，其中第 <code>i</code> 个加油站有汽油 <code>gas[i]</code> 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 <code>i</code> 个加油站开往第 <code>i+1</code> 个加油站需要消耗汽油 <code>cost[i]</code> 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 <code>gas</code> 和 <code>cost</code> ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 <code>-1</code> 。如果存在解，则 <strong>保证</strong> 它是 <strong>唯一</strong> 的。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释:</span><br><span class="line">从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油</span><br><span class="line">开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油</span><br><span class="line">开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。</span><br><span class="line">因此，3 可为起始索引。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: gas = [2,3,4], cost = [3,4,3]</span><br><span class="line">输出: -1</span><br><span class="line">解释:</span><br><span class="line">你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。</span><br><span class="line">我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油</span><br><span class="line">开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油</span><br><span class="line">开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油</span><br><span class="line">你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。</span><br><span class="line">因此，无论怎样，你都不可能绕环路行驶一周。</span><br></pre></td></tr></tbody></table></figure>

<p><strong>提示:</strong></p>
<ul>
<li><code>gas.length == n</code></li>
<li><code>cost.length == n</code></li>
<li><code>1 &lt;= n &lt;= 105</code></li>
<li><code>0 &lt;= gas[i], cost[i] &lt;= 104</code></li>
</ul>
<h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>下图的 黑色折线图 即 总油量剩余值，若要满足题目的要求：跑完全程再回到起点，总油量剩余值 的任意部分都需要在 X 轴以上，且跑到终点时：总剩余汽油量 &gt;= 0。</p>
<p>为了让 黑色折线图 任意部分都在 X 轴以上，我们需要向上移动 黑色折线图，直到所有点都在 X 轴或 X 轴以上。此时，处在 X 轴的点即为出发点。即 黑色折线图 的最低值的位置：index = 3。</p>
<p><img src="/../../../images/image-20230109224824634.png" alt="image-20230109224824634"></p>
<h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> {</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    思路：</span></span><br><span class="line"><span class="comment">        找到最后一个 sum 还是减小状态的下标即可，然后结果就是这个下标的下一个下标，即( index + 1 ) % len</span></span><br><span class="line"><span class="comment">        因为index 是最低点了，后面就是回升的了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> {</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i ++ ) {</span><br><span class="line">            sum += gas[ i ] - cost[ i ];</span><br><span class="line">            <span class="comment">// System.out.println( sum + " " + i );</span></span><br><span class="line">            <span class="keyword">if</span> ( sum &lt; min ) {</span><br><span class="line">                min = sum;</span><br><span class="line">                index = i + <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> sum &lt; <span class="number">0</span> ? -<span class="number">1</span> : index % len;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/leetcode-134.%E5%8A%A0%E6%B2%B9%E7%AB%99/" data-id="clkr14xyu00d8s4v64wv94z5b" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/leetcode/" rel="tag">leetcode</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%88%B7%E9%A2%98/" rel="tag">刷题</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/2-javap使用" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/2-javap%E4%BD%BF%E7%94%A8/" class="article-date">
  <time class="post-time" datetime="2023-01-09T07:12:26.476Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/2-javap%E4%BD%BF%E7%94%A8/">02-javap使用</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM中篇：字节码与类的加载器</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1、解析字节码的作用"><a href="#1、解析字节码的作用" class="headerlink" title="1、解析字节码的作用"></a>1、解析字节码的作用</h2><p><img src="/../../../images/image-20230109105233604.png" alt="image-20230109105233604"></p>
<h2 id="2、javac-g-操作"><a href="#2、javac-g-操作" class="headerlink" title="2、javac -g 操作"></a>2、javac -g 操作</h2><p><img src="/../../../images/image-20230109105203289.png" alt="image-20230109105203289"></p>
<h2 id="3、javap的用法"><a href="#3、javap的用法" class="headerlink" title="3、javap的用法"></a>3、javap的用法</h2><p><img src="/../../../images/image-20230109105401609.png" alt="image-20230109105401609"></p>
<p><img src="/../../../images/image-20230109111148023.png" alt="image-20230109111148023"></p>
<p><img src="/../../../images/image-20230109111249850.png" alt="image-20230109111249850"></p>
<p><mark>注意：-v虽然包含的信息很全，但是不包含私有private的，用 **-v -p **才可以带上私有的，这样信息就是最全的了</mark></p>
<p>如：演示javap -s （输出内部类型签名）：</p>
<p><img src="/../../../images/image-20230109110318593.png" alt="image-20230109110318593"></p>
<p>演示 javap -l （输出行号和本地变量表（局部变量表））：</p>
<p><img src="/../../../images/image-20230109110533368.png" alt="image-20230109110533368"></p>
<p>-c 和 -v 的内容对比：</p>
<p><img src="/../../../images/image-20230109111622323.png" alt="image-20230109111622323"></p>
<p><img src="/../../../images/image-20230109111550389.png" alt="image-20230109111550389"></p>
<h2 id="javap解析得到的文件结构的解读"><a href="#javap解析得到的文件结构的解读" class="headerlink" title="javap解析得到的文件结构的解读"></a>javap解析得到的文件结构的解读</h2><p><img src="/../../../images/image-20230109150619055.png" alt="image-20230109150619055"></p>
<p><img src="/../../../images/image-20230109150710937.png" alt="image-20230109150710937"></p>
<p><img src="/../../../images/image-20230109150838112.png" alt="image-20230109150838112"></p>
<p><img src="/../../../images/image-20230109150909746.png" alt="image-20230109150909746"></p>
<p><img src="/../../../images/image-20230109145505307.png" alt="image-20230109145505307"></p>
<p><img src="/../../../images/image-20230109150257068.png" alt="image-20230109150257068"></p>
<p><img src="/../../../images/image-20230109150459817.png" alt="image-20230109150459817"></p>
<p><img src="/../../../images/image-20230109150441824.png" alt="image-20230109150441824"></p>
<h2 id="javap使用小结"><a href="#javap使用小结" class="headerlink" title="javap使用小结"></a>javap使用小结</h2><p><img src="/../../../images/image-20230109151005736.png" alt="image-20230109151005736"></p>
<h1 id=""><a href="#" class="headerlink" title=""></a></h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/2-javap%E4%BD%BF%E7%94%A8/" data-id="clkr14xw90099s4v6gta7cgwj" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="tag">JVM中篇：字节码与类的加载器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/3-字节码指令集" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/" class="article-date">
  <time class="post-time" datetime="2023-01-09T02:19:47.567Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">09</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/">03-字节码指令集</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM中篇：字节码与类的加载器</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><p><img src="https://img-blog.csdnimg.cn/img_convert/630bca9b1bbeeeb4f772fea5f94d43fc.png"><img src="https://img-blog.csdnimg.cn/img_convert/74bb5f23ad01f05a39f8eb171d205390.png"><img src="https://img-blog.csdnimg.cn/img_convert/bb3c57508713e377f3f4084409abaa30.png" alt="img"></p>
<h1 id="2-加载与存储指令"><a href="#2-加载与存储指令" class="headerlink" title="2. 加载与存储指令"></a>2. 加载与存储指令</h1><p><img src="/../../../images/image-20230109154720979.png" alt="image-20230109154720979"></p>
<p><img src="/../../../images/image-20230109155158364.png" alt="image-20230109155158364"></p>
<hr>
<p><img src="https://img-blog.csdnimg.cn/img_convert/3585fe67d5d83aff5db707d8eedccbae.png" alt="0ca8044c-f78d-4787-aeac-c986a35f9cdf"><br><img src="https://gitee.com/vectorx/ImageCloud/raw/master/img/20210424190846.png" alt="16e3afaf-b7d8-4a23-8897-9fe02586aafd"><img src="https://img-blog.csdnimg.cn/img_convert/8e911caaa5c0502b038af324c16edce8.png" alt="08e01fd0-a33e-47e4-8fd2-34c2935db71d"></p>
<hr>

<h2 id="2-1-局部变量压栈指令"><a href="#2-1-局部变量压栈指令" class="headerlink" title="2.1. 局部变量压栈指令"></a>2.1. 局部变量压栈指令</h2><blockquote>
<p>iload 从局部变量中装载int类型值</p>
<p>lload 从局部变量中装载long类型值</p>
<p>fload 从局部变量中装载float类型值</p>
<p>dload 从局部变量中装载double类型值</p>
<p>aload 从局部变量中装载引用类型值（refernce）</p>
<p>iload_0 从局部变量0中装载int类型值</p>
<p>iload_1 从局部变量1中装载int类型值</p>
<p>iload_2 从局部变量2中装载int类型值</p>
<p>iload_3 从局部变量3中装载int类型值</p>
<p>lload_0 从局部变量0中装载long类型值</p>
<p>lload_1 从局部变量1中装载long类型值</p>
<p>lload_2 从局部变量2中装载long类型值</p>
<p>lload_3 从局部变量3中装载long类型值</p>
<p>fload_0 从局部变量0中装载float类型值</p>
<p>fload_1 从局部变量1中装载float类型值</p>
<p>fload_2 从局部变量2中装载float类型值</p>
<p>fload_3 从局部变量3中装载float类型值</p>
<p>dload_0 从局部变量0中装载double类型值</p>
<p>dload_1 从局部变量1中装载double类型值</p>
<p>dload_2 从局部变量2中装载double类型值</p>
<p>dload_3 从局部变量3中装载double类型值</p>
<p>aload_0 从局部变量0中装载引用类型值</p>
<p>aload_1 从局部变量1中装载引用类型值</p>
<p>aload_2 从局部变量2中装载引用类型值</p>
<p>aload_3 从局部变量3中装载引用类型值</p>
<p>iaload 从数组中装载int类型值</p>
<p>laload 从数组中装载long类型值</p>
<p>faload 从数组中装载float类型值</p>
<p>daload 从数组中装载double类型值</p>
<p>aaload 从数组中装载引用类型值</p>
<p>baload 从数组中装载byte类型或boolean类型值</p>
<p>caload 从数组中装载char类型值</p>
<p>saload 从数组中装载short类型值</p>
</blockquote>
<h2 id="局部变量压栈常用指令集"><a href="#局部变量压栈常用指令集" class="headerlink" title="局部变量压栈常用指令集"></a>局部变量压栈常用指令集</h2><table>
<thead>
<tr>
<th>xload_n</th>
<th>xload_0</th>
<th>xload_1</th>
<th>xload_2</th>
<th>xload_3</th>
</tr>
</thead>
<tbody><tr>
<td><b>iload_n</b></td>
<td>iload_0</td>
<td>iload_1</td>
<td>iload_2</td>
<td>iload_3</td>
</tr>
<tr>
<td><b>lload_n</b></td>
<td>lload_0</td>
<td>lload_1</td>
<td>lload_2</td>
<td>lload_3</td>
</tr>
<tr>
<td><b>fload_n</b></td>
<td>fload_0</td>
<td>fload_1</td>
<td>fload_2</td>
<td>fload_3</td>
</tr>
<tr>
<td><b>dload_n</b></td>
<td>dload_0</td>
<td>dload_1</td>
<td>dload_2</td>
<td>dload_3</td>
</tr>
<tr>
<td><b>aload_n</b></td>
<td>aload_0</td>
<td>aload_1</td>
<td>aload_2</td>
<td>aload_3</td>
</tr>
</tbody></table>
<h2 id="局部变量压栈指令剖析"><a href="#局部变量压栈指令剖析" class="headerlink" title="局部变量压栈指令剖析"></a>局部变量压栈指令剖析</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/a34d465c4c8c83b3fcedc3ba31401732.png" alt="1"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">load</span><span class="params">(<span class="type">int</span> num, Object obj, <span class="type">long</span> count, <span class="type">boolean</span> flag, <span class="type">short</span>[] arr)</span> {</span><br><span class="line">	System.out.println(num);</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    System.out.println(arr);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/deb49e69ed62ed9d71c7059748299b59.png" alt="3"></p>
<hr>

<h2 id="2-2-常量入栈指令"><a href="#2-2-常量入栈指令" class="headerlink" title="2.2. 常量入栈指令"></a>2.2. 常量入栈指令</h2><blockquote>
<p>aconst_null 将null对象引用压入栈</p>
<p>iconst_m1 将int类型常量-1压入栈</p>
<p>iconst_0 将int类型常量0压入栈</p>
<p>iconst_1 将int类型常量1压入栈</p>
<p>iconst_2 将int类型常量2压入栈</p>
<p>iconst_3 将int类型常量3压入栈</p>
<p>iconst_4 将int类型常量4压入栈</p>
<p>iconst_5 将int类型常量5压入栈</p>
<p>lconst_0 将long类型常量0压入栈</p>
<p>lconst_1 将long类型常量1压入栈</p>
<p>fconst_0 将float类型常量0压入栈</p>
<p>fconst_1 将float类型常量1压入栈</p>
<p>dconst_0 将double类型常量0压入栈</p>
<p>dconst_1 将double类型常量1压入栈</p>
<p>bipush 将一个8位带符号整数压入栈</p>
<p>sipush 将16位带符号整数压入栈</p>
<p>ldc 把常量池中的项压入栈</p>
<p>ldc_w 把常量池中的项压入栈（使用宽索引）</p>
<p>ldc2_w 把常量池中long类型或者double类型的项压入栈（使用宽索引）</p>
</blockquote>
<h2 id="常量入栈常用指令集"><a href="#常量入栈常用指令集" class="headerlink" title="常量入栈常用指令集"></a>常量入栈常用指令集</h2><table>
<thead>
<tr>
<th align="center">xconst_n</th>
<th>范围</th>
<th>xconst_null</th>
<th align="center">xconst_m1</th>
<th align="center">xconst_0</th>
<th align="center">xconst_1</th>
<th align="center">xconst_2</th>
<th align="center">xconst_3</th>
<th align="center">xconst_4</th>
<th align="center">xconst_5</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>iconst_n</strong></td>
<td>[-1, 5]</td>
<td></td>
<td align="center">iconst_m1</td>
<td align="center">iconst_0</td>
<td align="center">iconst_1</td>
<td align="center">iconst_2</td>
<td align="center">iconst_3</td>
<td align="center">iconst_4</td>
<td align="center">iconst_5</td>
</tr>
<tr>
<td align="center"><strong>lconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td align="center"></td>
<td align="center">lconst_0</td>
<td align="center">lconst_1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>fconst_n</strong></td>
<td>0, 1, 2</td>
<td></td>
<td align="center"></td>
<td align="center">fconst_0</td>
<td align="center">fconst_1</td>
<td align="center">fconst_2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>dconst_n</strong></td>
<td>0, 1</td>
<td></td>
<td align="center"></td>
<td align="center">dconst_0</td>
<td align="center">dconst_1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>aconst_n</strong></td>
<td>null, String literal, Class literal</td>
<td>aconst_null</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>bipush</strong></td>
<td>一个字节，2^8^，[-2^7^, 2^7^ - 1]，即[-128, 127]</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>sipush</strong></td>
<td>两个字节，2^16^，[-2^15^, 2^15^ - 1]，即[-32768, 32767]</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>ldc</strong></td>
<td>四个字节，2^32^，[-2^31^, 2^31^ - 1]</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>ldc_w</strong></td>
<td>宽索引</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><strong>ldc2_w</strong></td>
<td>宽索引，long或double</td>
<td></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h2 id="常量入栈指令剖析"><a href="#常量入栈指令剖析" class="headerlink" title="常量入栈指令剖析"></a>常量入栈指令剖析</h2><p>范围：const &lt; push &lt; ldc</p>
<hr>

<p><img src="/../../../images/image-20230109164556416.png" alt="image-20230109164556416"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fafa61a6702b5fc88179c404ba736029.png" alt="437a717e-98e2-4847-b52e-e6632d0745a4"><br><img src="https://img-blog.csdnimg.cn/img_convert/c0a6284e1deaf76669089e669916f440.png" alt="ffd7246e-2e46-41e0-9fd6-1e65ace5dbd1"></p>
<table>
    <tbody>  
        <tr>
            <th>类型</th> 
            <th>常数指令</th> 
            <th>范围</th> 
       </tr>
       <tr>
            <td rowspan="4">int(boolean,byte,char,short)</td>
            <td>iconst</td>
            <td>[-1, 5]</td>
       </tr>	
       <tr>
            <td>bipush</td>
            <td>[-128, 127]</td>
       </tr>
       <tr>
            <td>sipush</td>
            <td>[-32768, 32767]</td>
       </tr> 
       <tr>
            <td>ldc</td>
            <td>any int value</td>
       </tr>
       <tr>
            <td rowspan="2">long</td>
            <td>lconst</td>
            <td>0, 1</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any long value</td>
       </tr>
       <tr>
            <td rowspan="2">float</td>
            <td>fconst</td>
            <td>0, 1, 2</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any float value</td>
       </tr>
       <tr>
            <td rowspan="2">double</td>
            <td>dconst</td>
            <td>0, 1</td>
       </tr>	
       <tr>
            <td>ldc</td>
            <td>any double value</td>
       </tr> 
       <tr>
            <td rowspan="2">reference</td>
            <td>aconst</td>
            <td>null</td>
       </tr>
       <tr>
            <td>ldc</td>
            <td>String literal, Class literal</td>
       </tr>
   </tbody><tbody> 
</tbody></table>


<p><img src="https://img-blog.csdnimg.cn/img_convert/59982d71dc70f7d7b873f50130281c21.png" alt="566b9397-5afe-4a3f-9e17-9ebf504dfc80"><br><img src="https://img-blog.csdnimg.cn/img_convert/cd990ebc801bf53b4f7b1966d9974345.png" alt="b59702d2-4c93-44df-87f1-01a5dfe53b61"></p>
<h2 id="2-3-出栈装入局部变量表指令"><a href="#2-3-出栈装入局部变量表指令" class="headerlink" title="2.3. 出栈装入局部变量表指令"></a>2.3. 出栈装入局部变量表指令</h2><blockquote>
<p>istore 将int类型值存入局部变量</p>
<p>lstore 将long类型值存入局部变量</p>
<p>fstore 将float类型值存入局部变量</p>
<p>dstore 将double类型值存入局部变量</p>
<p>astore 将将引用类型或returnAddress类型值存入局部变量</p>
<p>istore_0 将int类型值存入局部变量0</p>
<p>istore_1 将int类型值存入局部变量1</p>
<p>istore_2 将int类型值存入局部变量2</p>
<p>istore_3 将int类型值存入局部变量3</p>
<p>lstore_0 将long类型值存入局部变量0</p>
<p>lstore_1 将long类型值存入局部变量1</p>
<p>lstore_2 将long类型值存入局部变量2</p>
<p>lstore_3 将long类型值存入局部变量3</p>
<p>fstore_0 将float类型值存入局部变量0</p>
<p>fstore_1 将float类型值存入局部变量1</p>
<p>fstore_2 将float类型值存入局部变量2</p>
<p>fstore_3 将float类型值存入局部变量3</p>
<p>dstore_0 将double类型值存入局部变量0</p>
<p>dstore_1 将double类型值存入局部变量1</p>
<p>dstore_2 将double类型值存入局部变量2</p>
<p>dstore_3 将double类型值存入局部变量3</p>
<p>astore_0 将引用类型或returnAddress类型值存入局部变量0</p>
<p>astore_1 将引用类型或returnAddress类型值存入局部变量1</p>
<p>astore_2 将引用类型或returnAddress类型值存入局部变量2</p>
<p>astore_3 将引用类型或returnAddress类型值存入局部变量3</p>
<p>iastore 将int类型值存入数组中</p>
<p>lastore 将long类型值存入数组中</p>
<p>fastore 将float类型值存入数组中</p>
<p>dastore 将double类型值存入数组中</p>
<p>aastore 将引用类型值存入数组中</p>
<p>bastore 将byte类型或者boolean类型值存入数组中</p>
<p>castore 将char类型值存入数组中</p>
<p>sastore 将short类型值存入数组中</p>
<p>wide指令</p>
<p>wide 使用附加字节扩展局部变量索引</p>
</blockquote>
<h2 id="出栈装入局部变量表常用指令集"><a href="#出栈装入局部变量表常用指令集" class="headerlink" title="出栈装入局部变量表常用指令集"></a>出栈装入局部变量表常用指令集</h2><table>
<thead>
<tr>
<th align="center">xstore_n</th>
<th align="center">xstore_0</th>
<th align="center">xstore_1</th>
<th align="center">xstore_2</th>
<th align="center">xstore_3</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>istore_n</strong></td>
<td align="center">istore_0</td>
<td align="center">istore_1</td>
<td align="center">istore_2</td>
<td align="center">istore_3</td>
</tr>
<tr>
<td align="center"><strong>lstore_n</strong></td>
<td align="center">lstore_0</td>
<td align="center">lstore_1</td>
<td align="center">lstore_2</td>
<td align="center">lstore_3</td>
</tr>
<tr>
<td align="center"><strong>fstore_n</strong></td>
<td align="center">fstore_0</td>
<td align="center">fstore_1</td>
<td align="center">fstore_2</td>
<td align="center">fstore_3</td>
</tr>
<tr>
<td align="center"><strong>dstore_n</strong></td>
<td align="center">dstore_0</td>
<td align="center">dstore_1</td>
<td align="center">dstore_2</td>
<td align="center">dstore_3</td>
</tr>
<tr>
<td align="center"><strong>astore_n</strong></td>
<td align="center">astore_0</td>
<td align="center">astore_1</td>
<td align="center">astore_2</td>
<td align="center">astore_3</td>
</tr>
</tbody></table>
<h2 id="出栈装入局部变量表指令剖析"><a href="#出栈装入局部变量表指令剖析" class="headerlink" title="出栈装入局部变量表指令剖析"></a>出栈装入局部变量表指令剖析</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/52b46ba6b57aa1ab8581cb022da7e58e.png" alt="1"><br><img src="https://img-blog.csdnimg.cn/img_convert/4adce45129332dd04b89f4aa8ffc6e28.png" alt="2"><br><img src="https://img-blog.csdnimg.cn/img_convert/e4665e8fc25e2d63bff2e8423b60b1dc.png" alt="3"></p>
<hr>

<h1 id="3-算术指令"><a href="#3-算术指令" class="headerlink" title="3. 算术指令"></a>3. 算术指令</h1><blockquote>
<h2 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h2><p>iadd 执行int类型的加法</p>
<p>ladd 执行long类型的加法</p>
<p>isub 执行int类型的减法</p>
<p>lsub 执行long类型的减法</p>
<p>imul 执行int类型的乘法</p>
<p>lmul 执行long类型的乘法</p>
<p>idiv 执行int类型的除法</p>
<p>ldiv 执行long类型的除法</p>
<p>irem 计算int类型除法的余数</p>
<p>lrem 计算long类型除法的余数</p>
<p>ineg 对一个int类型值进行取反操作</p>
<p>lneg 对一个long类型值进行取反操作</p>
<p>iinc 把一个常量值加到一个int类型的局部变量上</p>
<h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p>ishl 执行int类型的向左移位操作</p>
<p>lshl 执行long类型的向左移位操作</p>
<p>ishr 执行int类型的向右移位操作</p>
<p>lshr 执行long类型的向右移位操作</p>
<p>iushr 执行int类型的向右逻辑移位操作</p>
<p>lushr 执行long类型的向右逻辑移位操作</p>
<h3 id="按位布尔运算"><a href="#按位布尔运算" class="headerlink" title="按位布尔运算"></a>按位布尔运算</h3><p>iand 对int类型值进行“逻辑与”操作</p>
<p>land 对long类型值进行“逻辑与”操作</p>
<p>ior 对int类型值进行“逻辑或”操作</p>
<p>lor 对long类型值进行“逻辑或”操作</p>
<p>ixor 对int类型值进行“逻辑异或”操作</p>
<p>lxor 对long类型值进行“逻辑异或”操作</p>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>fadd 执行float类型的加法</p>
<p>dadd 执行double类型的加法</p>
<p>fsub 执行float类型的减法</p>
<p>dsub 执行double类型的减法</p>
<p>fmul 执行float类型的乘法</p>
<p>dmul 执行double类型的乘法</p>
<p>fdiv 执行float类型的除法</p>
<p>ddiv 执行double类型的除法</p>
<p>frem 计算float类型除法的余数</p>
<p>drem 计算double类型除法的余数</p>
<p>fneg 将一个float类型的数值取反</p>
<p>dneg 将一个double类型的数值取反</p>
</blockquote>
<p><img src="/../../../images/image-20230110092705627.png" alt="image-20230110092705627"></p>
<p><img src="/../../../images/image-20230110092628326.png" alt="image-20230110092628326"></p>
<p><img src="/../../../images/image-20230110093117073.png" alt="image-20230110093117073"></p>
<p><img src="/../../../images/image-20230110093414167.png" alt="image-20230110093414167"></p>
<h2 id="算术指令集"><a href="#算术指令集" class="headerlink" title="算术指令集"></a>算术指令集</h2><table>
    <tbody>  
        <tr>
            <th colspan="2">算数指令</th> 
            <th>int(boolean,byte,char,short)</th> 
            <th>long</th>
            <th>float</th> 
              <th>double</th> 
       </tr>
       <tr>
            <td colspan="2">加法指令</td>
            <td>iadd</td>
            <td>ladd</td>
            <td>fadd</td>
            <td>dadd</td>
       </tr>	
       <tr>
            <td colspan="2">减法指令</td>
            <td>isub</td>
            <td>lsub</td>
            <td>fsub</td>
            <td>dsub</td>
       </tr> 
       <tr>
            <td colspan="2">乘法指令</td>
            <td>imul</td>
            <td>lmul</td>
            <td>fmul</td>
            <td>dmul</td>
       </tr> 
       <tr>
            <td colspan="2">除法指令</td>
            <td>idiv</td>
            <td>ldiv</td>
            <td>fdiv</td>
            <td>ddiv</td>
       </tr>
       <tr>
            <td colspan="2">求余指令</td>
            <td>irem</td>
            <td>lrem</td>
            <td>frem</td>
            <td>drem</td>
       </tr>
       <tr>
            <td colspan="2">取反指令</td>
            <td>ineg</td>
            <td>lneg</td>
            <td>fneg</td>
            <td>dneg</td>
       </tr>
       <tr>
            <td colspan="2">自增指令</td>
            <td>iinc</td>
            <td></td>
            <td></td>
            <td></td>
       </tr>
       <tr>
            <td rowspan="4">位运算指令</td>
            <td>按位或指令</td>
            <td>ior</td>
            <td>lor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td>按位或指令</td>
            <td>ior</td>
            <td>lor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td>按位与指令</td>
            <td>iand</td>
            <td>land</td>
            <td></td>
            <td></td>
       </tr>
       <tr>
            <td>按位异或指令</td>
            <td>ixor</td>
            <td>lxor</td>
            <td></td>
            <td></td>
       </tr> 
       <tr>
            <td colspan="2">比较指令</td>
            <td></td>
            <td>lcmp</td>
            <td>fcmpg / fcmpl</td>
            <td>dcmpg / dcmpl</td>
       </tr> 
   </tbody><tbody> 
</tbody></table>



<p><img src="https://img-blog.csdnimg.cn/img_convert/39ac5dc0cb406c2d75b50b10226322b0.png"></p>
<blockquote>
<p>注意：NaN(Not a Number)表示不是一个数字</p>
</blockquote>
<h2 id="算术指令举例"><a href="#算术指令举例" class="headerlink" title="算术指令举例"></a>算术指令举例</h2><h3 id="举例1"><a href="#举例1" class="headerlink" title="举例1"></a>举例1</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bar</span><span class="params">(<span class="type">int</span> i)</span> {</span><br><span class="line">	<span class="keyword">return</span> ((i + <span class="number">1</span>) - <span class="number">2</span>) * <span class="number">3</span> / <span class="number">4</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/256d8a8ec2309b6d396795e9a7e79959.png" alt="a54c2ac8-dd36-49f4-a49d-9afd725e8365"></p>
<h3 id="举例2"><a href="#举例2" class="headerlink" title="举例2"></a>举例2</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line">	<span class="type">byte</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i + j;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/58c6064f2d2103610c6e2f9c9472f122.png" alt="image-20210424210710750"><br><img src="https://img-blog.csdnimg.cn/img_convert/d0257760ed00864d7e36421c2df971ca.png" alt="2"><br><img src="https://img-blog.csdnimg.cn/img_convert/df724aebb307c6dda0780bbf5d4e1f92.png" alt="3"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f2edaef3312398b63decea146718f2d6.gif" alt="img"></p>
<h3 id="举例3"><a href="#举例3" class="headerlink" title="举例3"></a>举例3</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">	<span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x / y;</span><br><span class="line">	<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">	System.out.println(a + b);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/ce924815ec9c6ddc5cd98f18538c250e.png" alt="c43c0407-020f-4ec4-bd27-e4c109640b39"><br><img src="https://img-blog.csdnimg.cn/img_convert/918a9850ced5114086db35ce59e651af.png" alt="04282df1-4e52-4c3d-a47b-84023159b624"></p>
<hr>

<h3 id="测定搞定-运算符"><a href="#测定搞定-运算符" class="headerlink" title="测定搞定++运算符"></a>测定搞定++运算符</h3><p><strong>例子1：</strong></p>
<p><img src="/../../../images/image-20230110103252540.png" alt="image-20230110103252540"></p>
<p><strong>例子2：</strong></p>
<p><img src="/../../../images/image-20230110104240767.png" alt="image-20230110104240767"></p>
<p><img src="/../../../images/image-20230110103546598.png" alt="image-20230110103546598"></p>
<h1 id="4-类型转换指令"><a href="#4-类型转换指令" class="headerlink" title="4. 类型转换指令"></a>4. 类型转换指令</h1><blockquote>
<h2 id="宽化类型转换"><a href="#宽化类型转换" class="headerlink" title="宽化类型转换"></a>宽化类型转换</h2><p>i2l 把int类型的数据转化为long类型</p>
<p>i2f 把int类型的数据转化为float类型</p>
<p>i2d 把int类型的数据转化为double类型</p>
<p>l2f 把long类型的数据转化为float类型</p>
<p>l2d 把long类型的数据转化为double类型</p>
<p>f2d 把float类型的数据转化为double类型</p>
<h2 id="窄化类型转换"><a href="#窄化类型转换" class="headerlink" title="窄化类型转换"></a>窄化类型转换</h2><p>i2b 把int类型的数据转化为byte类型</p>
<p>i2c 把int类型的数据转化为char类型</p>
<p>i2s 把int类型的数据转化为short类型</p>
<p>l2i 把long类型的数据转化为int类型</p>
<p>f2i 把float类型的数据转化为int类型</p>
<p>f2l 把float类型的数据转化为long类型</p>
<p>d2i 把double类型的数据转化为int类型</p>
<p>d2l 把double类型的数据转化为long类型</p>
<p>d2f 把double类型的数据转化为float类型</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center"><strong>byte</strong></th>
<th align="center"><strong>char</strong></th>
<th align="center"><strong>short</strong></th>
<th align="center"><strong>int</strong></th>
<th align="center"><strong>long</strong></th>
<th align="center"><strong>float</strong></th>
<th align="center"><strong>double</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>int</strong></td>
<td align="center">i2b</td>
<td align="center">i2c</td>
<td align="center">i2s</td>
<td align="center">○</td>
<td align="center">i2l</td>
<td align="center">i2f</td>
<td align="center">i2d</td>
</tr>
<tr>
<td align="center"><strong>long</strong></td>
<td align="center">l2i i2b</td>
<td align="center">l2i i2c</td>
<td align="center">l2i i2s</td>
<td align="center">l2i</td>
<td align="center">○</td>
<td align="center">l2f</td>
<td align="center">l2d</td>
</tr>
<tr>
<td align="center"><strong>float</strong></td>
<td align="center">f2i i2b</td>
<td align="center">f2i i2c</td>
<td align="center">f2i i2s</td>
<td align="center">f2i</td>
<td align="center">f2l</td>
<td align="center">○</td>
<td align="center">f2d</td>
</tr>
<tr>
<td align="center"><strong>double</strong></td>
<td align="center">d2i i2b</td>
<td align="center">d2i i2c</td>
<td align="center">d2i i2s</td>
<td align="center">d2i</td>
<td align="center">d2l</td>
<td align="center">d2f</td>
<td align="center">○</td>
</tr>
</tbody></table>
<p>类型转换指令可以将两种不同的数值类型进行相互转换。这些转换操作一般用于实现用户代码中的<strong>显式类型转換操作</strong>，或者用来处理字节码指令集中数据类型相关指令无法与<strong>数据类型</strong>一一对应的问题。</p>
<h2 id="4-1-宽化类型转换剖析"><a href="#4-1-宽化类型转换剖析" class="headerlink" title="4.1. 宽化类型转换剖析"></a>4.1. 宽化类型转换剖析</h2><blockquote>
<p>宽化类型转换( Widening Numeric Conversions)</p>
<ol>
<li>转换规则</li>
</ol>
<p>Java虚拟机直接支持以下数值的宽化类型转换（ widening numeric conversion,<strong>小范围类型向大范围类型的安全转换</strong>）。也就是说，并不需要指令执行，包括</p>
<blockquote>
<p>从int类型到long、float或者 double类型。对应的指令为：i21、i2f、i2d</p>
<p>从long类型到float、 double类型。对应的指令为：i2f、i2d</p>
<p>从float类型到double类型。对应的指令为：f2d </p>
</blockquote>
<p>简化为：int–&gt;long–&gt;float-&gt; double</p>
<ol start="2">
<li>精度损失问题</li>
</ol>
<blockquote>
<p>2.1. 宽化类型转换是不会因为超过目标类型最大值而丢失信息的，例如，从int转换到long,或者从int转换到double,都不会丢失任何信息，转换前后的值是精确相等的。</p>
<p>2.2. 从int、long类型数值转换到float,或者long类型数值转换到double时，将可能发生精度丢失一一可能丢失掉几个最低有效位上的值，转换后的浮点数值是根据IEEE754最接近含入模式所得到的正确整数值。</p>
</blockquote>
<p>尽管宽化类型转换实际上是<strong>可能发生精度丢失</strong>的，但是这种转换永远不会导致Java虚拟机抛出运行时异常</p>
<ol start="3">
<li>补充说明</li>
</ol>
<p><strong>从byte、char和 short类型到int类型的宽化类型转换实际上是不存在的。</strong>对于byte类型转为int,拟机并没有做实质性的转化处理，只是简单地通过操作数栈交換了两个数据。而将byte转为long时，使用的是i2l,可以看到在内部，byte在这里已经等同于int类型处理，类似的还有 short类型，这种处理方式有两个特点：</p>
<p>一方面可以减少实际的数据类型，如果为 short和byte都准备一套指令，那么指令的数量就会大増，而<strong>虚拟机目前的设计上，只愿意使用一个字节表示指令，因此指令总数不能超过256个，为了节省指令资源，将 short和byte当做int处理也在情理之中。</strong></p>
<p>另一方面，由于局部变量表中的槽位固定为32位，无论是byte或者 short存入局部变量表，都会占用32位空间。从这个角度说，也没有必要特意区分这几种数据类型。</p>
</blockquote>
<p>举例分析：</p>
<p><img src="/../../../images/image-20230110110140222.png" alt="image-20230110110140222"></p>
<p><img src="/../../../images/image-20230110110253180.png" alt="image-20230110110253180"></p>
<h2 id="4-2-窄化类型转换剖析"><a href="#4-2-窄化类型转换剖析" class="headerlink" title="4.2. 窄化类型转换剖析"></a>4.2. 窄化类型转换剖析</h2><blockquote>
<p>窄化类型转换( Narrowing Numeric Conversion)</p>
<ol>
<li>转换规则</li>
</ol>
<p>Java虚拟机也直接支持以下窄化类型转换：</p>
<blockquote>
<p>从主int类型至byte、 short或者char类型。对应的指令有：i2b、i2c、i2s</p>
<p>从long类型到int类型。对应的指令有：l2i</p>
<p>从float类型到int或者long类型。对应的指令有：f2i、f2l</p>
<p>从double类型到int、long或者float类型。对应的指令有：d2i、d2l、d2f</p>
</blockquote>
<ol start="2">
<li>精度损失问题</li>
</ol>
<p>窄化类型转换可能会导致转换结果具备不同的正负号、不同的数量级，因此，转换过程很可能会导致数值丢失精度。</p>
<p>尽管数据类型窄化转换可能会发生上限溢出、下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常</p>
<ol start="3">
<li>补充说明</li>
</ol>
<blockquote>
<p>3.1. 当将一个浮点值窄化转换为整数类型T(T限于int或long类型之一)的时候，将遵循以下转换规则：</p>
<blockquote>
<p>如果浮点值是NaN,那转换结果就是int或long类型的0.</p>
<p>如果浮点值不是无穷大的话，浮点值使用IEEE754的向零含入模式取整，获得整数值Vv如果v在目标类型T(int或long)的表示范围之内，那转换结果就是v。否则，将根据v的符号，转换为T所能表示的最大或者最小正数</p>
</blockquote>
<p>3.2. 当将一个double类型窄化转换为float类型时，将遵循以下转换规则</p>
<blockquote>
<p>通过向最接近数舍入模式舍入一个可以使用float类型表示的数字。最后结果根据下面这3条规则判断</p>
<p>如果转换结果的绝对值太小而无法使用float来表示，将返回float类型的正负零</p>
<p>如果转换结果的绝对值太大而无法使用float来表示，将返回float类型的正负无穷大。</p>
<p>对于double类型的NaN值将按规定转換为float类型的NaN值。</p>
</blockquote>
</blockquote>
</blockquote>
<hr>

<p><img src="/../../../images/image-20230110115749195.png" alt="image-20230110115749195"></p>
<p>精度损失的举例：</p>
<p><img src="/../../../images/image-20230110120128649.png" alt="image-20230110120128649"></p>
<p><strong>测试NaN，无穷大的情况：</strong></p>
<p><img src="/../../../images/image-20230110120800053.png" alt="image-20230110120800053"></p>
<h1 id="5-对象的创建与访问指令"><a href="#5-对象的创建与访问指令" class="headerlink" title="5. 对象的创建与访问指令"></a>5. 对象的创建与访问指令</h1><blockquote>
<h2 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h2><p>new 创建一个新对象</p>
<p>getfield 从对象中获取字段</p>
<p>putfield 设置对象中字段的值</p>
<p>getstatic 从类中获取静态字段</p>
<p>putstatic 设置类中静态字段的值</p>
<p>checkcast 确定对象为所给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。如果不是便抛出异常</p>
<p>instanceof 判断对象是否为给定的类型。后跟目标类，判断栈顶元素是否为目标类 / 接口的实例。是则压入 1，否则压入 0</p>
<h2 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h2><p>newarray 分配数据成员类型为基本上数据类型的新数组</p>
<p>anewarray 分配数据成员类型为引用类型的新数组</p>
<p>arraylength 获取数组长度</p>
<p>multianewarray 分配新的多维数组</p>
</blockquote>
<p>Java是面向对象的程序设计语言，虚拟机平台从字节码层面就对面向对象做了深层次的支持。有一系列指令专门用于对象操作，可进一步细分为创建指令、字段访问指令、数组操作指令、类型检查指令。</p>
<h2 id="5-1-创建指令"><a href="#5-1-创建指令" class="headerlink" title="5.1. 创建指令"></a>5.1. 创建指令</h2><table>
<thead>
<tr>
<th align="left">创建指令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">new</td>
<td align="left">创建类实例</td>
</tr>
<tr>
<td align="left">newarray</td>
<td align="left">创建基本类型数组</td>
</tr>
<tr>
<td align="left">anewarray</td>
<td align="left">创建引用类型数组</td>
</tr>
<tr>
<td align="left">multilanewarra</td>
<td align="left">创建多维数组</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/44ec8eda0028b78f02951aa5edc14751.png" alt="img"></p>
<p><img src="/../../../images/image-20230110135551913.png" alt="image-20230110135551913"></p>
<h2 id="5-2-字段访问指令"><a href="#5-2-字段访问指令" class="headerlink" title="5.2. 字段访问指令"></a>5.2. 字段访问指令</h2><table>
<thead>
<tr>
<th align="left">字段访问指令</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getstatic、putstatic</td>
<td align="left">访问类字段（static字段，或者称为类变量）的指令</td>
</tr>
<tr>
<td align="left">getfield、 putfield</td>
<td align="left">访问类实例字段（非static字段，或者称为实例变量）的指令</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c95da4b9bcb174f367617ca977451b14.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/6f7033f9caaf3216c6ca6795de12f6a4.png" alt="img"></p>
<h2 id="5-3-数组操作指令"><a href="#5-3-数组操作指令" class="headerlink" title="5.3. 数组操作指令"></a>5.3. 数组操作指令</h2><table>
<thead>
<tr>
<th>数组指令</th>
<th>byte(boolean)</th>
<th>char</th>
<th>short</th>
<th>long</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xaload</strong></td>
<td>baload</td>
<td>caload</td>
<td>saload</td>
<td>iaload</td>
<td>laload</td>
<td>faload</td>
<td>daload</td>
<td>aaload</td>
</tr>
<tr>
<td><strong>xastore</strong></td>
<td>bastore</td>
<td>castore</td>
<td>sastore</td>
<td>iastore</td>
<td>lastore</td>
<td>fastore</td>
<td>dastore</td>
<td>aastore</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a25e46492ce58084d3bb1ee9a4255ac4.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/4d55c1e67881b686d4dcb75118f257c5.png" alt="img"></p>
<h2 id="5-4-类型检查指令"><a href="#5-4-类型检查指令" class="headerlink" title="5.4. 类型检查指令"></a>5.4. 类型检查指令</h2><table>
<thead>
<tr>
<th>类型检查指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>instanceof</td>
<td>检查类型强制转换是否可以进行</td>
</tr>
<tr>
<td>checkcast</td>
<td>判断给定对象是否是某一个类的实例</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/df1e056d6e977d38b6c5974a428a040a.png" alt="img"></p>
<hr>

<h1 id="6-方法调用与返回指令"><a href="#6-方法调用与返回指令" class="headerlink" title="6. 方法调用与返回指令"></a>6. 方法调用与返回指令</h1><blockquote>
<h2 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h2><p>invokcvirtual 运行时按照对象的类来调用实例方法</p>
<p>invokespecial 根据编译时类型来调用实例方法</p>
<p>invokestatic 调用类（静态）方法</p>
<p>invokcinterface 调用接口方法</p>
<h2 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h2><p>ireturn 从方法中返回int类型的数据</p>
<p>lreturn 从方法中返回long类型的数据</p>
<p>freturn 从方法中返回float类型的数据</p>
<p>dreturn 从方法中返回double类型的数据</p>
<p>areturn 从方法中返回引用类型的数据</p>
<p>return 从方法中返回，返回值为void</p>
</blockquote>
<h2 id="6-1-方法调用指令"><a href="#6-1-方法调用指令" class="headerlink" title="6.1. 方法调用指令"></a>6.1. 方法调用指令</h2><table>
<thead>
<tr>
<th>方法调用指令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>invokevirtual</td>
<td>调用对象的实例方法</td>
</tr>
<tr>
<td>invokeinterface</td>
<td>调用接口方法</td>
</tr>
<tr>
<td>invokespecial</td>
<td>调用一些需要特殊处理的实例方法，包括实例初始化方法（构造器）、私有方法和父类方法</td>
</tr>
<tr>
<td>invokestatic</td>
<td>调用命名类中的类方法（static方法）</td>
</tr>
<tr>
<td>invokedynamic</td>
<td>调用动态绑定的方法</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6b6c265e506611b1fa05134d7ede3f30.png" alt="img"></p>
<p><img src="/../../../images/image-20230110161847552.png" alt="image-20230110161847552"></p>
<p><img src="/../../../images/image-20230110162226479.png" alt="image-20230110162226479"></p>
<p><img src="/../../../images/image-20230110162743637.png" alt="image-20230110162743637"></p>
<p><img src="/../../../images/image-20230110162820017.png" alt="image-20230110162820017"></p>
<h2 id="6-2-方法返回指令"><a href="#6-2-方法返回指令" class="headerlink" title="6.2. 方法返回指令"></a>6.2. 方法返回指令</h2><table>
<thead>
<tr>
<th>方法返回指令</th>
<th>void</th>
<th>int</th>
<th>long</th>
<th>float</th>
<th>double</th>
<th>reference</th>
</tr>
</thead>
<tbody><tr>
<td><strong>xreturn</strong></td>
<td>return</td>
<td>ireturn</td>
<td>lreturn</td>
<td>freutrn</td>
<td>dreturn</td>
<td>areturn</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8940d3d81dff02c08bf83cf0c66f3fea.png" alt="image-20210425222017858"><br><img src="https://img-blog.csdnimg.cn/img_convert/386375c9f516af716a5d8dec10177444.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">methodReturn</span><span class="params">()</span> {</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (i + j) / k;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/3fbd1f2ca9f4300eee5e0c4a0227a441.png" alt="image-20210425222245665"></p>
<hr>

<h1 id="7-操作数栈管理指令"><a href="#7-操作数栈管理指令" class="headerlink" title="7. 操作数栈管理指令"></a>7. 操作数栈管理指令</h1><blockquote>
<h2 id="通用-无类型）栈操作"><a href="#通用-无类型）栈操作" class="headerlink" title="通用(无类型）栈操作"></a>通用(无类型）栈操作</h2><p>nop 不做任何操作</p>
<p>pop 弹出栈顶端一个字长的内容</p>
<p>pop2 弹出栈顶端两个字长的内容</p>
<p>dup 复制栈顶部一个字长内容</p>
<p>dup_x1 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的两个字长的内容压入栈</p>
<p>dup_x2 复制栈顶部一个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2 复制栈顶部两个字长内容</p>
<p>dup2_x1 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的三个字长的内容压入栈</p>
<p>dup2_x2 复制栈顶部两个字长的内容，然后将复制内容及原来弹出的四个字长的内容压入栈</p>
<p>swap 交换栈顶部两个字长内容</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/316306469dcd1360c16578931cd064fa.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/0d8d5d90fc84398f114eae5d1119cf6b.png" alt="img"></p>
<hr>

<h1 id="8-控制转移指令"><a href="#8-控制转移指令" class="headerlink" title="8. 控制转移指令"></a>8. 控制转移指令</h1><blockquote>
<h2 id="比较指令"><a href="#比较指令" class="headerlink" title="比较指令"></a>比较指令</h2><p>lcmp 比较long类型值</p>
<p>fcmpl 比较float类型值（当遇到NaN时，返回-1）</p>
<p>fcmpg 比较float类型值（当遇到NaN时，返回1）</p>
<p>dcmpl 比较double类型值（当遇到NaN时，返回-1）</p>
<p>dcmpg 比较double类型值（当遇到NaN时，返回1）</p>
<h2 id="条件分支指令"><a href="#条件分支指令" class="headerlink" title="条件分支指令"></a>条件分支指令</h2><p>ifeq 如果等于0，则跳转</p>
<p>ifne 如果不等于0，则跳转</p>
<p>iflt 如果小于0，则跳转</p>
<p>ifge 如果大于等于0，则跳转</p>
<p>ifgt 如果大于0，则跳转</p>
<p>ifle 如果小于等于0，则跳转</p>
<h2 id="比较条件分支指令"><a href="#比较条件分支指令" class="headerlink" title="比较条件分支指令"></a>比较条件分支指令</h2><p>if_icmpeq 如果两个int值相等，则跳转</p>
<p>if_icmpne 如果两个int类型值不相等，则跳转</p>
<p>if_icmplt 如果一个int类型值小于另外一个int类型值，则跳转</p>
<p>if_icmpge 如果一个int类型值大于或者等于另外一个int类型值，则跳转</p>
<p>if_icmpgt 如果一个int类型值大于另外一个int类型值，则跳转</p>
<p>if_icmple 如果一个int类型值小于或者等于另外一个int类型值，则跳转</p>
<p>ifnull 如果等于null，则跳转</p>
<p>ifnonnull 如果不等于null，则跳转</p>
<p>if_acmpeq 如果两个对象引用相等，则跳转</p>
<p>if_acmpne 如果两个对象引用不相等，则跳转</p>
<h2 id="多条件分支跳转指令"><a href="#多条件分支跳转指令" class="headerlink" title="多条件分支跳转指令"></a>多条件分支跳转指令</h2><p>tableswitch 通过索引访问跳转表，并跳转</p>
<p>lookupswitch 通过键值匹配访问跳转表，并执行跳转操作</p>
<h2 id="无条件跳转指令"><a href="#无条件跳转指令" class="headerlink" title="无条件跳转指令"></a>无条件跳转指令</h2><p>goto 无条件跳转</p>
<p>goto_w 无条件跳转（宽索引）</p>
</blockquote>
<h2 id="8-1-比较指令"><a href="#8-1-比较指令" class="headerlink" title="8.1. 比较指令"></a>8.1. 比较指令</h2><blockquote>
<p>比较指令的作用是比较占栈顶两个元素的大小，并将比较结果入栽。</p>
<p>比较指令有： dcmpg,dcmpl、 fcmpg、fcmpl、lcmp</p>
<p>与前面讲解的指令类似，首字符d表示double类型，f表示float,l表示long.</p>
<p>对于double和float类型的数字，由于NaN的存在，各有两个版本的比较指令。以float为例，有fcmpg和fcmpl两个指令，它们的区别在于在数字比较时，若遇到NaN值，处理结果不同。</p>
<p>指令dcmpl和 dcmpg也是类似的，根据其命名可以推测其含义，在此不再赘述。</p>
<p>举例</p>
<p>指令 fcmp和fcmpl都从中弹出两个操作数，并将它们做比较，设栈顶的元素为v2,顶顺位第2位的元素为v1,</p>
<p><strong>若v1=v2, 则压入0；若v1&gt;v2则压入1；若v1&lt;v2则压入-1.</strong></p>
<p>两个指令的不同之处在于，如果遇到NaN值， fcmpg会压入1,而fcmpl会压入-1</p>
</blockquote>
<h2 id="8-2-条件跳转指令"><a href="#8-2-条件跳转指令" class="headerlink" title="8.2. 条件跳转指令"></a>8.2. 条件跳转指令</h2><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
<th>null</th>
<th>not null</th>
</tr>
</thead>
<tbody><tr>
<td>iflt</td>
<td>ifle</td>
<td>ifeq</td>
<td>ifng</td>
<td>ifge</td>
<td>ifgt</td>
<td>ifnull</td>
<td>ifnonnull</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e59234f41d6946ead781b686455783d9.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/85374206e3cdbb00f45971b1429c6d34.png" alt="img"></p>
<p><img src="/../../../images/image-20230110172437296.png" alt="image-20230110172437296"></p>
<p><img src="/../../../images/image-20230110172558692.png" alt="image-20230110172558692"></p>
<h2 id="8-3-比较条件跳转指令"><a href="#8-3-比较条件跳转指令" class="headerlink" title="8.3. 比较条件跳转指令"></a>8.3. 比较条件跳转指令</h2><table>
<thead>
<tr>
<th>&lt;</th>
<th>&lt;=</th>
<th>==</th>
<th>!=</th>
<th>&gt;=</th>
<th>&gt;</th>
</tr>
</thead>
<tbody><tr>
<td>if_icmplt</td>
<td>if_icmple</td>
<td>if_icmpeq、if_acmpeq</td>
<td>if_icmpne、if_acmpne</td>
<td>if_icmpge</td>
<td>if_icmpgt</td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7ffa349a864e62f3e0298b63acb904ae.png" alt="img"></p>
<h2 id="8-4-多条件分支跳转"><a href="#8-4-多条件分支跳转" class="headerlink" title="8.4. 多条件分支跳转"></a>8.4. 多条件分支跳转</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/f6f973613d257f1d172e0fcee504cd97.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/57c7b57b096f8a8cfcdcdd1b5d4e179b.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/a709c4fcd4bf627ad47d53ac062db47b.png" alt="img"></p>
<p><img src="/../../../images/image-20230110210256624.png" alt="image-20230110210256624"></p>
<p><img src="/../../../images/image-20230110210450102.png" alt="image-20230110210450102"></p>
<p><img src="/../../../images/image-20230110210833352.png" alt="image-20230110210833352"></p>
<h2 id="8-5-无条件跳转"><a href="#8-5-无条件跳转" class="headerlink" title="8.5. 无条件跳转"></a>8.5. 无条件跳转</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/9e86f7429623e68e353ce9d1962a1267.png" alt="img"></p>
<hr>



<p><img src="/../../../images/image-20230110211303331.png" alt="image-20230110211303331"></p>
<h1 id="9-异常处理指令"><a href="#9-异常处理指令" class="headerlink" title="9. 异常处理指令"></a>9. 异常处理指令</h1><blockquote>
<h2 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h2><p>athrow 抛出异常或错误。将栈顶异常抛出</p>
<p>jsr 跳转到子例程</p>
<p>jsr_w 跳转到子例程（宽索引）</p>
<p>rct 从子例程返回</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/img_convert/196b81557c33474cf2cfa2032aa65340.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/9e9883544cea41b6148e535da4417d78.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/daa25784fc259c12af58bb094d6ffc52.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/cba1429ffc09988d78008f5309a6374a.png" alt="img"></p>
<hr>

<h1 id="10-同步控制指令"><a href="#10-同步控制指令" class="headerlink" title="10. 同步控制指令"></a>10. 同步控制指令</h1><blockquote>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>montiorenter 进入并获取对象监视器。即：为栈顶对象加锁</p>
<p>monitorexit 释放并退出对象监视器。即：为栈顶对象解锁</p>
</blockquote>
<p>Java虚拟机支持两种同步结构：<strong>方法级的同步</strong>（同步方法） 和 <strong>方法内部一段指令序列的同步</strong>（方法内使用的同步代码块），这两种同步都是使用monitor监听器来支持的</p>
<h2 id="10-1-方法级的同步"><a href="#10-1-方法级的同步" class="headerlink" title="10.1. 方法级的同步"></a>10.1. 方法级的同步</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/20b7bf14a51e1be4f90dac5e305d2ea3.png" alt="img"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> {</span><br><span class="line">	i++;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><img src="https://img-blog.csdnimg.cn/img_convert/098e9fef1897cf213d14f145db04c9f1.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/84ff4ef05baf1b5774f43b203d6a6e23.png" alt="img"></p>
<h2 id="10-2-方法内指令指令序列的同步"><a href="#10-2-方法内指令指令序列的同步" class="headerlink" title="10.2. 方法内指令指令序列的同步"></a>10.2. 方法内指令指令序列的同步</h2><p><img src="https://img-blog.csdnimg.cn/img_convert/697b683f5fba682a6ed9772950f719a7.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/71ab99d8f145e61b31daa03a233f2596.png" alt="img"><br><img src="https://img-blog.csdnimg.cn/img_convert/ac36b8a792107c77956ef642afba2154.png" alt="img"></p>
<hr>

<p><img src="/../../../images/image-20230110220327662.png" alt="image-20230110220327662"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/09/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/3-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4%E9%9B%86/" data-id="clkr14xwe009gs4v686ueblrq" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="tag">JVM中篇：字节码与类的加载器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/Untitled" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/" class="article-date">
  <time class="post-time" datetime="2023-01-03T06:11:47.180Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>为什么学字节码文件的原因：</strong></p>
<p><img src="/../../../images/image-20230103141407495.png" alt="image-20230103141407495"></p>
<p><img src="/../../../images/image-20230103141317313.png" alt="image-20230103141317313"></p>
<p><img src="/../../../images/image-20230103141306367.png" alt="image-20230103141306367"></p>
<p><img src="/../../../images/image-20230103141338248.png" alt="image-20230103141338248"></p>
<p><strong>java前端编译器</strong></p>
<p><img src="/../../../images/image-20230103142540075.png" alt="image-20230103142540075"></p>
<p>一个程序的性能是否高效，其实跟语言是没太大的关系的，主要是编译器，比如java在早期的时候，没有编译器只有解释器，然后就很慢，后来又了JIT编译器后，就快很多了。</p>
<p><strong>前端编译器 vs 后端编译器</strong></p>
<p><img src="/../../../images/image-20230103144208971.png" alt="image-20230103144208971"></p>
<p><strong>透过字节码指令看代码执行细节：</strong></p>
<p><img src="/../../../images/image-20230103144413285.png" alt="image-20230103144413285"></p>
<p><img src="/../../../images/image-20230103144716615.png" alt="image-20230103144716615"></p>
<p><img src="/../../../images/image-20230103150037755.png" alt="image-20230103150037755"></p>
<p>例子2：</p>
<p><img src="/../../../images/image-20230103150626861.png" alt="image-20230103150626861"></p>
<p>例子3：</p>
<p><img src="/../../../images/image-20230105164434790.png" alt="image-20230105164434790"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 成员变量（非静态的）赋值过程：1.默认初始化 - 2.显示初始化 / 代码块中初始化 - 3. 构造器中初始化 -</span><br><span class="line">*                         4.有了对象之后，可以“对象.属性” 或 “对象.方法” 的方式对成员变量进行赋值</span><br></pre></td></tr></tbody></table></figure>

<p><img src="/../../../images/image-20230105162837668.png" alt="image-20230105162837668"></p>
<p><img src="/../../../images/image-20230105163558835.png" alt="image-20230105163558835"></p>
<p><img src="/../../../images/image-20230105164757916.png" alt="image-20230105164757916"></p>
<h2 id="解读Class文件的三种方式"><a href="#解读Class文件的三种方式" class="headerlink" title="解读Class文件的三种方式"></a>解读Class文件的三种方式</h2><p><img src="/../../../images/image-20230106210715710.png" alt="image-20230106210715710"></p>
<p><img src="/../../../images/image-20230106211249422.png" alt="image-20230106211249422"></p>
<p><img src="/../../../images/image-20230106211233536.png" alt="image-20230106211233536"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/" data-id="clkr14xwg009js4v69q2zag33" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/8/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>179</strong><br>文章</div></a>
      <a href="/categories"><div><strong>78</strong><br>分类</div></a>
      <a href="/tags"><div><strong>58</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>