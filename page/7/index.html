<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo &amp; github</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo &amp; github">
<meta property="og:url" content="http://example.com/page/7/index.html">
<meta property="og:site_name" content="Hexo &amp; github">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="其然乐衣">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo &amp; github" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

  
<link rel="stylesheet" href="/plugin/bganimation/bg.css">

  

  <link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css" rel="stylesheet" type="text/css">
<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>

<body>
  <div id="container">
    <div id="wrap">
      <div class="outer">
        <div class="widget-wrap mobile-header">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>170</strong><br>文章</div></a>
      <a href="/categories"><div><strong>75</strong><br>分类</div></a>
      <a href="/tags"><div><strong>56</strong><br>标签</div></a>
    </div>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

        <section id="main">
  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/Untitled" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/" class="article-date">
  <time class="post-time" datetime="2023-01-03T06:11:47.180Z" itemprop="datePublished">
    <span class="post-month">1月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>为什么学字节码文件的原因：</strong></p>
<p><img src="../../../images/image-20230103141407495.png" alt="image-20230103141407495"></p>
<p><img src="../../../images/image-20230103141317313.png" alt="image-20230103141317313"></p>
<p><img src="../../../images/image-20230103141306367.png" alt="image-20230103141306367"></p>
<p><img src="../../../images/image-20230103141338248.png" alt="image-20230103141338248"></p>
<p><strong>java前端编译器</strong></p>
<p><img src="../../../images/image-20230103142540075.png" alt="image-20230103142540075"></p>
<p>一个程序的性能是否高效，其实跟语言是没太大的关系的，主要是编译器，比如java在早期的时候，没有编译器只有解释器，然后就很慢，后来又了JIT编译器后，就快很多了。</p>
<p><strong>前端编译器 vs 后端编译器</strong></p>
<p><img src="../../../images/image-20230103144208971.png" alt="image-20230103144208971"></p>
<p><strong>透过字节码指令看代码执行细节：</strong></p>
<p><img src="../../../images/image-20230103144413285.png" alt="image-20230103144413285"></p>
<p><img src="../../../images/image-20230103144716615.png" alt="image-20230103144716615"></p>
<p><img src="../../../images/image-20230103150037755.png" alt="image-20230103150037755"></p>
<p>例子2：</p>
<p><img src="../../../images/image-20230103150626861.png" alt="image-20230103150626861"></p>
<p>例子3：</p>
<p><img src="../../../images/image-20230105164434790.png" alt="image-20230105164434790"></p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 成员变量（非静态的）赋值过程：1.默认初始化 - 2.显示初始化 / 代码块中初始化 - 3. 构造器中初始化 -</span><br><span class="line">*                         4.有了对象之后，可以“对象.属性” 或 “对象.方法” 的方式对成员变量进行赋值</span><br></pre></td></tr></tbody></table></figure>
<p><img src="../../../images/image-20230105162837668.png" alt="image-20230105162837668"></p>
<p><img src="../../../images/image-20230105163558835.png" alt="image-20230105163558835"></p>
<p><img src="../../../images/image-20230105164757916.png" alt="image-20230105164757916"></p>
<h2 id="解读class文件的三种方式"><a class="markdownIt-Anchor" href="#解读class文件的三种方式"></a> 解读Class文件的三种方式</h2>
<p><img src="../../../images/image-20230106210715710.png" alt="image-20230106210715710"></p>
<p><img src="../../../images/image-20230106211249422.png" alt="image-20230106211249422"></p>
<p><img src="../../../images/image-20230106211233536.png" alt="image-20230106211233536"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2023/01/03/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/Untitled/" data-id="clihkswil008apov6bs5ifdlu" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-异常or报错/不明异常" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/21/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/%E4%B8%8D%E6%98%8E%E5%BC%82%E5%B8%B8/" class="article-date">
  <time class="post-time" datetime="2022-12-20T16:46:49.635Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">21</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>当你的实体类实现了序列化接口<img src="../../images/image-20221221005142575.png" alt="image-20221221005142575">，当你去查询数据库的实体类时，有时候会报错，有时候又不会报，我也不知道为什么，报错如下：</p>
<p>java.ang.ClassCastException: lass com.webloq.entity.User cannot be cast to class javaang,String (com.webloq,entity.User is in unnamed module of loader</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/21/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/%E4%B8%8D%E6%98%8E%E5%BC%82%E5%B8%B8/" data-id="clihkswhb006apov6cnb7b0vi" class="article-share-link">分享</a>
      
      
    </footer>
  </div>
  
</article>




  
    <article id="post-异常or报错/java.lang.ClassNotFoundException lombok.Data" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/17/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/java.lang.ClassNotFoundException%20lombok.Data/" class="article-date">
  <time class="post-time" datetime="2022-12-16T17:25:51.584Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">17</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/17/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/java.lang.ClassNotFoundException%20lombok.Data/">java.lang.ClassNotFoundException lombok.Data</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/">异常or报错</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>springboot项目启动报错:</p>
<p><img src="https://img-blog.csdnimg.cn/20191219191118357.png" alt="img"></p>
<p>原因：mysql <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=datetime&amp;spm=1001.2101.3001.7020">datetime</a>类型，实体类 写成了 Data</p>
<p><img src="https://img-blog.csdnimg.cn/24af0326e2854017a42925a304442132.png" alt="img"></p>
<p>把Data全部改为Date即可：</p>
<p><img src="https://img-blog.csdnimg.cn/69878a80687c47238f29cc095bd52d5f.png" alt="img"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/17/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/java.lang.ClassNotFoundException%20lombok.Data/" data-id="clihkswha0068pov68e7bdczg" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8or%E6%8A%A5%E9%94%99/" rel="tag">异常or报错</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-elasticsearch/数据同步" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/12/elasticsearch/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" class="article-date">
  <time class="post-time" datetime="2022-12-12T09:06:59.689Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">12</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/12/elasticsearch/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/">数据同步</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/Elasticsearch/">Elasticsearch</a>,<a class="article-category-link" href="/categories/Elasticsearch/java/">java</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="方案一同步调用"><a class="markdownIt-Anchor" href="#方案一同步调用"></a> 方案一：同步调用</h3>
<p><img src="../../images/image-20221212170758302.png" alt="image-20221212170758302"></p>
<p>如果用上面这种同步调用方法的话，就会把业务代码形成耦合，业务耦合必定会影响性能。上面一次新增酒店的总耗时就相当于三个步骤的总耗时，显然这样时间会比较长，而且如果有其中的步骤出异常，那么新增酒店这整个业务就出问题了。这就是耦合带来的问题。</p>
<h3 id="方案二异步通知"><a class="markdownIt-Anchor" href="#方案二异步通知"></a> 方案二：异步通知</h3>
<p><img src="../../images/image-20221212171310763.png" alt="image-20221212171310763"></p>
<p>利用MQ进行异步通知，解出耦合，提高性能。但这种方案比较依靠MQ的可靠性。</p>
<h3 id="方案三监听binlog"><a class="markdownIt-Anchor" href="#方案三监听binlog"></a> 方案三：监听binlog</h3>
<p><img src="../../images/image-20221212171812077.png" alt="image-20221212171812077"></p>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结：</h3>
<p><img src="../../images/image-20221212171713573.png" alt="image-20221212171713573"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/12/elasticsearch/%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5/" data-id="clihkswfn003mpov628p51ct0" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Elasticsearch/" rel="tag">Elasticsearch</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-安全性/事务回滚/Spring Boot事务回滚" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/03/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/Spring%20Boot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/" class="article-date">
  <time class="post-time" datetime="2022-12-03T12:27:01.326Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">03</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/03/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/Spring%20Boot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/">Spring Boot事务回滚</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%89%E5%85%A8%E6%80%A7/">安全性</a>,<a class="article-category-link" href="/categories/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/">事务回滚</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a class="markdownIt-Anchor" href="#前言"></a> 前言</h1>
<p>我们开发系统的时候经常会遇到一些关于交易的需求，交易的过程大多数都比较繁琐（会包括修改库存、修改余额、记录交易账单等等步骤），这时候我们就不得不考虑其中的潜在风险了，比如我们在交易的过程中修改了库存（库存 -1），接下来需要进行支付操作，但是此时系统突然宕机或者网络突然中断，这也就导致我们无法完成整个交易流程，虽然用户还没付钱，但是我们的库存变少了（商家肯定就不高兴了👿），所以我们就需要用到事务回滚来解决上述的问题。</p>
<h1 id="spring-boot-事务回滚"><a class="markdownIt-Anchor" href="#spring-boot-事务回滚"></a> Spring Boot 事务回滚</h1>
<p>我们有两种方式可以实现事务回滚，第一种是自动回滚，第二种是手动回滚，这两种实现方式大同小异，二者都需要使用 @Transactional 注解来实现事务回滚，下面直接上代码，看看二者之间到底哪里不一样。</p>
<p>在接口实现类中有一个插入会员信息的方法，咱们就对这个方法进行改造，分别实现一下自动回滚和手动回滚👇</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">    cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">    SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">    <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
<h2 id="自动回滚"><a class="markdownIt-Anchor" href="#自动回滚"></a> 自动回滚</h2>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">    cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">    SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">    <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
<p>我们可以看到方法上增加了一个注解 @Transactional(rollbackFor = Exception.class) ，通过该注解可以对异常进行捕获，当发生异常时就可以进行回滚，从而撤销本次的入库操作。</p>
<p>很多方法中都会用 try-catch 对异常进行处理，如果此时在 catch 中对可能出现的异常进行了处理，但是并没有再手动抛出（throw）异常，Spring 则会认为该方法成功执行，也就不会进行回滚👇。 <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4b9858bcb9f4d22a5cc2931883efe1e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="在这里插入图片描述"> 正解如下👇：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">        cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">        SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">        <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        System.out.println(<span class="string">"方法出现异常："</span> + e);</span><br><span class="line">        <span class="comment">//手动抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
<p>P.S. 如果 try-catch 语句在 finally 语句块中进行了 return 操作，那么 catch 语句块中手动抛出的异常也会被覆盖，同样不会自动回滚。</p>
<h2 id="手动回滚"><a class="markdownIt-Anchor" href="#手动回滚"></a> 手动回滚</h2>
<p>手动回滚的实现方式也非常简单，只需要添加一句代码即可实现👇</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 插入会员信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> cashierMember 会员信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">insertCashierMember</span><span class="params">(CashierMember cashierMember)</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        cashierMember.setCreateTime(DateUtils.getNowDate());</span><br><span class="line">        cashierMember.setCreateBy(ShiroUtils.getLoginName());</span><br><span class="line">        SMSUtil.sendCreateMemberMessage(cashierMember.getPhonenumber());</span><br><span class="line">        <span class="keyword">return</span> cashierMemberMapper.insertCashierMember(cashierMember);</span><br><span class="line">    }<span class="keyword">catch</span> (Exception e){</span><br><span class="line">        System.out.println(<span class="string">"方法出现异常："</span> + e);</span><br><span class="line">        <span class="comment">//实现手动回滚</span></span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line">复制代码</span><br></pre></td></tr></tbody></table></figure>
<p>P.S. 这里只是举个例子，手动回滚语句不一定要添加在 catch 代码块中，我们可以在任何一个地方使用手动回滚语句。<strong>需要注意的是，我们虽然可以在其他地方增加手动回滚语句，但是手动回滚语句后的代码还会继续执行，所以不建议在非 catch 代码块中使用手动回滚语句。</strong> 如果非要这么用的话，就一定要好好斟酌一下自己的业务逻辑是不是会有 BUG 了。</p>
<h1 id="spring-boot-事务回滚注意事项"><a class="markdownIt-Anchor" href="#spring-boot-事务回滚注意事项"></a> Spring Boot 事务回滚注意事项</h1>
<p>这里我们再简单说几句关于 Spring Boot 事务回滚中的注意事项：</p>
<ol>
<li>想实现回滚，首先要保证 Spring Boot 开启了事务（在启动类上增加 @EnableTransactionManagement 注解开启事务（其实 Spring Boot 默认就是开启事务的），其次就是实现回滚的方法必须是 public 的。</li>
<li>@Transactional(rollbackFor=Exception.class) 表示的是该方法无论抛出什么异常都会进行自动回滚；如果不加 (rollbackFor=Exception.class) 的话，则代表了默认值，也就是只有当该方法抛出了非检查型异常（RuntimeException）时才会进行回滚。</li>
<li>由于事务的四大特性（原子性、一致性、隔离性、持久性），所以 @Transactional 一般是要加在业务层（也就是接口实现类）中。</li>
<li>如果将 @Transactional(rollbackFor=Exception.class) 加在了接口实现类上，那么这个类下的所有方法都将会被加上事务管理，即所有方法都会在自己出现异常时进行回滚操作。</li>
</ol>
<h1 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h1>
<p>本人经验有限，有些地方可能讲的没有特别到位，如果您在阅读的时候想到了什么问题，欢迎在评论区留言，我们后续再一一探讨🙇‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/03/%E5%AE%89%E5%85%A8%E6%80%A7/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/Spring%20Boot%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/" data-id="clihkswkn00cppov6cdlg9m4n" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A/" rel="tag">事务回滚</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%89%E5%85%A8%E6%80%A7/" rel="tag">安全性</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-文件服务器/MinIO/Minio设置文件永久访问和下载" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/Minio%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B0%B8%E4%B9%85%E8%AE%BF%E9%97%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/" class="article-date">
  <time class="post-time" datetime="2022-12-01T12:03:32.526Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/Minio%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B0%B8%E4%B9%85%E8%AE%BF%E9%97%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/">Minio设置文件永久访问和下载</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/">文件服务器</a>,<a class="article-category-link" href="/categories/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/">MinIO</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li></li>
</ol>
<blockquote>
<p>docker pull minio/mc</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/8c2815c4dfe14d15b74abcd173b9db9c.png" alt="img"></p>
<ol start="2">
<li></li>
</ol>
<blockquote>
<p>docker run -it --entrypoint=/bin/sh minio/mc</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/a26767d7c9d74cc5bee45a1bffd745af.png" alt="img"></p>
<ol start="3">
<li></li>
</ol>
<blockquote>
<p>mc config host add <alias> <your-s3-endpoint> <your-access-key> <your-secret-key> [–api API-SIGNATURE]</your-secret-key></your-access-key></your-s3-endpoint></alias></p>
</blockquote>
<blockquote>
<p>mc ls minio</p>
</blockquote>
<ul>
<li>ALIAS: 别名就是给你的云存储服务起了一个短点的外号。</li>
<li>S3 endpoint,access key和secret key是你的云存储服务提供的。
<ul>
<li>endpoint</li>
<li>access key、secret key 到这里大家肯定都知道啦。</li>
</ul>
</li>
<li>API签名是可选参数，默认情况下，它被设置为"S3v4"。</li>
</ul>
<p>例如：</p>
<p><img src="https://img-blog.csdnimg.cn/8d4b5fb05f35420d8342b57906cde36b.png" alt="img"></p>
<ol start="4">
<li>通过下面命令分别设置永久下载和永久分享</li>
</ol>
<blockquote>
<p>mc anonymous set download minio/file</p>
</blockquote>
<blockquote>
<p>mc anonymous set public minio/file</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/db7e3502bffc4e729b9cde0ff25c31f3.png" alt="img"></p>
<p>详细说明参考如下博文：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6992467402877304868">Docker 安装最新Minio Client，还附带解决如何设置永久访问和永久下载链接！！（详图）有需求值得收藏的哈！！！！ - 掘金 (juejin.cn)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/Minio%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E6%B0%B8%E4%B9%85%E8%AE%BF%E9%97%AE%E5%92%8C%E4%B8%8B%E8%BD%BD/" data-id="clihkswkl00clpov66f4xaej3" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MinIO/" rel="tag">MinIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">文件服务器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-文件服务器/MinIO/云服务器docker安装MinIO" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E5%AE%89%E8%A3%85MinIO/" class="article-date">
  <time class="post-time" datetime="2022-12-01T12:03:32.526Z" itemprop="datePublished">
    <span class="post-month">12月</span><br/>
    <span class="post-day">01</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E5%AE%89%E8%A3%85MinIO/">云服务器docker安装MinIO</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/">文件服务器</a>,<a class="article-category-link" href="/categories/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/">MinIO</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>执行命令 <code>docker pull minio/minio</code> 下载稳定版本镜像</li>
</ol>
<blockquote>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></tbody></table></figure>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/f3ce24819cf1437a959b0009e57124cd.png" alt="img"></p>
<ol start="2">
<li>创建并启动minio容器</li>
</ol>
<p>MINIO_ACCESS_KEY是登录的用户名，MINIO_SECRET_KEY是登陆的密码，根据自己的情况来设置登录的用户名和密码</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 9000:9000 -p 9001:9001 -d --name minio -v /opt/docker/minio/data:/data -v /opt/docker/minio/config:/root/.minio -e "MINIO_ROOT_USER=minio" -e "MINIO_ROOT_PASSWORD=minio@123456" minio/minio server /data --console-address ":9000" --address ":9001"</span><br></pre></td></tr></tbody></table></figure>
<p>–console-address “:9000”  中的9000 是可视化界面的访问端口</p>
<p>–address “:9001” 中的 9001是api端口，在springboot中整合是用到</p>
<ol start="3">
<li>开放9000端口</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/fd189f85c8834e899f4b5e0284876ea7.png" alt="img"></p>
<p>9001端口也是像上面一样开放即可</p>
<ol start="4">
<li>访问登录，使用IP+9000 登录即可测试，然后输入自己在启动创建容器时设置的账号和密码</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/d6823c8747fb4b8ab196b9f3a892d18a.png" alt="img"></p>
<p><img src="https://img-blog.csdnimg.cn/94216afbb986434c9934f8d7d1fe523f.png" alt="img"></p>
<hr>
<p>安装和使用，可以参照这个博文：</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/7101581935486615559">SpringBoot 整合 Minio 上传文件 - 掘金 (juejin.cn)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/12/01/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/MinIO/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8docker%E5%AE%89%E8%A3%85MinIO/" data-id="clihkswko00cqpov6818ih2ss" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MinIO/" rel="tag">MinIO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/" rel="tag">文件服务器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM中篇：字节码与类的加载篇/1-class文件结构" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/29/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/1-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" class="article-date">
  <time class="post-time" datetime="2022-11-29T14:01:57.207Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">29</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/29/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/1-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/">1-class文件结构</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/">JVM中篇：字节码与类的加载器</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<p><img src="../../../images/image-20230108231953467.png" alt="image-20230108231953467"></p>
<h1 id="1-class-文件结构"><a class="markdownIt-Anchor" href="#1-class-文件结构"></a> 1. Class 文件结构</h1>
<h2 id="11-class-字节码文件结构"><a class="markdownIt-Anchor" href="#11-class-字节码文件结构"></a> 1.1. Class 字节码文件结构</h2>
<table>
    <tbody>  
        <tr>
            <th></th> 
            <th>类型</th> 
            <th>名称</th> 
            <th>说明</th> 
            <th>长度</th> 
            <th>数量</th> 
       </tr>
       <tr>
            <td>魔数</td>
            <td>u4</td>
            <td>magic</td>
            <td>魔数,识别Class文件格式</td>
            <td>4个字节</td>     
            <td>1</td>
       </tr>
       <tr>
            <td rowspan="2">版本号</td>
            <td>u2</td>
            <td>minor_version</td>
            <td>副版本号(小版本)</td>
            <td>2个字节</td>     
            <td>1</td>
       </tr>
       <tr>
            <td>u2</td>
            <td>major_version</td>
            <td>主版本号(大版本)</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>	
        <tr>
            <td rowspan="2">常量池集合</td>
            <td>u2</td>
            <td>constant_pool_count</td>
            <td>常量池计数器</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>cp_info</td>
            <td>constant_pool</td>
            <td>常量池表</td>
            <td>n个字节</td>     
            <td>constant_pool_count - 1</td>
        </tr>
        <tr>
            <td>访问标识</td>
            <td>u2</td>
            <td>access_flags</td>
            <td>访问标识</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>	
        <tr>
            <td rowspan="4">索引集合</td>
            <td>u2</td>
            <td>this_class</td>
            <td>类索引</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>u2</td>
            <td>super_class</td>
            <td>父类索引</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>u2</td>
            <td>interfaces_count</td>
            <td>接口计数器</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>u2</td>
            <td>interfaces</td>
            <td>接口索引集合</td>
            <td>2个字节</td>     
            <td>interfaces_count</td>
        </tr>    
        <tr>
            <td rowspan="2">字段表集合</td>
            <td>u2</td>
            <td>fields_count</td>
            <td>字段计数器</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>field_info</td>
            <td>fields</td>
            <td>字段表</td>
            <td>n个字节</td>     
            <td>fields_count</td>
        </tr>	
        <tr>
            <td rowspan="2">方法表集合</td>
            <td>u2</td>
            <td>methods_count</td>
            <td>方法计数器</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>method_info</td>
            <td>methods</td>
            <td>方法表</td>
            <td>n个字节</td>     
            <td>methods_count</td>
        </tr>
        <tr>
            <td rowspan="2">属性表集合</td>
            <td>u2</td>
            <td>attributes_count</td>
            <td>属性计数器</td>
            <td>2个字节</td>     
            <td>1</td>
        </tr>
        <tr>
            <td>attribute_info</td>
            <td>attributes</td>
            <td>属性表</td>
            <td>n个字节</td>     
            <td>attributes_count</td>
        </tr>	
   </tbody><tbody> 
</tbody></table>
<p><img src="../../../images/image-20230106211846510.png" alt="image-20230106211846510"></p>
<p><img src="../../../images/image-20230106212954414.png" alt="image-20230106212954414"></p>
<p><img src="../../../images/image-20230106213322903.png" alt="image-20230106213322903"></p>
<p><img src="../../../images/image-20230106213238542.png" alt="image-20230106213238542"></p>
<p><img src="../../../images/image-20230107101026854.png" alt="image-20230107101026854"></p>
<p><img src="../../../images/image-20230107101258275.png" alt="image-20230107101258275"></p>
<p><img src="../../../images/image-20230107162311874.png" alt="image-20230107162311874"></p>
<h2 id="12-class-文件数据类型"><a class="markdownIt-Anchor" href="#12-class-文件数据类型"></a> 1.2. Class 文件数据类型</h2>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">定义</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">无符号数</td>
<td style="text-align:left">无符号数可以用来描述数字、索引引用、数量值或按照 utf-8 编码构成的字符串值。</td>
<td style="text-align:left">其中无符号数属于基本的数据类型。 以 u1、u2、u4、u8 来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节</td>
</tr>
<tr>
<td style="text-align:left">表</td>
<td style="text-align:left">表是由多个无符号数或其他表构成的复合数据结构。</td>
<td style="text-align:left">所有的表都以“_info”结尾。 由于表没有固定长度，所以通常会在其前面加上个数说明。</td>
</tr>
</tbody>
</table>
<h2 id="13-魔数"><a class="markdownIt-Anchor" href="#13-魔数"></a> 1.3. 魔数</h2>
<p><strong>Magic Number（魔数）</strong></p>
<ul>
<li>每个 Class 文件开头的 4 个字节的无符号整数称为魔数（Magic Number）</li>
<li>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的有效合法的 Class 文件。即：<strong>魔数是 Class 文件的标识符</strong>。</li>
<li>魔数值固定为 0xCAFEBABE。不会改变。</li>
<li>如果一个 Class 文件不以 0xCAFEBABE 开头，虚拟机在进行文件校验的时候就会直接抛出以下错误：</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error: A JNI error has occurred, please check your installation and <span class="keyword">try</span> again</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.ClassFormatError: Incompatible magic value <span class="number">1885430635</span> in <span class="keyword">class</span> <span class="title class_">file</span> StringTest</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>使用魔数而不是扩展名来进行识别主要是基于安全方面的考虑，因为文件扩展名可以随意地改动。</li>
</ul>
<h2 id="14-文件版本号"><a class="markdownIt-Anchor" href="#14-文件版本号"></a> 1.4. 文件版本号</h2>
<p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号。同样也是 4 个字节。第 5 个和第 6 个字节所代表的含义就是编译的副版本号 <strong>minor_version</strong>，而第 7 个和第 8 个字节就是编译的主版本号 <strong>major_version</strong>。</p>
<p>它们共同构成了 class 文件的格式版本号。譬如某个 Class 文件的主版本号为 M，副版本号为 m，那么这个 Class 文件的格式版本号就确定为 M.m。</p>
<p>版本号和 Java 编译器的对应关系如下表：</p>
<h3 id="141-class-文件版本号对应关系"><a class="markdownIt-Anchor" href="#141-class-文件版本号对应关系"></a> 1.4.1. Class 文件版本号对应关系</h3>
<table>
<thead>
<tr>
<th>主版本（十进制）</th>
<th>副版本（十进制）</th>
<th>编译器版本</th>
</tr>
</thead>
<tbody>
<tr>
<td>45</td>
<td>3</td>
<td>1.1</td>
</tr>
<tr>
<td>46</td>
<td>0</td>
<td>1.2</td>
</tr>
<tr>
<td>47</td>
<td>0</td>
<td>1.3</td>
</tr>
<tr>
<td>48</td>
<td>0</td>
<td>1.4</td>
</tr>
<tr>
<td>49</td>
<td>0</td>
<td>1.5</td>
</tr>
<tr>
<td>50</td>
<td>0</td>
<td>1.6</td>
</tr>
<tr>
<td>51</td>
<td>0</td>
<td>1.7</td>
</tr>
<tr>
<td>52</td>
<td>0</td>
<td>1.8</td>
</tr>
<tr>
<td>53</td>
<td>0</td>
<td>1.9</td>
</tr>
<tr>
<td>54</td>
<td>0</td>
<td>1.10</td>
</tr>
<tr>
<td>55</td>
<td>0</td>
<td>1.11</td>
</tr>
</tbody>
</table>
<p>Java 的版本号是从 45 开始的，JDK1.1 之后的每个 JDK 大版本发布主版本号向上加 1。</p>
<p><mark>不同版本的 Java 编译器编译的 Class 文件对应的版本是不一样的。目前，高版本的 Java 虚拟机可以执行由低版本编译器生成的 Class 文件，但是低版本的 Java 虚拟机不能执行由高版本编译器生成的 Class 文件。否则 JVM 会抛出 java.lang.UnsupportedClassVersionError 异常。（向下兼容）</mark></p>
<p>在实际应用中，由于开发环境和生产环境的不同，可能会导致该问题的发生。因此，需要我们在开发时，特别注意开发编译的 JDK 版本和生产环境中的 JDK 版本是否一致。</p>
<ul>
<li>虚拟机 JDK 版本为 1.k（k&gt;=2）时，对应的 class 文件格式版本号的范围为 45.0 - 44+k.0（含两端）。</li>
</ul>
<h2 id="15-常量池集合"><a class="markdownIt-Anchor" href="#15-常量池集合"></a> 1.5. 常量池集合</h2>
<p>常量池是 Class 文件中内容最为丰富的区域之一。常量池对于 Class 文件中的字段和方法解析也有着至关重要的作用。</p>
<p>随着 Java 虚拟机的不断发展，常量池的内容也日渐丰富。可以说，常量池是整个 Class 文件的基石。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5c2a8d904287373990cffe9b82428daa.png" alt="image-20210508233536076"></p>
<p>在版本号之后，紧跟着的是常量池的数量，以及若干个常量池表项。</p>
<p>常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项 u2 类型的无符号数，代表常量池容量计数值（constant_pool_count）。与 Java 中语言习惯不一样的是，这个容量计数是从 1 而不是 0 开始的。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2（无符号数）</td>
<td style="text-align:left">constant_pool_count</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">cp_info（表）</td>
<td style="text-align:left">constant_pool</td>
<td style="text-align:left">constant_pool_count - 1</td>
</tr>
</tbody>
</table>
<p>由上表可见，Class 文件使用了一个前置的容量计数器（constant_pool_count）加若干个连续的数据项（constant_pool）的形式来描述常量池内容。我们把这一系列连续常量池数据称为常量池集合。</p>
<ul>
<li><mark>常量池表项</mark>中，用于存放编译时期生成的各种<mark>字面量</mark>和<mark>符号引用</mark>，这部分内容将在类加载后进入方法区的<mark>运行时常量池</mark>中存放</li>
</ul>
<h3 id="151-常量池计数器"><a class="markdownIt-Anchor" href="#151-常量池计数器"></a> 1.5.1. 常量池计数器</h3>
<p><strong>constant_pool_count（常量池计数器）</strong></p>
<ul>
<li>由于常量池的数量不固定，时长时短，所以需要放置两个字节来表示常量池容量计数值。</li>
<li>常量池容量计数值（u2 类型）：<mark>从 1 开始</mark>，表示常量池中有多少项常量。即 constant_pool_count=1 表示常量池中有 0 个常量项。</li>
<li>Demo 的值为：</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a17ef03e0783c664a51491aafde85d2a.png" alt="image-20210508234020104"></p>
<p>其值为 0x0016，掐指一算，也就是 22。需要注意的是，这实际上只有 21 项常量。索引为范围是 1-21。为什么呢？</p>
<p>通常我们写代码时都是从 0 开始的，但是这里的常量池却是从 1 开始，因为它把第 0 项常量空出来了。这是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可用索引值 0 来表示。</p>
<h3 id="152-常量池表"><a class="markdownIt-Anchor" href="#152-常量池表"></a> 1.5.2. 常量池表</h3>
<p>constant_pool 是一种表结构，以 <strong>1 ~ constant_pool_count - 1</strong> 为索引。表明了后面有多少个常量项。</p>
<p>常量池主要存放两大类常量：<mark>字面量（Literal）</mark>和<mark>符号引用（Symbolic References）</mark></p>
<p>它包含了 class 文件结构及其子结构中引用的所有字符串常量、类或接口名、字段名和其他常量。常量池中的每一项都具备相同的特征。第 1 个字节作为类型标记，用于确定该项的格式，这个字节称为 tag byte（标记字节、标签字节）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">标志(或标识)</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CONSTANT_Utf8_info</td>
<td style="text-align:left">1</td>
<td style="text-align:left">UTF-8 编码的字符串</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Integer_info</td>
<td style="text-align:left">3</td>
<td style="text-align:left">整型字面量</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Float_info</td>
<td style="text-align:left">4</td>
<td style="text-align:left">浮点型字面量</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Long_info</td>
<td style="text-align:left">5</td>
<td style="text-align:left">长整型字面量</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Double_info</td>
<td style="text-align:left">6</td>
<td style="text-align:left">双精度浮点型字面量</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Class_info</td>
<td style="text-align:left">7</td>
<td style="text-align:left">类或接口的符号引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_String_info</td>
<td style="text-align:left">8</td>
<td style="text-align:left">字符串类型字面量</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Fieldref_info</td>
<td style="text-align:left">9</td>
<td style="text-align:left">字段的符号引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_Methodref_info</td>
<td style="text-align:left">10</td>
<td style="text-align:left">类中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InterfaceMethodref_info</td>
<td style="text-align:left">11</td>
<td style="text-align:left">接口中方法的符号引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_NameAndType_info</td>
<td style="text-align:left">12</td>
<td style="text-align:left">字段或方法的符号引用</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodHandle_info</td>
<td style="text-align:left">15</td>
<td style="text-align:left">表示方法句柄</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_MethodType_info</td>
<td style="text-align:left">16</td>
<td style="text-align:left">标志方法类型</td>
</tr>
<tr>
<td style="text-align:left">CONSTANT_InvokeDynamic_info</td>
<td style="text-align:left">18</td>
<td style="text-align:left">表示一个动态方法调用点</td>
</tr>
</tbody>
</table>
<h4 id="i-字面量和符号引用"><a class="markdownIt-Anchor" href="#i-字面量和符号引用"></a> Ⅰ. 字面量和符号引用</h4>
<p>在对这些常量解读前，我们需要搞清楚几个概念。</p>
<p>常量池主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。如下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">具体的常量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">字面量</td>
<td style="text-align:left">文本字符串</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">声明为 final 的常量值</td>
</tr>
<tr>
<td style="text-align:left">符号引用</td>
<td style="text-align:left">类和接口的全限定名</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">字段的名称和描述符</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left">方法的名称和描述符</td>
</tr>
</tbody>
</table>
<p><strong>全限定名</strong></p>
<p>com/atguigu/test/Demo 这个就是类的<strong>全限定名</strong>，仅仅是把包名（全类名）的“.“替换成”/”，为了使连续的多个全限定名之间不产生混淆，在使用时最后一般会加入一个“;”表示全限定名结束。</p>
<p><strong>简单名称</strong></p>
<p>简单名称是指没有类型和参数修饰的方法或者字段名称，上面例子中的类的 add()方法和 num 字段的简单名称分别是 add 和 num。</p>
<p><strong>描述符</strong></p>
<p><mark>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值</mark>。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的 void 类型都用一个大写字符来表示，而对象类型则用字符 L 加对象的全限定名来表示，详见下表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">基本数据类型 byte</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">基本数据类型 char</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">基本数据类型 double</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">基本数据类型 float</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">基本数据类型 int</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td style="text-align:left">基本数据类型 long</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td style="text-align:left">基本数据类型 short</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td style="text-align:left">基本数据类型 boolean</td>
</tr>
<tr>
<td style="text-align:left">V</td>
<td style="text-align:left">代表 void 类型</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td style="text-align:left">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">数组类型，代表一维数组。比如：`double[] is [D</td>
</tr>
</tbody>
</table>
<p>用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法 java.lang.String tostring()的描述符为()Ljava/lang/String; ，方法 int abc(int[]x, int y)的描述符为([II)I。</p>
<p><img src="../../../images/image-20230107105451433.png" alt="image-20230107105451433"></p>
<p><strong>补充说明：</strong></p>
<p>虚拟机在加载 Class 文件时才会进行动态链接，也就是说，Class 文件中不会保存各个方法和字段的最终内存布局信息。因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。<mark>当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中</mark>。</p>
<p>这里说明下符号引用和直接引用的区别与关联：</p>
<ul>
<li>符号引用：符号引用以<mark>一组符号</mark>来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。<mark>符号引用与虚拟机实现的内存布局无关</mark>，引用的目标并不一定已经加载到了内存中。</li>
<li>直接引用：直接引用可以是直接<mark>指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</mark>。<mark>直接引用是与虚拟机实现的内存布局相关的</mark>，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。</li>
</ul>
<h4 id="ii-常量类型和结构"><a class="markdownIt-Anchor" href="#ii-常量类型和结构"></a> Ⅱ. 常量类型和结构</h4>
<p>常量池中每一项常量都是一个表，J0K1.7 之后共有 14 种不同的表结构数据。如下表格所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8266c05b4b1506d4c456b427b90b1b75.png" alt="image-20210509001319088"></p>
<p>常量池表数据的解读视频教程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1PJ411n7xZ?p=221&amp;spm_id_from=pageDriver&amp;vd_source=746b9336d739b80b11820809545b6604">221-常量池表数据的解读2_哔哩哔哩_bilibili</a></p>
<p>根据上图每个类型的描述我们也可以知道每个类型是用来描述常量池中哪些内容（主要是字面量、符号引用）的。比如:<br>
CONSTANT_Integer_info 是用来描述常量池中字面量信息的，而且只是整型字面量信息。</p>
<p>标志为 15、16、18 的常量项类型是用来支持动态语言调用的（jdk1.7 时才加入的）。</p>
<p><strong>细节说明:</strong></p>
<ul>
<li>CONSTANT_Class_info 结构用于表示类或接口</li>
<li>CONSTAT_Fieldref_info、CONSTAHT_Methodref_infoF 和 lCONSTANIT_InterfaceMethodref_info 结构表示字段、方汇和按口小法</li>
<li>CONSTANT_String_info 结构用于表示示 String 类型的常量对象</li>
<li>CONSTANT_Integer_info 和 CONSTANT_Float_info 表示 4 字节（int 和 float）的数值常量</li>
<li>CONSTANT_Long_info 和 CONSTAT_Double_info 结构表示 8 字作（long 和 double）的数值常量
<ul>
<li>在 class 文件的常最池表中，所行的 a 字节常借均占两个表成员（项）的空问。如果一个 CONSTAHT_Long_info 和 CNSTAHT_Double_info 结构在常量池中的索引位 n，则常量池中一个可用的索引位 n+2，此时常量池长中索引为 n+1 的项仍然有效但必须视为不可用的。</li>
</ul>
</li>
<li>CONSTANT_NameAndType_info 结构用于表示字段或方法，但是和之前的 3 个结构不同，CONSTANT_NameAndType_info 结构没有指明该字段或方法所属的类或接口。</li>
<li>CONSTANT_Utf8_info 用于表示字符常量的值</li>
<li>CONSTANT_MethodHandle_info 结构用于表示方法句柄</li>
<li>CONSTANT_MethodType_info 结构表示方法类型</li>
<li>CONSTANT_InvokeDynamic_info 结构表示 invokedynamic 指令所用到的引导方法(bootstrap method)、引导方法所用到的动态调用名称(dynamic invocation name)、参数和返回类型，并可以给引导方法传入一系列称为静态参数（static argument）的常量。</li>
</ul>
<p><strong>解析方法：</strong></p>
<ul>
<li>一个字节一个字节的解析</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f3485b5ca6cb750454230270021fc68a.png" alt="image-20210509002525647"></p>
<ul>
<li>使用 javap 命令解析：javap-verbose Demo.class 或 jclasslib 工具会更方便。</li>
</ul>
<p><strong>总结 1：</strong></p>
<ul>
<li>这 14 种表（或者常量项结构）的共同点是：表开始的第一位是一个 u1 类型的标志位（tag），代表当前这个常量项使用的是哪种表结构，即哪种常量类型。</li>
<li>在常量池列表中，CONSTANT_Utf8_info 常量项是一种使用改进过的 UTF-8 编码格式来存储诸如文字字符串、类或者接口的全限定名、字段或者方法的简单名称以及描述符等常量字符串信息。</li>
<li>这 14 种常量项结构还有一个特点是，其中 13 个常量项占用的字节固定，只有 CONSTANT_Utf8_info 占用字节不固定，其大小由 length 决定。为什么呢？<mark>因为从常量池存放的内容可知，其存放的是字面量和符号引用，最终这些内容都会是一个字符串，这些字符串的大小是在编写程序时才确定</mark>，比如你定义一个类，类名可以取长取短，所以在没编译前，大小不固定，编译后，通过 utf-8 编码，就可以知道其长度。</li>
</ul>
<p><strong>总结 2：</strong></p>
<ul>
<li>常量池：可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型（后面的很多数据类型都会指向此处），也是占用 Class 文件空间最大的数据项目之一。</li>
<li>常量池中为什么要包含这些内容？Java 代码在进行 Javac 编译的时候，并不像 C 和 C++那样有“连接”这一步骤，而是在虚拟机加载 C1ass 文件的时候进行动态链接。也就是说，<mark>在 Class 文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用</mark>。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。关于类的创建和动态链接的内容，在虚拟机类加载过程时再进行详细讲解</li>
</ul>
<h2 id="16-访问标志"><a class="markdownIt-Anchor" href="#16-访问标志"></a> 1.6. 访问标志</h2>
<p><strong>访问标识（access_flag、访问标志、访问标记）</strong></p>
<p>在常量池后，紧跟着访问标记。<strong>该标记使用两个字节表示，用于识别一些类或者接口层次的访问信息</strong>，包括：这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被声明为 final 等。各种访问标记如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th>标志值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td>0x0001</td>
<td style="text-align:left">标志为 public 类型</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td>0x0010</td>
<td style="text-align:left">标志被声明为 final，只有类可以设置</td>
</tr>
<tr>
<td style="text-align:left">ACC_SUPER</td>
<td>0x0020</td>
<td style="text-align:left">标志允许使用 invokespecial 字节码指令的新语义，JDK1.0.2 之后编译出来的类的这个标志默认为真。（使用增强的方法调用父类方法）</td>
</tr>
<tr>
<td style="text-align:left">ACC_INTERFACE</td>
<td>0x0200</td>
<td style="text-align:left">标志这是一个接口</td>
</tr>
<tr>
<td style="text-align:left">ACC_ABSTRACT</td>
<td>0x0400</td>
<td style="text-align:left">是否为 abstract 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNTHETIC</td>
<td>0x1000</td>
<td style="text-align:left">标志此类并非由用户代码产生（即：由编译器产生的类，没有源码对应）</td>
</tr>
<tr>
<td style="text-align:left">ACC_ANNOTATION</td>
<td>0x2000</td>
<td style="text-align:left">标志这是一个注解</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td>0x4000</td>
<td style="text-align:left">标志这是一个枚举</td>
</tr>
</tbody>
</table>
<p>类的访问权限通常为 ACC_开头的常量。</p>
<p>每一种类型的表示都是通过设置访问标记的 32 位中的特定位来实现的。比如，若是 public final 的类，则该标记为 ACC_PUBLIC | ACC_FINAL。</p>
<p>使用 ACC_SUPER 可以让类更准确地定位到父类的方法 super.method()，现代编译器都会设置并且使用这个标记。</p>
<p><strong>补充说明：</strong></p>
<ol>
<li>
<p>带有 ACC_INTERFACE 标志的 class 文件表示的是接口而不是类，反之则表示的是类而不是接口。</p>
<ul>
<li>如果一个 class 文件被设置了 ACC_INTERFACE 标志，那么同时也得设置 ACC_ABSTRACT 标志。同时它不能再设置 ACC_FINAL、ACC_SUPER 或 ACC_ENUM 标志。</li>
<li>如果没有设置 ACC_INTERFACE 标志，那么这个 class 文件可以具有上表中除 ACC_ANNOTATION 外的其他所有标志。当然，ACC_FINAL 和 ACC_ABSTRACT 这类互斥的标志除外。这两个标志不得同时设置。</li>
</ul>
</li>
<li>
<p>ACC_SUPER 标志用于确定类或接口里面的 invokespecial 指令使用的是哪一种执行语义。<mark>针对 Java 虚拟机指令集的编译器都应当设置这个标志</mark>。对于 Java SE 8 及后续版本来说，无论 class 文件中这个标志的实际值是什么，也不管 class 文件的版本号是多少，Java 虚拟机都认为每个 class 文件均设置了 ACC_SUPER 标志。</p>
<ul>
<li>ACC_SUPER 标志是为了向后兼容由旧 Java 编译器所编译的代码而设计的。目前的 ACC_SUPER 标志在由 JDK1.0.2 之前的编译器所生成的 access_flags 中是没有确定含义的，如果设置了该标志，那么 0racle 的 Java 虚拟机实现会将其忽略。</li>
</ul>
</li>
<li>
<p>ACC_SYNTHETIC 标志意味着该类或接口是由编译器生成的，而不是由源代码生成的。</p>
</li>
<li>
<p>注解类型必须设置 ACC_ANNOTATION 标志。如果设置了 ACC_ANNOTATION 标志，那么也必须设置 ACC_INTERFACE 标志。</p>
</li>
<li>
<p>ACC_ENUM 标志表明该类或其父类为枚举类型。</p>
</li>
</ol>
<h2 id="17-类索引-父类索引-接口索引"><a class="markdownIt-Anchor" href="#17-类索引-父类索引-接口索引"></a> 1.7. 类索引、父类索引、接口索引</h2>
<p>在访问标记后，会指定该类的类别、父类类别以及实现的接口，格式如下：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td style="text-align:left">this_class</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:left">super_class</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:left">interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td style="text-align:left">interfaces[interfaces_count]</td>
</tr>
</tbody>
</table>
<p>这三项数据来确定这个类的继承关系：</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名。由于 Java 语言不允许多重继承，所以父类索引只有一个，除了 java.1ang.Object 之外，所有的 Java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 e。</li>
<li>接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按 implements 语句（如果这个类本身是一个接口，则应当是 extends 语句）后的接口顺序从左到右排列在接口索引集合中。</li>
</ul>
<h3 id="171-this_class类索引"><a class="markdownIt-Anchor" href="#171-this_class类索引"></a> 1.7.1. this_class（类索引）</h3>
<p>2 字节无符号整数，指向常量池的索引。它提供了类的全限定名，如 com/atguigu/java1/Demo。this_class 的值必须是对常量池表中某项的一个有效索引值。常量池在这个索引处的成员必须为 CONSTANT_Class_info 类型结构体，该结构体表示这个 class 文件所定义的类或接口。</p>
<h3 id="172-super_class父类索引"><a class="markdownIt-Anchor" href="#172-super_class父类索引"></a> 1.7.2. super_class（父类索引）</h3>
<p>2 字节无符号整数，指向常量池的索引。它提供了当前类的父类的全限定名。如果我们没有继承任何类，其默认继承的是 java/lang/object 类。同时，由于 Java 不支持多继承，所以其父类只有一个。</p>
<p>super_class 指向的父类不能是 final。</p>
<h3 id="173-interfaces"><a class="markdownIt-Anchor" href="#173-interfaces"></a> 1.7.3. interfaces</h3>
<p>指向常量池索引集合，它提供了一个符号引用到所有已实现的接口</p>
<p>由于一个类可以实现多个接口，因此需要以数组形式保存多个接口的索引，表示接口的每个索引也是一个指向常量池的 CONSTANT_Class（当然这里就必须是接口，而不是类）。</p>
<h4 id="i-interfaces_count接口计数器"><a class="markdownIt-Anchor" href="#i-interfaces_count接口计数器"></a> Ⅰ. interfaces_count（接口计数器）</h4>
<p>interfaces_count 项的值表示当前类或接口的直接超接口数量。</p>
<h4 id="ii-interfaces接口索引集合"><a class="markdownIt-Anchor" href="#ii-interfaces接口索引集合"></a> Ⅱ. interfaces[]（接口索引集合）</h4>
<p>interfaces[]中每个成员的值必须是对常量池表中某项的有效索引值，它的长度为 interfaces_count。每个成员 interfaces[i]必须为 CONSTANT_Class_info 结构，其中 0 &lt;= i &lt; interfaces_count。在 interfaces[]中，各成员所表示的接口顺序和对应的源代码中给定的接口顺序（从左至右）一样，即 interfaces[0]对应的是源代码中最左边的接口。</p>
<h2 id="18-字段表集合"><a class="markdownIt-Anchor" href="#18-字段表集合"></a> 1.8. 字段表集合</h2>
<p><strong>fields</strong></p>
<p>用于描述接口或类中声明的变量。字段（field）包括<mark>类级变量以及实例级变量</mark>，但是不包括方法内部、代码块内部声明的局部变量。</p>
<p>字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<p>它指向常量池索引集合，它描述了每个字段的完整信息。比如<mark>字段的标识符、访问修饰符（public、private 或 protected）、是类变量还是实例变量（static 修饰符）、是否是常量（final 修饰符）</mark>等。</p>
<p><strong>注意事项：</strong></p>
<ul>
<li>字段表集合中不会列出从父类或者实现的接口中继承而来的字段，但有可能列出原本 Java 代码之中不存在的字段。譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。</li>
<li>在 Java 语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的。</li>
</ul>
<h3 id="181-字段计数器"><a class="markdownIt-Anchor" href="#181-字段计数器"></a> 1.8.1. 字段计数器</h3>
<p><strong>fields_count（字段计数器）</strong></p>
<p>fields_count 的值表示当前 class 文件 fields 表的成员个数。使用两个字节来表示。</p>
<p>fields 表中每个成员都是一个 field_info 结构，用于表示该类或接口所声明的所有类字段或者实例字段，不包括方法内部声明的变量，也不包括从父类或父接口继承的那些字段。</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">access_flags</td>
<td style="text-align:left">访问标志</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">name_index</td>
<td style="text-align:left">字段名索引</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">描述符索引</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attributes_count</td>
<td style="text-align:left">属性计数器</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_info</td>
<td style="text-align:left">attributes</td>
<td style="text-align:left">属性集合</td>
<td style="text-align:left">attributes_count</td>
</tr>
</tbody>
</table>
<h3 id="182-字段表"><a class="markdownIt-Anchor" href="#182-字段表"></a> 1.8.2. 字段表</h3>
<h4 id="i-字段表访问标识"><a class="markdownIt-Anchor" href="#i-字段表访问标识"></a> Ⅰ. 字段表访问标识</h4>
<p>我们知道，一个字段可以被各种关键字去修饰，比如：作用域修饰符（public、private、protected）、static 修饰符、final 修饰符、volatile 修饰符等等。因此，其可像类的访问标志那样，使用一些标志来标记字段。字段的访问标志有如下这些：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:left">字段是否为 public</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td style="text-align:left">0x0002</td>
<td style="text-align:left">字段是否为 private</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td style="text-align:left">0x0004</td>
<td style="text-align:left">字段是否为 protected</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td style="text-align:left">0x0008</td>
<td style="text-align:left">字段是否为 static</td>
</tr>
<tr>
<td style="text-align:left">ACC_FINAL</td>
<td style="text-align:left">0x0010</td>
<td style="text-align:left">字段是否为 final</td>
</tr>
<tr>
<td style="text-align:left">ACC_VOLATILE</td>
<td style="text-align:left">0x0040</td>
<td style="text-align:left">字段是否为 volatile</td>
</tr>
<tr>
<td style="text-align:left">ACC_TRANSTENT</td>
<td style="text-align:left">0x0080</td>
<td style="text-align:left">字段是否为 transient</td>
</tr>
<tr>
<td style="text-align:left">ACC_SYNCHETIC</td>
<td style="text-align:left">0x1000</td>
<td style="text-align:left">字段是否为由编译器自动产生</td>
</tr>
<tr>
<td style="text-align:left">ACC_ENUM</td>
<td style="text-align:left">0x4000</td>
<td style="text-align:left">字段是否为 enum</td>
</tr>
</tbody>
</table>
<h4 id="ii-描述符索引"><a class="markdownIt-Anchor" href="#ii-描述符索引"></a> Ⅱ. 描述符索引</h4>
<p>描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte，char，double，float，int，long，short，boolean）及代表无返回值的 void 类型都用一个大写字符来表示，而对象则用字符 L 加对象的全限定名来表示，如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:left">基本数据类型 byte</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:left">基本数据类型 char</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:left">基本数据类型 double</td>
</tr>
<tr>
<td style="text-align:left">F</td>
<td style="text-align:left">基本数据类型 float</td>
</tr>
<tr>
<td style="text-align:left">I</td>
<td style="text-align:left">基本数据类型 int</td>
</tr>
<tr>
<td style="text-align:left">J</td>
<td style="text-align:left">基本数据类型 long</td>
</tr>
<tr>
<td style="text-align:left">S</td>
<td style="text-align:left">基本数据类型 short</td>
</tr>
<tr>
<td style="text-align:left">Z</td>
<td style="text-align:left">基本数据类型 boolean</td>
</tr>
<tr>
<td style="text-align:left">V</td>
<td style="text-align:left">代表 void 类型</td>
</tr>
<tr>
<td style="text-align:left">L</td>
<td style="text-align:left">对象类型，比如：<code>Ljava/lang/Object;</code></td>
</tr>
<tr>
<td style="text-align:left">[</td>
<td style="text-align:left">数组类型，代表一维数组。比如：`double[][][] is [[[D</td>
</tr>
</tbody>
</table>
<h4 id="iii-属性表集合"><a class="markdownIt-Anchor" href="#iii-属性表集合"></a> Ⅲ. 属性表集合</h4>
<p>一个字段还可能拥有一些属性，用于存储更多的额外信息。比如初始化值、一些注释信息等。属性个数存放在 attribute_count 中，属性具体内容存放在 attributes 数组中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以常量属性为例，结构为：</span></span><br><span class="line">ConstantValue_attribute{</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">    u2 constantvalue_index;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>说明：对于常量属性而言，attribute_length 值恒为 2。</p>
<h2 id="19-方法表集合"><a class="markdownIt-Anchor" href="#19-方法表集合"></a> 1.9. 方法表集合</h2>
<p>methods：指向常量池索引集合，它完整描述了每个方法的签名。</p>
<ul>
<li>在字节码文件中，每一个 method_info 项都对应着一个类或者接口中的方法信息。比如方法的访问修饰符（public、private 或 protected），方法的返回值类型以及方法的参数信息等。</li>
<li>如果这个方法不是抽象的或者不是 native 的，那么字节码中会体现出来。</li>
<li>一方面，methods 表只描述当前类或接口中声明的方法，不包括从父类或父接口继承的方法。另一方面，methods 表有可能会出现由编译器自动添加的方法，最典型的便是编译器产生的方法信息（比如：类（接口）初始化方法&lt;clinit&gt;()和实例初始化方法&lt;init&gt;()）。</li>
</ul>
<p><strong>使用注意事项：</strong></p>
<p>在 Java 语言中，要重载（Overload）一个方法，除了要与原方法<strong>具有相同的简单名称</strong>之外，还要求<strong>必须拥有一个与原方法不同的特征签名</strong>，特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此 Java 语言里无法仅仅依靠返回值的不同来对一个已有方法进行重载。但在 Class 文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法就可以共存。也就是说，如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个 class 文件中。</p>
<p>也就是说，尽管 Java 语法规范并不允许在一个类或者接口中声明多个方法签名相同的方法，但是和 Java 语法规范相反，字节码文件中却恰恰允许存放多个方法签名相同的方法，唯一的条件就是这些方法之间的返回值不能相同。</p>
<h3 id="191-方法计数器"><a class="markdownIt-Anchor" href="#191-方法计数器"></a> 1.9.1. 方法计数器</h3>
<p><strong>methods_count（方法计数器）</strong></p>
<p>methods_count 的值表示当前 class 文件 methods 表的成员个数。使用两个字节来表示。</p>
<p>methods 表中每个成员都是一个 method_info 结构。</p>
<h3 id="192-方法表"><a class="markdownIt-Anchor" href="#192-方法表"></a> 1.9.2. 方法表</h3>
<p><strong>methods[]（方法表）</strong></p>
<p>methods 表中的每个成员都必须是一个 method_info 结构，用于表示当前类或接口中某个方法的完整描述。如果某个 method_info 结构的 access_flags 项既没有设置 ACC_NATIVE 标志也没有设置 ACC_ABSTRACT 标志，那么该结构中也应包含实现这个方法所用的 Java 虚拟机指令。</p>
<p>method_info 结构可以表示类和接口中定义的所有方法，包括实例方法、类方法、实例初始化方法和类或接口初始化方法</p>
<p>方法表的结构实际跟字段表是一样的，方法表结构如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">access_flags</td>
<td style="text-align:left">访问标志</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">name_index</td>
<td style="text-align:left">方法名索引</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">descriptor_index</td>
<td style="text-align:left">描述符索引</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attributes_count</td>
<td style="text-align:left">属性计数器</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">attribute_info</td>
<td style="text-align:left">attributes</td>
<td style="text-align:left">属性集合</td>
<td style="text-align:left">attributes_count</td>
</tr>
</tbody>
</table>
<p><strong>方法表访问标志</strong></p>
<p>跟字段表一样，方法表也有访问标志，而且他们的标志有部分相同，部分则不同，方法表的具体访问标志如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">标志名称</th>
<th style="text-align:left">标志值</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">ACC_PUBLIC</td>
<td style="text-align:left">0x0001</td>
<td style="text-align:left">public，方法可以从包外访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PRIVATE</td>
<td style="text-align:left">0x0002</td>
<td style="text-align:left">private，方法只能本类访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_PROTECTED</td>
<td style="text-align:left">0x0004</td>
<td style="text-align:left">protected，方法在自身和子类可以访问</td>
</tr>
<tr>
<td style="text-align:left">ACC_STATIC</td>
<td style="text-align:left">0x0008</td>
<td style="text-align:left">static，静态方法</td>
</tr>
</tbody>
</table>
<h2 id="110-属性表集合"><a class="markdownIt-Anchor" href="#110-属性表集合"></a> 1.10. 属性表集合</h2>
<p>方法表集合之后的属性表集合，<mark>指的是 class 文件所携带的辅助信息</mark>，比如该 class 文件的源文件的名称。以及任何带有 RetentionPolicy.CLASS 或者 RetentionPolicy.RUNTIME 的注解。这类信息通常被用于 Java 虚拟机的验证和运行，以及 Java 程序的调试，<mark>一般无须深入了解</mark>。</p>
<p>此外，字段表、方法表都可以有自己的属性表。用于描述某些场景专有的信息。</p>
<p>属性表集合的限制没有那么严格，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，但 Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="1101-属性计数器"><a class="markdownIt-Anchor" href="#1101-属性计数器"></a> 1.10.1. 属性计数器</h3>
<p><strong>attributes_count（属性计数器）</strong></p>
<p>attributes_count 的值表示当前 class 文件属性表的成员个数。属性表中每一项都是一个 attribute_info 结构。</p>
<h3 id="1102-属性表"><a class="markdownIt-Anchor" href="#1102-属性表"></a> 1.10.2. 属性表</h3>
<p><strong>attributes[]（属性表）</strong></p>
<p>属性表的每个项的值必须是 attribute_info 结构。属性表的结构比较灵活，各种不同的属性只要满足以下结构即可。</p>
<p><strong>属性的通用格式</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性名索引</td>
</tr>
<tr>
<td style="text-align:left">u4</td>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性长度</td>
</tr>
<tr>
<td style="text-align:left">u1</td>
<td style="text-align:left">info</td>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">属性表</td>
</tr>
</tbody>
</table>
<p><strong>属性类型</strong></p>
<p>属性表实际上可以有很多类型，上面看到的 Code 属性只是其中一种，Java8 里面定义了 23 种属性。下面这些是虚拟机中预定义的属性：</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性名称</th>
<th style="text-align:left">使用位置</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Code</td>
<td style="text-align:left">方法表</td>
<td style="text-align:left">Java 代码编译成的字节码指令</td>
</tr>
<tr>
<td style="text-align:left">ConstantValue</td>
<td style="text-align:left">字段表</td>
<td style="text-align:left">final 关键字定义的常量池</td>
</tr>
<tr>
<td style="text-align:left">Deprecated</td>
<td style="text-align:left">类，方法，字段表</td>
<td style="text-align:left">被声明为 deprecated 的方法和字段</td>
</tr>
<tr>
<td style="text-align:left">Exceptions</td>
<td style="text-align:left">方法表</td>
<td style="text-align:left">方法抛出的异常</td>
</tr>
<tr>
<td style="text-align:left">EnclosingMethod</td>
<td style="text-align:left">类文件</td>
<td style="text-align:left">仅当一个类为局部类或者匿名类时才能拥有这个属性，这个属性用于标识这个类所在的外围方法</td>
</tr>
<tr>
<td style="text-align:left">InnerClass</td>
<td style="text-align:left">类文件</td>
<td style="text-align:left">内部类列表</td>
</tr>
<tr>
<td style="text-align:left">LineNumberTable</td>
<td style="text-align:left">Code 属性</td>
<td style="text-align:left">Java 源码的行号与字节码指令的对应关系</td>
</tr>
<tr>
<td style="text-align:left">LocalVariableTable</td>
<td style="text-align:left">Code 属性</td>
<td style="text-align:left">方法的局部变量描述</td>
</tr>
<tr>
<td style="text-align:left">StackMapTable</td>
<td style="text-align:left">Code 属性</td>
<td style="text-align:left">JDK1.6 中新增的属性，供新的类型检查检验器和处理目标方法的局部变量和操作数有所需要的类是否匹配</td>
</tr>
<tr>
<td style="text-align:left">Signature</td>
<td style="text-align:left">类，方法表，字段表</td>
<td style="text-align:left">用于支持泛型情况下的方法签名</td>
</tr>
<tr>
<td style="text-align:left">SourceFile</td>
<td style="text-align:left">类文件</td>
<td style="text-align:left">记录源文件名称</td>
</tr>
<tr>
<td style="text-align:left">SourceDebugExtension</td>
<td style="text-align:left">类文件</td>
<td style="text-align:left">用于存储额外的调试信息</td>
</tr>
<tr>
<td style="text-align:left">Synthetic</td>
<td style="text-align:left">类，方法表，字段表</td>
<td style="text-align:left">标志方法或字段为编译器自动生成的</td>
</tr>
<tr>
<td style="text-align:left">LocalVariableTypeTable</td>
<td style="text-align:left">类</td>
<td style="text-align:left">是哟很难过特征签名代替描述符，是为了引入泛型语法之后能描述泛型参数化类型而添加</td>
</tr>
<tr>
<td style="text-align:left">RuntimeVisibleAnnotations</td>
<td style="text-align:left">类，方法表，字段表</td>
<td style="text-align:left">为动态注解提供支持</td>
</tr>
<tr>
<td style="text-align:left">RuntimeInvisibleAnnotations</td>
<td style="text-align:left">类，方法表，字段表</td>
<td style="text-align:left">用于指明哪些注解是运行时不可见的</td>
</tr>
<tr>
<td style="text-align:left">RuntimeVisibleParameterAnnotation</td>
<td style="text-align:left">方法表</td>
<td style="text-align:left">作用与 RuntimeVisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td style="text-align:left">RuntimeInvisibleParameterAnnotation</td>
<td style="text-align:left">方法表</td>
<td style="text-align:left">作用与 RuntimeInvisibleAnnotations 属性类似，只不过作用对象或方法</td>
</tr>
<tr>
<td style="text-align:left">AnnotationDefault</td>
<td style="text-align:left">方法表</td>
<td style="text-align:left">用于记录注解类元素的默认值</td>
</tr>
<tr>
<td style="text-align:left">BootstrapMethods</td>
<td style="text-align:left">类文件</td>
<td style="text-align:left">用于保存 invokeddynamic 指令引用的引导方法限定符</td>
</tr>
</tbody>
</table>
<p>或者（查看官网）</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/412a7e52bfb1ee0aa8229db1402ae58a.png" alt="image-20210421235232911"></p>
<p><strong>部分属性详解</strong></p>
<p><strong>① ConstantValue 属性</strong></p>
<p>ConstantValue 属性表示一个常量字段的值。位于 field_info 结构的属性表中。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ConstantValue_attribute{</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">	u2 constantvalue_index;<span class="comment">//字段值在常量池中的索引，常量池在该索引处的项给出该属性表示的常量值。（例如，值是1ong型的，在常量池中便是CONSTANT_Long）</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>② Deprecated 属性</strong></p>
<p>Deprecated 属性是在 JDK1.1 为了支持注释中的关键词@deprecated 而引入的。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Deprecated_attribute{</span><br><span class="line">	u2 attribute_name_index;</span><br><span class="line">	u4 attribute_length;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>③ Code 属性</strong></p>
<p>Code 属性就是存放<strong>方法体里面的代码</strong>。但是，并非所有方法表都有 Code 属性。像接口或者抽象方法，他们没有具体的方法体，因此也就不会有 Code 属性了。Code 属性表的结构，如下图：</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性名索引</td>
</tr>
<tr>
<td style="text-align:left">u4</td>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性长度</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">max_stack</td>
<td style="text-align:left">1</td>
<td style="text-align:left">操作数栈深度的最大值</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">max_locals</td>
<td style="text-align:left">1</td>
<td style="text-align:left">局部变量表所需的存续空间</td>
</tr>
<tr>
<td style="text-align:left">u4</td>
<td style="text-align:left">code_length</td>
<td style="text-align:left">1</td>
<td style="text-align:left">字节码指令的长度</td>
</tr>
<tr>
<td style="text-align:left">u1</td>
<td style="text-align:left">code</td>
<td style="text-align:left">code_lenth</td>
<td style="text-align:left">存储字节码指令</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">exception_table_length</td>
<td style="text-align:left">1</td>
<td style="text-align:left">异常表长度</td>
</tr>
<tr>
<td style="text-align:left">exception_info</td>
<td style="text-align:left">exception_table</td>
<td style="text-align:left">exception_length</td>
<td style="text-align:left">异常表</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attributes_count</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性集合计数器</td>
</tr>
<tr>
<td style="text-align:left">attribute_info</td>
<td style="text-align:left">attributes</td>
<td style="text-align:left">attributes_count</td>
<td style="text-align:left">属性集合</td>
</tr>
</tbody>
</table>
<p>可以看到：Code 属性表的前两项跟属性表是一致的，即 Code 属性表遵循属性表的结构，后面那些则是他自定义的结构。</p>
<p><strong>④ InnerClasses 属性</strong></p>
<p>为了方便说明特别定义一个表示类或接口的 Class 格式为 C。如果 C 的常量池中包含某个 CONSTANT_Class_info 成员，且这个成员所表示的类或接口不属于任何一个包，那么 C 的 ClassFile 结构的属性表中就必须含有对应的 InnerClasses 属性。InnerClasses 属性是在 JDK1.1 中为了支持内部类和内部接口而引入的，位于 ClassFile 结构的属性表。</p>
<p><strong>⑤ LineNumberTable 属性</strong></p>
<p>LineNumberTable 属性是可选变长属性，位于 Code 结构的属性表。</p>
<p>LineNumberTable 属性是<mark>用来描述 <strong>Java 源码行号 与 字节码行号</strong>之间的对应关系</mark>。这个属性可以用来在调试的时候定位代码执行的行数。</p>
<ul>
<li>start_pc，即字节码行号；1ine_number，即 Java 源代码行号。</li>
</ul>
<p>在 Code 属性的属性表中，LineNumberTable 属性可以按照任意顺序出现，此外，多个 LineNumberTable 属性可以共同表示一个行号在源文件中表示的内容，即 LineNumberTable 属性不需要与源文件的行一一对应。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LineNumberTable属性表结构：</span></span><br><span class="line">LineNumberTable_attribute{</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 line_number_table_length;</span><br><span class="line">    {</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 line_number;</span><br><span class="line">    } line_number_table[line_number_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>⑥ LocalVariableTable 属性</strong></p>
<p>LocalVariableTable 是可选变长属性，位于 Code 属性的属性表中。它被调试器用于确定方法在执行过程中局部变量的信息。在 Code 属性的属性表中，LocalVariableTable 属性可以按照任意顺序出现。Code 属性中的每个局部变量最多只能有一个 LocalVariableTable 属性。</p>
<ul>
<li>start pc + length 表示这个变量在字节码中的生命周期起始和结束的偏移位置（this 生命周期从头 e 到结尾 10）</li>
<li>index 就是这个变量在局部变量表中的槽位<mark>（槽位可复用）</mark></li>
<li>name 就是变量名</li>
<li>Descriptor 表示局部变量类型描述</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LocalVariableTable属性表结构：</span></span><br><span class="line">LocalVariableTable_attribute{</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 local_variable_table_length;</span><br><span class="line">    {</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 length;</span><br><span class="line">        u2 name_index;</span><br><span class="line">        u2 descriptor_index;</span><br><span class="line">        u2 index;</span><br><span class="line">    } local_variable_table[local_variable_table_length];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><img src="../../../images/image-20230108220200811.png" alt="image-20230108220200811"></p>
<p><strong>⑦ Signature 属性</strong></p>
<p>Signature 属性是可选的定长属性，位于 ClassFile，field_info 或 method_info 结构的属性表中。在 Java 语言中，任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则 Signature 属性会为它记录泛型签名信息。</p>
<p><strong>⑧ SourceFile 属性</strong></p>
<p>SourceFile 属性结构</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">数量</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">attribute_name_index</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性名索引</td>
</tr>
<tr>
<td style="text-align:left">u4</td>
<td style="text-align:left">attribute_length</td>
<td style="text-align:left">1</td>
<td style="text-align:left">属性长度</td>
</tr>
<tr>
<td style="text-align:left">u2</td>
<td style="text-align:left">sourcefile index</td>
<td style="text-align:left">1</td>
<td style="text-align:left">源码文件素引</td>
</tr>
</tbody>
</table>
<p>可以看到，其长度总是固定的 8 个字节。</p>
<p><strong>⑨ 其他属性</strong></p>
<p>Java 虚拟机中预定义的属性有 20 多个，这里就不一一介绍了，通过上面几个属性的介绍，只要领会其精髓，其他属性的解读也是易如反掌。</p>
<h2 id="class文件结构小结"><a class="markdownIt-Anchor" href="#class文件结构小结"></a> Class文件结构小结</h2>
<p><img src="../../../images/image-20230109103959417.png" alt="image-20230109103959417"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/29/JVM/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E7%AF%87/1-class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/" data-id="clihkswif0080pov695ad5tqu" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM%E4%B8%AD%E7%AF%87%EF%BC%9A%E5%AD%97%E8%8A%82%E7%A0%81%E4%B8%8E%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%99%A8/" rel="tag">JVM中篇：字节码与类的加载器</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-Quartz/Quartz学习笔记" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="post-time" datetime="2022-11-27T12:50:56.294Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">27</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Quartz学习笔记</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">定时任务</a>,<a class="article-category-link" href="/categories/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/Quartz/">Quartz</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><img src="../../images/image-20221127205106372.png" alt="image-20221127205106372"></p>
<p><img src="../../images/image-20221127213810488.png" alt="image-20221127213810488"></p>
<p><img src="../../images/image-20221128143023074.png" alt="image-20221128143023074"></p>
<p><img src="../../images/image-20221128130326946.png" alt="image-20221128130326946"></p>
<p><img src="../../images/image-20221128142414350.png" alt="image-20221128142414350"></p>
<p><img src="../../images/image-20221128142313901.png" alt="image-20221128142313901"></p>
<p>quartz 总体架构</p>
<p><img src="../../images/image-20221127223745383.png" alt="image-20221127223745383"></p>
<h2 id="quartz的使用"><a class="markdownIt-Anchor" href="#quartz的使用"></a> Quartz的使用</h2>
<p>导包</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- quartz --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        System.out.println(<span class="string">"MyJob execute:"</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>测试类</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>运行结果图</p>
<p><img src="../../images/image-20221127225021946.png" alt="image-20221127225021946"></p>
<hr>
<h2 id=""><a class="markdownIt-Anchor" href="#"></a> </h2>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import org.quartz.Job;</span><br><span class="line">import org.quartz.JobDataMap;</span><br><span class="line">import org.quartz.JobExecutionContext;</span><br><span class="line">import org.quartz.JobExecutionException;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class MyJop implements Job {</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span><br><span class="line">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span><br><span class="line">     */</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) {</span><br><span class="line">        this.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void execute(JobExecutionContext context) throws JobExecutionException {</span><br><span class="line">//        System.out.println("MyJob execute:" + new Date());</span><br><span class="line"></span><br><span class="line">        JobDataMap jobDetailMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">        JobDataMap triggerMap = context.getTrigger().getJobDataMap();</span><br><span class="line">        // 获取 JobDetail 和 Trigger 合并，但如果存在相同的键值key,Trigger的会覆盖JobDetail的</span><br><span class="line">        JobDataMap mergeMap = context.getMergedJobDataMap();</span><br><span class="line"></span><br><span class="line">        System.out.println("jobDetailMap:" + jobDetailMap.getString("job"));</span><br><span class="line">        System.out.println("triggerMap:" + triggerMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("job"));</span><br><span class="line">        System.out.println("mergeMap:" + mergeMap.getString("trigger"));</span><br><span class="line">        System.out.println("——————————————————————————————————————————————————————————————————————————");</span><br><span class="line">        System.out.println( "name : " + name );</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package quartz.quartz;</span><br><span class="line"></span><br><span class="line">import org.quartz.*;</span><br><span class="line">import org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @author : 其然乐衣Letitbe</span><br><span class="line"> * @date : 2022/11/27</span><br><span class="line"> */</span><br><span class="line">public class TestJob {</span><br><span class="line">    public static void main(String[] args) {</span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJop.class)</span><br><span class="line">                // name: 任务名称（在调度器里不能重复，唯一的） group : 组</span><br><span class="line">                .withIdentity("jop1", "group1")</span><br><span class="line">                .usingJobData("job", "jobDetail1")</span><br><span class="line">                .usingJobData("name", "jobDetail2")</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 触发器</span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity("trigger1", "trigger1")</span><br><span class="line">                .usingJobData("trigger", "trigger")</span><br><span class="line">                // 会覆盖上面JobDetail中的name的值</span><br><span class="line">                .usingJobData("name", "trigger2")</span><br><span class="line">                .startNow()</span><br><span class="line">                //                                                            时间间隔           永久重复执行</span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(2).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        // 调度器</span><br><span class="line">        try {</span><br><span class="line">            Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            // 启动</span><br><span class="line">            scheduler.start();</span><br><span class="line">        } catch (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果</p>
<p><img src="../../images/image-20221128103703359.png" alt="image-20221128103703359"></p>
<hr>
<h2 id="job-封装成jobdetail设置属性"><a class="markdownIt-Anchor" href="#job-封装成jobdetail设置属性"></a> Job : 封装成JobDetail设置属性</h2>
<p><img src="../../images/image-20221128132915669.png" alt="image-20221128132915669"></p>
<p><img src="../../images/image-20221128104234972.png" alt="image-20221128104234972"></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在添加 .usingJobData("name", "trigger3") 的时候，</span></span><br><span class="line"><span class="comment">     * key 和 这里定义的属性名一样的话，就会给这里的属性赋值，下面就可以直接用了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> {</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 会发现，不加注解的情况下（@DisallowConcurrentExecution）</span></span><br><span class="line">        <span class="comment">// 下面的输出都是不一样的，证明不是同一个 Job 实例</span></span><br><span class="line">        System.out.println( <span class="string">"jobDetail : "</span> + System.identityHashCode(context.getJobDetail()) );</span><br><span class="line">        System.out.println( <span class="string">"job : "</span> + System.identityHashCode(context.getJobInstance()) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不加上注解的话（@DisallowConcurrentExecution），</span></span><br><span class="line">        <span class="comment">// 我们想着是每隔次启动 job 实例之后等待sleep 3秒 之后再重复启动的</span></span><br><span class="line">        <span class="comment">// 但是实际发现，每隔一秒就又有启动了，证明不是同一个job实例，所以它们之间的启动不需要等待sleep的时间</span></span><br><span class="line">        System.out.println(<span class="string">"execute : "</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<p><img src="../../images/image-20221128110013728.png" alt="image-20221128110013728"></p>
<hr>
<p>测试count++</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyJop</span> <span class="keyword">implements</span> <span class="title class_">Job</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line"></span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">triggerMap</span> <span class="operator">=</span> context.getTrigger().getJobDataMap();</span><br><span class="line">        <span class="type">JobDataMap</span> <span class="variable">jobDetailMap</span> <span class="operator">=</span> context.getJobDetail().getJobDataMap();</span><br><span class="line">        triggerMap.put(<span class="string">"count"</span>, triggerMap.getInt(<span class="string">"count"</span>) + <span class="number">1</span>);</span><br><span class="line">        jobDetailMap.put(<span class="string">"count1"</span>, jobDetailMap.getInt(<span class="string">"count1"</span>) + <span class="number">1</span>);</span><br><span class="line">        System.out.println( <span class="string">"triggerMap count : "</span> + triggerMap.getInt(<span class="string">"count"</span>) );</span><br><span class="line">        System.out.println( <span class="string">"jobDetailMap count : "</span> + jobDetailMap.getInt(<span class="string">"count1"</span>) );</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestJob</span> {</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {</span><br><span class="line">        <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(MyJop.class)</span><br><span class="line">                <span class="comment">// name: 任务名称（在调度器里不能重复，唯一的） group : 组</span></span><br><span class="line">                .withIdentity(<span class="string">"jop1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"job"</span>, <span class="string">"jobDetail1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"jobDetail2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count1"</span>, <span class="number">0</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发器</span></span><br><span class="line">        <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(<span class="string">"trigger1"</span>, <span class="string">"trigger1"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"trigger"</span>, <span class="string">"trigger"</span>)</span><br><span class="line">                <span class="comment">// 会覆盖上面JobDetail中的name的值</span></span><br><span class="line">                .usingJobData(<span class="string">"name"</span>, <span class="string">"trigger2"</span>)</span><br><span class="line">                .usingJobData(<span class="string">"count"</span>, count)</span><br><span class="line">                .startNow()</span><br><span class="line">                <span class="comment">//                                                            时间间隔           永久重复执行</span></span><br><span class="line">                .withSchedule(SimpleScheduleBuilder.simpleSchedule().withIntervalInSeconds(<span class="number">2</span>).repeatForever())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调度器</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Scheduler</span> <span class="variable">scheduler</span> <span class="operator">=</span> StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">            scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">            <span class="comment">// 启动</span></span><br><span class="line">            scheduler.start();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果图：</p>
<p><img src="../../images/image-20221128132552340.png" alt="image-20221128132552340"></p>
<p>Springboot整合Quartz</p>
<p><img src="../../images/image-20221128143743504.png" alt="image-20221128143743504"></p>
<p>Springboot整合Quartz</p>
<p>使用Springboot里面的监听器，让项目在启动后也启动了调度器</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.quartz.QuartzJobBean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@DisallowConcurrentExecution</span> : 禁止并发地执行通过一个 job 定义（JobDetail定义的）的多个实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@DisallowConcurrentExecution</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 持久化 JobDetail 中的 JobDataMap (对 trigger 中的 datamap 无效)</span></span><br><span class="line"><span class="comment"> * 如果一个任务不是持久化的，则当没有触发器关联它的时候，Quartz会从scheduler中删除它</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PersistJobDataAfterExecution</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuartzJob</span> <span class="keyword">extends</span> <span class="title class_">QuartzJobBean</span> {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">executeInternal</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            System.out.println(context.getScheduler().getSchedulerInstanceId());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"taskname : "</span> + context.getJobDetail().getKey().getName() );</span><br><span class="line">            System.out.println(<span class="string">"执行时间 ："</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">        } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SchedulerConfig</span> {</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Scheduler <span class="title function_">scheduler</span><span class="params">()</span> {</span><br><span class="line">        <span class="type">Scheduler</span> <span class="variable">scheduler1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            scheduler1 = StdSchedulerFactory.getDefaultScheduler();</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> scheduler1;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> quartz.bootquartz.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ContextRefreshedEvent;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> quartz.bootquartz.QuartzJob;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> : 其然乐衣Letitbe</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> : 2022/11/28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StartApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; {</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入调度器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> {</span><br><span class="line">        <span class="type">TriggerKey</span> <span class="variable">triggerKey</span> <span class="operator">=</span> TriggerKey.triggerKey(<span class="string">"trigger1"</span>, <span class="string">"group1"</span>);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="type">Trigger</span> <span class="variable">trigger</span> <span class="operator">=</span> scheduler.getTrigger(triggerKey);</span><br><span class="line">            <span class="keyword">if</span> (trigger == <span class="literal">null</span>) {</span><br><span class="line">                trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                        .withIdentity(triggerKey)</span><br><span class="line">                        .withSchedule(CronScheduleBuilder.cronSchedule(<span class="string">"0/5 * * * * ?"</span>))</span><br><span class="line">                        .startNow()</span><br><span class="line">                        .build();</span><br><span class="line">                <span class="type">JobDetail</span> <span class="variable">jobDetail</span> <span class="operator">=</span> JobBuilder.newJob(QuartzJob.class)</span><br><span class="line">                        .withIdentity(<span class="string">"job1"</span>, <span class="string">"group1"</span>)</span><br><span class="line">                        .build();</span><br><span class="line"></span><br><span class="line">                scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line">                scheduler.start();</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (SchedulerException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>结果：</p>
<p><img src="../../images/image-20221128152834236.png" alt="image-20221128152834236"></p>
<p><img src="../../images/image-20221217151142631.png" alt="image-20221217151142631"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/27/Quartz/Quartz%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="clihkswdc000qpov68hph4n0u" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Quartz/" rel="tag">Quartz</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/" rel="tag">定时任务</a></li></ul>

    </footer>
  </div>
  
</article>




  
    <article id="post-JVM/JVM上篇：内存与垃圾回收篇/13. 垃圾回收器" class="wow slideInRight article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" class="article-date">
  <time class="post-time" datetime="2022-11-24T09:06:54.329Z" itemprop="datePublished">
    <span class="post-month">11月</span><br/>
    <span class="post-day">24</span>
  </time>
</a>
   
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/">13. 垃圾回收器</a>
    </h1>
  

        <div>
          
  <div class="article-category">
    <a class="article-category-link" href="/categories/JVM/">JVM</a>,<a class="article-category-link" href="/categories/JVM/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/">内存与垃圾回收篇</a>
  </div>

          
              

          
        </div>
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>[toc]</p>
<h1 id="13-垃圾回收器"><a class="markdownIt-Anchor" href="#13-垃圾回收器"></a> 13. 垃圾回收器</h1>
<h2 id="131-gc-分类与性能指标"><a class="markdownIt-Anchor" href="#131-gc-分类与性能指标"></a> 13.1. GC 分类与性能指标</h2>
<h3 id="1311-垃圾回收器概述"><a class="markdownIt-Anchor" href="#1311-垃圾回收器概述"></a> 13.1.1. 垃圾回收器概述</h3>
<p>垃圾收集器没有在规范中进行过多的规定，可以由不同的厂商、不同版本的 JVM 来实现。</p>
<p>由于 JDK 的版本处于高速迭代过程中，因此 Java 发展至今已经衍生了众多的 GC 版本。</p>
<p>从不同角度分析垃圾收集器，可以将 GC 分为不同的类型。</p>
<h3 id="1312-垃圾收集器分类"><a class="markdownIt-Anchor" href="#1312-垃圾收集器分类"></a> 13.1.2. 垃圾收集器分类</h3>
<p>按<mark>线程数</mark>分，可以分为<mark>串行垃圾回收器</mark>和<mark>并行垃圾回收器</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/ab10d1899d353ea14797f9ce1778503c.png" alt="image-20210512144253383"></p>
<p>串行回收指的是在同一时间段内只允许有一个 CPU 用于执行垃圾回收操作，此时工作线程被暂停，直至垃圾收集工作结束。</p>
<ul>
<li>在诸如单 CPU 处理器或者较小的应用内存等硬件平台不是特别优越的场合，串行回收器的性能表现可以超过并行回收器和并发回收器。所以，<mark>串行回收默认被应用在客户端的 Client 模式下的 JVM 中</mark></li>
<li>在并发能力比较强的 CPU 上，并行回收器产生的停顿时间要短于串行回收器。</li>
</ul>
<p>和串行回收相反，并行收集可以运用多个 CPU 同时执行垃圾回收，因此提升了应用的吞吐量，不过并行回收仍然与串行回收一样，采用独占式，使用了“Stop-the-World”机制。</p>
<p>按照<mark>工作模式</mark>分，可以分为<mark>并发式垃圾回收器</mark>和<mark>独占式垃圾回收器</mark>。</p>
<ul>
<li>并发式垃圾回收器与应用程序线程交替工作，以尽可能减少应用程序的停顿时间。</li>
<li>独占式垃圾回收器（Stop the world）一旦运行，就停止应用程序中的所有用户线程，直到垃圾回收过程完全结束。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/6e2c2869a4450dc405bda0ea8a8e7c31.png" alt="image-20200713083443486"></p>
<p>按<mark>碎片处理方式</mark>分，可分为<mark>压缩式垃圾回收器</mark>和<mark>非压缩式垃圾回收器</mark>。</p>
<ul>
<li>压缩式垃圾回收器会在回收完成后，对存活对象进行压缩整理，消除回收后的碎片。</li>
<li>非压缩式的垃圾回收器不进行这步操作。</li>
</ul>
<p>按<mark>工作的内存区间</mark>分，又可分为<mark>年轻代垃圾回收器</mark>和<mark>老年代垃圾回收器</mark>。</p>
<h3 id="1313-评估-gc-的性能指标"><a class="markdownIt-Anchor" href="#1313-评估-gc-的性能指标"></a> 13.1.3. 评估 GC 的性能指标</h3>
<p>（加粗的是比较重要的）</p>
<ul>
<li><strong><mark>吞吐量</mark>：运行用户代码的时间占总运行时间的比例（总运行时间 = 程序的运行时间 + 内存回收的时间）</strong></li>
<li><mark>垃圾收集开销</mark>：吞吐量的补数，垃圾收集所用时间与总运行时间的比例。</li>
<li><strong><mark>暂停时间</mark>：执行垃圾收集时，程序的工作线程被暂停的时间。</strong></li>
<li><mark>收集频率</mark>：相对于应用程序的执行，收集操作发生的频率。</li>
<li><strong><mark>内存占用</mark>：Java 堆区所占的内存大小。</strong></li>
<li><mark>快速</mark>：一个对象从诞生到被回收所经历的时间。</li>
</ul>
<p><strong>吞吐量、暂停时间、内存占用</strong> 这三者共同构成一个“<strong>不可能三角</strong>”。三者总体的表现会随着技术进步而越来越好。一款优秀的收集器通常最多同时满足其中的两项。</p>
<p>这三项里，暂停时间的重要性日益凸显。因为随着硬件发展，内存占用多些越来越能容忍，硬件性能的提升也有助于降低收集器运行时对应用程序的影响，即提高了吞吐量。而内存的扩大，对延迟反而带来负面效果。</p>
<p>简单来说，主要抓住两点：吞吐量、暂停时间</p>
<h4 id="吞吐量"><a class="markdownIt-Anchor" href="#吞吐量"></a> 吞吐量</h4>
<p>吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即吞吐量 = 运行用户代码时间 /（运行用户代码时间+垃圾收集时间）。比如：虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
<p>这种情况下，应用程序能容忍较高的暂停时间，因此，高吞吐量的应用程序有更长的时间基准，快速响应是不必考虑的</p>
<p>吞吐量优先，意味着在单位时间内，STW 的时间最短：0.2 + 0.2 = 0.4</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/a05d48c1926a03c3acdebf74d10bf522.png" alt="image-20200713084726176"></p>
<h4 id="暂停时间"><a class="markdownIt-Anchor" href="#暂停时间"></a> 暂停时间</h4>
<p>“暂停时间”是指一个时间段内应用程序线程暂停，让 GC 线程执行的状态。</p>
<p>例如，GC 期间 100 毫秒的暂停时间意味着在这 100 毫秒期间内没有应用程序线程是活动的。</p>
<p>暂停时间优先，意味着尽可能让单次 STW 的时间最短：0.1 + 0.1 + 0.1 + 0.1 + 0.1 = 0.5</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/de90092e21cbff31926f7cc7dceebf25.png" alt="image-20200713085306400"></p>
<h4 id="吞吐量-vs-暂停时间"><a class="markdownIt-Anchor" href="#吞吐量-vs-暂停时间"></a> 吞吐量 vs 暂停时间</h4>
<p>高吞吐量较好因为这会让应用程序的最终用户感觉只有应用程序线程在做“生产性”工作。直觉上，吞吐量越高程序运行越快。</p>
<p>低暂停时间（低延迟）较好因为从最终用户的角度来看不管是 GC 还是其他原因导致一个应用被挂起始终是不好的。这取决于应用程序的类型，<mark>有时候甚至短暂的 200 毫秒暂停都可能打断终端用户体验</mark>。因此，具有低的较大暂停时间是非常重要的，特别是对于一个<mark>交互式应用程序</mark>。</p>
<p>不幸的是”高吞吐量”和”低暂停时间”是一对相互竞争的目标（矛盾）。</p>
<ul>
<li>因为如果选择以吞吐量优先，那么<mark>必然需要降低内存回收的执行频率</mark>，但是这样会导致 GC 需要更长的暂停时间来执行内存回收。</li>
<li>相反的，如果选择以低延迟优先为原则，那么为了降低每次执行内存回收时的暂停时间，也<mark>只能频繁地执行内存回收</mark>，但这又引起了年轻代内存的缩减和导致程序吞吐量的下降。</li>
</ul>
<p>在设计（或使用）GC 算法时，我们必须确定我们的目标：一个 GC 算法只可能针对两个目标之一（即只专注于较大吞吐量或最小暂停时间），或尝试找到一个二者的折衷。</p>
<p><strong>现在标准：<mark>在最大吞吐量优先的情况下，降低停顿时间</mark></strong></p>
<h2 id="132-不同的垃圾回收器概述"><a class="markdownIt-Anchor" href="#132-不同的垃圾回收器概述"></a> 13.2. 不同的垃圾回收器概述</h2>
<p>垃圾收集机制是 Java 的招牌能力，极大地提高了开发效率。这当然也是面试的热点。</p>
<h3 id="1321-垃圾回收器发展史"><a class="markdownIt-Anchor" href="#1321-垃圾回收器发展史"></a> 13.2.1. 垃圾回收器发展史</h3>
<p>有了虚拟机，就一定需要收集垃圾的机制，这就是 Garbage Collection，对应的产品我们称为 Garbage Collector。</p>
<ul>
<li>1999 年随 JDK1.3.1 一起来的是串行方式的 serialGc，它是第一款 GC。ParNew 垃圾收集器是 Serial 收集器的多线程版本</li>
<li>2002 年 2 月 26 日，Parallel GC 和 Concurrent Mark Sweep GC 跟随 JDK1.4.2 一起发布·</li>
<li>Parallel GC 在 JDK6 之后成为 HotSpot 默认 GC。</li>
<li>2012 年，在 JDK1.7u4 版本中，G1 可用。</li>
<li>2017 年，JDK9 中 G1 变成默认的垃圾收集器，以替代 CMS。</li>
<li>2018 年 3 月，JDK10 中 G1 垃圾回收器的并行完整垃圾回收，实现并行性来改善最坏情况下的延迟。</li>
<li>2018 年 9 月，JDK11 发布。引入 Epsilon 垃圾回收器，又被称为 "No-Op(无操作)“ 回收器。同时，引入 ZGC：可伸缩的低延迟垃圾回收器（Experimental）</li>
<li>2019 年 3 月，JDK12 发布。增强 G1，自动返回未用堆内存给操作系统。同时，引入 Shenandoah GC：低停顿时间的 GC（Experimental）。·</li>
<li>2019 年 9 月，JDK13 发布。增强 ZGC，自动返回未用堆内存给操作系统。</li>
<li>2020 年 3 月，JDK14 发布。删除 CMS 垃圾回收器。扩展 ZGC 在 macos 和 Windows 上的应用</li>
</ul>
<h3 id="1322-7-种经典的垃圾收集器"><a class="markdownIt-Anchor" href="#1322-7-种经典的垃圾收集器"></a> 13.2.2. 7 种经典的垃圾收集器</h3>
<ul>
<li>串行回收器：Serial、Serial Old</li>
<li>并行回收器：ParNew、Parallel Scavenge、Parallel old</li>
<li>并发回收器：CMS、G1</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/90c3bcdc22cd0b49e10d702c608c4fc6.png" alt="image-20200713093551365"></p>
<p>官方手册：<a target="_blank" rel="noopener" href="https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf">https://www.oracle.com/technetwork/java/javase/tech/memorymanagement-whitepaper-1-150020.pdf</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c529d76b22212c44275b94675cc56760.png" alt="image-20210512145950897"></p>
<h3 id="1323-7-款经典收集器与垃圾分代之间的关系"><a class="markdownIt-Anchor" href="#1323-7-款经典收集器与垃圾分代之间的关系"></a> 13.2.3. 7 款经典收集器与垃圾分代之间的关系</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/fd16701d3e150d5e58d52b7306473a42.png" alt="image-20200713093757644"></p>
<ul>
<li>
<p>新生代收集器：Serial、ParNew、Parallel Scavenge；</p>
</li>
<li>
<p>老年代收集器：Serial Old、Parallel Old、CMS；</p>
</li>
<li>
<p>整堆收集器：G1；</p>
</li>
</ul>
<h3 id="1324-垃圾收集器的组合关系"><a class="markdownIt-Anchor" href="#1324-垃圾收集器的组合关系"></a> 13.2.4. 垃圾收集器的组合关系</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b92c2212bea2907cb75ff9ef26f346fe.png" alt="image-20200713094745366"></p>
<ol>
<li>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1；</li>
<li>其中 Serial Old 作为 CMS 出现"<code>Concurrent Mode Failure</code>"失败的后备预案。</li>
<li>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial+CMS、ParNew+Serial Old 这两个组合声明为废弃（JEP173），并在 JDK9 中完全取消了这些组合的支持（JEP214），即：移除。</li>
<li>（绿色虚线）JDK14 中：弃用 Parallel Scavenge 和 Serialold GC 组合（JEP366）</li>
<li>（绿色虚框）JDK14 中：删除 CMS 垃圾回收器（JEP363）</li>
</ol>
<h3 id="1325-不同的垃圾收集器概述"><a class="markdownIt-Anchor" href="#1325-不同的垃圾收集器概述"></a> 13.2.5. 不同的垃圾收集器概述</h3>
<p>为什么要有很多收集器，一个不够吗？因为 Java 的使用场景很多，移动端，服务器等。所以就需要针对不同的场景，提供不同的垃圾收集器，提高垃圾收集的性能。</p>
<p>虽然我们会对各个收集器进行比较，但并非为了挑选一个最好的收集器出来。没有一种放之四海皆准、任何场景下都适用的完美收集器存在，更加没有万能的收集器。所以<mark>我们选择的只是对具体应用最合适的收集器</mark>。</p>
<h3 id="1326-如何查看默认垃圾收集器"><a class="markdownIt-Anchor" href="#1326-如何查看默认垃圾收集器"></a> 13.2.6. 如何查看默认垃圾收集器</h3>
<p><code>-XX:+PrintCommandLineFlags</code>：查看命令行相关参数（包含使用的垃圾收集器）</p>
<p>使用命令行指令：<code>jinfo -flag 相关垃圾回收器参数 进程ID</code></p>
<h2 id="133-serial-回收器串行回收"><a class="markdownIt-Anchor" href="#133-serial-回收器串行回收"></a> 13.3. Serial 回收器：串行回收</h2>
<p>Serial 收集器是最基本、历史最悠久的垃圾收集器了。JDK1.3 之前回收新生代唯一的选择。</p>
<p>Serial 收集器作为 HotSpot 中 client 模式下的默认新生代垃圾收集器。</p>
<p><mark>Serial 收集器采用复制算法、串行回收和"stop-the-World"机制的方式执行内存回收。</mark></p>
<p>除了年轻代之外，Serial 收集器还提供用于执行老年代垃圾收集的 Serial Old 收集器。<mark>Serial Old 收集器同样也采用了串行回收和"Stop the World"机制，只不过内存回收算法使用的是标记-压缩算法。</mark></p>
<ul>
<li>Serial old 是运行在 Client 模式下默认的老年代的垃圾回收器</li>
<li>Serial 0ld 在 Server 模式下主要有两个用途：① 与新生代的 Parallel scavenge 配合使用 ② 作为老年代 CMS 收集器的后备垃圾收集方案</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/d66b612e68381df2101c3e829a18b4f0.png" alt="image-20200713100703799"></p>
<p>这个收集器是一个单线程的收集器，但它的“单线程”的意义并不仅仅说明它只会<mark>使用一个 CPU 或一条收集线程去完成垃圾收集工作</mark>，更重要的是在它进行垃圾收集时，<mark>必须暂停其他所有的工作线程</mark>，直到它收集结束（Stop The World）</p>
<p>优势：<mark>简单而高效</mark>（与其他收集器的单线程比），对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。运行在 Client 模式下的虚拟机是个不错的选择。</p>
<p>在用户的桌面应用场景中，可用内存一般不大（几十 MB 至一两百 MB），可以在较短时间内完成垃圾收集（几十 ms 至一百多 ms），只要不频繁发生，使用串行回收器是可以接受的。</p>
<p>在 HotSpot 虚拟机中，使用<code>-XX:+UseSerialGC</code>参数可以指定年轻代和老年代都使用串行收集器。等价于新生代用 Serial GC，且老年代用 Serial Old GC</p>
<p><strong>总结</strong></p>
<p>这种垃圾收集器大家了解，现在已经不用串行的了。而且在限定单核 cpu 才可以用。现在都不是单核的了。</p>
<p>对于交互较强的应用而言，这种垃圾收集器是不能接受的（因为它是串行的，导致用户完全停止了，容易影响用户交互）。一般在 Java web 应用程序中是不会采用串行垃圾收集器的。</p>
<h2 id="134-parnew-回收器并行回收"><a class="markdownIt-Anchor" href="#134-parnew-回收器并行回收"></a> 13.4. ParNew 回收器：并行回收</h2>
<p>如果说 Serial GC 是年轻代中的单线程垃圾收集器，那么 ParNew 收集器则是 Serial 收集器的多线程版本。Par 是 Parallel 的缩写，New：只能处理的是新生代</p>
<p>ParNew 收集器除了采用<mark>并行回收</mark>的方式执行内存回收外，两款垃圾收集器之间几乎没有任何区别。ParNew 收集器在年轻代中同样也是采用<mark>复制算法、"Stop-the-World"机制</mark>。</p>
<p>ParNew 是很多 JVM 运行在 Server 模式下新生代的默认垃圾收集器。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/187fdcd46a1cb35be6d88a01a433c0f3.png" alt="image-20200713102030127"></p>
<ul>
<li>对于新生代，回收次数频繁，使用并行方式高效。</li>
<li>对于老年代，回收次数少，使用串行方式节省资源。（CPU 并行需要切换线程，串行可以省去切换线程的资源）</li>
</ul>
<p>由于 ParNew 收集器是基于并行回收，那么是否可以断定 ParNew 收集器的回收效率在任何场景下都会比 serial 收集器更高效？</p>
<ul>
<li>ParNew 收集器运行在多 CPU 的环境下，由于可以充分利用多 CPU、多核心等物理硬件资源优势，可以更快速地完成垃圾收集，提升程序的吞吐量。</li>
<li>但是<mark>在单个 CPU 的环境下，ParNew 收集器不比 Serial 收集器更高效</mark>。虽然 Serial 收集器是基于串行回收，但是由于 CPU 不需要频繁地做任务切换，因此可以有效避免多线程交互过程中产生的一些额外开销。</li>
</ul>
<p>因为除 Serial 外，目前只有 ParNew GC 能与 CMS 收集器配合工作</p>
<p>在程序中，开发人员可以通过选项"<code>-XX:+UseParNewGC</code>"手动指定使用 ParNew 收集器执行内存回收任务。它表示年轻代使用并行收集器，不影响老年代。</p>
<p><code>-XX:ParallelGCThreads</code>限制线程数量，默认开启和 CPU 数据相同的线程数。</p>
<h2 id="135-parallel-回收器吞吐量优先"><a class="markdownIt-Anchor" href="#135-parallel-回收器吞吐量优先"></a> 13.5. Parallel 回收器：吞吐量优先</h2>
<p>HotSpot 的年轻代中除了拥有 ParNew 收集器是基于并行回收的以外，Parallel Scavenge 收集器同样也采用了<mark>复制算法、并行回收和"Stop the World"机制</mark>。</p>
<p>那么 Parallel 收集器的出现是否多此一举？</p>
<ul>
<li>和 ParNew 收集器不同，ParallelScavenge 收集器的目标则是达到一个<mark>可控制的吞吐量</mark>（Throughput），它也被称为吞吐量优先的垃圾收集器。</li>
<li>自适应调节策略也是 Parallel Scavenge 与 ParNew 一个重要区别。</li>
</ul>
<p>高吞吐量则可以高效率地利用 CPU 时间，尽快完成程序的运算任务，主要<mark>适合在后台运算而不需要太多交互的任务</mark>。因此，常见在服务器环境中使用。<mark>例如，那些执行批量处理、订单处理、工资支付、科学计算的应用程序</mark>。</p>
<p>Parallel 收集器在 JDK1.6 时提供了用于执行老年代垃圾收集的 Parallel Old 收集器，用来代替老年代的 Serial Old 收集器。</p>
<p>Parallel Old 收集器采用了<mark>标记-压缩算法</mark>，但同样也是基于<mark>并行回收和"Stop-the-World"机制</mark>。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8a4b655ee277aaf0f9a46754248ce05a.png" alt="image-20200713110359441"></p>
<p>在程序吞吐量优先的应用场景中，Parallel 收集器和 Parallel Old 收集器的组合，在 Server 模式下的内存回收性能很不错。在 Java8 中，默认是此垃圾收集器。</p>
<p><strong>参数配置</strong></p>
<ul>
<li>
<p><code>-XX:+UseParallelGC</code> 手动指定年轻代使用 Parallel 并行收集器执行内存回收任务。</p>
</li>
<li>
<p><code>-XX:+UseParallelOldGC</code> 手动指定老年代都是使用并行回收收集器。</p>
<ul>
<li>分别适用于新生代和老年代。默认 jdk8 是开启的。</li>
<li>上面两个参数，默认开启一个，另一个也会被开启。（互相激活）</li>
</ul>
</li>
<li>
<p><code>-XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般地，最好与 CPU 数量相等，以避免过多的线程数影响垃圾收集性能。</p>
<p class="katex-block katex-error" title="ParseError: KaTeX parse error: Undefined control sequence: \* at position 80: …= 8) \\ 3 + (5 \̲*̲ CPU＿Count / 8)…">ParallelGCThreads = \begin{cases} CPU_Count &amp; \text (CPU_Count &lt;= 8) \\ 3 + (5 \* CPU＿Count / 8) &amp; \text (CPU_Count &gt; 8) \end{cases} 
</p>
</li>
<li>
<p><code>-XX:MaxGCPauseMillis</code> 设置垃圾收集器最大停顿时间（即 STw 的时间）。单位是毫秒。</p>
<ul>
<li>为了尽可能地把停顿时间控制在 MaxGCPauseMills 以内，收集器在工作时会调整 Java 堆大小或者其他一些参数。</li>
<li>对于用户来讲，停顿时间越短体验越好。但是在服务器端，我们注重高并发，整体的吞吐量。所以服务器端适合 Parallel，进行控制。</li>
<li><mark>该参数使用需谨慎</mark>。</li>
</ul>
</li>
<li>
<p><code>-XX:GCTimeRatio</code> 垃圾收集时间占总时间的比例（=1/（N+1））。用于衡量吞吐量的大小。</p>
<ul>
<li>取值范围（0, 100）。默认值 99，也就是垃圾回收时间不超过 1%。</li>
<li>与前一个<code>-XX:MaxGCPauseMillis </code>参数有一定矛盾性。暂停时间越长，Radio 参数就容易超过设定的比例。</li>
</ul>
</li>
<li>
<p><code>-XX:+UseAdaptivesizePolicy</code> 设置 Parallel Scavenge 收集器具有<mark>自适应调节策略</mark></p>
<ul>
<li>在这种模式下，年轻代的大小、Eden 和 Survivor 的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点。</li>
<li>在手动调优比较困难的场合，可以直接使用这种自适应的方式，仅指定虚拟机的最大堆、目标的吞吐量（<code>GCTimeRatio</code>）和停顿时间（<code>MaxGCPauseMills</code>），让虚拟机自己完成调优工作。</li>
</ul>
</li>
</ul>
<h2 id="136-cms-回收器低延迟"><a class="markdownIt-Anchor" href="#136-cms-回收器低延迟"></a> 13.6. CMS 回收器：低延迟</h2>
<p>在 JDK1.5 时期，Hotspot 推出了一款在<mark>强交互应用</mark>中几乎可认为有划时代意义的垃圾收集器：CMS（Concurrent-Mark-Sweep）收集器，<mark>这款收集器是 HotSpot 虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作</mark>。</p>
<p>CMS 收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。停顿时间越短（低延迟）就越适合与用户交互的程序，良好的响应速度能提升用户体验。</p>
<ul>
<li><mark>目前很大一部分的 Java 应用集中在互联网站或者 B/S 系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短</mark>，以给用户带来较好的体验。CMS 收集器就非常符合这类应用的需求。</li>
</ul>
<p>CMS 的垃圾收集算法采用<mark>标记-清除算法</mark>，并且也会"Stop-the-World"</p>
<p>不幸的是，CMS 作为老年代的收集器，却无法与 JDK1.4.0 中已经存在的新生代收集器 Parallel Scavenge 配合工作，所以在 JDK1.5 中使用 CMS 来收集老年代的时候，新生代只能选择 ParNew 或者 Serial 收集器中的一个。</p>
<p>在 G1 出现之前，CMS 使用还是非常广泛的。一直到今天，仍然有很多系统使用 CMS GC。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f84a132db8c56a488e14f51e2c4d7fa7.png" alt="image-20200713205154007"></p>
<p>CMS 整个过程比之前的收集器要复杂，整个过程分为 4 个主要阶段，即初始标记阶段、并发标记阶段、重新标记阶段和并发清除阶段</p>
<ul>
<li><strong>初始标记</strong>（Initial-Mark）阶段：在这个阶段中，程序中所有的工作线程都将会因为“Stop-the-World”机制而出现短暂的暂停，这个阶段的主要任务<mark>仅仅只是标记出 GCRoots 能直接关联到的对象</mark>。一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的<mark>速度非常快</mark>。</li>
<li><strong>并发标记</strong>（Concurrent-Mark）阶段：从 GC Roots 的<mark>直接关联对象开始遍历整个对象图的过程</mark>，这个过程耗时较长但是<mark>不需要停顿用户线程</mark>，可以与垃圾收集线程一起并发运行。</li>
<li><strong>重新标记</strong>（Remark）阶段：由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了<mark>修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录</mark>，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短。</li>
<li><strong>并发清除</strong>（Concurrent-Sweep）阶段：此阶段<mark>清理删除掉标记阶段判断的已经死亡的对象，释放内存空间</mark>。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</li>
</ul>
<p>尽管 CMS 收集器采用的是并发回收（非独占式），但是<mark>在其初始化标记和再次标记这两个阶段中仍然需要执行“Stop-the-World”机制</mark>暂停程序中的工作线程，不过暂停时间并不会太长，因此可以说明目前所有的垃圾收集器都做不到完全不需要“stop-the-World”，只是尽可能地缩短暂停时间。</p>
<p><mark>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</mark></p>
<p>另外，由于在垃圾收集阶段用户线程没有中断，<mark>所以在 CMS 回收过程中，还应该确保应用程序用户线程有足够的内存可用</mark>。因此，CMS 收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，而是<mark>当堆内存使用率达到某一阈值时，便开始进行回收</mark>，以确保应用程序在 CMS 工作过程中依然有足够的空间支持应用程序运行。要是 CMS 运行期间预留的内存无法满足程序需要，就会出现一次“<code>Concurrent Mode Failure</code>” 失败，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</p>
<p>CMS 收集器的垃圾收集算法采用的是标记清除算法，这意味着每次执行完内存回收后，由于被执行内存回收的无用对象所占用的内存空间极有可能是不连续的一些内存块，不可避免地将会<mark>产生一些内存碎片</mark>。那么 CMS 在为新对象分配内存空间时，将无法使用指针碰撞（Bump the Pointer）技术，而只能够选择空闲列表（Free List）执行内存分配。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/052d6ef7655e46e040729082ac36da30.png" alt="image-20200713212230352"></p>
<p><strong>有人会觉得既然 Mark Sweep 会造成内存碎片，那么为什么不把算法换成 Mark Compact？</strong></p>
<p>答案其实很简单，因为当并发清除的时候，用 Compact 整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact 更适合“Stop the World” 这种场景下使用</p>
<h3 id="1361-cms-的优点"><a class="markdownIt-Anchor" href="#1361-cms-的优点"></a> 13.6.1. CMS 的优点</h3>
<ul>
<li>并发收集</li>
<li>低延迟</li>
</ul>
<h3 id="1362-cms-的弊端"><a class="markdownIt-Anchor" href="#1362-cms-的弊端"></a> 13.6.2. CMS 的弊端</h3>
<ul>
<li><mark>会产生内存碎片</mark>，导致并发清除后，用户线程可用的空间不足。在无法分配大对象的情况下，不得不提前触发 FullGC（如果来一次业务高峰，导致提前触发Full GC，这时虚拟机将启动后备预案：临时启用 Serial Old 收集器来重新进行老年代的垃圾收集，而单线程的垃圾回收器Serial OId，是性能最差的一个，停顿可能是几秒钟甚至十几秒钟，业务高峰时，停顿时间就很长了，给用户的体验就是很卡）。</li>
<li><mark>CMS 收集器对 CPU 资源非常敏感</mark>。在并发阶段，它虽然不会导致用户停顿，但是会因为占用了一部分线程而导致应用程序变慢，总吞吐量会降低。</li>
<li><mark>CMS 收集器无法处理浮动垃圾</mark>。可能出现“<code>Concurrent Mode Failure</code>"失败而导致另一次 Full GC 的产生。在并发标记阶段由于程序的工作线程和垃圾收集线程是同时运行或者交叉运行的，那么<mark>在并发标记阶段如果产生新的垃圾对象，CMS 将无法对这些垃圾对象进行标记，最终会导致这些新产生的垃圾对象没有被及时回收</mark>，从而只能在下一次执行 GC 时释放这些之前未被回收的内存空间。</li>
</ul>
<h3 id="1363-设置的参数"><a class="markdownIt-Anchor" href="#1363-设置的参数"></a> 13.6.3. 设置的参数</h3>
<ul>
<li>
<p><code>-XX:+UseConcMarkSweepGC </code>手动指定使用 CMS 收集器执行内存回收任务。</p>
<p>开启该参数后会自动将<code>-xx:+UseParNewGC</code>打开。即：ParNew（Young 区用）+CMS（Old 区用）+ Serial Old 的组合。</p>
</li>
<li>
<p><code>-XX:CMSInitiatingOccupanyFraction</code> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。</p>
<ul>
<li>JDK5 及以前版本的默认值为 68，即当老年代的空间使用率达到 68%时，会执行一次 CMS 回收。<mark>JDK6 及以上版本默认值为 92%</mark></li>
<li>如果内存增长缓慢，则可以设置一个稍大的值，大的阀值可以有效降低 CMS 的触发频率，减少老年代回收的次数可以较为明显地改善应用程序性能。反之，如果应用程序内存使用率增长很快，则应该降低这个阈值，以避免频繁触发老年代串行收集器。因此通过该选项便可以有效降低 Ful1Gc 的执行次数。</li>
</ul>
</li>
<li>
<p><code>-XX:+UseCMSCompactAtFullCollection</code> 用于指定在执行完 Full GC 后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。</p>
</li>
<li>
<p><code>-XX:CMSFullGCsBeforeCompaction</code> 设置在执行多少次 Full GC 后对内存空间进行压缩整理。</p>
</li>
<li>
<p><code>-XX:ParallelcMSThreads</code> 设置 CMS 的线程数量。</p>
<ul>
<li>CMS 默认启动的线程数是（ParallelGCThreads+3）/4，ParallelGCThreads 是年轻代并行收集器的线程数。当 CPU 资源比较紧张时，受到 CMS 收集器线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</li>
</ul>
</li>
</ul>
<h3 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h3>
<p>HotSpot 有这么多的垃圾回收器，那么如果有人问，Serial GC、Parallel GC、Concurrent Mark Sweep GC 这三个 Gc 有什么不同呢？</p>
<p>请记住以下口令：</p>
<ul>
<li>如果你想要最小化地 使用内存和并行开销，请选 Serial GC；</li>
<li>如果你想要最大化应用程序的吞吐量，请选 Parallel GC；</li>
<li>如果你想要最小化 GC 的中断或停顿时间，请选 CMS GC。</li>
</ul>
<h3 id="1364-jdk-后续版本中-cms-的变化"><a class="markdownIt-Anchor" href="#1364-jdk-后续版本中-cms-的变化"></a> 13.6.4. JDK 后续版本中 CMS 的变化</h3>
<p>JDK9 新特性：CMS 被标记为 Deprecate 了（JEP291）</p>
<ul>
<li>如果对 JDK9 及以上版本的 HotSpot 虚拟机使用参数<code>-XX: +UseConcMarkSweepGC</code>来开启 CMS 收集器的话，用户会收到一个警告信息，提示 CMS 未来将会被废弃。</li>
</ul>
<p>JDK14 新特性：删除 CMS 垃圾回收器（JEP363）</p>
<ul>
<li>移除了 CMS 垃圾收集器，如果在 JDK14 中使用 <code>-XX:+UseConcMarkSweepGC</code>的话，JVM 不会报错，只是给出一个 warning 信息，但是不会 exit。JVM 会自动回退以默认 GC 方式启动 JVM</li>
</ul>
<h2 id="137-g1-回收器区域化分代式"><a class="markdownIt-Anchor" href="#137-g1-回收器区域化分代式"></a> 13.7. G1 回收器：区域化分代式</h2>
<p><strong>既然我们已经有了前面几个强大的 GC，为什么还要发布 Garbage First（G1）？</strong></p>
<p>原因就在于应用程序所应对的<mark>业务越来越庞大、复杂，用户越来越多</mark>，没有 GC 就不能保证应用程序正常进行，而<strong>经常造成 STW 的 GC 又跟不上实际的需求</strong>，所以才会<strong>不断地尝试对 GC 进行优化</strong>。G1（Garbage-First）垃圾回收器是在 Java7 update4 之后引入的一个新的垃圾回收器，是当今收集器技术发展的最前沿成果之一。</p>
<p>与此同时，为了适应现在<mark>不断扩大的内存和不断增加的处理器数量</mark>，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量。</p>
<p><mark>官方给 G1 设定的目标是在延迟可控的情况下获得尽可能高的吞吐量，所以才担当起“全功能收集器”的重任与期望。</mark></p>
<p><strong>为什么名字叫 Garbage First(G1)呢？</strong></p>
<p>因为 G1 是一个并行回收器，它把堆内存分割为很多不相关的区域（Region）（物理上不连续的）。使用不同的 Region 来表示 Eden、幸存者 0 区，幸存者 1 区，老年代等。</p>
<p>G1 GC 有计划地避免在整个 Java 堆中进行全区域的垃圾收集。G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。</p>
<p>由于这种方式的侧重点在于回收垃圾最大量的区间（Region），所以我们给 G1 一个名字：垃圾优先（Garbage First）。</p>
<p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<mark>主要针对配备多核 CPU 及大容量内存的机器</mark>，以极高概率满足 GC 停顿时间的同时，还兼具高吞吐量的性能特征。</p>
<p>在 JDK1.7 版本正式启用，移除了 Experimental 的标识，是<mark>JDK9 以后的默认垃圾回收器</mark>，取代了 CMS 回收器以及 Parallel+Parallel Old 组合。被 Oracle 官方称为“<mark>全功能的垃圾收集器</mark>”。</p>
<p>与此同时，CMS 已经在 JDK9 中被标记为废弃（deprecated）。在 jdk8 中还不是默认的垃圾回收器，需要使用<code>-XX:+UseG1GC</code>来启用。</p>
<h3 id="1371-g1-回收器的特点优势"><a class="markdownIt-Anchor" href="#1371-g1-回收器的特点优势"></a> 13.7.1. G1 回收器的特点（优势）</h3>
<p>与其他 GC 收集器相比，G1 使用了全新的<strong>分区算法</strong>，其特点如下所示：</p>
<h4 id="并行与并发"><a class="markdownIt-Anchor" href="#并行与并发"></a> 并行与并发</h4>
<ul>
<li>并行性：G1 在回收期间，可以有多个 GC 线程同时工作，有效利用多核计算能力。此时用户线程 STW</li>
<li>并发性：G1 拥有与应用程序<strong>交替执行</strong>的能力（就不用考虑STW了），部分工作可以和应用程序同时执行，因此，一般来说，不会在整个回收阶段发生完全阻塞应用程序的情况</li>
</ul>
<h4 id="分代收集"><a class="markdownIt-Anchor" href="#分代收集"></a> 分代收集</h4>
<ul>
<li>从分代上看，<mark>G1 依然属于分代型垃圾回收器</mark>，它会区分年轻代和老年代，年轻代依然有 Eden 区和 Survivor 区。但从堆的结构上看，它不要求整个 Eden 区、年轻代或者老年代都是连续的，也不再坚持固定大小和固定数量。</li>
<li>将<mark>堆空间分为若干个区域（Region），这些区域中包含了逻辑上的年轻代和老年代</mark>。</li>
<li>和之前的各类回收器不同，它同时<mark>兼顾年轻代和老年代</mark>。对比其他回收器，或者工作在年轻代，或者工作在老年代；</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9a71df3a4013da274aa3b28cd95e7d37.png" alt="image-20200713215105293"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8bcd36541731eb308043eba968b7a828.png" alt="image-20200713215133839"></p>
<h4 id="空间整合"><a class="markdownIt-Anchor" href="#空间整合"></a> 空间整合</h4>
<ul>
<li>CMS：“标记-清除”算法、内存碎片、若干次 Gc 后进行一次碎片整理</li>
<li>G1 将内存划分为一个个的 region。内存的回收是以 region 作为基本单位的。<mark>Region 之间是复制算法</mark>，但整体上实际可看作是<mark>标记-压缩（Mark-Compact）算法</mark>，两种算法都可以避免内存碎片。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次 GC。尤其是当 Java 堆非常大的时候，G1 的优势更加明显。</li>
</ul>
<h4 id="可预测的停顿时间模型即软实时-soft-real-time"><a class="markdownIt-Anchor" href="#可预测的停顿时间模型即软实时-soft-real-time"></a> 可预测的停顿时间模型（即：软实时 soft real-time）</h4>
<p>这是 G1 相对于 CMS 的另一大优势，G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在垃圾收集上的时间不得超过 N 毫秒。</p>
<ul>
<li>由于分区的原因，G1 可以只选取部分区域进行内存回收，这样缩小了回收的范围，因此对于全局停顿情况的发生也能得到较好的控制。</li>
<li>G1 跟踪各个 Region 里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，<mark>每次根据允许的收集时间，优先回收价值最大的 Region</mark>。保证了 G1 收集器在有限的时间内可以获取尽可能高的收集效率。</li>
<li>相比于 CMSGC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</li>
</ul>
<h3 id="1372-g1-垃圾收集器的缺点"><a class="markdownIt-Anchor" href="#1372-g1-垃圾收集器的缺点"></a> 13.7.2. G1 垃圾收集器的缺点</h3>
<p>相较于 CMS，G1 还不具备全方位、压倒性优势。比如在用户程序运行过程中，G1 无论是为了垃圾收集产生的内存占用（Footprint）还是程序运行时的额外执行负载（Overload）都要比 CMS 要高。</p>
<p>从经验上来说，在小内存应用上 CMS 的表现大概率会优于 G1，而 G1 在大内存应用上则发挥其优势。平衡点在 6-8GB 之间。</p>
<h3 id="1373-g1-回收器的参数设置"><a class="markdownIt-Anchor" href="#1373-g1-回收器的参数设置"></a> 13.7.3. G1 回收器的参数设置</h3>
<ul>
<li><code>-XX:+UseG1GC</code>：手动指定使用 G1 垃圾收集器执行内存回收任务</li>
<li><code>-XX:G1HeapRegionSize</code> 设置每个 Region 的大小。值是 2 的幂，范围是 1MB 到 32MB 之间，目标是根据最小的 Java 堆大小划分出约 2048 个区域。默认是堆内存的 1/2000。</li>
<li><code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了）</li>
<li><code>-XX:+ParallelGCThread</code> 设置 STW 工作线程数的值。最多设置为 8（上面说过 Parallel 回收器的线程计算公式，当 CPU_Count &gt; 8 时，ParallelGCThreads 也会大于 8）</li>
<li><code>-XX:ConcGCThreads</code> 设置并发标记的线程数。将 n 设置为并行垃圾回收线程数（ParallelGCThreads）的 1/4 左右。</li>
<li><code>-XX:InitiatingHeapOccupancyPercent</code> 设置触发并发 GC 周期的 Java 堆占用率阈值。超过此值，就触发 GC。默认值是 45。</li>
</ul>
<h3 id="1374-g1-收集器的常见操作步骤"><a class="markdownIt-Anchor" href="#1374-g1-收集器的常见操作步骤"></a> 13.7.4. G1 收集器的常见操作步骤</h3>
<p>G1 的设计原则就是简化 JVM 性能调优，开发人员只需要简单的三步即可完成调优：</p>
<ul>
<li>第一步：开启 G1 垃圾收集器</li>
<li>第二步：设置堆的最大内存</li>
<li>第三步：设置最大的停顿时间</li>
</ul>
<p>G1 中提供了三种垃圾回收模式：Young GC、Mixed GC 和 Full GC，在不同的条件下被触发。</p>
<h3 id="1375-g1-收集器的适用场景"><a class="markdownIt-Anchor" href="#1375-g1-收集器的适用场景"></a> 13.7.5. G1 收集器的适用场景</h3>
<p>面向服务端应用，针对具有大内存、多处理器的机器。（在普通大小的堆里表现并不惊喜）</p>
<p>最主要的应用是需要低 GC 延迟，并具有大堆的应用程序提供解决方案；如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒；（G1 通过每次只清理一部分而不是全部的 Region 的增量式清理来保证每次 GC 停顿时间不会过长）。</p>
<p>用来替换掉 JDK1.5 中的 CMS 收集器；在下面的情况时，使用 G1 可能比 CMS 好：</p>
<ul>
<li>超过 50%的 Java 堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）</li>
</ul>
<p>HotSpot 垃圾收集器里，除了 G1 以外，其他的垃圾收集器使用内置的 JVM 线程执行 GC 的多线程操作，而 G1 GC 可以采用应用线程承担后台运行的 GC 工作，即当 JVM 的 GC 线程处理速度慢时，系统会调用应用程序线程帮助加速垃圾回收过程。</p>
<h3 id="1376-分区-region化整为零"><a class="markdownIt-Anchor" href="#1376-分区-region化整为零"></a> 13.7.6. 分区 Region：化整为零</h3>
<p>使用 G1 收集器时，它将整个 Java 堆划分成约 2048 个大小相同的独立 Region 块，每个 Region 块大小根据堆空间的实际大小而定，整体被控制在 1MB 到 32MB 之间，且为 2 的 N 次幂，即 1MB，2MB，4MB，8MB，16MB，32MB。可以通过<code>-XX:G1HeapRegionSize</code>设定。<mark><strong>所有的 Region 大小相同</strong>，且在 JVM 生命周期内不会被改变。</mark></p>
<p>（之所以要分代，就是要对堆内存进行局部清理，缩短停留提升回收效率。尽管分了代，对于新生代和老年代而言内存空间占用还是比较大，所以G1就使用了分区，通过更细的粒度来回收内存，以控制回收停留时间）</p>
<p>虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分 Region（不需要连续）的集合。通过 Region 的动态分配方式实现逻辑上的连续。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/74c611464ae6cdae3cbfffaef213cfd5.png" alt="image-20200713223244886"></p>
<p>一个 region 有可能属于 Eden，Survivor 或者 Old/Tenured 内存区域。但是一个 region 只可能属于一个角色。图中的 E 表示该 region 属于 Eden 内存区域，S 表示属于 survivor 内存区域，O 表示属于 Old 内存区域。图中空白的表示未使用的内存空间。</p>
<p>（region在整个jvm生命周期里的角色是可以转变的，比如说，当Eden区满的时候，触发YGC，YGC评判它价值比较高，就优先回收它了，回收完后，就一整个空白了，因为数据就会被提升复制到S幸存区了，就把Eden这区清空，那么这块空白的region就会被放到一个空闲列表中（专门用来记录这些空闲的region的），空闲之后，那么下一刻可能就会从这个空闲列表中将它选出来充当Old区了）</p>
<p>G1 垃圾收集器还增加了一种新的内存区域，叫做 Humongous 内存区域，如图中的 H 块。主要用于存储大对象，如果超过 1.5 个 region，就放到 H。</p>
<p>设置 H 的原因：对于堆中的对象，默认直接会被分配到老年代，但是如果它是一个短期存在的大对象就会对垃圾收集器造成负面影响。为了解决这个问题，G1 划分了一个 Humongous 区，它用来专门存放大对象。<mark>如果一个 H 区装不下一个大对象，那么 G1 会寻找连续的 H 区来存储。</mark>为了能找到连续的 H 区，有时候不得不启动 Full GC。G1 的大多数行为都把 H 区作为老年代的一部分来看待。</p>
<p>每个 Region 都是通过指针碰撞来分配空间</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/049520c5a004b63f750e04d5362a2992.png" alt="image-20200713223509993"></p>
<h3 id="1377-g1-垃圾回收器的回收过程"><a class="markdownIt-Anchor" href="#1377-g1-垃圾回收器的回收过程"></a> 13.7.7. G1 垃圾回收器的回收过程</h3>
<p>G1GC 的垃圾回收过程主要包括如下三个环节：</p>
<ul>
<li>
<p>年轻代 GC（Young GC）</p>
</li>
<li>
<p>老年代并发标记过程（Concurrent Marking）</p>
</li>
<li>
<p>混合回收（Mixed GC）（涉及到新生代和老年代混合回收）</p>
<p>可能第四种情况：（如果需要，单线程、独占式、高强度的 Full GC 还是继续存在的。它针对 GC 的评估失败提供了一种失败保护机制，即强力回收。情况如：（  <code>-XX:MaxGCPauseMillis</code> 设置期望达到的最大 GC 停顿时间指标（JVM 会尽力实现，但不保证达到）。默认值是 200ms（人的平均反应速度）。（不要一味地设置得太小，太小的话，每次能清理的region个数就非常少，如果分配的用户进程占用的region数据进程比较快，最终的结果导致内存使用率越来越高，栈满时就会Full GC，出先Full GC的话，那就效率很低的了））</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/e8f79c3cdeb0969981703f7a026cf581.png" alt="image-20200713224113996"></p>
<p>顺时针，Young gc -&gt; Young gc + Concurrent mark-&gt;Mixed GC 顺序，进行垃圾回收。</p>
<p>应用程序分配内存，<mark>当年轻代的 Eden 区用尽时开始年轻代回收过程</mark>；G1 的年轻代收集阶段是一个<mark>并行的独占式</mark>收集器。在年轻代回收期，G1GC 暂停所有应用程序线程，启动多线程执行年轻代回收。然后<mark>从年轻代区间移动存活对象到 Survivor 区间或者老年区间，也有可能是两个区间都会涉及</mark>。</p>
<p>当堆内存使用达到一定值（默认 45%）时，开始老年代并发标记过程。</p>
<p>标记完成马上开始混合回收过程。对于一个混合回收期，G1 GC 从老年区间移动存活对象到空闲区间，这些空闲区间也就成为了老年代的一部分。和年轻代不同，老年代的 G1 回收器和其他 GC 不同，<mark>G1 的老年代回收器不需要整个老年代被回收，一次只需要扫描/回收一小部分老年代的 Region 就可以了</mark>。同时，这个老年代 Region 是和年轻代一起被回收的。</p>
<p>举个例子：一个 Web 服务器，Java 进程最大堆内存为 4G，每分钟响应 1500 个请求，每 45 秒钟会新分配大约 2G 的内存。G1 会每 45 秒钟进行一次年轻代回收，每 31 个小时整个堆的使用率会达到 45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收。</p>
<h3 id="1378-remembered-set"><a class="markdownIt-Anchor" href="#1378-remembered-set"></a> 13.7.8. Remembered Set</h3>
<ul>
<li>
<p>一个对象被不同区域引用的问题</p>
</li>
<li>
<p>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其他任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？</p>
</li>
<li>
<p>在其他的分代收集器，也存在这样的问题（而 G1 更突出）回收新生代也不得不同时扫描老年代？</p>
</li>
<li>
<p>这样的话会降低 MinorGC 的效率；</p>
</li>
</ul>
<p><strong>解决方法：</strong></p>
<ul>
<li>
<p>无论 G1 还是其他分代收集器，<strong>JVM 都是使用 Remembered Set 来避免全局扫描：</strong></p>
</li>
<li>
<p><mark>每个 Region 都有一个对应的 Remembered Set；</mark></p>
</li>
<li>
<p>每次 Reference 类型数据写操作时，都会产生一个 Write Barrier （写屏障）暂时中断操作；</p>
</li>
<li>
<p>然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其他收集器：检查老年代对象是否引用了新生代对象）；</p>
</li>
<li>
<p>如果不同，通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；</p>
</li>
<li>
<p>当进行垃圾收集时，在 GC 根节点的枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c97de4bdada1da5a9fdd344692ed0957.png" alt="image-20200713224716715"></p>
<h3 id="1379-g1-回收过程一年轻代-gc"><a class="markdownIt-Anchor" href="#1379-g1-回收过程一年轻代-gc"></a> 13.7.9. G1 回收过程一：年轻代 GC</h3>
<p>JVM 启动时，G1 先准备好 Eden 区，程序在运行过程中不断创建对象到 Eden 区，当 Eden 空间耗尽时，G1 会启动一次年轻代垃圾回收过程。</p>
<p>年轻代垃圾回收只会回收 Eden 区和 Survivor 区。</p>
<p>首先 G1 停止应用程序的执行（Stop-The-World），G1 创建回收集（Collection Set），回收集是指需要被回收的内存分段的集合，年轻代回收过程的回收集包含年轻代 Eden 区和 Survivor 区所有的内存分段。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f29fa4dfe3abf4a77be06fdf3378aecf.png" alt="image-20200713225100632"></p>
<p>然后开始如下回收过程：</p>
<ol>
<li><mark>第一阶段，扫描根</mark>。根是指 static 变量指向的对象，正在执行的方法调用链条上的局部变量等。根引用连同 RSet 记录的外部引用作为扫描存活对象的入口。</li>
<li><mark>第二阶段，更新 RSet</mark>。处理 dirty card queue（见备注）中的 card，更新 RSet。此阶段完成后，<mark>RSet 可以准确的反映老年代对所在的内存分段中对象的引用</mark>。</li>
<li><mark>第三阶段，处理 RSet</mark>。识别被老年代对象指向的 Eden 中的对象，这些被指向的 Eden 中的对象被认为是存活的对象。</li>
<li><mark>第四阶段，复制对象</mark>。此阶段，对象树被遍历，Eden 区内存段中存活的对象会被复制到 Survivor 区中空的内存分段，Survivor 区内存段中存活的对象如果年龄未达阈值，年龄会加 1，达到阀值会被会被复制到 Old 区中空的内存分段。如果 Survivor 空间不够，Eden 空间的部分数据会直接晋升到老年代空间。</li>
<li><mark>第五阶段，处理引用</mark>。处理 Soft，Weak，Phantom，Final，JNI Weak 等引用。最终 Eden 空间的数据为空，GC 停止工作，而目标内存中的对象都是连续存储的，没有碎片，所以复制过程可以达到内存整理的效果，减少碎片。</li>
</ol>
<h3 id="13710-g1-回收过程二并发标记过程"><a class="markdownIt-Anchor" href="#13710-g1-回收过程二并发标记过程"></a> 13.7.10. G1 回收过程二：并发标记过程</h3>
<ol>
<li><mark>初始标记阶段</mark>：标记从根节点直接可达的对象。这个阶段是 STW 的，并且会触发一次年轻代 GC。</li>
<li><mark>根区域扫描（Root Region Scanning）</mark>：G1 GC 扫描 Survivor 区直接可达的老年代区域对象，并标记被引用的对象。这一过程必须在 Young GC 之前完成 。</li>
<li><mark>并发标记（Concurrent Marking）</mark>：在整个堆中进行并发标记（和应用程序并发执行），此过程可能被 YoungGC 中断。在并发标记阶段，<mark>若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收</mark>。同时，并发标记过程中，会计算每个区域的对象活性（区域中存活对象的比例）。</li>
<li><mark>再次标记（Remark）</mark>：由于应用程序持续进行，需要修正上一次的标记结果。是 STW 的。G1 中采用了比 CMS 更快的初始快照算法：snapshot-at-the-beginning（SATB）。</li>
<li><mark>独占清理（cleanup，STW）</mark>：计算各个区域的存活对象和 GC 回收比例，并进行排序，识别可以混合回收的区域。为下阶段做铺垫。是 STW 的。这个阶段并不会实际上去做垃圾的收集</li>
<li><mark>并发清理阶段</mark>：识别并清理完全空闲的区域。</li>
</ol>
<h3 id="13711-g1-回收过程三混合回收"><a class="markdownIt-Anchor" href="#13711-g1-回收过程三混合回收"></a> 13.7.11. G1 回收过程三：混合回收</h3>
<p>当越来越多的对象晋升到老年代 old region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即 Mixed GC，该算法并不是一个 Old GC，除了回收整个 Young Region，还会回收一部分的 Old Region。这里需要注意：<mark>是一部分老年代，而不是全部老年代</mark>。可以选择哪些 Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。也要注意的是 Mixed GC 并不是 Full GC。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/766b882cba7e709202005a3baeb596d0.png" alt="image-20200713225810871"></p>
<p>并发标记结束以后，老年代中百分百为垃圾的内存分段被回收了，部分为垃圾的内存分段被计算了出来。默认情况下，这些老年代的内存分段会分 8 次（可以通过<code>-XX:G1MixedGCCountTarget</code>设置）被回收</p>
<p>混合回收的回收集（Collection Set）包括八分之一的老年代内存分段，Eden 区内存分段，Survivor 区内存分段。混合回收的算法和年轻代回收的算法完全一样，只是回收集多了老年代的内存分段。具体过程请参考上面的年轻代回收过程。</p>
<p>由于老年代中的内存分段默认分 8 次回收，G1 会优先回收垃圾多的内存分段。<font color="blue">垃圾占内存分段比例越高的，越会被先回收</font>。并且有一个阈值会决定内存分段是否被回收，<code>-XX:G1MixedGCLiveThresholdPercent</code>，默认为 65%，意思是垃圾占内存分段比例要达到 65%才会被回收。如果垃圾占比太低，意味着存活的对象占比高，在复制的时候会花费更多的时间。</p>
<p>混合回收并不一定要进行 8 次。有一个阈值<code>-XX:G1HeapWastePercent</code>，默认值为 10%，意思是允许整个堆内存中有 10%的空间被浪费，意味着如果发现可以回收的垃圾占堆内存的比例低于 10%，则不再进行混合回收。因为 GC 会花费很多的时间但是回收到的内存却很少。</p>
<h3 id="13712-g1-回收可选的过程四full-gc"><a class="markdownIt-Anchor" href="#13712-g1-回收可选的过程四full-gc"></a> 13.7.12. G1 回收可选的过程四：Full GC</h3>
<p>G1 的初衷就是要避免 Full GC 的出现。但是如果上述方式不能正常工作，G1 会停止应用程序的执行（Stop-The-World），使用单线程的内存回收算法进行垃圾回收，性能会非常差，应用程序停顿时间会很长。</p>
<p>要避免 Full GC 的发生，一旦发生需要进行调整。什么时候会发生 Full GC 呢？比如<mark>堆内存太小</mark>，当 G1 在复制存活对象的时候没有空的内存分段可用，则会回退到 Full GC，这种情况可以通过增大内存解决。</p>
<p>导致 G1 Full GC 的原因可能有两个：</p>
<ul>
<li>Evacuation 的时候没有足够的 to-space 来存放晋升的对象；</li>
<li>并发处理过程完成之前空间耗尽。</li>
</ul>
<h3 id="13713-补充"><a class="markdownIt-Anchor" href="#13713-补充"></a> 13.7.13. 补充</h3>
<p>从 Oracle 官方透露出来的信息可获知，回收阶段（Evacuation）其实本也有想过设计成与用户程序一起并发执行，但这件事情做起来比较复杂，考虑到 G1 只是回一部分 Region，停顿时间是用户可控制的，所以并不迫切去实现，而<mark>选择把这个特性放到了 G1 之后出现的低延迟垃圾收集器（即 ZGC）中</mark>。另外，还考虑到 G1 不是仅仅面向低延迟，停顿用户线程能够最大幅度提高垃圾收集效率，为了保证吞吐量所以才选择了完全暂停用户线程的实现方案。</p>
<h3 id="13714-g1-回收器优化建议"><a class="markdownIt-Anchor" href="#13714-g1-回收器优化建议"></a> 13.7.14. G1 回收器优化建议</h3>
<p>年轻代大小</p>
<ul>
<li>避免使用<code>-Xmn</code>或<code>-XX:NewRatio</code>等相关选项显式设置年轻代大小</li>
<li>固定年轻代的大小会覆盖暂停时间目标</li>
</ul>
<p>暂停时间目标不要太过严苛</p>
<ul>
<li>G1 GC 的吞吐量目标是 90%的应用程序时间和 10%的垃圾回收时间</li>
<li>评估 G1 GC 的吞吐量时，暂停时间目标不要太严苛。目标太过严苛表示你愿意承受更多的垃圾回收开销，而这些会直接影响到吞吐量。</li>
</ul>
<h2 id="138-垃圾回收器总结"><a class="markdownIt-Anchor" href="#138-垃圾回收器总结"></a> 13.8. 垃圾回收器总结</h2>
<h3 id="1381-7-种经典垃圾回收器总结"><a class="markdownIt-Anchor" href="#1381-7-种经典垃圾回收器总结"></a> 13.8.1. 7 种经典垃圾回收器总结</h3>
<p>截止 JDK1.8，一共有 7 款不同的垃圾收集器。每一款的垃圾收集器都有不同的特点，在具体使用的时候，需要根据具体的情况选用不同的垃圾收集器。</p>
<table>
<thead>
<tr>
<th style="text-align:left">垃圾收集器</th>
<th style="text-align:left">分类</th>
<th style="text-align:left">作用位置</th>
<th style="text-align:left">使用算法</th>
<th style="text-align:left">特点</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Serial</td>
<td style="text-align:left">串行运行</td>
<td style="text-align:left">作用于新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">响应速度优先</td>
<td style="text-align:left">适用于单 CPU 环境下的 client 模式</td>
</tr>
<tr>
<td style="text-align:left">ParNew</td>
<td style="text-align:left">并行运行</td>
<td style="text-align:left">作用于新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">响应速度优先</td>
<td style="text-align:left">多 CPU 环境 Server 模式下与 CMS 配合使用</td>
</tr>
<tr>
<td style="text-align:left">Parallel</td>
<td style="text-align:left">并行运行</td>
<td style="text-align:left">作用于新生代</td>
<td style="text-align:left">复制算法</td>
<td style="text-align:left">吞吐量优先</td>
<td style="text-align:left">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td style="text-align:left">Serial Old</td>
<td style="text-align:left">串行运行</td>
<td style="text-align:left">作用于老年代</td>
<td style="text-align:left">标记-压缩算法</td>
<td style="text-align:left">响应速度优先</td>
<td style="text-align:left">适用于单 CPU 环境下的 Client 模式</td>
</tr>
<tr>
<td style="text-align:left">Parallel Old</td>
<td style="text-align:left">并行运行</td>
<td style="text-align:left">作用于老年代</td>
<td style="text-align:left">标记-压缩算法</td>
<td style="text-align:left">吞吐量优先</td>
<td style="text-align:left">适用于后台运算而不需要太多交互的场景</td>
</tr>
<tr>
<td style="text-align:left">CMS</td>
<td style="text-align:left">并发运行</td>
<td style="text-align:left">作用于老年代</td>
<td style="text-align:left">标记-清除算法</td>
<td style="text-align:left">响应速度优先</td>
<td style="text-align:left">适用于互联网或 B／S 业务</td>
</tr>
<tr>
<td style="text-align:left">G1</td>
<td style="text-align:left">并发、并行运行</td>
<td style="text-align:left">作用于新生代、老年代</td>
<td style="text-align:left">标记-压缩算法、复制算法</td>
<td style="text-align:left">响应速度优先</td>
<td style="text-align:left">面向服务端应用</td>
</tr>
</tbody>
</table>
<p>GC 发展阶段：Serial =&gt; Parallel（并行）=&gt; CMS（并发）=&gt; G1 =&gt; ZGC</p>
<h3 id="1382-垃圾回收器组合"><a class="markdownIt-Anchor" href="#1382-垃圾回收器组合"></a> 13.8.2. 垃圾回收器组合</h3>
<p>不同厂商、不同版本的虚拟机实现差距比较大。HotSpot 虚拟机在 JDK7/8 后所有收集器及组合如下图</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/5e57edaa3ec7295424480c67daee499e.png" alt="image-20200714080151020"></p>
<ol>
<li>
<p>两个收集器间有连线，表明它们可以搭配使用：Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1;</p>
</li>
<li>
<p>其中 Serial Old 作为 CMS 出现＂<code>Concurrent Mode Failure</code>＂失败的后备预案。</p>
</li>
<li>
<p>（红色虚线）由于维护和兼容性测试的成本，在 JDK 8 时将 Serial ＋ CMS、ParNew ＋ Serial old 这两个组合声明为 Deprecated（JEP 173），并在 JDK 9 中</p>
</li>
</ol>
<p>完全取消了这些组合的支持（JEP214），即：移除。</p>
<ol start="4">
<li>
<p>（绿色虚线）JDK 14 中：弃用 ParallelScavenge 和 SeriaOold GC 组合(JEP 366)</p>
</li>
<li>
<p>（绿色虚框）JDK 14 中：删除 CMS 垃圾回收器（JEP 363）</p>
</li>
</ol>
<h3 id="1383-怎么选择垃圾回收器"><a class="markdownIt-Anchor" href="#1383-怎么选择垃圾回收器"></a> 13.8.3. 怎么选择垃圾回收器</h3>
<p>Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择，选择合适的垃圾收集器可以让 JVM 的性能有一个很大的提升。</p>
<p>怎么选择垃圾收集器？</p>
<ol>
<li>
<p>优先调整堆的大小让 JVM 自适应完成。</p>
</li>
<li>
<p>如果内存小于 100M，使用串行收集器</p>
</li>
<li>
<p>如果是单核、单机程序，并且没有停顿时间的要求，串行收集器</p>
</li>
<li>
<p>如果是多 CPU、需要高吞吐量、允许停顿时间超过 1 秒，选择并行或者 JVM 自己选择</p>
</li>
<li>
<p>如果是多 CPU、追求低停顿时间，需快速响应（比如延迟不能超过 1 秒，如互联网应用），使用并发收集器</p>
<p>官方推荐 G1，性能高。<mark>现在互联网的项目，基本都是使用 G1</mark>。</p>
</li>
</ol>
<p>最后需要明确一个观点：</p>
<ol>
<li>没有最好的收集器，更没有万能的收集</li>
<li>调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器</li>
</ol>
<p><strong>面试</strong></p>
<p>对于垃圾收集，面试官可以循序渐进从理论、实践各种角度深入，也未必是要求面试者什么都懂。但如果你懂得原理，一定会成为面试中的加分项。 这里较通用、基础性的部分如下：</p>
<ul>
<li>
<p>垃圾收集的算法有哪些？如何判断一个对象是否可以回收？</p>
</li>
<li>
<p>垃圾收集器工作的基本流程。</p>
</li>
</ul>
<p>另外，大家需要多关注垃圾回收器这一章的各种常用的参数</p>
<h2 id="139-gc-日志分析"><a class="markdownIt-Anchor" href="#139-gc-日志分析"></a> 13.9. GC 日志分析</h2>
<p>通过阅读 Gc 日志，我们可以了解 Java 虚拟机内存分配与回收策略。 内存分配与垃圾回收的参数列表</p>
<ul>
<li><code>-XX:+PrintGC</code> 输出 GC 日志。类似：<code>-verbose:gc</code></li>
<li><code>-XX:+PrintGCDetails</code> 输出 GC 的详细日志</li>
<li><code>-XX:+PrintGCTimestamps</code> 输出 GC 的时间戳（以基准时间的形式）</li>
<li><code>-XX:+PrintGCDatestamps</code> 输出 GcC 的时间戳（以日期的形式，如 2013-05-04T21：53：59.234+0800）</li>
<li><code>-XX:+PrintHeapAtGC</code> 在进行 GC 的前后打印出堆的信息</li>
<li><code>-Xloggc:../logs/gc.log</code> 日志文件的输出路径</li>
</ul>
<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc</span><br></pre></td></tr></tbody></table></figure>
<p>这个只会显示总的 GC 堆的变化，如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) 80832K-&gt;19298K(227840K),<span class="number">0.0084018</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) 109499K-&gt;21465K(228352K),<span class="number">0.0184066</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> 21465K-&gt;16716K(201728K),<span class="number">0.0619261</span> secs]</span><br></pre></td></tr></tbody></table></figure>
<p>参数解析</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GC、Full GC：GC的类型，GC只在新生代上进行，Full GC包括永生代，新生代，老年代。</span><br><span class="line">Allocation Failure：GC发生的原因。</span><br><span class="line">80832K-&gt;19298K：堆在GC前的大小和GC后的大小。</span><br><span class="line">228840k：现在的堆大小。</span><br><span class="line"><span class="number">0.0084018</span> secs：GC持续的时间。</span><br></pre></td></tr></tbody></table></figure>
<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure>
<p>输入信息如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen:70640K-&gt;10116K(141312K)] 80541K-&gt;20017K(227328K),<span class="number">0.0172573</span> secs] [Times:user=<span class="number">0.03</span> sys=<span class="number">0.00</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[GC (Metadata GC Threshold) [PSYoungGen:98859K-&gt;8154K(142336K)] 108760K-&gt;21261K(228352K),<span class="number">0.0151573</span> secs] [Times:user=<span class="number">0.00</span> sys=<span class="number">0.01</span>,real=<span class="number">0.02</span> secs]</span><br><span class="line">[Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span>[PSYoungGen:8154K-&gt;0K(142336K)]</span><br><span class="line">[ParOldGen:13107K-&gt;16809K(62464K)] 21261K-&gt;16809K(204800K),[Metaspace:20599K-&gt;20599K(1067008K)],<span class="number">0.0639732</span> secs]</span><br><span class="line">[Times:user=<span class="number">0.14</span> sys=<span class="number">0.00</span>,real=<span class="number">0.06</span> secs]</span><br></pre></td></tr></tbody></table></figure>
<p>参数解析</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GC，Full FC：同样是GC的类型</span><br><span class="line">Allocation Failure：GC原因</span><br><span class="line">PSYoungGen：使用了Parallel Scavenge并行垃圾收集器的新生代GC前后大小的变化</span><br><span class="line">ParOldGen：使用了Parallel Old并行垃圾收集器的老年代GC前后大小的变化</span><br><span class="line">Metaspace： 元数据区GC前后大小的变化，JDK1<span class="number">.8</span>中引入了元数据区以替代永久代</span><br><span class="line">xxx secs：指GC花费的时间</span><br><span class="line">Times：user：指的是垃圾收集器花费的所有CPU时间，sys：花费在等待系统调用或系统事件的时间，real：GC从开始到结束的时间，包括其他进程占用时间片的实际时间。</span><br></pre></td></tr></tbody></table></figure>
<p>打开 GC 日志</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimestamps -XX:+PrintGCDatestamps</span><br></pre></td></tr></tbody></table></figure>
<p>输入信息如下</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">24.518</span>+0800: <span class="number">3.287</span>: [GC (Allocation Failure) [PSYoungGen:136162K-&gt;5113K(136192K)] 141425K-&gt;17632K(222208K),<span class="number">0.0248249</span> secs] [Times:user=<span class="number">0.05</span> sys=<span class="number">0.00</span>,real=<span class="number">0.03</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.559</span>+0800: <span class="number">4.329</span>: [GC (Metadata GC Threshold) [PSYoungGen:97578K-&gt;10068K(274944K)] 110096K-&gt;22658K(360960K),<span class="number">0.0094071</span> secs] [Times: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>,real=<span class="number">0.01</span> secs]</span><br><span class="line"></span><br><span class="line"><span class="number">2019</span>-09-24T22:<span class="number">15</span>:<span class="number">25.569</span>+0800: <span class="number">4.338</span>: [Full <span class="title function_">GC</span> <span class="params">(Metadata GC Threshold)</span> [PSYoungGen:10068K-&gt;0K(274944K)][ParoldGen:12590K-&gt;13564K(56320K)] 22658K-&gt;13564K(331264K),[Metaspace:20590K-&gt;20590K(1067008K)],<span class="number">0.0494875</span> secs] [Times: user=<span class="number">0.17</span> sys=<span class="number">0.02</span>,real=<span class="number">0.05</span> secs]</span><br></pre></td></tr></tbody></table></figure>
<p>说明：带上了日期和实践</p>
<p>如果想把 GC 日志存到文件的话，是下面的参数：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xloggc:/path/to/gc.log</span><br></pre></td></tr></tbody></table></figure>
<p><strong>日志补充说明</strong></p>
<ul>
<li>
<p>“<code>[GC</code>"和”<code>[Full GC</code>"说明了这次垃圾收集的停顿类型，如果有"Full"则说明 GC 发生了"Stop The World"</p>
</li>
<li>
<p>使用 Serial 收集器在新生代的名字是 Default New Generation，因此显示的是"<code>[DefNew</code>"</p>
</li>
<li>
<p>使用 ParNew 收集器在新生代的名字会变成"<code>[ParNew</code>"，意思是"Parallel New Generation"</p>
</li>
<li>
<p>使用 Parallel scavenge 收集器在新生代的名字是”<code>[PSYoungGen</code>"</p>
</li>
<li>
<p>老年代的收集和新生代道理一样，名字也是收集器决定的</p>
</li>
<li>
<p>使用 G1 收集器的话，会显示为"garbage-first heap"</p>
</li>
<li>
<p><mark>Allocation Failure</mark></p>
<p>表明本次引起 GC 的原因是因为在年轻代中没有足够的空间能够存储新的数据了。</p>
</li>
<li>
<p><mark>[PSYoungGen：5986K-&gt;696K(8704K) ] 5986K-&gt;704K(9216K)</mark></p>
<p>中括号内：GC 回收前年轻代大小，回收后大小，（年轻代总大小）</p>
<p>括号外：GC 回收前年轻代和老年代大小，回收后大小，（年轻代和老年代总大小）</p>
</li>
<li>
<p><mark>user 代表用户态回收耗时，sys 内核态回收耗时，rea 实际耗时</mark>。由于多核的原因，时间总和可能会超过 real 时间</p>
</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Heap（堆）</span><br><span class="line">PSYoungGen（Parallel Scavenge收集器新生代）total 9216K，used 6234K [<span class="number">0x00000000ff600000</span>,<span class="number">0x0000000100000000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">eden space（堆中的Eden区默认占比是<span class="number">8</span>）8192K，<span class="number">768</span> used [<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ffc16b08</span>,<span class="number">0x00000000ffe00000</span>)</span><br><span class="line">from space（堆中的Survivor，这里是From Survivor区默认占比是<span class="number">1</span>）1024K， <span class="number">0</span>% used [<span class="number">0x00000000fff00000</span>,<span class="number">0x00000000fff00000</span>,<span class="number">0x0000000100000000</span>)</span><br><span class="line">to space（堆中的Survivor，这里是to Survivor区默认占比是<span class="number">1</span>，需要先了解一下堆的分配策略）1024K, <span class="number">0</span>% used [<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000ffe00000</span>,<span class="number">0x00000000fff00000</span>)</span><br><span class="line"></span><br><span class="line">ParOldGen（老年代总大小和使用大小）total 10240K， used 7001K ［<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff600000</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line">object space（显示个使用百分比）10240K，<span class="number">688</span> used [<span class="number">0x00000000fec00000</span>,<span class="number">0x00000000ff2d6630</span>,<span class="number">0x00000000ff600000</span>)</span><br><span class="line"></span><br><span class="line">PSPermGen（永久代总大小和使用大小）total 21504K， used 4949K [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000faf00000</span>,<span class="number">0x00000000fec00000</span>)</span><br><span class="line">object space（显示个使用百分比，自己能算出来）21504K， <span class="number">238</span> used [<span class="number">0x00000000f9a00000</span>,<span class="number">0x00000000f9ed55e0</span>,<span class="number">0x00000000faf00000</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="minor-gc-日志"><a class="markdownIt-Anchor" href="#minor-gc-日志"></a> Minor GC 日志</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/9364561fbb81a0e2f9aedc45a383972f.png" alt="image-20200714082555688"></p>
<h3 id="full-gc-日志"><a class="markdownIt-Anchor" href="#full-gc-日志"></a> Full GC 日志</h3>
<p><img src="https://img-blog.csdnimg.cn/img_convert/502793e725122b958f2861932e5ef9c1.png" alt="image-20210512194815354"></p>
<p><strong>举例</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1MB</span> <span class="operator">=</span> <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testAllocation</span><span class="params">()</span> { </span><br><span class="line">    <span class="type">byte</span> [] allocation1, allocation2, allocation3, allocation4;  </span><br><span class="line">    allocation1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation2 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation3 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">2</span> *_1MB];   </span><br><span class="line">    allocation4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span> *_1MB];</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> {    </span><br><span class="line">    testAllocation();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>设置 JVM 参数</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms10m -Xmx10m -XX:+PrintGCDetails</span><br></pre></td></tr></tbody></table></figure>
<p><strong>图示</strong></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/8dada6b73786eb693975593db10ce825.png" alt="image-20200714083332238"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/78f6489bd1a3b74e14ee4a95392df8c2.png" alt="image-20200714083526790"></p>
<p>（ jdk7是如上图分析所示。但是JDK8和JDK7不一样，大对象来的时候，发现新生代装不下，直接进入老年代 ）</p>
<p>可以用一些工具去分析这些 GC 日志</p>
<p>常用的日志分析工具有：GCViewer、GCEasy、GCHisto、GCLogViewer、Hpjmeter、garbagecat 等</p>
<h2 id="13x-垃圾回收器的新发展"><a class="markdownIt-Anchor" href="#13x-垃圾回收器的新发展"></a> 13.X. 垃圾回收器的新发展</h2>
<p>GC 仍然处于飞速发展之中，目前的默认选项<mark>G1 GC 在不断的进行改进</mark>，很多我们原来认为的缺点，例如串行的 Fu11GC、Card Table 扫描的低效等，都已经被大幅改进，例如，JDK10 以后，Fu11GC 已经是并行运行，在很多场景下，其表现还略优于 ParallelGC 的并行 Ful1GC 实现。</p>
<p>即使是 Serial GC，虽然比较古老，但是简单的设计和实现未必就是过时的，它本身的开销，不管是 GC 相关数据结构的开销，还是线程的开销，都是非常小的，所以随着云计算的兴起，<mark>在 Serverless 等新的应用场景下，Serial GC 找到了新的舞台</mark>。</p>
<p>比较不幸的是 CMSGC，因为其算法的理论缺陷等原因，虽然现在还有非常大的用户群体，但在 JDK9 中已经被标记为废弃，并在 JDK14 版本中移除</p>
<h3 id="13x1-jdk11-新特性"><a class="markdownIt-Anchor" href="#13x1-jdk11-新特性"></a> 13.X.1. JDK11 新特性</h3>
<p>Epsilon:A No-Op GarbageCollector（Epsilon 垃圾回收器，"No-Op（无操作）"回收器）<a target="_blank" rel="noopener" href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/318</a></p>
<p>ZGC:A Scalable Low-Latency Garbage Collector（Experimental）（ZGC：可伸缩的低延迟垃圾回收器，处于实验性阶段）<a target="_blank" rel="noopener" href="http://openidk.iava.net/jeps/318">http://openidk.iava.net/jeps/333</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4aaef244379d75ba838e10d4178b2960.png" alt="image-20210512195426194"></p>
<p>现在 G1 回收器已成为默认回收器好几年了。</p>
<p>我们还看到了引入了两个新的收集器：ZGC（JDK11 出现）和 Shenandoah（Open JDK12）。主打特点：低停顿时间</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/00920e4ae2b2c80a8016e6d8f4632545.png" alt="image-20210512195528695"></p>
<h3 id="13x2-open-jdk12-的-shenandoash-gc"><a class="markdownIt-Anchor" href="#13x2-open-jdk12-的-shenandoash-gc"></a> 13.X.2. Open JDK12 的 Shenandoash GC</h3>
<p><mark>Open JDK12 的 Shenandoash GC：低停顿时间的 GC（实验性）</mark></p>
<p><mark>Shenandoah，无疑是众多 GC 中最孤独的一个。</mark>是第一款不由 oracle 公司团队领导开发的 Hotspot 垃圾收集器。不可避免的<mark>受到官方的排挤</mark>。比如号称 OpenJDK 和 OracleJDK 没有区别的 Oracle 公司仍拒绝在 OracleJDK12 中支持 Shenandoah。</p>
<p>Shenandoah 垃圾回收器最初由 RedHat 进行的一项垃圾收集器研究项目 Pauseless GC 的实现，<mark>旨在针对 JVM 上的内存回收实现低停顿的需求</mark>.。在 2014 年贡献给 OpenJDK。</p>
<p>Red Hat 研发 Shenandoah 团队对外宣称，<mark>Shenandoah 垃圾回收器的暂停时间与堆大小无关，这意味着无论将堆设置为 200MB 还是 200GB，99.9%的目标都可以把垃圾收集的停顿时间限制在十毫秒以内。</mark>不过实际使用性能将取决于实际工作堆的大小和工作负载。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/01f566c0db04f0e475db05addd94259f.png" alt="image-20200714090608807"></p>
<p>这是 RedHat 在 2016 年发表的论文数据，测试内容是使用 Es 对 200GB 的维基百科数据进行索引。从结果看：</p>
<ul>
<li>停顿时间比其他几款收集器确实有了质的飞跃，但也未实现最大停顿时间控制在十毫秒以内的目标。</li>
<li>而吞吐量方面出现了明显的下降，总运行时间是所有测试收集器里最长的。</li>
</ul>
<p>总结</p>
<ul>
<li>Shenandoah GC 的弱项：高运行负担下的吞吐量下降。</li>
<li>Shenandoah GC 的强项：低延迟时间。</li>
<li>Shenandoah GC 的工作过程大致分为九个阶段，这里就不再赘述。在之前 Java12 新特性视频里有过介绍。</li>
</ul>
<p>【Java12 新特性地址】</p>
<p><a target="_blank" rel="noopener" href="http://www.atguigu.com/download_detail.shtml?v=222">http://www.atguigu.com/download_detail.shtml?v=222</a></p>
<p>或</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866">https://www.bilibili.com/video/BV1jJ411M7kQ?from=search&amp;seid=12339069673726242866</a></p>
<h3 id="13x3-令人震惊-革命性的-zgc"><a class="markdownIt-Anchor" href="#13x3-令人震惊-革命性的-zgc"></a> 13.X.3. 令人震惊、革命性的 ZGC</h3>
<p>官方地址：<a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/gctuning/">https://docs.oracle.com/en/java/javase/12/gctuning/</a></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f78eebadbabf7450ded984f0f1e3a405.png" alt="image-20210512200236647"></p>
<p>ZGC 与 Shenandoah 目标高度相似，<mark>在尽可能对吞吐量影响不大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停颇时间限制在十毫秒以内的低延迟。</mark></p>
<p>《深入理解 Java 虚拟机》一书中这样定义 ZGC：ZGC 收集器是一款基于 Region 内存布局的，（暂时）不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现<mark>可并发的标记-压缩算法</mark>的，以<mark>低延迟为首要目标</mark>的一款垃圾收集器。</p>
<p>ZGC 的工作过程可以分为 4 个阶段：<mark>并发标记 - 并发预备重分配 - 并发重分配 - 并发重映射</mark> 等。</p>
<p>ZGC 几乎在所有地方并发执行的，除了初始标记的是 STw 的。所以停顿时间几乎就耗费在初始标记上，这部分的实际时间是非常少的。</p>
<p>测试数据：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b08828b548a255493e934c6fe3308e50.png" alt="image-20200714091201073"></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/4e648c4e37d84f5d83d965b55f6bc5f9.png" alt="image-20200714091401511"></p>
<p>在 ZGC 的强项停顿时间测试上，它毫不留情的将 Parallel、G1 拉开了两个数量级的差距。无论平均停顿、95％停顿、99％停顿、99.9％停顿，还是最大停顿时间，ZGC 都能毫不费劲控制在 10 毫秒以内。</p>
<p>虽然 ZGC 还在试验状态，没有完成所有特性，但此时性能已经相当亮眼，用“令人震惊、革命性”来形容，不为过。 <mark>未来将在服务端、大内存、低延迟应用的首选垃圾收集器。</mark></p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/59b014ca2eeda5332fd40a4a2356f883.png" alt="image-20200714093243028"></p>
<p><mark>JEP 364：ZGC 应用在 macos 上</mark></p>
<p><mark>JEP 365：ZGC 应用在 Windows 上</mark></p>
<p>JDK14 之前，ZGC 仅 Linux 才支持。</p>
<p>尽管许多使用 zGc 的用户都使用类 Linux 的环境，但在 Windows 和 macos 上，人们也需要 ZGC 进行开发部署和测试。许多桌面应用也可以从 ZGC 中受益。因此，ZGC 特性被移植到了 Windows 和 macos 上。</p>
<p>现在 mac 或 Windows 上也能使用 zGC 了，示例如下：</p>
<figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockExperimentalVMOptions -XX:+UseZGC</span><br></pre></td></tr></tbody></table></figure>
<h3 id="13x4-其他垃圾回收器aligc"><a class="markdownIt-Anchor" href="#13x4-其他垃圾回收器aligc"></a> 13.X.4. 其他垃圾回收器：AliGC</h3>
<p>AliGC 是阿里巴巴 JVM 团队基于 G1 算法，面向大堆（LargeHeap）应用场景。指定场景下的对比：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/835fff5c3a7884de2a1d564b7f332900.png" alt="image-20200714093604012"></p>
<p>当然，其它厂商也提供了各种别具一格的 GC 实现，例如比较有名的低延迟 GC：Zing，有兴趣可以参考提供的链接 <a target="_blank" rel="noopener" href="https://www.infoq.com/articles/azul_gc_in_detail">https://www.infoq.com/articles/azul_gc_in_detail</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/11/24/JVM/JVM%E4%B8%8A%E7%AF%87%EF%BC%9A%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/13.%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/" data-id="clihkswhq0071pov67l01ht3w" class="article-share-link">分享</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JVM/" rel="tag">JVM</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%86%85%E5%AD%98%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AF%87/" rel="tag">内存与垃圾回收篇</a></li></ul>

    </footer>
  </div>
  
</article>




  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/6/">&amp;laquo; pre</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/17/">17</a><a class="extend next" rel="next" href="/page/8/">next &amp;raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <h1 class="blog-title">Hexo &amp; github</h1>
    <h2 class="blog-subtitle"></h2>
    <ul class="blog-link">
     
          <a href="/" title="Home">
            <li>主页</li>
          </a>
        
          <a href="/archives" title="Archives">
            <li>归档</li>
          </a>
        
          <a href="/categories" title="Categories">
            <li>分类</li>
          </a>
        
          <a href="/tags" title="Tags">
            <li>标签</li>
          </a>
        
          <a href="/about" title="About">
            <li>关于</li>
          </a>
        
    </ul>
  </div>
</div>

  
    <div class="widget-wrap">
  <h3 class="widget-title"></h3>
  <div class="widget">
    <img class="avatar" src="https://img.zcool.cn/community/015bd15c248fbba80121df90241501.jpg@1280w_1l_2o_100sh.jpg">
    <h2 class="author">其然乐衣</h2>
    <h3 class="description"></h3>
    <div class="count-box">
      <a href="/archives"><div><strong>170</strong><br>文章</div></a>
      <a href="/categories"><div><strong>75</strong><br>分类</div></a>
      <a href="/tags"><div><strong>56</strong><br>标签</div></a>
    </div>



    <div class="social-link">
      
        <a class="hvr-bounce-in" href="https://github.com/RunningYu" target="_blank" title="Github">
          Github
        </a>
      
    </div>

    <div class="friend-link">
      <h2>其它个人平台链接</h2>
      
        <a class="hvr-bounce-in" href="https://blog.csdn.net/QRLYLETITBE?spm=1010.2135.3001.5421" target="_blank" title="My_CSDN">
          My_CSDN
        </a>
      
        <a class="hvr-bounce-in" href="https://juejin.cn/user/4490835346855565" target="_blank" title="My_juejin">
          My_juejin
        </a>
      
    </div>
  </div>
</div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy;2022 - 2023 其然乐衣<br>
      由<a href="http://hexo.io/" target="_blank">Hexo</a>强力驱动 | 
      主题-<a target="_blank" rel="noopener" href="https://github.com/ShanaMaid/hexo-theme-shana">Shana</a>
      
    </div>
    
  </div>
</footer>
    </div>
    

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src="//apps.bdimg.com/libs/wow/0.1.6/wow.min.js"></script>
<script>
new WOW().init();
</script>   


  
<link rel="stylesheet" href="/plugin/fancybox/jquery.fancybox.css">

  
<script src="/plugin/fancybox/jquery.fancybox.pack.js"></script>




  
<link rel="stylesheet" href="/plugin/galmenu/GalMenu.css">

  
<script src="/plugin/galmenu/GalMenu.js"></script>

  <div class="GalMenu GalDropDown">
      <div class="circle" id="gal">
        <div class="ring">
          
            <a href="/" title="" class="menuItem">首页</a>
          
            <a href="/tags" title="" class="menuItem">标签</a>
          
            <a href="/categories" title="" class="menuItem">分类</a>
          
            <a href="/" title="" class="menuItem">归档</a>
          
            <a href="/xxxxxxxxx" title="" class="menuItem">xxx</a>
          
            <a href="/xxxxxxx" title="" class="menuItem">xxxx</a>
          
        </div>
        
          <audio id="audio" src="plugin/galmenu/wulusai.mp3"></audio>
        
      </div> 
</div>
<div id="overlay" style="opacity: 1; cursor: pointer;"></div>
  <script type="text/javascript">var items = document.querySelectorAll('.menuItem');
    for (var i = 0,
    l = items.length; i < l; i++) {
      items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%";
      items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + "%"
    }</script>
<script type="text/javascript">
  $(document).ready(function() {
    $('body').GalMenu({
      'menu': 'GalDropDown'
    })
  });
</script>

  <section class="hidden-xs"> 
  <ul class="cb-slideshow"> 
    <li><span>苟利</span></li> 
    <li><span>国家</span></li> 
    <li><span>生死以</span></li> 
    <li><span>岂能</span></li> 
    <li><span>祸福</span></li> 
    <li><span>趋避之</span></li> 
  </ul>
</section>

<script src="/js/script.js"></script>




  </div>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>